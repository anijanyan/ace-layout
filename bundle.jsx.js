/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 10776:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var _src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport fake namespace object from non-harmony */ _src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_src_ace__WEBPACK_IMPORTED_MODULE_0__, 2)))
/* harmony export */ });
/* harmony import */ var _src_ace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80820);

_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/abap', () => __webpack_require__.e(/* import() */ 7161).then(__webpack_require__.t.bind(__webpack_require__, 67161, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/abc', () => __webpack_require__.e(/* import() */ 4723).then(__webpack_require__.t.bind(__webpack_require__, 44723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/actionscript', () => __webpack_require__.e(/* import() */ 9950).then(__webpack_require__.t.bind(__webpack_require__, 69950, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ada', () => __webpack_require__.e(/* import() */ 6199).then(__webpack_require__.t.bind(__webpack_require__, 76199, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/alda', () => __webpack_require__.e(/* import() */ 8653).then(__webpack_require__.t.bind(__webpack_require__, 68653, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/apache_conf', () => __webpack_require__.e(/* import() */ 6014).then(__webpack_require__.t.bind(__webpack_require__, 46014, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/apex', () => __webpack_require__.e(/* import() */ 4255).then(__webpack_require__.t.bind(__webpack_require__, 54255, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/applescript', () => __webpack_require__.e(/* import() */ 1276).then(__webpack_require__.t.bind(__webpack_require__, 21276, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/aql', () => __webpack_require__.e(/* import() */ 5917).then(__webpack_require__.t.bind(__webpack_require__, 85917, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/asciidoc', () => __webpack_require__.e(/* import() */ 7488).then(__webpack_require__.t.bind(__webpack_require__, 87488, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/asl', () => __webpack_require__.e(/* import() */ 7023).then(__webpack_require__.t.bind(__webpack_require__, 37023, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/assembly_arm32', () => __webpack_require__.e(/* import() */ 4583).then(__webpack_require__.t.bind(__webpack_require__, 64583, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/assembly_x86', () => __webpack_require__.e(/* import() */ 1746).then(__webpack_require__.t.bind(__webpack_require__, 11746, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/astro', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5120)]).then(__webpack_require__.t.bind(__webpack_require__, 15120, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/autohotkey', () => __webpack_require__.e(/* import() */ 2674).then(__webpack_require__.t.bind(__webpack_require__, 32674, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/basic', () => __webpack_require__.e(/* import() */ 8389).then(__webpack_require__.t.bind(__webpack_require__, 38389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/batchfile', () => __webpack_require__.e(/* import() */ 8253).then(__webpack_require__.t.bind(__webpack_require__, 18253, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/bibtex', () => __webpack_require__.e(/* import() */ 3989).then(__webpack_require__.t.bind(__webpack_require__, 93989, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/c9search', () => __webpack_require__.e(/* import() */ 6679).then(__webpack_require__.t.bind(__webpack_require__, 66679, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/c_cpp', () => __webpack_require__.e(/* import() */ 7668).then(__webpack_require__.t.bind(__webpack_require__, 97668, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cirru', () => __webpack_require__.e(/* import() */ 2295).then(__webpack_require__.t.bind(__webpack_require__, 74676, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/clojure', () => __webpack_require__.e(/* import() */ 4335).then(__webpack_require__.t.bind(__webpack_require__, 4335, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cobol', () => __webpack_require__.e(/* import() */ 3436).then(__webpack_require__.t.bind(__webpack_require__, 83436, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/coffee', () => __webpack_require__.e(/* import() */ 1079).then(__webpack_require__.t.bind(__webpack_require__, 61079, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/coldfusion', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4341)]).then(__webpack_require__.t.bind(__webpack_require__, 54341, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/crystal', () => __webpack_require__.e(/* import() */ 7465).then(__webpack_require__.t.bind(__webpack_require__, 7465, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csharp', () => __webpack_require__.e(/* import() */ 4764).then(__webpack_require__.t.bind(__webpack_require__, 54764, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_document', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(3928), __webpack_require__.e(215)]).then(__webpack_require__.t.bind(__webpack_require__, 40215, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_orchestra', () => Promise.all(/* import() */[__webpack_require__.e(3928), __webpack_require__.e(1763)]).then(__webpack_require__.t.bind(__webpack_require__, 11763, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_score', () => __webpack_require__.e(/* import() */ 9858).then(__webpack_require__.t.bind(__webpack_require__, 79858, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csp', () => __webpack_require__.e(/* import() */ 5409).then(__webpack_require__.t.bind(__webpack_require__, 55409, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/css', () => __webpack_require__.e(/* import() */ 1080).then(__webpack_require__.t.bind(__webpack_require__, 41080, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/curly', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9430)]).then(__webpack_require__.t.bind(__webpack_require__, 39430, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cuttlefish', () => __webpack_require__.e(/* import() */ 4186).then(__webpack_require__.t.bind(__webpack_require__, 64186, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/d', () => __webpack_require__.e(/* import() */ 343).then(__webpack_require__.t.bind(__webpack_require__, 343, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dart', () => __webpack_require__.e(/* import() */ 3006).then(__webpack_require__.t.bind(__webpack_require__, 83006, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/diff', () => __webpack_require__.e(/* import() */ 6104).then(__webpack_require__.t.bind(__webpack_require__, 56104, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/django', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(3332)]).then(__webpack_require__.t.bind(__webpack_require__, 43332, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dockerfile', () => __webpack_require__.e(/* import() */ 1257).then(__webpack_require__.t.bind(__webpack_require__, 31257, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dot', () => __webpack_require__.e(/* import() */ 1304).then(__webpack_require__.t.bind(__webpack_require__, 51304, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/drools', () => __webpack_require__.e(/* import() */ 4554).then(__webpack_require__.t.bind(__webpack_require__, 34554, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/edifact', () => __webpack_require__.e(/* import() */ 261).then(__webpack_require__.t.bind(__webpack_require__, 50261, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/eiffel', () => __webpack_require__.e(/* import() */ 2920).then(__webpack_require__.t.bind(__webpack_require__, 2920, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ejs', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(31)]).then(__webpack_require__.t.bind(__webpack_require__, 30031, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/elixir', () => __webpack_require__.e(/* import() */ 7692).then(__webpack_require__.t.bind(__webpack_require__, 37692, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/elm', () => __webpack_require__.e(/* import() */ 6135).then(__webpack_require__.t.bind(__webpack_require__, 6135, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/erlang', () => __webpack_require__.e(/* import() */ 3544).then(__webpack_require__.t.bind(__webpack_require__, 33544, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/flix', () => __webpack_require__.e(/* import() */ 4140).then(__webpack_require__.t.bind(__webpack_require__, 34140, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/forth', () => __webpack_require__.e(/* import() */ 7076).then(__webpack_require__.t.bind(__webpack_require__, 27076, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fortran', () => __webpack_require__.e(/* import() */ 553).then(__webpack_require__.t.bind(__webpack_require__, 80553, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fsharp', () => __webpack_require__.e(/* import() */ 7657).then(__webpack_require__.t.bind(__webpack_require__, 17657, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fsl', () => __webpack_require__.e(/* import() */ 3698).then(__webpack_require__.t.bind(__webpack_require__, 33698, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ftl', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(769)]).then(__webpack_require__.t.bind(__webpack_require__, 50769, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gcode', () => __webpack_require__.e(/* import() */ 3695).then(__webpack_require__.t.bind(__webpack_require__, 83695, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gherkin', () => __webpack_require__.e(/* import() */ 5005).then(__webpack_require__.t.bind(__webpack_require__, 25005, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gitignore', () => __webpack_require__.e(/* import() */ 297).then(__webpack_require__.t.bind(__webpack_require__, 297, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/glsl', () => __webpack_require__.e(/* import() */ 903).then(__webpack_require__.t.bind(__webpack_require__, 80903, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gobstones', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(3845)]).then(__webpack_require__.t.bind(__webpack_require__, 93845, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/golang', () => __webpack_require__.e(/* import() */ 8009).then(__webpack_require__.t.bind(__webpack_require__, 38009, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/graphqlschema', () => __webpack_require__.e(/* import() */ 3105).then(__webpack_require__.t.bind(__webpack_require__, 63105, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/groovy', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(2025)]).then(__webpack_require__.t.bind(__webpack_require__, 32025, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haml', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(4848), __webpack_require__.e(2545)]).then(__webpack_require__.t.bind(__webpack_require__, 42545, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/handlebars', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(2527)]).then(__webpack_require__.t.bind(__webpack_require__, 52527, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haskell', () => __webpack_require__.e(/* import() */ 2119).then(__webpack_require__.t.bind(__webpack_require__, 82119, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haskell_cabal', () => __webpack_require__.e(/* import() */ 5611).then(__webpack_require__.t.bind(__webpack_require__, 85611, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haxe', () => __webpack_require__.e(/* import() */ 1151).then(__webpack_require__.t.bind(__webpack_require__, 91151, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/hjson', () => __webpack_require__.e(/* import() */ 6929).then(__webpack_require__.t.bind(__webpack_require__, 56929, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234)]).then(__webpack_require__.t.bind(__webpack_require__, 32234, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html_elixir', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(562)]).then(__webpack_require__.t.bind(__webpack_require__, 562, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html_ruby', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(9261)]).then(__webpack_require__.t.bind(__webpack_require__, 9261, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ini', () => __webpack_require__.e(/* import() */ 5481).then(__webpack_require__.t.bind(__webpack_require__, 95481, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/io', () => __webpack_require__.e(/* import() */ 247).then(__webpack_require__.t.bind(__webpack_require__, 70247, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ion', () => __webpack_require__.e(/* import() */ 2613).then(__webpack_require__.t.bind(__webpack_require__, 92613, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jack', () => __webpack_require__.e(/* import() */ 1820).then(__webpack_require__.t.bind(__webpack_require__, 81820, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jade', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(9681)]).then(__webpack_require__.t.bind(__webpack_require__, 29681, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/java', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(8259)]).then(__webpack_require__.t.bind(__webpack_require__, 38259, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/javascript', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388)]).then(__webpack_require__.t.bind(__webpack_require__, 93388, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jexl', () => __webpack_require__.e(/* import() */ 1770).then(__webpack_require__.t.bind(__webpack_require__, 91770, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/json', () => __webpack_require__.e(/* import() */ 5081).then(__webpack_require__.t.bind(__webpack_require__, 45081, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/json5', () => __webpack_require__.e(/* import() */ 8314).then(__webpack_require__.t.bind(__webpack_require__, 88314, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jsp', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(9706)]).then(__webpack_require__.t.bind(__webpack_require__, 99706, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jssm', () => __webpack_require__.e(/* import() */ 5660).then(__webpack_require__.t.bind(__webpack_require__, 65660, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jsx', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(3442)]).then(__webpack_require__.t.bind(__webpack_require__, 93442, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/julia', () => __webpack_require__.e(/* import() */ 8270).then(__webpack_require__.t.bind(__webpack_require__, 18270, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/kotlin', () => __webpack_require__.e(/* import() */ 3682).then(__webpack_require__.t.bind(__webpack_require__, 63682, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/latex', () => __webpack_require__.e(/* import() */ 8311).then(__webpack_require__.t.bind(__webpack_require__, 88311, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/latte', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(3629)]).then(__webpack_require__.t.bind(__webpack_require__, 43629, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/less', () => __webpack_require__.e(/* import() */ 9686).then(__webpack_require__.t.bind(__webpack_require__, 79686, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/liquid', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(307)]).then(__webpack_require__.t.bind(__webpack_require__, 20307, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lisp', () => __webpack_require__.e(/* import() */ 111).then(__webpack_require__.t.bind(__webpack_require__, 20111, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/livescript', () => __webpack_require__.e(/* import() */ 4854).then(__webpack_require__.t.bind(__webpack_require__, 34854, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/logiql', () => __webpack_require__.e(/* import() */ 3983).then(__webpack_require__.t.bind(__webpack_require__, 13983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/logtalk', () => __webpack_require__.e(/* import() */ 5527).then(__webpack_require__.t.bind(__webpack_require__, 65527, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lsl', () => __webpack_require__.e(/* import() */ 3476).then(__webpack_require__.t.bind(__webpack_require__, 83476, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lua', () => __webpack_require__.e(/* import() */ 9781).then(__webpack_require__.t.bind(__webpack_require__, 39781, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/luapage', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8130)]).then(__webpack_require__.t.bind(__webpack_require__, 88130, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lucene', () => __webpack_require__.e(/* import() */ 313).then(__webpack_require__.t.bind(__webpack_require__, 10313, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/makefile', () => __webpack_require__.e(/* import() */ 5383).then(__webpack_require__.t.bind(__webpack_require__, 5383, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/markdown', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5390)]).then(__webpack_require__.t.bind(__webpack_require__, 75390, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mask', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(2699)]).then(__webpack_require__.t.bind(__webpack_require__, 92699, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/matlab', () => __webpack_require__.e(/* import() */ 4406).then(__webpack_require__.t.bind(__webpack_require__, 84406, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/maze', () => __webpack_require__.e(/* import() */ 2328).then(__webpack_require__.t.bind(__webpack_require__, 92328, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mediawiki', () => __webpack_require__.e(/* import() */ 9723).then(__webpack_require__.t.bind(__webpack_require__, 59723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mel', () => __webpack_require__.e(/* import() */ 365).then(__webpack_require__.t.bind(__webpack_require__, 30365, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mips', () => __webpack_require__.e(/* import() */ 7240).then(__webpack_require__.t.bind(__webpack_require__, 47240, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mixal', () => __webpack_require__.e(/* import() */ 9156).then(__webpack_require__.t.bind(__webpack_require__, 9156, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mushcode', () => __webpack_require__.e(/* import() */ 4223).then(__webpack_require__.t.bind(__webpack_require__, 44223, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mysql', () => __webpack_require__.e(/* import() */ 3221).then(__webpack_require__.t.bind(__webpack_require__, 43221, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nasal', () => __webpack_require__.e(/* import() */ 8855).then(__webpack_require__.t.bind(__webpack_require__, 71236, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nginx', () => __webpack_require__.e(/* import() */ 6535).then(__webpack_require__.t.bind(__webpack_require__, 96535, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nim', () => __webpack_require__.e(/* import() */ 5799).then(__webpack_require__.t.bind(__webpack_require__, 15799, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nix', () => __webpack_require__.e(/* import() */ 4348).then(__webpack_require__.t.bind(__webpack_require__, 64348, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nsis', () => __webpack_require__.e(/* import() */ 1312).then(__webpack_require__.t.bind(__webpack_require__, 31312, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nunjucks', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(1236)]).then(__webpack_require__.t.bind(__webpack_require__, 1236, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/objectivec', () => __webpack_require__.e(/* import() */ 5507).then(__webpack_require__.t.bind(__webpack_require__, 85507, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ocaml', () => __webpack_require__.e(/* import() */ 4875).then(__webpack_require__.t.bind(__webpack_require__, 54875, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/odin', () => __webpack_require__.e(/* import() */ 1675).then(__webpack_require__.t.bind(__webpack_require__, 91675, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/partiql', () => __webpack_require__.e(/* import() */ 1078).then(__webpack_require__.t.bind(__webpack_require__, 51078, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pascal', () => __webpack_require__.e(/* import() */ 5143).then(__webpack_require__.t.bind(__webpack_require__, 75143, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/perl', () => __webpack_require__.e(/* import() */ 1934).then(__webpack_require__.t.bind(__webpack_require__, 21934, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pgsql', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(5440)]).then(__webpack_require__.t.bind(__webpack_require__, 65440, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/php', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9883)]).then(__webpack_require__.t.bind(__webpack_require__, 99883, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/php_laravel_blade', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9883), __webpack_require__.e(3212)]).then(__webpack_require__.t.bind(__webpack_require__, 33212, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pig', () => __webpack_require__.e(/* import() */ 1951).then(__webpack_require__.t.bind(__webpack_require__, 71951, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/plain_text', () => __webpack_require__.e(/* import() */ 7001).then(__webpack_require__.t.bind(__webpack_require__, 57001, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/plsql', () => __webpack_require__.e(/* import() */ 3219).then(__webpack_require__.t.bind(__webpack_require__, 73219, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/powershell', () => __webpack_require__.e(/* import() */ 5818).then(__webpack_require__.t.bind(__webpack_require__, 5818, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/praat', () => __webpack_require__.e(/* import() */ 5227).then(__webpack_require__.t.bind(__webpack_require__, 35227, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prisma', () => __webpack_require__.e(/* import() */ 5159).then(__webpack_require__.t.bind(__webpack_require__, 25159, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prolog', () => __webpack_require__.e(/* import() */ 9492).then(__webpack_require__.t.bind(__webpack_require__, 29492, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/properties', () => __webpack_require__.e(/* import() */ 1994).then(__webpack_require__.t.bind(__webpack_require__, 31994, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/protobuf', () => __webpack_require__.e(/* import() */ 4712).then(__webpack_require__.t.bind(__webpack_require__, 54712, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prql', () => __webpack_require__.e(/* import() */ 2260).then(__webpack_require__.t.bind(__webpack_require__, 22260, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/puppet', () => __webpack_require__.e(/* import() */ 661).then(__webpack_require__.t.bind(__webpack_require__, 10661, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/python', () => __webpack_require__.e(/* import() */ 5313).then(__webpack_require__.t.bind(__webpack_require__, 35313, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/qml', () => __webpack_require__.e(/* import() */ 2857).then(__webpack_require__.t.bind(__webpack_require__, 32857, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/r', () => __webpack_require__.e(/* import() */ 3317).then(__webpack_require__.t.bind(__webpack_require__, 13317, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/raku', () => __webpack_require__.e(/* import() */ 9042).then(__webpack_require__.t.bind(__webpack_require__, 39042, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/razor', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8871)]).then(__webpack_require__.t.bind(__webpack_require__, 78871, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rdoc', () => __webpack_require__.e(/* import() */ 7787).then(__webpack_require__.t.bind(__webpack_require__, 17787, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/red', () => __webpack_require__.e(/* import() */ 6328).then(__webpack_require__.t.bind(__webpack_require__, 66328, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/redshift', () => __webpack_require__.e(/* import() */ 5074).then(__webpack_require__.t.bind(__webpack_require__, 25074, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rhtml', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9748)]).then(__webpack_require__.t.bind(__webpack_require__, 9748, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/robot', () => __webpack_require__.e(/* import() */ 571).then(__webpack_require__.t.bind(__webpack_require__, 50571, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rst', () => __webpack_require__.e(/* import() */ 5262).then(__webpack_require__.t.bind(__webpack_require__, 25262, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ruby', () => Promise.all(/* import() */[__webpack_require__.e(4848), __webpack_require__.e(1067)]).then(__webpack_require__.t.bind(__webpack_require__, 11067, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rust', () => __webpack_require__.e(/* import() */ 7149).then(__webpack_require__.t.bind(__webpack_require__, 17149, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sac', () => __webpack_require__.e(/* import() */ 4350).then(__webpack_require__.t.bind(__webpack_require__, 64350, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sass', () => __webpack_require__.e(/* import() */ 1525).then(__webpack_require__.t.bind(__webpack_require__, 31525, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scad', () => __webpack_require__.e(/* import() */ 1092).then(__webpack_require__.t.bind(__webpack_require__, 91092, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scala', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(8789)]).then(__webpack_require__.t.bind(__webpack_require__, 68789, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scheme', () => __webpack_require__.e(/* import() */ 3656).then(__webpack_require__.t.bind(__webpack_require__, 53656, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scrypt', () => __webpack_require__.e(/* import() */ 9660).then(__webpack_require__.t.bind(__webpack_require__, 79660, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scss', () => __webpack_require__.e(/* import() */ 2007).then(__webpack_require__.t.bind(__webpack_require__, 72007, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sh', () => __webpack_require__.e(/* import() */ 5052).then(__webpack_require__.t.bind(__webpack_require__, 95052, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sjs', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(461)]).then(__webpack_require__.t.bind(__webpack_require__, 30461, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/slim', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(2561), __webpack_require__.e(1026)]).then(__webpack_require__.t.bind(__webpack_require__, 41026, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/smarty', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4939)]).then(__webpack_require__.t.bind(__webpack_require__, 14939, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/smithy', () => __webpack_require__.e(/* import() */ 2213).then(__webpack_require__.t.bind(__webpack_require__, 22213, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/snippets', () => __webpack_require__.e(/* import() */ 6473).then(__webpack_require__.t.bind(__webpack_require__, 96473, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/soy_template', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8180)]).then(__webpack_require__.t.bind(__webpack_require__, 95799, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/space', () => __webpack_require__.e(/* import() */ 245).then(__webpack_require__.t.bind(__webpack_require__, 10245, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sparql', () => __webpack_require__.e(/* import() */ 8886).then(__webpack_require__.t.bind(__webpack_require__, 38886, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sql', () => __webpack_require__.e(/* import() */ 7447).then(__webpack_require__.t.bind(__webpack_require__, 17447, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sqlserver', () => __webpack_require__.e(/* import() */ 80).then(__webpack_require__.t.bind(__webpack_require__, 70080, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/stylus', () => __webpack_require__.e(/* import() */ 5241).then(__webpack_require__.t.bind(__webpack_require__, 55241, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/svg', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(4445)]).then(__webpack_require__.t.bind(__webpack_require__, 14445, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/swift', () => __webpack_require__.e(/* import() */ 468).then(__webpack_require__.t.bind(__webpack_require__, 40468, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tcl', () => __webpack_require__.e(/* import() */ 7228).then(__webpack_require__.t.bind(__webpack_require__, 47228, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/terraform', () => __webpack_require__.e(/* import() */ 5131).then(__webpack_require__.t.bind(__webpack_require__, 25131, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tex', () => __webpack_require__.e(/* import() */ 3190).then(__webpack_require__.t.bind(__webpack_require__, 13190, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/text', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 49432, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/textile', () => __webpack_require__.e(/* import() */ 6314).then(__webpack_require__.t.bind(__webpack_require__, 56314, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/toml', () => __webpack_require__.e(/* import() */ 3571).then(__webpack_require__.t.bind(__webpack_require__, 63571, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tsx', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(2656)]).then(__webpack_require__.t.bind(__webpack_require__, 72656, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/turtle', () => __webpack_require__.e(/* import() */ 9433).then(__webpack_require__.t.bind(__webpack_require__, 89433, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/twig', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5858)]).then(__webpack_require__.t.bind(__webpack_require__, 45858, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/typescript', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(532)]).then(__webpack_require__.t.bind(__webpack_require__, 50532, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vala', () => __webpack_require__.e(/* import() */ 1905).then(__webpack_require__.t.bind(__webpack_require__, 41905, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vbscript', () => __webpack_require__.e(/* import() */ 2956).then(__webpack_require__.t.bind(__webpack_require__, 92956, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/velocity', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(540)]).then(__webpack_require__.t.bind(__webpack_require__, 540, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/verilog', () => __webpack_require__.e(/* import() */ 4741).then(__webpack_require__.t.bind(__webpack_require__, 84741, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vhdl', () => __webpack_require__.e(/* import() */ 5941).then(__webpack_require__.t.bind(__webpack_require__, 95941, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/visualforce', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5392)]).then(__webpack_require__.t.bind(__webpack_require__, 95392, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vue', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(2561), __webpack_require__.e(7171)]).then(__webpack_require__.t.bind(__webpack_require__, 47171, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/wollok', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(843)]).then(__webpack_require__.t.bind(__webpack_require__, 843, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/xml', () => __webpack_require__.e(/* import() */ 9846).then(__webpack_require__.t.bind(__webpack_require__, 49846, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/yaml', () => __webpack_require__.e(/* import() */ 8176).then(__webpack_require__.t.bind(__webpack_require__, 48176, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/zeek', () => __webpack_require__.e(/* import() */ 5178).then(__webpack_require__.t.bind(__webpack_require__, 15178, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/zig', () => __webpack_require__.e(/* import() */ 2181).then(__webpack_require__.t.bind(__webpack_require__, 52181, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/abc', () => __webpack_require__.e(/* import() */ 3450).then(__webpack_require__.t.bind(__webpack_require__, 93450, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/abc.snippets', () => __webpack_require__.e(/* import() */ 7396).then(__webpack_require__.t.bind(__webpack_require__, 97396, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/actionscript', () => __webpack_require__.e(/* import() */ 8770).then(__webpack_require__.t.bind(__webpack_require__, 46389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/actionscript.snippets', () => __webpack_require__.e(/* import() */ 4257).then(__webpack_require__.t.bind(__webpack_require__, 64257, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/c_cpp', () => __webpack_require__.e(/* import() */ 4249).then(__webpack_require__.t.bind(__webpack_require__, 94249, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/c_cpp.snippets', () => __webpack_require__.e(/* import() */ 9037).then(__webpack_require__.t.bind(__webpack_require__, 79037, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/clojure', () => __webpack_require__.e(/* import() */ 2010).then(__webpack_require__.t.bind(__webpack_require__, 72010, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/clojure.snippets', () => __webpack_require__.e(/* import() */ 8980).then(__webpack_require__.t.bind(__webpack_require__, 48980, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/coffee', () => __webpack_require__.e(/* import() */ 7896).then(__webpack_require__.t.bind(__webpack_require__, 37896, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/coffee.snippets', () => __webpack_require__.e(/* import() */ 9590).then(__webpack_require__.t.bind(__webpack_require__, 69590, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_document', () => __webpack_require__.e(/* import() */ 3630).then(__webpack_require__.t.bind(__webpack_require__, 73630, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_document.snippets', () => __webpack_require__.e(/* import() */ 9552).then(__webpack_require__.t.bind(__webpack_require__, 69552, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_orchestra', () => __webpack_require__.e(/* import() */ 2120).then(__webpack_require__.t.bind(__webpack_require__, 62120, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_orchestra.snippets', () => __webpack_require__.e(/* import() */ 4998).then(__webpack_require__.t.bind(__webpack_require__, 14998, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/css', () => __webpack_require__.e(/* import() */ 6389).then(__webpack_require__.t.bind(__webpack_require__, 16389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/css.snippets', () => __webpack_require__.e(/* import() */ 1329).then(__webpack_require__.t.bind(__webpack_require__, 81329, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/dart', () => __webpack_require__.e(/* import() */ 8137).then(__webpack_require__.t.bind(__webpack_require__, 20518, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/dart.snippets', () => __webpack_require__.e(/* import() */ 8829).then(__webpack_require__.t.bind(__webpack_require__, 18829, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/diff', () => __webpack_require__.e(/* import() */ 8043).then(__webpack_require__.t.bind(__webpack_require__, 18043, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/diff.snippets', () => __webpack_require__.e(/* import() */ 1019).then(__webpack_require__.t.bind(__webpack_require__, 91019, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/django', () => __webpack_require__.e(/* import() */ 4095).then(__webpack_require__.t.bind(__webpack_require__, 64095, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/django.snippets', () => __webpack_require__.e(/* import() */ 6775).then(__webpack_require__.t.bind(__webpack_require__, 16775, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/drools', () => __webpack_require__.e(/* import() */ 7113).then(__webpack_require__.t.bind(__webpack_require__, 87113, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/drools.snippets', () => __webpack_require__.e(/* import() */ 4541).then(__webpack_require__.t.bind(__webpack_require__, 84541, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/edifact', () => __webpack_require__.e(/* import() */ 796).then(__webpack_require__.t.bind(__webpack_require__, 60796, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/edifact.snippets', () => __webpack_require__.e(/* import() */ 1362).then(__webpack_require__.t.bind(__webpack_require__, 11362, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/erlang', () => __webpack_require__.e(/* import() */ 4879).then(__webpack_require__.t.bind(__webpack_require__, 14879, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/erlang.snippets', () => __webpack_require__.e(/* import() */ 5511).then(__webpack_require__.t.bind(__webpack_require__, 45511, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/fsl', () => __webpack_require__.e(/* import() */ 9491).then(__webpack_require__.t.bind(__webpack_require__, 29491, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/fsl.snippets', () => __webpack_require__.e(/* import() */ 4291).then(__webpack_require__.t.bind(__webpack_require__, 44291, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/gobstones', () => __webpack_require__.e(/* import() */ 1296).then(__webpack_require__.t.bind(__webpack_require__, 81296, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/gobstones.snippets', () => __webpack_require__.e(/* import() */ 5454).then(__webpack_require__.t.bind(__webpack_require__, 35454, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/graphqlschema', () => __webpack_require__.e(/* import() */ 3976).then(__webpack_require__.t.bind(__webpack_require__, 63976, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/graphqlschema.snippets', () => __webpack_require__.e(/* import() */ 8582).then(__webpack_require__.t.bind(__webpack_require__, 38582, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haml', () => __webpack_require__.e(/* import() */ 1398).then(__webpack_require__.t.bind(__webpack_require__, 1398, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haml.snippets', () => __webpack_require__.e(/* import() */ 9736).then(__webpack_require__.t.bind(__webpack_require__, 49736, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haskell', () => __webpack_require__.e(/* import() */ 6286).then(__webpack_require__.t.bind(__webpack_require__, 66286, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haskell.snippets', () => __webpack_require__.e(/* import() */ 3056).then(__webpack_require__.t.bind(__webpack_require__, 13056, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/html', () => __webpack_require__.e(/* import() */ 2853).then(__webpack_require__.t.bind(__webpack_require__, 42853, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/html.snippets', () => __webpack_require__.e(/* import() */ 7921).then(__webpack_require__.t.bind(__webpack_require__, 27921, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/io', () => __webpack_require__.e(/* import() */ 4612).then(__webpack_require__.t.bind(__webpack_require__, 64612, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/java', () => __webpack_require__.e(/* import() */ 5884).then(__webpack_require__.t.bind(__webpack_require__, 45884, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/java.snippets', () => __webpack_require__.e(/* import() */ 2178).then(__webpack_require__.t.bind(__webpack_require__, 42178, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/javascript', () => __webpack_require__.e(/* import() */ 207).then(__webpack_require__.t.bind(__webpack_require__, 70207, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/javascript.snippets', () => __webpack_require__.e(/* import() */ 3575).then(__webpack_require__.t.bind(__webpack_require__, 93575, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/jsp', () => __webpack_require__.e(/* import() */ 8371).then(__webpack_require__.t.bind(__webpack_require__, 58371, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/jsp.snippets', () => __webpack_require__.e(/* import() */ 4787).then(__webpack_require__.t.bind(__webpack_require__, 44787, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/liquid', () => __webpack_require__.e(/* import() */ 3916).then(__webpack_require__.t.bind(__webpack_require__, 93916, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/liquid.snippets', () => __webpack_require__.e(/* import() */ 5058).then(__webpack_require__.t.bind(__webpack_require__, 45058, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lsl', () => __webpack_require__.e(/* import() */ 3121).then(__webpack_require__.t.bind(__webpack_require__, 53121, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lsl.snippets', () => __webpack_require__.e(/* import() */ 3797).then(__webpack_require__.t.bind(__webpack_require__, 43797, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lua', () => __webpack_require__.e(/* import() */ 4876).then(__webpack_require__.t.bind(__webpack_require__, 74876, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lua.snippets', () => __webpack_require__.e(/* import() */ 3650).then(__webpack_require__.t.bind(__webpack_require__, 63650, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/makefile', () => __webpack_require__.e(/* import() */ 2640).then(__webpack_require__.t.bind(__webpack_require__, 52640, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/makefile.snippets', () => __webpack_require__.e(/* import() */ 2398).then(__webpack_require__.t.bind(__webpack_require__, 72398, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/markdown', () => __webpack_require__.e(/* import() */ 9253).then(__webpack_require__.t.bind(__webpack_require__, 99253, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/markdown.snippets', () => __webpack_require__.e(/* import() */ 2177).then(__webpack_require__.t.bind(__webpack_require__, 2177, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/maze', () => __webpack_require__.e(/* import() */ 2335).then(__webpack_require__.t.bind(__webpack_require__, 12335, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/maze.snippets', () => __webpack_require__.e(/* import() */ 4487).then(__webpack_require__.t.bind(__webpack_require__, 74487, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/perl', () => __webpack_require__.e(/* import() */ 6185).then(__webpack_require__.t.bind(__webpack_require__, 76185, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/perl.snippets', () => __webpack_require__.e(/* import() */ 2989).then(__webpack_require__.t.bind(__webpack_require__, 62989, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/php', () => __webpack_require__.e(/* import() */ 6302).then(__webpack_require__.t.bind(__webpack_require__, 6302, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/php.snippets', () => __webpack_require__.e(/* import() */ 4880).then(__webpack_require__.t.bind(__webpack_require__, 64880, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/python', () => __webpack_require__.e(/* import() */ 8066).then(__webpack_require__.t.bind(__webpack_require__, 48066, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/python.snippets', () => __webpack_require__.e(/* import() */ 1884).then(__webpack_require__.t.bind(__webpack_require__, 31884, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/r', () => __webpack_require__.e(/* import() */ 4676).then(__webpack_require__.t.bind(__webpack_require__, 4676, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/r.snippets', () => __webpack_require__.e(/* import() */ 1738).then(__webpack_require__.t.bind(__webpack_require__, 21738, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/razor', () => __webpack_require__.e(/* import() */ 1598).then(__webpack_require__.t.bind(__webpack_require__, 11598, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/razor.snippets', () => __webpack_require__.e(/* import() */ 6848).then(__webpack_require__.t.bind(__webpack_require__, 6848, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/robot', () => __webpack_require__.e(/* import() */ 334).then(__webpack_require__.t.bind(__webpack_require__, 80334, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/robot.snippets', () => __webpack_require__.e(/* import() */ 8320).then(__webpack_require__.t.bind(__webpack_require__, 48320, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/rst', () => __webpack_require__.e(/* import() */ 767).then(__webpack_require__.t.bind(__webpack_require__, 20767, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/rst.snippets', () => __webpack_require__.e(/* import() */ 1975).then(__webpack_require__.t.bind(__webpack_require__, 51975, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/ruby', () => __webpack_require__.e(/* import() */ 8780).then(__webpack_require__.t.bind(__webpack_require__, 98780, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/ruby.snippets', () => __webpack_require__.e(/* import() */ 914).then(__webpack_require__.t.bind(__webpack_require__, 90914, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sh', () => __webpack_require__.e(/* import() */ 723).then(__webpack_require__.t.bind(__webpack_require__, 70723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sh.snippets', () => __webpack_require__.e(/* import() */ 5795).then(__webpack_require__.t.bind(__webpack_require__, 75795, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/snippets', () => __webpack_require__.e(/* import() */ 7318).then(__webpack_require__.t.bind(__webpack_require__, 27318, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/snippets.snippets', () => __webpack_require__.e(/* import() */ 9688).then(__webpack_require__.t.bind(__webpack_require__, 59688, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sql', () => __webpack_require__.e(/* import() */ 3690).then(__webpack_require__.t.bind(__webpack_require__, 53690, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sql.snippets', () => __webpack_require__.e(/* import() */ 7316).then(__webpack_require__.t.bind(__webpack_require__, 57316, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sqlserver', () => __webpack_require__.e(/* import() */ 1529).then(__webpack_require__.t.bind(__webpack_require__, 71529, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sqlserver.snippets', () => __webpack_require__.e(/* import() */ 3181).then(__webpack_require__.t.bind(__webpack_require__, 93181, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tcl', () => __webpack_require__.e(/* import() */ 585).then(__webpack_require__.t.bind(__webpack_require__, 90585, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tcl.snippets', () => __webpack_require__.e(/* import() */ 8173).then(__webpack_require__.t.bind(__webpack_require__, 8173, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tex', () => __webpack_require__.e(/* import() */ 275).then(__webpack_require__.t.bind(__webpack_require__, 80275, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tex.snippets', () => __webpack_require__.e(/* import() */ 7715).then(__webpack_require__.t.bind(__webpack_require__, 47715, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/textile', () => __webpack_require__.e(/* import() */ 8671).then(__webpack_require__.t.bind(__webpack_require__, 88671, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/textile.snippets', () => __webpack_require__.e(/* import() */ 2039).then(__webpack_require__.t.bind(__webpack_require__, 32039, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/vala', () => __webpack_require__.e(/* import() */ 4782).then(__webpack_require__.t.bind(__webpack_require__, 44782, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/velocity', () => __webpack_require__.e(/* import() */ 2327).then(__webpack_require__.t.bind(__webpack_require__, 72327, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/velocity.snippets', () => __webpack_require__.e(/* import() */ 3871).then(__webpack_require__.t.bind(__webpack_require__, 53871, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/wollok', () => __webpack_require__.e(/* import() */ 1020).then(__webpack_require__.t.bind(__webpack_require__, 81020, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/wollok.snippets', () => __webpack_require__.e(/* import() */ 3634).then(__webpack_require__.t.bind(__webpack_require__, 73634, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/ambiance', () => __webpack_require__.e(/* import() */ 697).then(__webpack_require__.t.bind(__webpack_require__, 70697, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/chaos', () => __webpack_require__.e(/* import() */ 3201).then(__webpack_require__.t.bind(__webpack_require__, 33201, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/chrome', () => __webpack_require__.e(/* import() */ 5403).then(__webpack_require__.t.bind(__webpack_require__, 75403, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_day', () => __webpack_require__.e(/* import() */ 1652).then(__webpack_require__.t.bind(__webpack_require__, 51652, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_night', () => __webpack_require__.e(/* import() */ 8440).then(__webpack_require__.t.bind(__webpack_require__, 68440, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_night_low_color', () => __webpack_require__.e(/* import() */ 189).then(__webpack_require__.t.bind(__webpack_require__, 30189, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud_editor', () => __webpack_require__.e(/* import() */ 9486).then(__webpack_require__.t.bind(__webpack_require__, 89486, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud_editor_dark', () => __webpack_require__.e(/* import() */ 7029).then(__webpack_require__.t.bind(__webpack_require__, 27029, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/clouds', () => __webpack_require__.e(/* import() */ 983).then(__webpack_require__.t.bind(__webpack_require__, 30983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/clouds_midnight', () => __webpack_require__.e(/* import() */ 3474).then(__webpack_require__.t.bind(__webpack_require__, 3474, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cobalt', () => __webpack_require__.e(/* import() */ 4718).then(__webpack_require__.t.bind(__webpack_require__, 42337, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/crimson_editor', () => __webpack_require__.e(/* import() */ 5006).then(__webpack_require__.t.bind(__webpack_require__, 65006, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dawn', () => __webpack_require__.e(/* import() */ 6919).then(__webpack_require__.t.bind(__webpack_require__, 66919, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dracula', () => __webpack_require__.e(/* import() */ 7931).then(__webpack_require__.t.bind(__webpack_require__, 67931, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dreamweaver', () => __webpack_require__.e(/* import() */ 9426).then(__webpack_require__.t.bind(__webpack_require__, 99426, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/eclipse', () => __webpack_require__.e(/* import() */ 9912).then(__webpack_require__.t.bind(__webpack_require__, 39912, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github', () => __webpack_require__.e(/* import() */ 4214).then(__webpack_require__.t.bind(__webpack_require__, 24214, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github_dark', () => __webpack_require__.e(/* import() */ 650).then(__webpack_require__.t.bind(__webpack_require__, 68269, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github_light_default', () => __webpack_require__.e(/* import() */ 1767).then(__webpack_require__.t.bind(__webpack_require__, 81767, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gob', () => __webpack_require__.e(/* import() */ 4773).then(__webpack_require__.t.bind(__webpack_require__, 94773, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox', () => __webpack_require__.e(/* import() */ 294).then(__webpack_require__.t.bind(__webpack_require__, 90294, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox_dark_hard', () => __webpack_require__.e(/* import() */ 3701).then(__webpack_require__.t.bind(__webpack_require__, 43701, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox_light_hard', () => __webpack_require__.e(/* import() */ 8429).then(__webpack_require__.t.bind(__webpack_require__, 18429, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/idle_fingers', () => __webpack_require__.e(/* import() */ 3902).then(__webpack_require__.t.bind(__webpack_require__, 63902, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/iplastic', () => __webpack_require__.e(/* import() */ 5496).then(__webpack_require__.t.bind(__webpack_require__, 65496, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/katzenmilch', () => __webpack_require__.e(/* import() */ 5195).then(__webpack_require__.t.bind(__webpack_require__, 25195, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/kr_theme', () => __webpack_require__.e(/* import() */ 7750).then(__webpack_require__.t.bind(__webpack_require__, 97750, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/kuroir', () => __webpack_require__.e(/* import() */ 5993).then(__webpack_require__.t.bind(__webpack_require__, 35993, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/merbivore', () => __webpack_require__.e(/* import() */ 42).then(__webpack_require__.t.bind(__webpack_require__, 40042, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/merbivore_soft', () => __webpack_require__.e(/* import() */ 5649).then(__webpack_require__.t.bind(__webpack_require__, 35649, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/mono_industrial', () => __webpack_require__.e(/* import() */ 9322).then(__webpack_require__.t.bind(__webpack_require__, 29322, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/monokai', () => __webpack_require__.e(/* import() */ 507).then(__webpack_require__.t.bind(__webpack_require__, 507, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/nord_dark', () => __webpack_require__.e(/* import() */ 3823).then(__webpack_require__.t.bind(__webpack_require__, 53823, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/one_dark', () => __webpack_require__.e(/* import() */ 8792).then(__webpack_require__.t.bind(__webpack_require__, 28792, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/pastel_on_dark', () => __webpack_require__.e(/* import() */ 2633).then(__webpack_require__.t.bind(__webpack_require__, 72633, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/solarized_dark', () => __webpack_require__.e(/* import() */ 8793).then(__webpack_require__.t.bind(__webpack_require__, 58793, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/solarized_light', () => __webpack_require__.e(/* import() */ 1897).then(__webpack_require__.t.bind(__webpack_require__, 51897, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/sqlserver', () => __webpack_require__.e(/* import() */ 2038).then(__webpack_require__.t.bind(__webpack_require__, 2038, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/terminal', () => __webpack_require__.e(/* import() */ 8097).then(__webpack_require__.t.bind(__webpack_require__, 78097, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/textmate', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 87983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow', () => __webpack_require__.e(/* import() */ 5494).then(__webpack_require__.t.bind(__webpack_require__, 35494, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night', () => __webpack_require__.e(/* import() */ 1007).then(__webpack_require__.t.bind(__webpack_require__, 11007, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_blue', () => __webpack_require__.e(/* import() */ 6094).then(__webpack_require__.t.bind(__webpack_require__, 6094, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_bright', () => __webpack_require__.e(/* import() */ 6910).then(__webpack_require__.t.bind(__webpack_require__, 36910, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_eighties', () => __webpack_require__.e(/* import() */ 4200).then(__webpack_require__.t.bind(__webpack_require__, 74200, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/twilight', () => __webpack_require__.e(/* import() */ 693).then(__webpack_require__.t.bind(__webpack_require__, 40693, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/vibrant_ink', () => __webpack_require__.e(/* import() */ 2144).then(__webpack_require__.t.bind(__webpack_require__, 12144, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/xcode', () => __webpack_require__.e(/* import() */ 1292).then(__webpack_require__.t.bind(__webpack_require__, 21292, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/vim', () => __webpack_require__.e(/* import() */ 2829).then(__webpack_require__.t.bind(__webpack_require__, 2829, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/emacs', () => __webpack_require__.e(/* import() */ 8534).then(__webpack_require__.t.bind(__webpack_require__, 48534, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/sublime', () => __webpack_require__.e(/* import() */ 8390).then(__webpack_require__.t.bind(__webpack_require__, 48390, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/vscode', () => __webpack_require__.e(/* import() */ 3087).then(__webpack_require__.t.bind(__webpack_require__, 13087, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/beautify', () => __webpack_require__.e(/* import() */ 4166).then(__webpack_require__.t.bind(__webpack_require__, 34166, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/code_lens', () => __webpack_require__.e(/* import() */ 1377).then(__webpack_require__.t.bind(__webpack_require__, 91377, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/command_bar', () => __webpack_require__.e(/* import() */ 7700).then(__webpack_require__.t.bind(__webpack_require__, 47700, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/elastic_tabstops_lite', () => __webpack_require__.e(/* import() */ 958).then(__webpack_require__.t.bind(__webpack_require__, 10958, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/emmet', () => __webpack_require__.e(/* import() */ 9395).then(__webpack_require__.t.bind(__webpack_require__, 79395, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/error_marker', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 4126, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/hardwrap', () => __webpack_require__.e(/* import() */ 7674).then(__webpack_require__.t.bind(__webpack_require__, 57674, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/inline_autocomplete', () => __webpack_require__.e(/* import() */ 9885).then(__webpack_require__.t.bind(__webpack_require__, 29885, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/keybinding_menu', () => __webpack_require__.e(/* import() */ 3281).then(__webpack_require__.t.bind(__webpack_require__, 73281, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/language_tools', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 61893, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/linking', () => __webpack_require__.e(/* import() */ 4323).then(__webpack_require__.t.bind(__webpack_require__, 94323, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/modelist', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 91772, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/options', () => __webpack_require__.e(/* import() */ 6613).then(__webpack_require__.t.bind(__webpack_require__, 86613, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/prompt', () => __webpack_require__.e(/* import() */ 1085).then(__webpack_require__.t.bind(__webpack_require__, 71085, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/rtl', () => __webpack_require__.e(/* import() */ 7413).then(__webpack_require__.t.bind(__webpack_require__, 87413, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/searchbox', () => __webpack_require__.e(/* import() */ 1570).then(__webpack_require__.t.bind(__webpack_require__, 41570, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/settings_menu', () => __webpack_require__.e(/* import() */ 1214).then(__webpack_require__.t.bind(__webpack_require__, 11214, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/simple_tokenizer', () => __webpack_require__.e(/* import() */ 3199).then(__webpack_require__.t.bind(__webpack_require__, 23199, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/spellcheck', () => __webpack_require__.e(/* import() */ 3641).then(__webpack_require__.t.bind(__webpack_require__, 53641, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/split', () => __webpack_require__.e(/* import() */ 8939).then(__webpack_require__.t.bind(__webpack_require__, 58939, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/static_highlight', () => __webpack_require__.e(/* import() */ 7254).then(__webpack_require__.t.bind(__webpack_require__, 47254, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/statusbar', () => __webpack_require__.e(/* import() */ 5044).then(__webpack_require__.t.bind(__webpack_require__, 5044, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/textarea', () => __webpack_require__.e(/* import() */ 2697).then(__webpack_require__.t.bind(__webpack_require__, 92697, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/themelist', () => __webpack_require__.e(/* import() */ 1494).then(__webpack_require__.t.bind(__webpack_require__, 91494, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/whitespace', () => __webpack_require__.e(/* import() */ 1482).then(__webpack_require__.t.bind(__webpack_require__, 21482, 19)));



/***/ }),

/***/ 80820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * The main class required to set up an Ace instance in the browser.
 *
 * @namespace Ace
 **/

"include loader_build";

var dom = __webpack_require__(71435);

var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Editor = (__webpack_require__(27258).Editor);
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
var UndoManager = (__webpack_require__(79870)/* .UndoManager */ .a);
var Renderer = (__webpack_require__(21016).VirtualRenderer);

// The following require()s are for inclusion in the built ace file
__webpack_require__(28402);
__webpack_require__(93050);
__webpack_require__(30214);
__webpack_require__(48369);
__webpack_require__(51358);
__webpack_require__(87983);
__webpack_require__(4126);

exports.config = __webpack_require__(76321);


/**
 * Embeds the Ace editor into the DOM, at the element provided by `el`.
 * @param {String | HTMLElement & {env?: any, value?: any} | null} [el] Either the id of an element, or the element itself
 * @param {Object } [options] Options for the editor
 * @returns {Editor}
 **/
exports.edit = function(el, options) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = el.textContent;
        el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);
    var editor = new Editor(new Renderer(el), doc, options);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    editor.on("destroy", function() {
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};

/**
 * Creates a new [[EditSession]], and returns the associated [[Document]].
 * @param {import('./document').Document | String} text {:textParam}
 * @param {import("../ace-internal").Ace.SyntaxMode} [mode] {:modeParam}
 * @returns {EditSession}
 **/
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.Range = Range;
exports.Editor = Editor;
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.VirtualRenderer = Renderer;
var version = exports.config.version;
exports.version = version;


/***/ }),

/***/ 67490:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./document").Document} Document
 */
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

/**
 * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.
 **/
class Anchor {
    /**
     * Creates a new `Anchor` and associates it with a document.
     *
     * @param {Document} doc The document to associate with the anchor
     * @param {Number|import("../ace-internal").Ace.Point} row The starting row position
     * @param {Number} [column] The starting column position
     **/
    constructor(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);

        if (typeof row != "number")
            this.setPosition(row.row, row.column);
        else
            this.setPosition(row, column);
    }

    /**
     * Returns an object identifying the `row` and `column` position of the current anchor.
     * @returns {import("../ace-internal").Ace.Point}
     **/
    getPosition() {
        return this.$clipPositionToDocument(this.row, this.column);
    }

    /**
     *
     * Returns the current document.
     * @returns {Document}
     **/
    getDocument() {
        return this.document;
    }

    /**
     * Internal function called when `"change"` event fired.
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onChange(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;

        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    }

    /**
     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
     * @param {Number} row The row index to move the anchor to
     * @param {Number} column The column index to move the anchor to
     * @param {Boolean} [noClip] Identifies if you want the position to be clipped
     **/
    setPosition(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    }

    /**
     * When called, the `"change"` event listener is removed.
     *
     **/
    detach() {
        this.document.off("change", this.$onChange);
    }

    /**
     * When called, the `"change"` event listener is appended.
     * @param {Document} doc The document to associate with
     *
     **/
    attach(doc) {
        /**@type{Document}*/
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    }

    /**
     * Clips the anchor position to the specified row and column.
     * @param {Number} row The row index to clip the anchor to
     * @param {Number} column The column index to clip the anchor to
     * @returns {import("../ace-internal").Ace.Point}
     *
     **/
    $clipPositionToDocument(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    }
}

/**
 * experimental: allows anchor to stick to the next on the left
 */
Anchor.prototype.$insertRight = false;

oop.implement(Anchor.prototype, EventEmitter);

function $pointsInOrder(point1, point2, equalPointsInOrder) {
    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
    return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
}

function $getTransformedPoint(delta, point, moveIfEqual) {
    // Get delta info.
    var deltaIsInsert = delta.action == "insert";
    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
    var deltaStart = delta.start;
    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.

    // DELTA AFTER POINT: No change needed.
    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
            row: point.row,
            column: point.column
        };
    }

    // DELTA BEFORE POINT: Move point by delta shift.
    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
    }

    // DELTA ENVELOPS POINT (delete only): Move point to delta start.
    // TODO warn if delta.action != "remove" ?

    return {
        row: deltaStart.row,
        column: deltaStart.column
    };
}

exports.M = Anchor;


/***/ }),

/***/ 28646:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    // Validate action string.
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    
    // Validate lines type.
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");

    // Validate range type.
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");

    // Validate that the start point is contained in the document.
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    
    // Validate that the end point is contained in the document (remove deltas only).
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    
    // Validate that the .range size matches the .lines size.
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

/**
 * Applies a delta to a document.
 * @param {string[]} docLines
 * @param {import("../ace-internal").Ace.Delta} delta
 * @param [doNotValidate]
 */
exports.T = function(docLines, delta, doNotValidate) {
    // disabled validation since it breaks autocompletion popup
    // if (!doNotValidate)
    //    validateDelta(docLines, delta);
    
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                // @ts-ignore
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};


/***/ }),

/***/ 26347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("../ace-internal").Ace.CompletionProviderOptions} CompletionProviderOptions
 * @typedef {import("../ace-internal").Ace.CompletionOptions} CompletionOptions
 * @typedef {import("../ace-internal").Ace.Position} Position
 */
var HashHandler = (__webpack_require__(93050).HashHandler);
var AcePopup = (__webpack_require__(51826).AcePopup);
var AceInline = (__webpack_require__(76703)/* .AceInline */ .V);
var getAriaId = (__webpack_require__(51826).getAriaId);
var util = __webpack_require__(28630);
var lang = __webpack_require__(39955);
var dom = __webpack_require__(71435);
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var config = __webpack_require__(76321);
var event = __webpack_require__(19631);
var preventParentScroll = (__webpack_require__(58298)/* .preventParentScroll */ .K);

/**
 * @typedef BaseCompletion
 * @property {number} [score] - a numerical value that determines the order in which completions would be displayed.
 * A lower score means that the completion would be displayed further from the start
 * @property {string} [meta] - a short description of the completion
 * @property {string} [caption] - the text that would be displayed in the completion list. If omitted, value or snippet
 * would be shown instead.
 * @property {string} [docHTML] - an HTML string that would be displayed as an additional popup
 * @property {string} [docText] - a plain text that would be displayed as an additional popup. If `docHTML` exists,
 * it would be used instead of `docText`.
 * @property {string} [completerId] - the identifier of the completer
 * @property {import("../ace-internal").Ace.IRange} [range] - An object specifying the range of text to be replaced with the new completion value (experimental)
 * @property {any} [command] - A command to be executed after the completion is inserted (experimental)
 * @property {string} [snippet] - a text snippet that would be inserted when the completion is selected
 * @property {string} [value] - The text that would be inserted when selecting this completion.
 * @property {import("../ace-internal").Ace.Completer} [completer]
 * @property {boolean} [hideInlinePreview]
 * @export
 */

/**
 * @typedef {BaseCompletion & {snippet: string}} SnippetCompletion
 * @property {string} snippet
 * @property {string} [value]
 * @export
 */

/**
 * @typedef {BaseCompletion & {value: string}} ValueCompletion
 * @property {string} value
 * @property {string} [snippet]
 * @export
 */

/**
 * Represents a suggested text snippet intended to complete a user's input
 * @typedef Completion
 * @type {SnippetCompletion|ValueCompletion}
 * @export
 */

var destroyCompleter = function(e, editor) {
    editor.completer && editor.completer.destroy();
};

/**
 * This object controls the autocompletion components and their lifecycle.
 * There is an autocompletion popup, an optional inline ghost text renderer and a docuent tooltip popup inside.
 */
class Autocomplete {
    constructor() {
        this.autoInsert = false;
        this.autoSelect = true;
        this.autoShown = false;
        this.exactMatch = false;
        this.inlineEnabled = false;
        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys(this.commands);
        this.parentNode = null;
        this.setSelectOnHover = false;
        /**@private*/
        this.hasSeen = new Set();

        /**
         *  @property {Boolean} showLoadingState - A boolean indicating whether the loading states of the Autocompletion should be shown to the end-user. If enabled
         * it shows a loading indicator on the popup while autocomplete is loading.
         *
         * Experimental: This visualisation is not yet considered stable and might change in the future.
         */
        this.showLoadingState = false;

        /**
         *  @property {number} stickySelectionDelay - a numerical value that determines after how many ms the popup selection will become 'sticky'.
         *  Normally, when new elements are added to an open popup, the selection is reset to the first row of the popup. If sticky, the focus will remain
         *  on the currently selected item when new items are added to the popup. Set to a negative value to disable this feature and never set selection to sticky.
         */
        this.stickySelectionDelay = 500;

        this.blurListener = this.blurListener.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);
        this.onLayoutChange = this.onLayoutChange.bind(this);

        this.changeTimer = lang.delayedCall(function() {
            this.updateCompletions(true);
        }.bind(this));

        this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
        this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);

        this.stickySelectionTimer = lang.delayedCall(function() {
            this.stickySelection = true;
        }.bind(this), this.stickySelectionDelay);

        this.$firstOpenTimer = lang.delayedCall(/**@this{Autocomplete}*/function() {
            var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
            if (this.autoShown || (this.popup && this.popup.isOpen) || !initialPosition || this.editor.completers.length === 0) return;

            this.completions = new FilteredList(Autocomplete.completionsForLoading);
            this.openPopup(this.editor, initialPosition.prefix, false);
            this.popup.renderer.setStyle("ace_loading", true);
        }.bind(this), this.stickySelectionDelay);
    }

    static get completionsForLoading() { return [{
            caption: config.nls("autocomplete.loading", "Loading..."),
            value: ""
        }];
    }

    $init() {
        /**@type {AcePopup}**/
        this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
        this.popup.on("click", function(e) {
            this.insertMatch();
            e.stop();
        }.bind(this));
        this.popup.focus = this.editor.focus.bind(this.editor);
        this.popup.on("show", this.$onPopupShow.bind(this));
        this.popup.on("hide", this.$onHidePopup.bind(this));
        this.popup.on("select", this.$onPopupChange.bind(this));
        event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
        this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
        this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
        return this.popup;
    }


    $initInline() {
        if (!this.inlineEnabled || this.inlineRenderer)
            return;
        this.inlineRenderer = new AceInline();
        return this.inlineRenderer;
    }

    /**
     * @return {AcePopup}
     */
    getPopup() {
        return this.popup || this.$init();
    }

    $onHidePopup() {
        if (this.inlineRenderer) {
            this.inlineRenderer.hide();
        }
        this.hideDocTooltip();
        this.stickySelectionTimer.cancel();
        this.popupTimer.cancel();
        this.stickySelection = false;
    }
    $seen(completion) {
        if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
            completion.completer.onSeen(this.editor, completion);
            this.hasSeen.add(completion);
        }
    }
    $onPopupChange(hide) {
        if (this.inlineRenderer && this.inlineEnabled) {
            var completion = hide ? null : this.popup.getData(this.popup.getRow());
            this.$updateGhostText(completion);
            // If the mouse is over the tooltip, and we're changing selection on hover don't
            // move the tooltip while hovering over the popup.
            if (this.popup.isMouseOver && this.setSelectOnHover) {
                // @ts-expect-error TODO: potential wrong arguments
                this.tooltipTimer.call(null, null);
                return;
            }

            // Update the popup position after a short wait to account for potential scrolling
            this.popupTimer.schedule();
            this.tooltipTimer.schedule();
        } else {
            // @ts-expect-error TODO: potential wrong arguments
            this.popupTimer.call(null, null);
            // @ts-expect-error TODO: potential wrong arguments
            this.tooltipTimer.call(null, null);
        }
    }

    $updateGhostText(completion) {
        // Ghost text can include characters normally not part of the prefix (e.g. whitespace).
        // When typing ahead with ghost text however, we want to simply prefix with respect to the
        // base of the completion.
        var row = this.base.row;
        var column = this.base.column;
        var cursorColumn = this.editor.getCursorPosition().column;
        var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);

        if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
            this.inlineRenderer.hide();
        } else {
            this.$seen(completion);
        }
    }

    $onPopupRender() {
        const inlineEnabled = this.inlineRenderer && this.inlineEnabled;
        if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
            for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {
                var completion = this.popup.getData(i);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                    this.$seen(completion);
                }
            }
        }
    }

    $onPopupShow(hide) {
        this.$onPopupChange(hide);
        this.stickySelection = false;
        if (this.stickySelectionDelay >= 0)
            this.stickySelectionTimer.schedule(this.stickySelectionDelay);
    }

    observeLayoutChanges() {
        if (this.$elements || !this.editor) return;
        window.addEventListener("resize", this.onLayoutChange, {passive: true});
        window.addEventListener("wheel", this.mousewheelListener);

        var el = this.editor.container.parentNode;
        var elements = [];
        while (el) {
            elements.push(el);
            el.addEventListener("scroll", this.onLayoutChange, {passive: true});
            el = el.parentNode;
        }
        this.$elements = elements;
    }
    unObserveLayoutChanges() {
        // @ts-expect-error This is expected for some browsers
        window.removeEventListener("resize", this.onLayoutChange, {passive: true});
        window.removeEventListener("wheel", this.mousewheelListener);
        this.$elements && this.$elements.forEach((el) => {
            // @ts-expect-error This is expected for some browsers
            el.removeEventListener("scroll", this.onLayoutChange, {passive: true});
        });
        this.$elements = null;
    }

    /**
     * @internal
     */
    onLayoutChange() {
        if (!this.popup.isOpen) return this.unObserveLayoutChanges();
        this.$updatePopupPosition();
        this.updateDocTooltip();
    }

    $updatePopupPosition() {
        var editor = this.editor;
        var renderer = editor.renderer;

        var lineHeight = renderer.layerConfig.lineHeight;
        var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
        pos.left -= this.popup.getTextLeftOffset();

        var rect = editor.container.getBoundingClientRect();
        pos.top += rect.top - renderer.layerConfig.offset;
        pos.left += rect.left - editor.renderer.scrollLeft;
        pos.left += renderer.gutterWidth;

        var posGhostText = {
            top: pos.top,
            left: pos.left
        };

        if (renderer.$ghostText && renderer.$ghostTextWidget) {
            if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
            }
        }

        // posGhostText can be below the editor rendering the popup away from the editor.
        // In this case, we want to render the popup such that the top aligns with the bottom of the editor.
        var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
        var lowestPosition = editorContainerBottom < posGhostText.top ?
            {top: editorContainerBottom, left: posGhostText.left} :
            posGhostText;

        // Try to render below ghost text, then above ghost text, then over ghost text
        if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
            return;
        }

        if (this.popup.tryShow(pos, lineHeight, "top")) {
            return;
        }

        this.popup.show(pos, lineHeight);
    }

    /**
     * @param {Editor} editor
     * @param {string} prefix
     * @param {boolean} [keepPopupPosition]
     */
    openPopup(editor, prefix, keepPopupPosition) {
        this.$firstOpenTimer.cancel();

        if (!this.popup)
            this.$init();

        if (this.inlineEnabled && !this.inlineRenderer)
            this.$initInline();

        this.popup.autoSelect = this.autoSelect;
        this.popup.setSelectOnHover(this.setSelectOnHover);

        var oldRow = this.popup.getRow();
        var previousSelectedItem = this.popup.data[oldRow];

        this.popup.setData(this.completions.filtered, this.completions.filterText);
        if (this.editor.textInput.setAriaOptions) {
            this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
            });
        }

        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);

        var newRow;
        if (this.stickySelection)
            newRow = this.popup.data.indexOf(previousSelectedItem);
        if (!newRow || newRow === -1)
            newRow = 0;

        this.popup.setRow(this.autoSelect ? newRow : -1);

        // If we stay on the same row, but the content is different, we want to update the popup.
        if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
            this.$onPopupChange();

        // If we stay on the same line and have inlinePreview enabled, we want to make sure the
        // ghost text remains up-to-date.
        const inlineEnabled = this.inlineRenderer && this.inlineEnabled;
        if (newRow === oldRow && inlineEnabled) {
            var completion = this.popup.getData(this.popup.getRow());
            this.$updateGhostText(completion);
        }

        if (!keepPopupPosition) {
            this.popup.setTheme(editor.getTheme());
            this.popup.setFontSize(editor.getFontSize());

            this.$updatePopupPosition();
            if (this.tooltipNode) {
                this.updateDocTooltip();
            }
        }
        this.changeTimer.cancel();
        this.observeLayoutChanges();
    }

    /**
     * Detaches all elements from the editor, and cleans up the data for the session
     */
    detach() {
        if (this.editor) {
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.off("changeSelection", this.changeListener);
            this.editor.off("blur", this.blurListener);
            this.editor.off("mousedown", this.mousedownListener);
            this.editor.off("mousewheel", this.mousewheelListener);
        }
        this.$firstOpenTimer.cancel();

        this.changeTimer.cancel();
        this.hideDocTooltip();

        if (this.completionProvider) {
            this.completionProvider.detach();
        }

        if (this.popup && this.popup.isOpen)
            this.popup.hide();

        if (this.popup && this.popup.renderer) {
            this.popup.renderer.off("afterRender", this.$onPopupRender);
        }

        if (this.base)
            this.base.detach();
        this.activated = false;
        this.completionProvider = this.completions = this.base = null;
        this.unObserveLayoutChanges();
    }

    changeListener(e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row != this.base.row || cursor.column < this.base.column) {
            this.detach();
        }
        if (this.activated)
            this.changeTimer.schedule();
        else
            this.detach();
    }

    blurListener(e) {
        // we have to check if activeElement is a child of popup because
        // on IE preventDefault doesn't stop scrollbar from being focussed
        var el = document.activeElement;
        var text = this.editor.textInput.getElement();
        var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
        var container = this.popup && this.popup.container;
        if (el != text && el.parentNode != container && !fromTooltip
            && el != this.tooltipNode && e.relatedTarget != text
        ) {
            this.detach();
        }
    }

    mousedownListener(e) {
        this.detach();
    }

    mousewheelListener(e) {
        if (this.popup && !this.popup.isMouseOver)
            this.detach();
    }

    mouseOutListener(e) {
        // Check whether the popup is still open after the mouseout event,
        // if so, attempt to move it to its desired position.
        if (this.popup.isOpen)
            this.$updatePopupPosition();
    }

   goTo(where) {
        this.popup.goTo(where);
    }

    /**
     * @param {Completion} data
     * @param {undefined} [options]
     * @return {boolean | void}
     */
    insertMatch(data, options) {
        if (!data)
            data = this.popup.getData(this.popup.getRow());
        if (!data)
            return false;
        if (data.value === "") // Explicitly given nothing to insert, e.g. "No suggestion state"
            return this.detach();
        var completions = this.completions;
        // @ts-expect-error TODO: potential wrong arguments
        var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
        // detach only if new popup was not opened while inserting match
        if (this.completions == completions)
            this.detach();
        return result;
    }

    /**
     * This is the entry point for the autocompletion class, triggers the actions which collect and display suggestions
     * @param {Editor} editor
     * @param {CompletionOptions} [options]
     */
    showPopup(editor, options) {
        if (this.editor)
            this.detach();

        this.activated = true;

        this.editor = editor;
        if (editor.completer != this) {
            if (editor.completer)
                editor.completer.detach();
            editor.completer = this;
        }

        editor.on("changeSelection", this.changeListener);
        editor.on("blur", this.blurListener);
        editor.on("mousedown", this.mousedownListener);
        editor.on("mousewheel", this.mousewheelListener);

        this.updateCompletions(false, options);
    }

    /**
     *
     * @param {{pos: Position, prefix: string}} [initialPosition]
     * @return {CompletionProvider}
     */
    getCompletionProvider(initialPosition) {
        if (!this.completionProvider)
            this.completionProvider = new CompletionProvider(initialPosition);
        return this.completionProvider;
    }

    /**
     * This method is deprecated, it is only kept for backwards compatibility.
     * Use the same method include CompletionProvider instead for the same functionality.
     * @deprecated
     */
    gatherCompletions(editor, callback) {
        return this.getCompletionProvider().gatherCompletions(editor, callback);
    }

    /**
     * @param {boolean} keepPopupPosition
     * @param {CompletionOptions} [options]
     */
    updateCompletions(keepPopupPosition, options) {
        if (keepPopupPosition && this.base && this.completions) {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
            if (prefix == this.completions.filterText)
                return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
                return this.detach();
            if (this.completions.filtered.length == 1
            && this.completions.filtered[0].value == prefix
            && !this.completions.filtered[0].snippet)
                return this.detach();
            this.openPopup(this.editor, prefix, keepPopupPosition);
            return;
        }

        if (options && options.matches) {
            var pos = this.editor.getSelectionRange().start;
            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
            this.base.$insertRight = true;
            this.completions = new FilteredList(options.matches);
            this.getCompletionProvider().completions = this.completions;
            return this.openPopup(this.editor, "", keepPopupPosition);
        }

        var session = this.editor.getSession();
        var pos = this.editor.getCursorPosition();
        var prefix = util.getCompletionPrefix(this.editor);
        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
        this.base.$insertRight = true;
        var completionOptions = {
            exactMatch: this.exactMatch,
            // @ts-expect-error TODO: couldn't find initializer
            ignoreCaption: this.ignoreCaption
        };
        this.getCompletionProvider({
            prefix,
            pos
        }).provideCompletions(this.editor, completionOptions,
            /**
             * @type {(err: any, completions: FilteredList, finished: boolean) => void | boolean}
             * @this {Autocomplete}
             */
            function (err, completions, finished) {
                var filtered = completions.filtered;
                var prefix = util.getCompletionPrefix(this.editor);
            this.$firstOpenTimer.cancel();

                if (finished) {
                    // No results
                    if (!filtered.length) {
                        var emptyMessage = !this.autoShown && this.emptyMessage;
                        if (typeof emptyMessage == "function") emptyMessage = this.emptyMessage(prefix);
                        if (emptyMessage) {
                        var completionsForEmpty = [{
                            caption: emptyMessage,
                                    value: ""
                                }
                            ];
                            this.completions = new FilteredList(completionsForEmpty);
                            this.openPopup(this.editor, prefix, keepPopupPosition);
                            this.popup.renderer.setStyle("ace_loading", false);
                            this.popup.renderer.setStyle("ace_empty-message", true);
                            return;
                        }
                        return this.detach();
                    }

                    // One result equals to the prefix
                    if (filtered.length == 1 && filtered[0].value == prefix
                        && !filtered[0].snippet) return this.detach();

                    // Autoinsert if one result
                    if (this.autoInsert && !this.autoShown && filtered.length == 1) return this.insertMatch(
                        filtered[0]);
                }
            // If showLoadingState is true and there is still a completer loading, show 'Loading...'
            // in the top row of the completer popup.
            this.completions = !finished && this.showLoadingState ?
                new FilteredList(
                    Autocomplete.completionsForLoading.concat(filtered), completions.filterText
                ) :
                completions;

                this.openPopup(this.editor, prefix, keepPopupPosition);

            this.popup.renderer.setStyle("ace_empty-message", false);
            this.popup.renderer.setStyle("ace_loading", !finished);
        }.bind(this));

        if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
            this.$firstOpenTimer.delay(this.stickySelectionDelay/2);
        }
    }

    cancelContextMenu() {
        this.editor.$mouseHandler.cancelContextMenu();
    }

    updateDocTooltip() {
        var popup = this.popup;
        var all = this.completions.filtered;
        var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
        var doc = null;
        if (!selected || !this.editor || !this.popup.isOpen)
            return this.hideDocTooltip();

        var completersLength = this.editor.completers.length;
        for (var i = 0; i < completersLength; i++) {
            var completer = this.editor.completers[i];
            if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
            }
        }
        if (!doc && typeof selected != "string")
            doc = selected;

        if (typeof doc == "string")
            doc = {docText: doc};
        if (!doc || !(doc.docHTML || doc.docText))
            return this.hideDocTooltip();
        this.showDocTooltip(doc);
    }

    showDocTooltip(item) {
        if (!this.tooltipNode) {
            this.tooltipNode = dom.createElement("div");
            this.tooltipNode.style.margin = "0";
            this.tooltipNode.style.pointerEvents = "auto";
            this.tooltipNode.style.overscrollBehavior = "contain";
            this.tooltipNode.tabIndex = -1;
            this.tooltipNode.onblur = this.blurListener.bind(this);
            this.tooltipNode.onclick = this.onTooltipClick.bind(this);
            this.tooltipNode.id = "doc-tooltip";
            this.tooltipNode.setAttribute("role", "tooltip");
            // prevent editor scroll if tooltip is inside an editor
            this.tooltipNode.addEventListener("wheel", preventParentScroll);
        }
        var theme = this.editor.renderer.theme;
        this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " +
            (theme.isDark? "ace_dark " : "") + (theme.cssClass || "");

        var tooltipNode = this.tooltipNode;
        if (item.docHTML) {
            tooltipNode.innerHTML = item.docHTML;
        } else if (item.docText) {
            tooltipNode.textContent = item.docText;
        }

        if (!tooltipNode.parentNode)
            this.popup.container.appendChild(this.tooltipNode);

        var popup = this.popup;
        var rect = popup.container.getBoundingClientRect();
        tooltipNode.style.top = popup.container.style.top;
        tooltipNode.style.bottom = popup.container.style.bottom;

        tooltipNode.style.display = "block";
        if (window.innerWidth - rect.right < 320) {
            if (rect.left < 320) {
                if(popup.isTopdown) {
                    tooltipNode.style.top = rect.bottom + "px";
                    tooltipNode.style.left = rect.left + "px";
                    tooltipNode.style.right = "";
                    tooltipNode.style.bottom = "";
                } else {
                    tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                    tooltipNode.style.left = rect.left + "px";
                    tooltipNode.style.right = "";
                    tooltipNode.style.bottom = "";
                }
            } else {
                tooltipNode.style.right = window.innerWidth - rect.left + "px";
                tooltipNode.style.left = "";
            }
        } else {
            tooltipNode.style.left = (rect.right + 1) + "px";
            tooltipNode.style.right = "";
        }
    }

    hideDocTooltip() {
        this.tooltipTimer.cancel();
        if (!this.tooltipNode) return;
        var el = this.tooltipNode;
        if (!this.editor.isFocused() && document.activeElement == el)
            this.editor.focus();
        this.tooltipNode = null;
        if (el.parentNode)
            el.parentNode.removeChild(el);
    }

    /**
     * @param e
     * @internal
     */
    onTooltipClick(e) {
        var a = e.target;
        while (a && a != this.tooltipNode) {
            if (a.nodeName == "A" && a.href) {
                a.rel = "noreferrer";
                a.target = "_blank";
                break;
            }
            a = a.parentNode;
        }
    }

    destroy() {
        this.detach();
        if (this.popup) {
            this.popup.destroy();
            var el = this.popup.container;
            if (el && el.parentNode)
                el.parentNode.removeChild(el);
        }
        if (this.editor && this.editor.completer == this) {
            this.editor.off("destroy", destroyCompleter);
            this.editor.completer = null;
        }
        this.inlineRenderer = this.popup = this.editor = null;
    }

    /**
     * @param {Editor} editor
     * @return {Autocomplete}
     */
    static for(editor) {
        if (editor.completer instanceof Autocomplete) {
            return editor.completer;
        }
        if (editor.completer) {
            editor.completer.destroy();
            editor.completer = null;
        }
        if (config.get("sharedPopups")) {
            if (!Autocomplete["$sharedInstance"])
                Autocomplete["$sharedInstance"] = new Autocomplete();
            editor.completer = Autocomplete["$sharedInstance"];
        } else {
            editor.completer = new Autocomplete();
            editor.once("destroy", destroyCompleter);
        }
        // @ts-expect-error
        return editor.completer;
    }

}

Autocomplete.prototype.commands = {
    "Up": function(editor) { editor.completer.goTo("up"); },
    "Down": function(editor) { editor.completer.goTo("down"); },
    "Ctrl-Up|Ctrl-Home": function(editor) { editor.completer.goTo("start"); },
    "Ctrl-Down|Ctrl-End": function(editor) { editor.completer.goTo("end"); },

    "Esc": function(editor) { editor.completer.detach(); },
    "Return": function(editor) { return editor.completer.insertMatch(); },
    "Shift-Return": function(editor) { editor.completer.insertMatch(null, {deleteSuffix: true}); },
    "Tab": function(editor) {
        var result = editor.completer.insertMatch();
        if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
        else
            return result;
    },
    "Backspace": function(editor) {
        editor.execCommand("backspace");
        var prefix = util.getCompletionPrefix(editor);
        if (!prefix && editor.completer)
            editor.completer.detach();
    },

    "PageUp": function(editor) { editor.completer.popup.gotoPageUp(); },
    "PageDown": function(editor) { editor.completer.popup.gotoPageDown(); }
};

Autocomplete.startCommand = {
    name: "startAutocomplete",
    exec: function(editor, options) {
        var completer = Autocomplete.for(editor);
        completer.autoInsert = false;
        completer.autoSelect = true;
        completer.autoShown = false;
        completer.showPopup(editor, options);
        // prevent ctrl-space opening context menu on firefox on mac
        completer.cancelContextMenu();
    },
    bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
};

/**
 * This class is responsible for providing completions and inserting them to the editor
 */
class CompletionProvider {


    /**
     * @param {{pos: Position, prefix: string}} [initialPosition]
     */
    constructor(initialPosition) {
        this.initialPosition = initialPosition;
        this.active = true;
    }

    /**
     * @param {Editor} editor
     * @param {number} index
     * @param {CompletionProviderOptions} [options]
     * @returns {boolean}
     */
    insertByIndex(editor, index, options) {
        if (!this.completions || !this.completions.filtered) {
            return false;
        }
        return this.insertMatch(editor, this.completions.filtered[index], options);
    }

    /**
     * @param {Editor} editor
     * @param {Completion} data
     * @param {CompletionProviderOptions} [options]
     * @returns {boolean}
     */
    insertMatch(editor, data, options) {
        if (!data)
            return false;

        editor.startOperation({command: {name: "insertMatch"}});
        if (data.completer && data.completer.insertMatch) {
            data.completer.insertMatch(editor, data);
        } else {
            // TODO add support for options.deleteSuffix
            if (!this.completions)
                return false;

            var replaceBefore = this.completions.filterText.length;
            var replaceAfter = 0;
            if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
            }

            if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                    ranges = editor.selection.getAllRanges();
                }
                else {
                    ranges = [editor.getSelectionRange()];
                }
                for (var i = 0, range; range = ranges[i]; i++) {
                    range.start.column -= replaceBefore;
                    range.end.column += replaceAfter;
                    editor.session.remove(range);
                }
            }

            if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
            }
            else {
                this.$insertString(editor, data);
            }
            if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
            }

            if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
            }
        }
        editor.endOperation();
        return true;
    }

    /**
     * @param {Editor} editor
     * @param {Completion} data
     */
    $insertString(editor, data) {
        var text = data.value || data;
        editor.execCommand("insertstring", text);
    }

    /**
     * @param {Editor} editor
     * @param {import("../ace-internal").Ace.CompletionCallbackFunction} callback
     */
    gatherCompletions(editor, callback) {
        var session = editor.getSession();
        var pos = editor.getCursorPosition();

        var prefix = util.getCompletionPrefix(editor);

        var matches = [];
        this.completers = editor.completers;
        var total = editor.completers.length;
        editor.completers.forEach(function(completer, i) {
            completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                    results = results.map((result) =>  {
                        return Object.assign(result, {hideInlinePreview: completer.hideInlinePreview});
                    });

                if (!err && results)
                    matches = matches.concat(results);
                // Fetch prefix again, because they may have changed by now
                callback(null, {
                    prefix: util.getCompletionPrefix(editor),
                    matches: matches,
                    finished: (--total === 0)
                });
            });
        });
        return true;
    }

    /**
     * This is the entry point to the class, it gathers, then provides the completions asynchronously via callback.
     * The callback function may be called multiple times, the last invokation is marked with a `finished` flag
     * @param {Editor} editor
     * @param {CompletionProviderOptions} options
     * @param {(err: Error | undefined, completions: FilteredList | [], finished: boolean) => void} callback
     */
    provideCompletions(editor, options, callback) {
        var processResults = function(results) {
            var prefix = results.prefix;
            var matches = results.matches;

            this.completions = new FilteredList(matches);

            if (options.exactMatch)
                this.completions.exactMatch = true;

            if (options.ignoreCaption)
                this.completions.ignoreCaption = true;

            this.completions.setFilter(prefix);

            if (results.finished || this.completions.filtered.length)
                callback(null, this.completions, results.finished);
        }.bind(this);

        var isImmediate = true;
        var immediateResults = null;
        this.gatherCompletions(editor, function(err, results) {
            if (!this.active) {
                return;
            }
            if (err) {
                callback(err, [], true);
                this.detach();
            }
            var prefix = results.prefix;

            // Wrong prefix or wrong session -> ignore
            if (prefix.indexOf(results.prefix) !== 0)
                return;

            // If multiple completers return their results immediately, we want to process them together
            if (isImmediate) {
                immediateResults = results;
                return;
            }

            processResults(results);
        }.bind(this));

        isImmediate = false;
        if (immediateResults) {
            var results = immediateResults;
            immediateResults = null;
            processResults(results);
        }
    }

    detach() {
        this.active = false;
        this.completers && this.completers.forEach(function(completer) {
            if (typeof completer.cancel === "function") {
                completer.cancel();
            }
        });
    }
}

class FilteredList {
    /**
     * @param {any} array
     * @param {string} [filterText]
     */
    constructor(array, filterText) {
        this.all = array;
        this.filtered = array;
        this.filterText = filterText || "";
        this.exactMatch = false;
        this.ignoreCaption = false;
    }

    setFilter(str) {
        if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
            var matches = this.filtered;
        else
            var matches = this.all;

        this.filterText = str;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function(a, b) {
            return b.exactMatch - a.exactMatch || b.$score - a.$score
                || (a.caption || a.value).localeCompare(b.caption || b.value);
        });

        // make unique
        var prev = null;
        matches = matches.filter(function(item){
            var caption = item.snippet || item.caption || item.value;
            if (caption === prev) return false;
            prev = caption;
            return true;
        });

        this.filtered = matches;
    }

    filterCompletions(items, needle) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        loop: for (var i = 0, item; item = items[i]; i++) {
            var caption = (!this.ignoreCaption && item.caption) || item.value || item.snippet;
            if (!caption) continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;

            if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                    continue loop;
            } else {
                /**
                 * It is for situation then, for example, we find some like 'tab' in item.value="Check the table"
                 * and want to see "Check the TABle" but see "Check The tABle".
                 */
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                    penalty = fullMatchIndex;
                } else {
                    // caption char iteration is faster in Chrome but slower in Firefox, so lets use indexOf
                    for (var j = 0; j < needle.length; j++) {
                        // TODO add penalty on case mismatch
                        var i1 = caption.indexOf(lower[j], lastIndex + 1);
                        var i2 = caption.indexOf(upper[j], lastIndex + 1);
                        index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;
                        if (index < 0)
                            continue loop;
                        distance = index - lastIndex - 1;
                        if (distance > 0) {
                            // first char mismatch should be more sensitive
                            if (lastIndex === -1)
                                penalty += 10;
                            penalty += distance;
                            matchMask = matchMask | (1 << j);
                        }
                        lastIndex = index;
                    }
                }
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.$score = (item.score || 0) - penalty;
            results.push(item);
        }
        return results;
    }
}

exports.jT = Autocomplete;
exports.o2 = CompletionProvider;
exports.C3 = FilteredList;


/***/ }),

/***/ 76703:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 */
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var AceInlineScreenReader = (__webpack_require__(88629)/* .AceInlineScreenReader */ ._);

/**
 * This object is used to manage inline code completions rendered into an editor with ghost text.
 */
class AceInline {
    /**
     * Creates the inline completion renderer which renders the inline code completions directly in the target editor.
     */
    constructor() {
        this.editor = null;
    }
    
    /**
     * Renders the completion as ghost text to the current cursor position
     * @param {Editor} editor
     * @param {import("../../ace-internal").Ace.Completion} completion
     * @param {string} prefix
     * @returns {boolean} True if the completion could be rendered to the editor, false otherwise
     */
    show(editor, completion, prefix) {
        prefix = prefix || "";
        if (editor && this.editor && this.editor !== editor) {
            this.hide();
            this.editor = null;
            this.inlineScreenReader = null;
        }
        if (!editor || !completion) {
            return false;
        }
        if (!this.inlineScreenReader) {
            this.inlineScreenReader = new AceInlineScreenReader(editor);
        }
        var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
        if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
            return false;
        }
        this.editor = editor;

        this.inlineScreenReader.setScreenReaderContent(displayText);

        displayText = displayText.slice(prefix.length);
        if (displayText === "") {
            editor.removeGhostText();
        } else {
            editor.setGhostText(displayText);
        }
        return true;
    }

    isOpen() {
        if (!this.editor) {
            return false;
        }
        return !!this.editor.renderer.$ghostText;
    }

    hide() {
        if (!this.editor) {
            return false;
        }
        this.editor.removeGhostText();
        return true;
    }

    destroy() {
        this.hide();
        this.editor = null;
        if (this.inlineScreenReader) {
            this.inlineScreenReader.destroy();
            this.inlineScreenReader = null;
        }
    }
}


exports.V = AceInline;


/***/ }),

/***/ 88629:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * This object is used to communicate inline code completions rendered into an editor with ghost text to screen reader users.
 */
class AceInlineScreenReader {
    /**
     * Creates the off-screen div in which the ghost text content in redered and which the screen reader reads.
     * @param {import("../editor").Editor} editor
     */
    constructor(editor) {
        this.editor = editor;

        this.screenReaderDiv = document.createElement("div");
        this.screenReaderDiv.classList.add("ace_screenreader-only");
        this.editor.container.appendChild(this.screenReaderDiv);
    }

    /**
     * Set the ghost text content to the screen reader div
     * @param {string} content
     */
    setScreenReaderContent(content) {
        // Path for when inline preview is used with 'normal' completion popup.
        if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/(this.editor.completer).popup) {
            this.popup = /**@type{import("../autocomplete").Autocomplete}*/(this.editor.completer).popup;

            this.popup.renderer.on("afterRender", function() {
                let row = this.popup.getRow();
                let t = this.popup.renderer.$textLayer;
                let selected = t.element.childNodes[row - t.config.firstRow];
                if (selected) {
                    let idString = "doc-tooltip ";
                    for (let lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                        idString += `ace-inline-screenreader-line-${lineIndex} `;
                    }
                    selected.setAttribute("aria-describedby", idString);      
                }
            }.bind(this));
        }

        // TODO: Path for when special inline completion popup is used.
        // https://github.com/ajaxorg/ace/issues/5348

        // Remove all children of the div
        while (this.screenReaderDiv.firstChild) {
            this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
        }
        this._lines = content.split(/\r\n|\r|\n/);
        const codeElement = this.createCodeBlock();
        this.screenReaderDiv.appendChild(codeElement);
    }

    destroy() {
        this.screenReaderDiv.remove();
    }

    /**
     * Take this._lines, render it as <code> blocks and add those to the screen reader div.
     */
    createCodeBlock() {
        const container = document.createElement("pre");
        container.setAttribute("id", "ace-inline-screenreader");

        for (let lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
            const codeElement = document.createElement("code");
            codeElement.setAttribute("id", `ace-inline-screenreader-line-${lineIndex}`);
            const line = document.createTextNode(this._lines[lineIndex]);

            codeElement.appendChild(line);
            container.appendChild(codeElement);
        }

        return container;
    }
}

exports._ = AceInlineScreenReader;


/***/ }),

/***/ 51826:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Renderer = (__webpack_require__(21016).VirtualRenderer);
var Editor = (__webpack_require__(27258).Editor);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var event = __webpack_require__(19631);
var lang = __webpack_require__(39955);
var dom = __webpack_require__(71435);
var nls = (__webpack_require__(76321).nls);
var userAgent = __webpack_require__(74943);

var getAriaId = function (index) {
    return `suggest-aria-id:${index}`;
};

// Safari requires different ARIA A11Y attributes compared to other browsers
var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";

/**
 *
 * @param {HTMLElement} [el]
 * @return {Editor}
 */
var $singleLineEditor = function(el) {
    var renderer = new Renderer(el);

    renderer.$maxLines = 4;
    var editor = new Editor(renderer);

    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);

    editor.$mouseHandler.$focusTimeout = 0;
    editor.$highlightTagPending = true;

    return editor;
};

/**
 * This object is used in some places where needed to show popups - like prompt; autocomplete etc.
 */
class AcePopup {
    /**
     * Creates and renders single line editor in popup window. If `parentNode` param is isset, then attaching it to this element.
     * @param {Element} [parentNode]
     */
    constructor(parentNode) {
        var el = dom.createElement("div");
        /**@type {AcePopup}*/
        // @ts-ignore
        var popup = $singleLineEditor(el);

        if (parentNode) {
            parentNode.appendChild(el);
        }
        el.style.display = "none";
        popup.renderer.content.style.cursor = "default";
        popup.renderer.setStyle("ace_autocomplete");

        // Set aria attributes for the popup
        popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
        popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
        popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
        popup.renderer.textarea.setAttribute("aria-hidden", "true");

        popup.setOption("displayIndentGuides", false);
        popup.setOption("dragDelay", 150);

        var noop = function(){};

        popup.focus = noop;
        popup.$isFocused = true;

        popup.renderer.$cursorLayer.restartTimer = noop;
        popup.renderer.$cursorLayer.element.style.opacity = "0";

        popup.renderer.$maxLines = 8;
        popup.renderer.$keepTextAreaAtCursor = false;

        popup.setHighlightActiveLine(false);
        // set default highlight color
        // @ts-ignore
        popup.session.highlight("");
        popup.session.$searchHighlight.clazz = "ace_highlight-marker";

        popup.on("mousedown", function(e) {
            var pos = e.getDocumentPosition();
            popup.selection.moveToPosition(pos);
            selectionMarker.start.row = selectionMarker.end.row = pos.row;
            e.stop();
        });

        var lastMouseEvent;
        var hoverMarker = new Range(-1, 0, -1, Infinity);
        var selectionMarker = new Range(-1, 0, -1, Infinity);
        selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
        popup.setSelectOnHover = function (val) {
            if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
            } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
            }
        };
        popup.setSelectOnHover(false);
        popup.on("mousemove", function(e) {
            if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
            }
            if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
            }
            lastMouseEvent = e;
            lastMouseEvent.scrollTop = popup.renderer.scrollTop;
            popup.isMouseOver = true;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row);
            }
        });
        popup.renderer.on("beforeRender", function() {
            if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row, true);
            }
        });
        popup.renderer.on("afterRender", function () {
            var row = popup.getRow();
            var t = popup.renderer.$textLayer;
            var selected = /** @type {HTMLElement|null} */(t.element.childNodes[row - t.config.firstRow]);
            var el = document.activeElement; // Active element is textarea of main editor
            if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                el.removeAttribute("aria-activedescendant");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
            }
            popup.selectedNode = selected;
            if (selected) {
                dom.addCssClass(selected, "ace_selected");
                var ariaId = getAriaId(row);
                selected.id = ariaId;
                t.element.setAttribute("aria-activedescendant", ariaId);
                el.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute("role", optionAriaRole);
                selected.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                selected.setAttribute("aria-label", popup.getData(row).caption || popup.getData(row).value);
                selected.setAttribute("aria-setsize", popup.data.length);
                selected.setAttribute("aria-posinset", row + 1);
                selected.setAttribute("aria-describedby", "doc-tooltip");
                selected.setAttribute(ariaActiveState, "true");
            }
        });
        var hideHoverMarker = function() { setHoverMarker(-1); };
        var setHoverMarker = function(row, suppressRedraw) {
            if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                    popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
            }
        };
        popup.getHoveredRow = function() {
            return hoverMarker.start.row;
        };

        event.addListener(popup.container, "mouseout", function() {
            popup.isMouseOver = false;
            hideHoverMarker();
        });
        popup.on("hide", hideHoverMarker);
        popup.on("changeSelection", hideHoverMarker);

        popup.session.doc.getLength = function() {
            return popup.data.length;
        };
        popup.session.doc.getLine = function(i) {
            var data = popup.data[i];
            if (typeof data == "string")
                return data;
            return (data && data.value) || "";
        };

        var bgTokenizer = popup.session.bgTokenizer;
        bgTokenizer.$tokenizeRow = function(row) {
            /**@type {import("../../ace-internal").Ace.Completion &{name?, className?, matchMask?, message?}}*/
            var data = popup.data[row];
            var tokens = [];
            if (!data)
                return tokens;
            if (typeof data == "string")
                data = {value: data};
            var caption = data.caption || data.value || data.name;

            function addToken(value, className) {
                value && tokens.push({
                    type: (data.className || "") + (className || ""),
                    value: value
                });
            }

            var lower = caption.toLowerCase();
            var filterText = (popup.filterText || "").toLowerCase();
            var lastIndex = 0;
            var lastI = 0;
            for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & (1 << i) || i == filterText.length)) {
                    var sub = filterText.slice(lastI, i);
                    lastI = i;
                    var index = lower.indexOf(sub, lastIndex);
                    if (index == -1) continue;
                    addToken(caption.slice(lastIndex, index), "");
                    lastIndex = index + sub.length;
                    addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
            }
            addToken(caption.slice(lastIndex, caption.length), "");

            tokens.push({type: "completion-spacer", value: " "});
            if (data.meta)
                tokens.push({type: "completion-meta", value: data.meta});
            if (data.message)
                tokens.push({type: "completion-message", value: data.message});

            return tokens;
        };
        bgTokenizer.$updateOnChange = noop;
        bgTokenizer.start = noop;

        popup.session.$computeWidth = function() {
            return this.screenWidth = 0;
        };

        // public
        popup.isOpen = false;
        popup.isTopdown = false;
        popup.autoSelect = true;
        popup.filterText = "";
        popup.isMouseOver = false;

        popup.data = [];
        popup.setData = function(list, filterText) {
            popup.filterText = filterText || "";
            popup.setValue(lang.stringRepeat("\n", list.length), -1);
            popup.data = list || [];
            popup.setRow(0);
        };
        popup.getData = function(row) {
            return popup.data[row];
        };

        popup.getRow = function() {
            return selectionMarker.start.row;
        };
        popup.setRow = function(line) {
            line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
            if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                    popup._signal("select");
            }
        };

        popup.on("changeSelection", function() {
            if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
            popup.renderer.scrollCursorIntoView();
        });

        popup.hide = function() {
            this.container.style.display = "none";
            popup.anchorPos = null;
            popup.anchor = null;
            if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
            }
        };

        /**
         * Tries to show the popup anchored to the given position and anchors.
         * If the anchor is not specified it tries to align to bottom and right as much as possible.
         * If the popup does not have enough space to be rendered with the given anchors, it returns false without rendering the popup.
         * The forceShow flag can be used to render the popup in these cases, which slides the popup so it entirely fits on the screen.
         * @param {{top: number, left: number}} pos
         * @param {number} lineHeight
         * @param {"top" | "bottom" | undefined} anchor
         * @param {boolean} forceShow
         * @returns {boolean}
         */
        popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
            if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor &&
                popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left &&
                popup.anchor === anchor
            ) {
                return true;
            }

            var el = this.container;
            var screenHeight = window.innerHeight;
            var screenWidth = window.innerWidth;
            var renderer = this.renderer;
            // var maxLines = Math.min(renderer.$maxLines, this.session.getLength());
            var maxH = renderer.$maxLines * lineHeight * 1.4;
            var dims = { top: 0, bottom: 0, left: 0 };

            var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
            var spaceAbove = pos.top - 3 * this.$borderSize;
            if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                    anchor = "bottom";
                } else {
                    anchor = "top";
                }
            }

            if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
            } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
            }

            var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;

            if (!forceShow && !fitsX) {
                return false;
            }

            if (!fitsX) {
                if (anchor === "top") {
                    renderer.$maxPixelHeight = spaceAbove;
                } else {
                    renderer.$maxPixelHeight = spaceBelow;
                }
            } else {
                renderer.$maxPixelHeight = null;
            }


            if (anchor === "top") {
                el.style.top = "";
                el.style.bottom = (screenHeight - dims.bottom) + "px";
                popup.isTopdown = false;
            } else {
                el.style.top = dims.top + "px";
                el.style.bottom = "";
                popup.isTopdown = true;
            }

            el.style.display = "";

            var left = pos.left;
            if (left + el.offsetWidth > screenWidth)
                left = screenWidth - el.offsetWidth;

            el.style.left = left + "px";
            el.style.right = "";

            if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
            }

            popup.anchorPos = pos;
            popup.anchor = anchor;

            return true;
        };

        popup.show = function(pos, lineHeight, topdownOnly) {
            this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : undefined, true);
        };

        popup.goTo = function(where) {
            var row = this.getRow();
            var max = this.session.getLength() - 1;

            switch(where) {
                case "up": row = row <= 0 ? max : row - 1; break;
                case "down": row = row >= max ? -1 : row + 1; break;
                case "start": row = 0; break;
                case "end": row = max; break;
            }

            this.setRow(row);
        };


        popup.getTextLeftOffset = function() {
            return this.$borderSize + this.renderer.$padding + this.$imageSize;
        };

        popup.$imageSize = 0;
        popup.$borderSize = 1;

        return popup;
    }
}

dom.importCssString(`
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
}
.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
}
.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233,233,253,0.4);
    position: absolute;
    z-index: 2;
}
.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
}
.ace_completion-meta {
    opacity: 0.5;
    margin-left: 0.9em;
}
.ace_completion-message {
    margin-left: 0.9em;
    color: blue;
}
.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #2d69c7;
}
.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #93ca12;
}
.ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
}
.ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
}
.ace_autocomplete .ace_text-layer  {
    width: calc(100% - 8px);
}
.ace_autocomplete .ace_line {
    display: flex;
    align-items: center;
}
.ace_autocomplete .ace_line > * {
    min-width: 0;
    flex: 0 0 auto;
}
.ace_autocomplete .ace_line .ace_ {
    flex: 0 1 auto;
    overflow: hidden;
    text-overflow: ellipsis;
}
.ace_autocomplete .ace_completion-spacer {
    flex: 1;
}
.ace_autocomplete.ace_loading:after  {
    content: "";
    position: absolute;
    top: 0px;
    height: 2px;
    width: 8%;
    background: blue;
    z-index: 100;
    animation: ace_progress 3s infinite linear;
    animation-delay: 300ms;
    transform: translateX(-100%) scaleX(1);
}
@keyframes ace_progress {
    0% { transform: translateX(-100%) scaleX(1) }
    50% { transform: translateX(625%) scaleX(2) } 
    100% { transform: translateX(1500%) scaleX(3) } 
}
@media (prefers-reduced-motion) {
    .ace_autocomplete.ace_loading:after {
        transform: translateX(625%) scaleX(2);
        animation: none;
     }
}
`, "autocompletion.css", false);

exports.AcePopup = AcePopup;
exports.$singleLineEditor = $singleLineEditor;
exports.getAriaId = getAriaId;


/***/ }),

/***/ 60565:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Range = (__webpack_require__(91902)/* .Range */ .Q);

var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;

function getWordIndex(doc, pos) {
    var textBefore = doc.getTextRange(Range.fromPoints({
        row: 0,
        column: 0
    }, pos));
    return textBefore.split(splitRegex).length - 1;
}

/**
 * Does a distance analysis of the word `prefix` at position `pos` in `doc`.
 * @return Map
 */
function wordDistance(doc, pos) {
    var prefixPos = getWordIndex(doc, pos);
    var words = doc.getValue().split(splitRegex);
    var wordScores = Object.create(null);

    var currentWord = words[prefixPos];

    words.forEach(function (word, idx) {
        if (!word || word === currentWord) return;

        var distance = Math.abs(prefixPos - idx);
        var score = words.length - distance;
        if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
        }
        else {
            wordScores[word] = score;
        }
    });
    return wordScores;
}

exports.getCompletions = function (editor, session, pos, prefix, callback) {
    var wordScore = wordDistance(session, pos);
    var wordList = Object.keys(wordScore);
    callback(null, wordList.map(function (word) {
        return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
        };
    }));
};


/***/ }),

/***/ 28630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @typedef {import("../editor").Editor} Editor
 */

exports.parForEach = function(array, fn, callback) {
    var completed = 0;
    var arLength = array.length;
    if (arLength === 0)
        callback();
    for (var i = 0; i < arLength; i++) {
        fn(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
                callback(result, err);
        });
    }
};

var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;

exports.retrievePrecedingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos-1; i >= 0; i--) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf.reverse().join("");
};

exports.retrieveFollowingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos; i < text.length; i++) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf;
};

/**
 * @param editor
 * @return {string}
 */
exports.getCompletionPrefix = function (editor) {
    var pos = editor.getCursorPosition();
    var line = editor.session.getLine(pos.row);
    var prefix;
    editor.completers.forEach(function(completer) {
        if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function(identifierRegex) {
                if (!prefix && identifierRegex)
                    prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
        }
    }.bind(this));
    return prefix || this.retrievePrecedingIdentifier(line, pos.column);
};

/**
 * @param {Editor} editor
 * @param {string} [previousChar] if not provided, it falls back to the preceding character in the editor
 * @returns {boolean} whether autocomplete should be triggered
 */
exports.triggerAutocomplete = function (editor, previousChar) {
    var previousChar = previousChar == null
        ? editor.session.getPrecedingCharacter()
        : previousChar;
    return editor.completers.some((completer) => {
        if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
        }
    });
};


/***/ }),

/***/ 93857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./document").Document} Document
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./tokenizer").Tokenizer} Tokenizer
 */
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. 
 * 
 * If a certain row is changed, everything below that row is re-tokenized.
 **/
class BackgroundTokenizer {
    
    /**
     * Creates a new `BackgroundTokenizer` object.
     * @param {Tokenizer} tokenizer The tokenizer to use
     * @param {EditSession} [session] The editor session to associate with
     **/
    constructor(tokenizer, session) {
        /**@type {false|number}*/
        this.running = false;
        this.lines = [];
        /**@type {string[]|string[][]}*/
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;

        var self = this;

        this.$worker = function() {
            if (!self.running) { return; }

            var workerStart = new Date();
            var currentLine = self.currentLine;
            var endLine = -1;
            var doc = self.doc;

            var startLine = currentLine;
            while (self.lines[currentLine])
                currentLine++;

            var len = doc.getLength();
            var processedLines = 0;
            self.running = false;
            while (currentLine < len) {
                self.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                    currentLine++;
                } while (self.lines[currentLine]);

                // only check every 5 lines
                processedLines ++;
                // @ts-ignore
                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                    self.running = setTimeout(self.$worker, 20);
                    break;
                }
            }
            self.currentLine = currentLine;

            if (endLine == -1)
                endLine = currentLine;

            if (startLine <= endLine)
                self.fireUpdateEvent(startLine, endLine);
        };
    }
    
    /**
     * Sets a new tokenizer for this object.
     * @param {Tokenizer} tokenizer The new tokenizer to use
     **/
    setTokenizer(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    }

    /**
     * Sets a new document to associate with this object.
     * @param {Document} doc The new document to associate with
     **/
    setDocument(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    }


    /**
     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
     * @param {Number} firstRow The starting row region
     * @param {Number} lastRow The final row region
     **/
    fireUpdateEvent(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    }

    /**
     * Starts tokenizing at the row indicated.
     * @param {Number} startRow The row to start at
     **/
    start(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());

        // remove all cached items below this line
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        // pretty long delay to prevent the tokenizer from interfering with the user
        this.running = setTimeout(this.$worker, 700);
    }

    /**
     * Sets pretty long delay to prevent the tokenizer from interfering with the user
     */
    scheduleStart() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    $updateOnChange(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    }

    /**
     * Stops tokenizing.
     **/
    stop() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    }

    /**
     * Gives list of [[Token]]'s of the row. (tokens are cached)
     * @param {Number} row The row to get tokens at
     * @returns {import("../ace-internal").Ace.Token[]}
     **/
    getTokens(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    }

    /**
     * Returns the state of tokenization at the end of a row.
     * @param {Number} row The row to get state at
     * @returns {string | string[]}
     **/
    getState(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    }

    /**
     * @param {number} row
     */
    $tokenizeRow(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        // @ts-expect-error TODO: potential wrong argument
        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    }

    cleanup() {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.removeAllListeners();
    }

}

oop.implement(BackgroundTokenizer.prototype, EventEmitter);

exports.K = BackgroundTokenizer;


/***/ }),

/***/ 16585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var bidiUtil = __webpack_require__(50973);
var lang = __webpack_require__(39955);
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;

/**
 * This object is used to ensure Bi-Directional support (for languages with text flowing from right to left, like Arabic or Hebrew)
 * including correct caret positioning, text selection mouse and keyboard arrows functioning
 **/
class BidiHandler {
    /**
     * Creates a new `BidiHandler` object
     * @param {EditSession} session The session to use
     **/
    constructor(session) {
        this.session = session;
        this.bidiMap = {};
        /* current screen row */
        this.currentRow = null;
        this.bidiUtil = bidiUtil;
        /* Arabic/Hebrew character width differs from regular character width */
        this.charWidths = [];
        this.EOL = "\xAC";
        this.showInvisibles = true;
        this.isRtlDir = false;
        this.$isRtl = false;
        this.line = "";
        this.wrapIndent = 0;
        this.EOF = "\xB6";
        this.RLE = "\u202B";
        this.contentWidth = 0;
        this.fontMetrics = null;
        this.rtlLineOffset = 0;
        this.wrapOffset = 0;
        this.isMoveLeftOperation = false;
        this.seenBidi = bidiRE.test(session.getValue());
    }

    /**
     * Returns 'true' if row contains Bidi characters, in such case
     * creates Bidi map to be used in operations related to selection
     * (keyboard arrays, mouse click, select)
     * @param {Number} screenRow the screen row to be checked
     * @param {Number} [docRow] the document row to be checked [optional]
     * @param {Number} [splitIndex] the wrapped screen line index [ optional]
    **/
    isBidiRow(screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onChange(delta) {
        if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        }
        else {
            this.currentRow = null;
        }
    }

    getDocumentRow() {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0)
                docRow = this.session.$docRowCache[index];
        }

        return docRow;
    }

    getSplitIndex() {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;

                prevIndex = currentIndex;
                splitIndex++;
            }
        } else {
            splitIndex = this.currentRow;
        }

        return splitIndex;
    }

    updateRowLine(docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();

        var isLastRow = (docRow === this.session.getLength() - 1),
            endOfLine = isLastRow ? this.EOF : this.EOL;

        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();

                if(splitIndex > 0 && splits.length) {
                    this.wrapIndent = splits.indent;
                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                    this.line = (splitIndex < splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                            this.line.substring(splits[splits.length - 1]);
                } else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }

                if (splitIndex == splits.length) {
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
                }
            }
        } else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }

        /* replace tab and wide characters by commensurate spaces */
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });

        if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
    }

    updateBidiMap() {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        } else {
            this.bidiMap = {};
        }
    }

    /**
     * Resets stored info related to current screen row
    **/
    markAsDirty() {
        this.currentRow = null;
    }

    /**
     * Updates array of character widths
     * @param {Object} fontMetrics metrics
     *
    **/
    updateCharacterWidths(fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;

        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;

        this.currentRow = null;
    }

    setShowInvisibles(showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    }

    setEolChar(eolChar) {
        this.EOL = eolChar;
    }

    setContentWidth(width) {
        this.contentWidth = width;
    }

    isRtlLine(row) {
        if (this.$isRtl) return true;
        if (row != undefined)
            return (this.session.getLine(row).charAt(0) == this.RLE);
        else
            return this.isRtlDir;
    }

    setRtlDirection(editor, isRtlDir) {
        var cursor = editor.getCursorPosition();
        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);
        }
    }


    /**
     * Returns offset of character at position defined by column.
     * @param {Number} col the screen column position
     *
     * @return {Number} horizontal pixel offset of given screen column
     **/
    getPosLeft(col) {
        col -= this.wrapIndent;
        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),
            levels = this.bidiMap.bidiLevels, left = 0;

        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
            visualIdx++;

        for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }

        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
            left += this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        if (this.isRtlDir)
            left += this.rtlLineOffset;

        return left;
    }

    /**
     * Returns 'selections' - array of objects defining set of selection rectangles
     * @param {Number} startCol the start column position
     * @param {Number} endCol the end column position
     *
     * @return {Object[]} Each object contains 'left' and 'width' values defining selection rectangle.
    **/
    getSelections(startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,
            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                isSelected = false, isSelectedPrev = false, selectionStart = 0;

        if (this.wrapIndent)
            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
            if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }

        if (isSelected && (visIdx === levels.length)) {
            selections.push({left: selectionStart, width: offset - selectionStart});
        }

        if(this.isRtlDir) {
            for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
            }
        }
        return selections;
    }

    /**
     * Converts character coordinates on the screen to respective document column number
     * @param {Number} posX character horizontal offset
     *
     * @return {Number} screen column number corresponding to given pixel offset
    **/
    offsetToCol(posX) {
        if(this.isRtlDir)
            posX -= this.rtlLineOffset;

        var logicalIdx = 0, posX = Math.max(posX, 0),
            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                charWidth = this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        while(posX > offset + charWidth/2) {
            offset += charWidth;
            if(visualIdx === levels.length - 1) {
                /* quit when we on the right of the last character, flag this by charWidth = 0 */
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }

        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
        /* Bidi character on the left and None Bidi character on the right */
            if(posX < offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
        /* None Bidi character on the left and Bidi character on the right */
            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);

        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
        /* To the right of last character, which is None Bidi, in RTL direction or */
        /* to the left of first Bidi character, in LTR direction */
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        } else {
            /* Tweak visual position when Bidi character on the left in order to map it to corresponding logical position */
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                visualIdx--;

            /* Regular case */
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }

        if (logicalIdx === 0 && this.isRtlDir)
            logicalIdx++;

        return (logicalIdx + this.wrapIndent);
    }

}

exports.t = BidiHandler;


/***/ }),

/***/ 65217:
/***/ ((module) => {

"use strict";


var $cancelT;
module.exports = { 
    /** @type {string|false} */
    lineMode: false,
    pasteCancelled: function() {
        if ($cancelT && $cancelT > Date.now() - 50)
            return true;
        return $cancelT = false;
    },
    cancel: function() {
        $cancelT = Date.now();
    }
};


/***/ }),

/***/ 63379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *
 * @typedef {import("../editor").Editor} Editor
 */
var oop = __webpack_require__(2645);
var MultiHashHandler = (__webpack_require__(93050).MultiHashHandler);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

class CommandManager extends MultiHashHandler{
    /**
     * new CommandManager(platform, commands)
     * @param {String} platform Identifier for the platform; must be either `"mac"` or `"win"`
     * @param {any[]} commands A list of commands
     **/
    constructor(platform, commands) {
        super(commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
            if (!e.args) {
                return e.command.exec(e.editor, {}, e.event, true);
            }
            return e.command.exec(e.editor, e.args, e.event, false);
        });
    }

    /**
     * 
     * @param {string | string[] | import("../../ace-internal").Ace.Command} command
     * @param {Editor} editor
     * @param {any} args
     * @returns {boolean}
     */
    exec(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }
        
        if (typeof command === "string")
            command = this.commands[command];

        if (!this.canExecute(command, editor)) {
            return false; 
        }
        
        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    }

    /**
     *
     * @param {string | import("../../ace-internal").Ace.Command} command
     * @param {Editor} editor
     * @returns {boolean}
     */
    canExecute(command, editor) {
        if (typeof command === "string")
            command = this.commands[command];
        
        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
            return false;
        
        return true;
    }
    

    /**
     * @param {Editor} editor
     * @returns {boolean}
     */
    toggleRecording(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.off("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    }

    /**
     * @param {Editor} editor
     */
    replay(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    }

    trimMacro(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    }

}
oop.implement(CommandManager.prototype, EventEmitter);

exports.CommandManager = CommandManager;


/***/ }),

/***/ 21604:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var lang = __webpack_require__(39955);
var config = __webpack_require__(76321);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

function bindKey(win, mac) {
    return {win: win, mac: mac};
}

/*
    multiSelectAction: "forEach"|"forEachLine"|function|undefined,
    scrollIntoView: true|"cursor"|"center"|"selectionPart"
*/
/**@type {import("../../ace-internal").Ace.Command[]} */
exports.P = [{
    name: "showSettingsMenu",
    description: "Show settings menu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    description: "Go to next error",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    description: "Go to previous error",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    description: "Select all",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    description: "Center selection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    description: "Go to line...",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor, line) {
        // backwards compatibility
        if (typeof line === "number" && !isNaN(line))
            editor.gotoLine(line);
        editor.prompt({ $type: "gotoLine" });
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    description: "Toggle fold widget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    description: "Toggle parent fold widget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    description: "Fold all",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldAllComments",
    description: "Fold all comments",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAllComments(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    description: "Fold other",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    description: "Unfold all",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    description: "Find next",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    description: "Find previous",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    description: "Select or find next",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    description: "Select or find previous",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    description: "Find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
    },
    readOnly: true
}, {
    name: "overwrite",
    description: "Overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    description: "Select to start",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    description: "Go to start",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    description: "Select up",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    description: "Go line up",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    description: "Select to end",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    description: "Go to end",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    description: "Select down",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    description: "Go line down",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    description: "Select word left",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    description: "Go to word left",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    description: "Select to line start",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    description: "Go to line start",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    description: "Select left",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    description: "Go to left",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    description: "Select word right",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    description: "Go to word right",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    description: "Select to line end",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    description: "Go to line end",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    description: "Select right",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    description: "Go to right",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    description: "Select page down",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    description: "Page down",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    description: "Go to page down",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    description: "Select page up",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    description: "Page up",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    description: "Go to page up",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    description: "Scroll up",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    description: "Scroll down",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    description: "Select line start",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    description: "Select line end",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    description: "Toggle recording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    description: "Replay macro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    description: "Jump to matching",
    bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    description: "Select to matching",
    bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    description: "Expand to matching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    description: "Pass keys to browser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    description: "Copy",
    exec: function(editor) {
        // placeholder for replay macro
    },
    readOnly: true
},

// commands disabled in readOnly mode
{
    name: "cut",
    description: "Cut",
    exec: function(editor) {
        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
        editor._emit("cut", range);

        if (!range.isEmpty())
            editor.session.remove(range);
        editor.clearSelection();
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    description: "Paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    description: "Remove line",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    description: "Duplicate selection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    description: "Sort lines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    description: "Toggle comment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    description: "Toggle block comment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    description: "Modify number up",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    description: "Modify number down",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    description: "Replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
    }
}, {
    name: "undo",
    description: "Undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    description: "Redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    description: "Copy lines up",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    description: "Move lines up",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    description: "Copy lines down",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    description: "Move lines down",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    description: "Delete",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    description: "Backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    description: "Cut or delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    description: "Remove to line start",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    description: "Remove to line end",
    bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestarthard",
    description: "Remove to line start hard",
    bindKey: bindKey("Ctrl-Shift-Backspace", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.start.column = 0;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineendhard",
    description: "Remove to line end hard",
    bindKey: bindKey("Ctrl-Shift-Delete", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.end.column = Number.MAX_VALUE;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    description: "Remove word left",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    description: "Remove word right",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    description: "Outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    description: "Indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    description: "Block outdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    description: "Block indent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    description: "Insert string",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    description: "Insert text",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    description: "Split line",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    description: "Transpose letters",
    bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    description: "To uppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    description: "To lowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "autoindent",
    description: "Auto Indent",
    bindKey: bindKey(null, null),
    exec: function(editor) { editor.autoIndent(); },
    scrollIntoView: "animate"
}, {
    name: "expandtoline",
    description: "Expand to line",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "openlink",
    bindKey: bindKey("Ctrl+F3", "F3"),
    exec: function(editor) { editor.openLink(); }
}, {
    name: "joinlines",
    description: "Join lines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            // Don't insert a newline at the end of the document
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            // Select the text that was previously selected
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            // If the joined line had something in it, start the cursor at that something
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    description: "Invert selection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];

        // If multiple selections don't exist, rangeList will return 0 so replace with single range
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                // The last selection must connect to the end of the document, unless it already does
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                // The first selection must connect to the start of the document, unless it already does
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}, {
    name: "addLineAfter",
    description: "Add new line after the current line",
    exec: function(editor) {
        editor.selection.clearSelection();
        editor.navigateLineEnd();
        editor.insert("\n");
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "addLineBefore",
    description: "Add new line before the current line",
    exec: function(editor) {
        editor.selection.clearSelection();
        var cursor = editor.getCursorPosition();
        editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
        editor.insert("\n");
        if (cursor.row === 0) editor.navigateUp();
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "openCommandPallete",
    exec: function(editor) {
        console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
        editor.prompt({ $type: "commands" });
    },
    readOnly: true
}, {
    name: "openCommandPalette",
    description: "Open command palette",
    bindKey: bindKey("F1", "F1"),
    exec: function(editor) {
        editor.prompt({ $type: "commands" });
    },
    readOnly: true
}, {
    name: "modeSelect",
    description: "Change language mode...",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        editor.prompt({ $type: "modes" });
    },
    readOnly: true
}];

for (var i = 1; i < 9; i++) {
    exports.P.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function(editor) { editor.session.foldToLevel(this.level); },
        scrollIntoView: "center",
        readOnly: true
    });
}


/***/ }),

/***/ 45375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * commands to enter multiselect mode
 * @type {import("../../ace-internal").Ace.Command[]}
 */
exports.defaultCommands = [{
    name: "addCursorAbove",
    description: "Add cursor above",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    description: "Add cursor below",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    description: "Add cursor above (skip current)",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    description: "Add cursor below (skip current)",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    description: "Select more before",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    description: "Select more after",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    description: "Select next before",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    description: "Select next after",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "toggleSplitSelectionIntoLines",
    description: "Split selection into lines",
    exec: function(editor) {
        if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
        else
            editor.multiSelect.splitIntoLines();
    },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "splitSelectionIntoLines",
    description: "Split into lines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    readOnly: true
}, {
    name: "alignCursors",
    description: "Align cursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    description: "Find all",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];

/**
 * commands active only in multiselect mode
 * @type {import("../../ace-internal").Ace.Command[]}
 */
exports.multiSelectCommands = [{
    name: "singleSelection",
    description: "Single selection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
}];

var HashHandler = (__webpack_require__(93050).HashHandler);
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);


/***/ }),

/***/ 76321:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
"no use strict";

var lang = __webpack_require__(39955);
var net = __webpack_require__(78552);
var dom = __webpack_require__(71435);
var AppConfig = (__webpack_require__(20845)/* .AppConfig */ .o);

module.exports = exports = new AppConfig();

/** @type {import("../ace-internal").Ace.ConfigOptions} */
var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {},
    loadWorkerFromBlob: true,
    sharedPopups: false,
    useStrictCSP: null
};

/**
 * @template {keyof import("../ace-internal").Ace.ConfigOptions} K
 * @param {K} key - The key of the config option to retrieve.
 * @returns {import("../ace-internal").Ace.ConfigOptions[K]} - The value of the config option.
 */
exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);
    return options[key];
};

/**
 * @template {keyof import("../ace-internal").Ace.ConfigOptions} K
 * @param {K} key
 * @param {import("../ace-internal").Ace.ConfigOptions[K]} value
 */
exports.set = function(key, value) {
    if (options.hasOwnProperty(key))
        options[key] = value;
    else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
    if (key == "useStrictCSP")
        dom.useStrictCSP(value);
};
/**
 * @return {import("../ace-internal").Ace.ConfigOptions}
 */
exports.all = function() {
    return lang.copyObject(options);
};

exports.$modes = {};

/**
 * module loading
 * @param {string} name
 * @param {string} [component]
 * @returns {string}
 */
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";

    // todo make this configurable or get rid of '-'
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};
/**
 * @param {string} name
 * @param {string} subst
 * @returns {string}
 */
exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

var loader = function(moduleName, cb) {
    if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
        return cb(null, __webpack_require__(87983));
    if (customLoader)
        return customLoader(moduleName, cb);
    console.error("loader is not configured");
};
var customLoader;

/** @arg {(name: string, callback: (error: any, module: any) => void) => void} cb */
exports.setLoader = function(cb) {
    customLoader = cb;
};

exports.dynamicModules = Object.create(null);
exports.$loading = {};
exports.$loaded = {};
/**
 * @param {string | [string, string]} moduleId
 * @param {(module: any) => void} onLoad
 */
exports.loadModule = function(moduleId, onLoad) {
    var loadedModule;
    if (Array.isArray(moduleId)) {
        var moduleType = moduleId[0];
        var moduleName = moduleId[1];
    } else if (typeof moduleId == "string") {
        var moduleName = moduleId;
    }
    var load = function (module) {
        // require(moduleName) can return empty object if called after require([moduleName], callback)
        if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);

        if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];

        exports.$loading[moduleName].push(onLoad);

        if (exports.$loading[moduleName].length > 1) return;

        var afterLoad = function() {
            loader(moduleName, function(err, module) {
                if (module) exports.$loaded[moduleName] = module;
                exports._emit("load.module", {name: moduleName, module: module});
                var listeners = exports.$loading[moduleName];
                exports.$loading[moduleName] = null;
                listeners.forEach(function(onLoad) {
                    onLoad && onLoad(module);
                });
            });
        };

        if (!exports.get("packaged")) return afterLoad();

        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
    };

    if (exports.dynamicModules[moduleName]) {
        exports.dynamicModules[moduleName]().then(function (module) {
            if (module.default) {
                load(module.default);
            }
            else {
                load(module);
            }
        });
    } else {
        // backwards compatibility for node and packaged version
        try {
            loadedModule = this.$require(moduleName);
        } catch (e) {}
        load(loadedModule || exports.$loaded[moduleName]);
    }
};

exports.$require = function(moduleName) {
    if (typeof module["require"] == "function") {
        var req = "require";
        return module[req](moduleName);
    }
};

exports.setModuleLoader = function (moduleName, onLoad) {
    exports.dynamicModules[moduleName] = onLoad;
};

var reportErrorIfPathIsNotConfigured = function() {
    if (
        !options.basePath && !options.workerPath
        && !options.modePath && !options.themePath
        && !Object.keys(options.$moduleUrls).length
    ) {
        console.error(
            "Unable to infer path to ace from script src,",
            "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes",
            "or with webpack use ace/webpack-resolver"
        );
        reportErrorIfPathIsNotConfigured = function() {};
    }
};

exports.version = "1.37.5";




/***/ }),

/***/ 53120:
/***/ ((module) => {

/*
styles = []
for (var i = 1; i < 16; i++) {
    styles.push(".ace_br" + i + "{" + (
        ["top-left", "top-right", "bottom-right", "bottom-left"]
    ).map(function(x, j) {
        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : "" 
    }).filter(Boolean).join(" ") + "}")
}
styles.join("\\n")
*/
module.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(60em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "↩";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;


/***/ }),

/***/ 98306:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.NewLineMode} NewLineMode
 */
var oop = __webpack_require__(2645);
var applyDelta = (__webpack_require__(28646)/* .applyDelta */ .T);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Anchor = (__webpack_require__(67490)/* .Anchor */ .M);

/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. 
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 **/
class Document {
    /**
     *
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param {String | String[]} textOrLines text The starting text
     **/
    constructor(textOrLines) {
        /**@type {string[]}*/
        this.$lines = [""];

        // There has to be one line at least in the document. If you pass an empty
        // string to the insert function, nothing will happen. Workaround.
        if (textOrLines.length === 0) {
            this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({row: 0, column: 0}, textOrLines);
        } else {
            this.insert({row: 0, column:0}, textOrLines);
        }
    }
    
    /**
     * Replaces all the lines in the current `Document` with the value of `text`.
     *
     * @param {String} text The text to use
     **/
    setValue(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text || "");
    }

    /**
     * Returns all the lines in the document as a single string, joined by the new line character.
     * @returns {String}
     **/
   getValue() {
        return this.getAllLines().join(this.getNewLineCharacter());
    }

    /** 
     * Creates a new `Anchor` to define a floating point in the document.
     * @param {Number} row The row number to use
     * @param {Number} column The column number to use
     * @returns {Anchor}
     **/
    createAnchor(row, column) {
        return new Anchor(this, row, column);
    }

    /**
     * @param {string} text
     */
    $detectNewLine(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    }

    /**
     * Returns the newline character that's being used, depending on the value of `newLineMode`. 
     * @returns {String} If `newLineMode == windows`, `\r\n` is returned.  
     *  If `newLineMode == unix`, `\n` is returned.  
     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.
     *
     **/
    getNewLineCharacter() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    }

    /**
     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
     * @param {NewLineMode} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]
     
     **/
    setNewLineMode(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    }

    /**
     * Returns the type of newlines being used; either `windows`, `unix`, or `auto`
     * @returns {NewLineMode}
     **/
    getNewLineMode() {
        return this.$newLineMode;
    }

    /**
     * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
     * @param {String} text The text to check
     * @returns {boolean}
     **/
    isNewLine(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    }

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row index to retrieve
     * @returns {string}
     **/
    getLine(row) {
        return this.$lines[row] || "";
    }

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     * @returns {string[]}
     **/
    getLines(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    }

    /**
     * Returns all lines in the document as string array.
     * @returns {string[]}
     **/
    getAllLines() {
        return this.getLines(0, this.getLength());
    }

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    getLength() {
        return this.$lines.length;
    }

    /**
     * Returns all the text within `range` as a single string.
     * @param {IRange} range The range to work with.
     * 
     * @returns {String}
     **/
    getTextRange(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    }
    
    /**
     * Returns all the text within `range` as an array of lines.
     * @param {IRange} range The range to work with.
     * 
     * @returns {string[]}
     **/
    getLinesForRange(range) {
        var lines;
        if (range.start.row === range.end.row) {
            // Handle a single-line range.
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            // Handle a multi-line range.
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    }

    // Deprecated methods retained for backwards compatibility.
    /**
     * @param row
     * @param lines
     
     * @deprecated
     */
    insertLines(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    }

    /**
     * @param firstRow
     * @param lastRow
     * @returns {String[]}
     
     * @deprecated
     */
    removeLines(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    }

    /**
     * @param position
     * @returns {Point}
     
     * @deprecated
     */
    insertNewLine(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    }

    /**
     * Inserts a block of `text` at the indicated `position`.
     * @param {Point} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text to insert
     * @returns {Point} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. 
     
     **/
    insert(position, text) {
        // Only detect new lines if the document has no line break yet.
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    }
    
    /**
     * Inserts `text` into the `position` at the current row. This method also triggers the `"change"` event.
     * 
     * This differs from the `insert` method in two ways:
     *   1. This does NOT handle newline characters (single-line text only).
     *   2. This is faster than the `insert` method for single-line text insertions.
     * 
     * @param {Point} position The position to insert at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text without new lines
     * @returns {Point} Returns the position of the end of the inserted text
     **/
    insertInLine(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    }

    /**
     * 
     * @param {number} row
     * @param {number} column
     * @return {Point}
     */
    clippedPos(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    }

    /**
     * @param {Point} pos
     * @return {Point}
     */
    clonePos(pos) {
        return {row: pos.row, column: pos.column};
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {Point}
     */
    pos(row, column) {
        return {row: row, column: column};
    }

    /**
     * @param {Point} position
     * @return {Point}
     * @private
     */
    $clipPosition(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    }
    
    /**
     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `"change"` event.
     * @param {Number} row The index of the row to insert at
     * @param {string[]} lines An array of strings
     
     **/
    insertFullLines(row, lines) {
        // Clip to document.
        // Allow one past the document end.
        row = Math.min(Math.max(row, 0), this.getLength());
        
        // Calculate insertion point.
        var column = 0;
        if (row < this.getLength()) {
            // Insert before the specified row.
            lines = lines.concat([""]);
            column = 0;
        } else {
            // Insert after the last row in the document.
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        
        // Insert.
        this.insertMergedLines({row: row, column: column}, lines);
    }

    /**
     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `"change"` event.
     * @param {Point} position
     * @param {string[]} lines An array of strings
     * @returns {Point} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     **/    
    insertMergedLines(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    }

    /**
     * Removes the `range` from the document.
     * @param {IRange} range A specified Range to remove
     * @returns {Point} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     
     **/
    remove(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    }

    /**
     * Removes the specified columns from the `row`. This method also triggers a `"change"` event.
     * @param {Number} row The row to remove from
     * @param {Number} startColumn The column to start removing at 
     * @param {Number} endColumn The column to stop removing at
     * @returns {Point} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.
     
     **/
    removeInLine(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    }

    /**
     * Removes a range of full lines. This method also triggers the `"change"` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {String[]} Returns all the removed lines.
     
     **/
    removeFullLines(firstRow, lastRow) {
        // Clip to document.
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        
        // Calculate deletion range.
        // Delete the ending new line unless we're at the end of the document.
        // If we're at the end of the document, delete the starting new line.
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        
        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        
        // Return the deleted lines.
        return deletedLines;
    }

    /**
     * Removes the new line between `row` and the row immediately following it. This method also triggers the `"change"` event.
     * @param {Number} row The row to check
     *
     **/
    removeNewLine(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    }

    /**
     * Replaces a range in the document with the new `text`.
     * @param {Range | IRange} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Point} Returns an object containing the final row and column, like this:
     *     {row: endRow, column: 0}
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     **/
    replace(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        // @ts-expect-error
        if (text.length === 0 && range.isEmpty())
            return range.start;

        // Shortcut: If the text we want to insert is the same as it is already
        // in the document, we don't have to replace anything.
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    }

    /**
     * Applies all changes in `deltas` to the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    applyDeltas(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    }
    
    /**
     * Reverts all changes in `deltas` from the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    revertDeltas(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    }
    
    /**
     * Applies `delta` to the document.
     * @param {Delta} delta A delta object (can include "insert" and "remove" actions)
     * @param {boolean} [doNotValidate]
     **/
    applyDelta(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        // An empty range is a NOOP.
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    }

    /**
     * @param {Delta} delta
     */
    $safeApplyDelta(delta) {
        var docLength = this.$lines.length;
        // verify that delta is in the document to prevent applyDelta from corrupting lines array 
        if (
            delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
            || delta.action == "insert" && delta.start.row <= docLength
        ) {
            this.applyDelta(delta);
        }
    }

    /**
     * 
     * @param {Delta} delta
     * @param {number} MAX
     */
    $splitAndapplyLargeDelta(delta, MAX) {
        // Split large insert deltas. This is necessary because:
        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)
        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.
        // we use 20000 to leave some space for actual stack
        // 
        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete
        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas
        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js
        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row; 
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        // Update remaining delta.
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    }
    
    /**
     * Reverts `delta` from the document.
     * @param {Delta} delta A delta object (can include "insert" and "remove" actions)
     **/
    revertDelta(delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    }
    
    /**
     * Converts an index position in a document to a `{row, column}` object.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Number} index An index to convert
     * @param {Number} [startRow=0] The row from which to start the conversion
     * @returns {Point} A `{row, column}` object of the `index` position
     */
    indexToPosition(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: index + lines[l-1].length + newlineLength};
    }

    /**
     * Converts the `{row, column}` position in a document to the character's index.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Point} pos The `{row, column}` to convert
     * @param {Number} [startRow=0] The row from which to start the conversion
     * @returns {Number} The index position in the document
     */
    positionToIndex(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    }

    /**
     * Splits a string of text on any newline (`\n`) or carriage-return (`\r`) characters.
     *
     * @method $split
     * @param {String} text The text to work with
     * @returns {String[]} A String array, with each index containing a piece of the original `text` string.
     *
     **/
    $split(text) {
        return text.split(/\r\n|\r|\n/);
    }
}

Document.prototype.$autoNewLine = "";
Document.prototype.$newLineMode = "auto";

oop.implement(Document.prototype, EventEmitter);

exports.y = Document;


/***/ }),

/***/ 33464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./layer/font_metrics").FontMetrics} FontMetrics
 * @typedef {import("./edit_session/fold_line").FoldLine} FoldLine
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.SyntaxMode} SyntaxMode
 * @typedef {import("../ace-internal").Ace.LineWidget} LineWidget
 */

var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var BidiHandler = (__webpack_require__(16585)/* .BidiHandler */ .t);
var config = __webpack_require__(76321);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Selection = (__webpack_require__(98345)/* .Selection */ .L);
var TextMode = (__webpack_require__(49432).Mode);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var LineWidgets = (__webpack_require__(90563)/* .LineWidgets */ .G);
var Document = (__webpack_require__(98306)/* .Document */ .y);
var BackgroundTokenizer = (__webpack_require__(93857)/* .BackgroundTokenizer */ .K);
var SearchHighlight = (__webpack_require__(10464)/* .SearchHighlight */ .V);
var UndoManager = (__webpack_require__(79870)/* .UndoManager */ .a);

/**
 * @typedef TextMode
 * @type {SyntaxMode}
 */

/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 *
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 **/
class EditSession {
    /**
     * Sets up a new `EditSession` and associates it with the given `Document` and `Mode`.
     * @param {Document | String} [text] [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
     * @param {SyntaxMode} [mode] [The initial language mode to use for the document]{: #modeParam}
     **/
    constructor(text, mode) {
        /**@type {Document}*/this.doc;
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$editor = null;
        this.prevOp = {};

        /** @type {FoldLine[]} */
        this.$foldData = [];
        this.id = "session" + (++EditSession.$uid);
        this.$foldData.toString = function() {
            return this.join("\n");
        };

        // Set default background tokenizer with Text mode until editor session mode is set
        this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);


        var _self = this;
        this.bgTokenizer.on("update", function(e) {
            _self._signal("tokenizerUpdate", e);
        });

        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);

        if (typeof text != "object" || !text.getLine)
            text = new Document(/**@type{string}*/(text));

        this.setDocument(text);

        this.selection = new Selection(this);
        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.on("changeSelection", this.$onSelectionChange);
        this.selection.on("changeCursor", this.$onSelectionChange);

        this.$bidiHandler = new BidiHandler(this);

        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);

        this.destroyed = false;
        this.$initOperationListeners();
    }

    $initOperationListeners() {
        /**@type {import("../ace-internal").Ace.Operation | null}*/
        this.curOp = null;
        this.on("change", () => {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.docChanged = true;
        }, true);
        this.on("changeSelection", () => {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.selectionChanged = true;
        }, true);

        // Fallback mechanism in case current operation doesn't finish more explicitly.
        // Triggered, for example, when a consumer makes programmatic changes without invoking endOperation afterwards.
        this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
    }

    /**
     * Start an Ace operation, which will then batch all the subsequent changes (to either content or selection) under a single atomic operation.
     * @param {{command?: {name?: string}, args?: any}|undefined} [commandEvent] Optional name for the operation
     */
    startOperation(commandEvent) {
        if (this.curOp) {
            if (!commandEvent || this.curOp.command) {
                return;
            }
            this.prevOp = this.curOp;
        }
        if (!commandEvent) {
            commandEvent = {};
        }

        this.$operationResetTimer.schedule();
        this.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args
        };
        this.curOp.selectionBefore = this.selection.toJSON();
        this._signal("startOperation", commandEvent);
    }

    /**
     * End current Ace operation.
     * Emits "beforeEndOperation" event just before clearing everything, where the current operation can be accessed through `curOp` property.
     * @param {any} [e]
     */
    endOperation(e) {
        if (this.curOp) {
            if (e && e.returnValue === false) {
                this.curOp = null;
                this._signal("endOperation", e);
                return;
            }
            if (e == true && this.curOp.command && this.curOp.command.name == "mouse") {
                // When current operation is mousedown, we wait for the mouseup to end the operation.
                // So during a user selection, we would only end the operation when the final selection is known.
                return;
            }

            const currentSelection = this.selection.toJSON();
            this.curOp.selectionAfter = currentSelection;
            this.$lastSel = this.selection.toJSON();
            this.getUndoManager().addSelection(currentSelection);

            this._signal("beforeEndOperation");
            this.prevOp = this.curOp;
            this.curOp = null;
            this._signal("endOperation", e);
        }
    }

    /**
     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
     *
     * @param {Document} doc The new `Document` to use
     *
     **/
    setDocument(doc) {
        if (this.doc)
            this.doc.off("change", this.$onChange);
        this.doc = doc;
        doc.on("change", this.$onChange, true);

        this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    }

    /**
     * Returns the `Document` associated with this session.
     * @return {Document}
     **/
    getDocument() {
        return this.doc;
    }

    /**
     * Get "widgetManager" from EditSession
     * 
     * @returns {LineWidgets} object
     */
    get widgetManager() {
        const widgetManager = new LineWidgets(this);
        // todo remove the widgetManger assignement from lineWidgets constructor when introducing breaking changes
        this.widgetManager = widgetManager;

        if (this.$editor)
            widgetManager.attach(this.$editor);
        
        return widgetManager;
    }

    /**
     * Set "widgetManager" in EditSession
     * 
     * @returns void
     */
    set widgetManager(value) {
        Object.defineProperty(this, "widgetManager", {
            writable: true, 
            enumerable: true,
            configurable: true,
            value: value,
        });
    }
    /**
     * @param {Number} docRow The row to work with
     *
     **/
    $resetRowCache(docRow) {
        if (!docRow) {
            /** @type {number[]} */
            this.$docRowCache = [];
            /** @type {number[]} */
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    }

    $getRowCacheIndex(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    }

    resetCaches() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (!this.destroyed)
            this.bgTokenizer.start(0);
    }

    /**
     * @param e
     * @internal
     */
    onChangeFold(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    }

    /**
     *
     * @param {Delta} delta
     * @internal
     */
    onChange(delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager) {
            if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                    // @ts-expect-error TODO: this action type is missing in the types
                    action: "removeFolds",
                    folds:  removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    }

    onSelectionChange() {
        this._signal("changeSelection");
    }

    /**
     * Sets the session text.
     * @param {String} text The new text to place
     **/
    setValue(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    }

     /**
     * Returns a new instance of EditSession with state from JSON.
     * @method fromJSON
     * @param {string|object} session The EditSession state.
     * @returns {EditSession}
     */
    static fromJSON(session) {
        if (typeof session == "string")
            session = JSON.parse(session);
        const undoManager = new UndoManager();
        undoManager.$undoStack = session.history.undo;
        undoManager.$redoStack = session.history.redo;
        undoManager.mark = session.history.mark;
        undoManager.$rev = session.history.rev;

        const editSession = new EditSession(session.value);
        session.folds.forEach(function(fold) {
          editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
        });
        editSession.setAnnotations(session.annotations);
        editSession.setBreakpoints(session.breakpoints);
        editSession.setMode(session.mode);
        editSession.setScrollLeft(session.scrollLeft);
        editSession.setScrollTop(session.scrollTop);
        editSession.setUndoManager(undoManager);
        editSession.selection.fromJSON(session.selection);

        return editSession;
    }

    /**
     * Returns the current edit session.
     * @method toJSON
     * @returns {Object}
     */
    toJSON() {
        return {
            annotations: this.$annotations,
            breakpoints: this.$breakpoints,
            folds: this.getAllFolds().map(function(fold) {
                return fold.range;
            }),
            history: this.getUndoManager(),
            mode: this.$mode.$id,
            scrollLeft: this.$scrollLeft,
            scrollTop: this.$scrollTop,
            selection: this.selection.toJSON(),
            value: this.doc.getValue()
        };
    }

    /**
     * Returns the current [[Document `Document`]] as a string.
     * @method toString
     * @returns {String}
     * @alias EditSession.getValue
     *
     **/
    toString() {
        return this.doc.getValue();
    }

    /**
     * Returns selection object.
     * @returns {Selection}
     **/
    getSelection() {
        return this.selection;
    }

    /**
     * {:BackgroundTokenizer.getState}
     * @param {Number} row The row to start at
     * @returns {string | string[]}
     * @related BackgroundTokenizer.getState
     **/
    getState(row) {
        return this.bgTokenizer.getState(row);
    }

    /**
     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
     * @param {Number} row The row to start at
     * @returns {import("../ace-internal").Ace.Token[]}
     **/
    getTokens(row) {
        return this.bgTokenizer.getTokens(row);
    }

    /**
     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
     * @param {Number} row The row number to retrieve from
     * @param {Number} column The column number to retrieve from
     * @returns {import("../ace-internal").Ace.Token}
     *
     **/
    getTokenAt(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    }

    /**
     * Sets the undo manager.
     * @param {UndoManager} undoManager The new undo manager
     **/
    setUndoManager(undoManager) {
        this.$undoManager = undoManager;

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();
                self.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        } else {
            this.$syncInformUndoManager = function() {};
        }
    }

    /**
     * starts a new group in undo history
     **/
    markUndoGroup() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    }

    /**
     * Returns the current undo manager.
     * @returns {UndoManager}
     **/
    getUndoManager() {
        // @ts-ignore
        return this.$undoManager || this.$defaultUndoManager;
    }

    /**
     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\t'`.
     * @returns {String}
     **/
    getTabString() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    }

    /**
     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
     * @param {Boolean} val Value indicating whether or not to use soft tabs
     **/
    setUseSoftTabs(val) {
        this.setOption("useSoftTabs", val);
    }

    /**
     * Returns `true` if soft tabs are being used, `false` otherwise.
     * @returns {Boolean}
     **/
    getUseSoftTabs() {
        // todo might need more general way for changing settings from mode, but this is ok for now
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    }
    /**
     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
     * @param {Number} tabSize The new tab size
     **/
    setTabSize(tabSize) {
        this.setOption("tabSize", tabSize);
    }
    /**
     * Returns the current tab size.
     * @return {number}
     **/
    getTabSize() {
        return this.$tabSize;
    }

    /**
     * Returns `true` if the character at the position is a soft tab.
     * @param {Point} position The position to check
     **/
    isTabStop(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    }

    /**
     * Set whether keyboard navigation of soft tabs moves the cursor within the soft tab, rather than over
     * @param {Boolean} navigateWithinSoftTabs Value indicating whether or not to navigate within soft tabs
     **/
    setNavigateWithinSoftTabs(navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
    }
    /**
     * Returns `true` if keyboard navigation moves the cursor within soft tabs, `false` if it moves the cursor over soft tabs.
     * @returns {Boolean}
     **/
    getNavigateWithinSoftTabs() {
        return this.$navigateWithinSoftTabs;
    }

    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable.
     *
     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     *
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     *
     **/
    setOverwrite(overwrite) {
        this.setOption("overwrite", overwrite);
    }

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     **/
    getOverwrite() {
        return this.$overwrite;
    }

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     **/
    toggleOverwrite() {
        this.setOverwrite(!this.$overwrite);
    }

    /**
     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
     * @param {Number} row The row number
     * @param {String} className The class to add
     **/
    addGutterDecoration(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    }

    /**
     * Removes `className` from the `row`.
     * @param {Number} row The row number
     * @param {String} className The class to add
     **/
    removeGutterDecoration(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    }

    /**
     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.
     * @returns {String[]}
     **/
    getBreakpoints() {
        return this.$breakpoints;
    }

    /**
     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
     * @param {number[]} rows An array of row indices
     **/
    setBreakpoints(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    }

    /**
     * Removes all breakpoints on the rows. This function also emits the `'changeBreakpoint'` event.
     **/
    clearBreakpoints() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Sets a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     * @param {String} className Class of the breakpoint
     **/
    setBreakpoint(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Removes a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     **/
    clearBreakpoint(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
     * @param {Range} range Define the range of the marker
     * @param {String} clazz Set the CSS class for the marker
     * @param {import("../ace-internal").Ace.MarkerRenderer | "fullLine" | "screenLine" | "text" | "line"} [type] Identify the renderer type of the marker. If string provided, corresponding built-in renderer is used. Supported string types are "fullLine", "screenLine", "text" or "line". If a Function is provided, that Function is used as renderer.
     * @param {Boolean} [inFront] Set to `true` to establish a front marker
     *
     * @return {Number} The new marker id
     **/
    addMarker(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    }

    /**
     * Adds a dynamic marker to the session.
     * @param {import("../ace-internal").Ace.MarkerLike} marker object with update method
     * @param {Boolean} [inFront] Set to `true` to establish a front marker
     *
     * @return {import("../ace-internal").Ace.MarkerLike} The added marker
     **/
    addDynamicMarker(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    }

    /**
     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
     * @param {Number} markerId A number representing a marker
     **/
    removeMarker(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete (markers[markerId]);
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
    }

    /**
     * Returns an object containing all of the markers, either front or back.
     * @param {Boolean} [inFront] If `true`, indicates you only want front markers; `false` indicates only back markers
     *
     * @returns {{[id: number]: import("../ace-internal").Ace.MarkerLike}}
     **/
    getMarkers(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    }

    /**
     * @param {RegExp} re
     */
    highlight(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    }

    /**
     * experimental
     * @param {number} startRow
     * @param {number} endRow
     * @param {string} clazz
     * @param {boolean} [inFront]
     * @return {Range}
     */
    highlightLines(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    }

    /*
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: "Missing argument",
     *    type: "error" // or "warning" or "info"
     *  }
     */
    /**
     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
     * @param {import("../ace-internal").Ace.Annotation[]} annotations A list of annotations
     **/
    setAnnotations(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    }

    /**
     * Returns the annotations for the `EditSession`.
     * @returns {import("../ace-internal").Ace.Annotation[]}
     **/
    getAnnotations() {
        return this.$annotations || [];
    }

    /**
     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
     **/
    clearAnnotations() {
        this.setAnnotations([]);
    }

    /**
     * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
     * @param {String} text A block of text
     *
     **/
    $detectNewLine(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    }

    /**
     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
     * @param {Number} row The row to start at
     * @param {Number} column The column to start at
     *
     * @returns {Range}
     **/
    getWordRange(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    }

    /**
     * Gets the range of a word, including its right whitespace.
     * @param {Number} row The row number to start from
     * @param {Number} column The column number to start from
     *
     * @return {Range}
     **/
    getAWordRange(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    }

    /**
     * {:Document.setNewLineMode.desc}
     * @param {import("../ace-internal").Ace.NewLineMode} newLineMode {:Document.setNewLineMode.param}
     *
     *
     * @related Document.setNewLineMode
     **/
    setNewLineMode(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    }

    /**
     *
     * Returns the current new line mode.
     * @returns {import("../ace-internal").Ace.NewLineMode}
     * @related Document.getNewLineMode
     **/
    getNewLineMode() {
        return this.doc.getNewLineMode();
    }

    /**
     * Identifies if you want to use a worker for the `EditSession`.
     * @param {Boolean} useWorker Set to `true` to use a worker
     **/
    setUseWorker(useWorker) { this.setOption("useWorker", useWorker); }

    /**
     * Returns `true` if workers are being used.
     **/
    getUseWorker() { return this.$useWorker; }

    /**
     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
     * @internal
     **/
    onReloadTokenizer(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    }

    /**
     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
     * @param {SyntaxMode | string} mode Set a new text mode
     * @param {() => void} [cb] optional callback
     **/
    setMode(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = /**@type{string}*/(mode) || "ace/mode/text";
        }

        // this is needed if ace isn't on require path (e.g tests in node)
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        // load on demand
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));

        // set mode to text until loading is finished
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    }

    /**
     * @param mode
     * @param [$isPlaceholder]
     */
    $onChangeMode(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode)
            return;

        var oldMode = this.$mode;
        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.on !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on("update", onReloadTokenizer);
        }

        this.bgTokenizer.setTokenizer(tokenizer);
        this.bgTokenizer.setDocument(this.getDocument());

        /**@type {RegExp}*/
        this.tokenRe = mode.tokenRe;
        /**@type {RegExp}*/
        this.nonTokenRe = mode.nonTokenRe;


        if (!$isPlaceholder) {
            // experimental method, used by c9 findiniles
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode", {oldMode: oldMode, mode: mode});
        }
    }

    $stopWorker() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    }

    $startWorker() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    }

    /**
     * Returns the current text mode.
     * @returns {TextMode} The current text mode
     **/
    getMode() {
        return this.$mode;
    }

    /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     **/
    setScrollTop(scrollTop) {
        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop);
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    }

    /**
     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
     * @returns {Number}
     **/
    getScrollTop() {
        return this.$scrollTop;
    }

    /**
     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
     * @param {number} scrollLeft
     */
    setScrollLeft(scrollLeft) {
        // scrollLeft = Math.round(scrollLeft);
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    }

    /**
     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
     * @returns {Number}
     **/
    getScrollLeft() {
        return this.$scrollLeft;
    }

    /**
     * Returns the width of the screen.
     * @returns {Number}
     **/
    getScreenWidth() {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    }

    /**
     * @return {number}
     */
    getLineWidgetMaxWidth() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    }

    /**
     * @param {boolean} [force]
     */
    $computeWidth(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    }

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row to retrieve from
     * @returns {String}
     **/
    getLine(row) {
        return this.doc.getLine(row);
    }

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     * @returns {String[]}
     *
     **/
    getLines(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    }

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    getLength() {
        return this.doc.getLength();
    }

    /**
     * {:Document.getTextRange.desc}
     * @param {IRange} [range] The range to work with
     *
     * @returns {String}
     **/
    getTextRange(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    }

    /**
     * Inserts a block of `text` and the indicated `position`.
     * @param {Point} position The position {row, column} to start inserting at
     * @param {String} text A chunk of text to insert
     * @returns {Point} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.
     **/
    insert(position, text) {
        return this.doc.insert(position, text);
    }

    /**
     * Removes the `range` from the document.
     * @param {IRange} range A specified Range to remove
     * @returns {Point} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     **/
    remove(range) {
        return this.doc.remove(range);
    }

    /**
     * Removes a range of full lines. This method also triggers the `'change'` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {String[]} Returns all the removed lines.
     *
     * @related Document.removeFullLines
     *
     **/
    removeFullLines(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    }

    /**
     * Reverts previous changes to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} [dontSelect] If `true`, doesn't select the range of where the change occured
     **/
    undoChanges(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
            } else if (delta.folds) {
                this.addFolds(delta.folds);
            }
        }
        if (!dontSelect && this.$undoSelect) {
            //@ts-expect-error TODO: potential wrong property
            if (deltas.selectionBefore)
                //@ts-expect-error TODO: potential wrong property
                this.selection.fromJSON(deltas.selectionBefore);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
    }

    /**
     * Re-implements a previously undone change to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} [dontSelect] {:dontSelect}
     **/
    redoChanges(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
            }
        }

        if (!dontSelect && this.$undoSelect) {
            //@ts-expect-error TODO: potential wrong property
            if (deltas.selectionAfter)
                //@ts-expect-error TODO: potential wrong property
                this.selection.fromJSON(deltas.selectionAfter);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
    }

    /**
     * Enables or disables highlighting of the range where an undo occurred.
     * @param {Boolean} enable If `true`, selects the range of the reinserted change
     *
     **/
    setUndoSelect(enable) {
        this.$undoSelect = enable;
    }

    /**
     *
     * @param {Delta[]} deltas
     * @param {boolean} [isUndo]
     * @return {Range}
     */
    $getUndoSelection(deltas, isUndo) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var range, point;

        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start) continue; // skip folds
            if (!range) {
                if (isInsert(delta)) {
                    range = Range.fromPoints(delta.start, delta.end);
                } else {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
            }

            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        return range;
    }

    /**
     * Replaces a range in the document with the new `text`.
     *
     * @param {IRange} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Point} An object containing the final row and column, like this:
     * ```
     * {row: endRow, column: 0}
     * ```
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     * @related Document.replace
     **/
    replace(range, text) {
        return this.doc.replace(range, text);
    }

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     *  ```json
     *    { row: newRowLocation, column: newColumnLocation }
     *  ```
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Point} toPosition The location (row and column) where you want to move the text to
     * @param {boolean} [copy]
     * @returns {Range} The new range where the text was moved to.
     **/
    moveText(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    }

    /**
     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
     *
     * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
     * @param {Number} startRow Starting row
     * @param {Number} endRow Ending row
     * @param {String} indentString The indent token
     **/
    indentRows(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    }

    /**
     * Outdents all the rows defined by the `start` and `end` properties of `range`.
     * @param {Range} range A range of rows
     **/
    outdentRows(range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    }

    /**
     *
     * @param {number} firstRow
     * @param {number} lastRow
     * @param [dir]
     * @returns {number}
     */
    $moveLines(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    }
    /**
     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move up
     * @param {Number} lastRow The final row to move up
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/
    moveLinesUp(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    }

    /**
     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move down
     * @param {Number} lastRow The final row to move down
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/
    moveLinesDown(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    }

    /**
     * Duplicates all the text between `firstRow` and `lastRow`.
     * @param {Number} firstRow The starting row to duplicate
     * @param {Number} lastRow The final row to duplicate
     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     **/
    duplicateLines(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    }

    /**
     * @param {number} row
     * @returns {number}
     */
    $clipRowToDocument(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    }

    /**
     * @param {number} row
     * @param {number} column
     * @returns {number}
     */
    $clipColumnToRow(row, column) {
        if (column < 0) return 0;
        return Math.min(this.doc.getLine(row).length, column);
    }

    /**
     * @param {number} row
     * @param {number} column
     * @returns {Point}
     */
    $clipPositionToDocument(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    }

    /**
     * @param {Range} range
     * @returns {Range}
     */
    $clipRangeToDocument(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    }

    /**
     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
     **/
    setUseWrapMode(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);

            // If wrapMode is activaed, the wrapData array has to be initialized.
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    }

    /**
     * Returns `true` if wrap mode is being used; `false` otherwise.
     * @returns {Boolean}
     **/
    getUseWrapMode() {
        return this.$useWrapMode;
    }

    // Allow the wrap limit to move freely between min and max. Either
    // parameter can be null to allow the wrap limit to be unconstrained
    // in that direction. Or set both parameters to the same number to pin
    // the limit to that value.
    /**
     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
     * @param {Number} min The minimum wrap value (the left side wrap)
     * @param {Number} max The maximum wrap value (the right side wrap)
     **/
    setWrapLimitRange(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();

            // This will force a recalculation of the wrap limit
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    }

    /**
     * This should generally only be called by the renderer when a resize is detected.
     * @param {Number} desiredLimit The new wrap limit
     * @param [$printMargin]
     * @returns {Boolean}
     **/
    adjustWrapLimit(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    }

    /**
     *
     * @param {number} wrapLimit
     * @param {number} [min]
     * @param {number} [max]
     * @returns {number}
     */
    $constrainWrapLimit(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    }

    /**
     * Returns the value of wrap limit.
     * @returns {Number} The wrap limit.
     **/
    getWrapLimit() {
        return this.$wrapLimit;
    }

    /**
     * Sets the line length for soft wrap in the editor. Lines will break
     *  at a minimum of the given length minus 20 chars and at a maximum
     *  of the given number of chars.
     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
     */
    setWrapLimit(limit) {
        this.setWrapLimitRange(limit, limit);
    }

    /**
     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
     *
     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
     *
     * @returns {{ min: number, max: number }}
     **/
    getWrapLimitRange() {
        // Avoid unexpected mutation by returning a copy
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    }

    /**
     * @param {Delta} delta
     */
    $updateInternalDataOnChange(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;

        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);

                // If some new line is added inside of a foldLine, then split
                // the fold line up.
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    // Inside of the foldLine range. Need to split stuff up.
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    // Infront of the foldLine but same row. Need to shift column.
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    // Nothing to do if the insert is after the foldLine.
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            // Realign folds. E.g. if you add some new chars before a fold, the
            // fold should "move" to the right.
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                // Get all the folds in the change range and remove them.
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    }

    /**
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $updateRowLengthCache(firstRow, lastRow) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    }

    /**
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $updateWrapData(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    }

    /**
     * @param {number[]}tokens
     * @param {number} wrapLimit
     * @param {number} tabSize
     * @returns {*[]}
     */
    $computeWrapSplits(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            // The document size is the current size - the extra width for tabs
            // and multipleWidth characters.
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2) len -= 1;
            }

            if (!splits.length) {
                indent = getWrapIndent();
                //@ts-expect-error TODO: potential wrong property
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            // This is, where the split should be.
            var split = lastSplit + wrapLimit - indent;

            // If there is a space or tab at this split position, then making
            // a split is simple.
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                /* disabled see https://github.com/ajaxorg/ace/issues/1186
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] >= SPACE) {
                    split ++;
                } */
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Check if split is inside of a placeholder. Placeholder are
            // not splitable. Therefore, seek the beginning of the placeholder
            // and try to place the split before the placeholder's start.
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                // Seek the start of the placeholder and do the split
                // before the placeholder. By definition there always
                // a PLACEHOLDER_START between split and lastSplit.
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        // split++; << No incremental here as we want to
                        //  have the position before the Placeholder.
                        break;
                    }
                }

                // If the PLACEHOLDER_START is not the index of the
                // last split, then we can do the split
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }

                // If the PLACEHOLDER_START IS the index of the last
                // split, then we have to place the split after the
                // placeholder. So, let's seek for the end of the placeholder.
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }

                // If spilt == tokens.length, then the placeholder is the last
                // thing in the line and adding a new split doesn't make sense.
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }

                // Finally, add the split...
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Search for the first non space/tab/placeholder/punctuation token backwards.
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            // If we found one, then add the split.
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }

            // === ELSE ===
            split = lastSplit + wrapLimit;
            // The split is inside of a CHAR or CHAR_EXT token and no space
            // around -> force a split.
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    }

    /**
     * Given a string, returns an array of the display characters, including tabs and spaces.
     * @param {String} str The string to check
     * @param {Number} [offset] The value to start at
     * @returns {number[]}
     **/
    $getDisplayTokens(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            // Tab
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            // Space
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    }

    /**
     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
     * @param {String} str The string to calculate the screen width of
     * @param {Number} [maxScreenColumn]
     * @param {Number} [screenColumn]
     * @returns {Number[]} Returns an `int[]` array with two elements:<br/>
     * The first position indicates the number of columns for `str` on screen.<br/>
     * The second value contains the position of the document column that this function read until.
     **/
    $getStringScreenWidth(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            // tab
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    }

    /**
     * Returns number of screenrows in a wrapped line.
     * @param {Number} row The row number to check
     * @returns {Number}
     **/
    getRowLength(row) {
        var h = 1;
        if (this.lineWidgets)
            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;

        if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
        else
            return this.$wrapData[row].length + h;
    }

    /**
     * @param {Number} row
     * @returns {Number}
     **/
    getRowLineCount(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    }

    /**
     * @param {Number} screenRow
     * @returns {Number}
     **/
    getRowWrapIndent(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    }

    /**
     * Returns the position (on screen) for the last character in the provided screen row.
     * @param {Number} screenRow The screen row to check
     * @returns {Number}
     *
     * @related EditSession.documentToScreenColumn
     **/
    getScreenLastRowColumn(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    }

    /**
     * For the given document row and column, this returns the column position of the last screen row.
     * @param {Number} docRow
     * @param {Number} docColumn
     * @returns {number}
     **/
    getDocumentLastRowColumn(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    }

    /**
     * For the given document row and column, this returns the document position of the last row.
     * @param {Number} docRow
     * @param {Number} docColumn
     * @returns {Point}
     **/
    getDocumentLastRowColumnPosition(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    }

    /**
     * For the given row, this returns the split data.
     * @param {number} row
     * @returns {String | undefined}
     */
    getRowSplitData(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    }

    /**
     * The distance to the next tab stop at the specified screen column.
     * @param {Number} screenColumn The screen column to check
     *
     * @returns {Number}
     **/
    getScreenTabSize(screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
    }

    /**
     * @param {number} screenRow
     * @param {number} screenColumn
     * @returns {number}
     */
    screenToDocumentRow(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    }

    /**
     * @param {number} screenRow
     * @param {number} screenColumn
     * @returns {number}
     */
    screenToDocumentColumn(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    }

    /**
     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
     * @param {Number} screenRow The screen row to check
     * @param {Number} screenColumn The screen column to check
     * @param {Number} [offsetX] screen character x-offset [optional]
     *
     * @returns {Point} The object returned has two properties: `row` and `column`.
     *
     * @related EditSession.documentToScreenPosition
     **/
    screenToDocumentPosition(screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            // clip at the end of the document
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];

        // We remove one character at the end so that the docColumn
        // position returned is not associated to the next row on the screen.
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    }

    /**
     * Converts document coordinates to screen coordinates. {:conversionConsiderations}
     * @param {Number|Point} docRow The document row to check
     * @param {Number|undefined} [docColumn] The document column to check
     * @returns {Point} The object returned by this method has two properties: `row` and `column`.
     *
     * @related EditSession.screenToDocumentPosition
     **/
    documentToScreenPosition(docRow, docColumn) {
        // Normalize the passed in arguments.
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(/**@type{Point}*/(docRow).row, /**@type{Point}*/(docRow).column);
        else
            pos = this.$clipPositionToDocument(/**@type{number}*/(docRow), docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;

        // Clamp the docRow position in case it's inside of a folded block.
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;

        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }

        // Calculate the text line that is displayed in docRow on the screen.
        var textLine = "";
        // Check if the final row we want to reach is inside of a fold.
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        // Clamp textLine if in wrapMode.
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }

        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    }

    /**
     * For the given document row and column, returns the screen column.
     * @param {Number|Point} row
     * @param {Number} [docColumn]
     * @returns {Number}
     **/
    documentToScreenColumn(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    }

    /**
     * For the given document row and column, returns the screen row.
     * @param {Number|Point} docRow
     * @param {Number} [docColumn]
     * @returns {number}
     **/
    documentToScreenRow(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    }

    /**
     * Returns the length of the screen.
     * @returns {Number}
     **/
    getScreenLength() {
        var screenRows = 0;
        /**@type {FoldLine}*/
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();

            // Remove the folded lines again.
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }

        // todo
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    }

    /**
     * @param {FontMetrics} fm
     */
    $setFontMetrics(fm) {
        if (!this.$enableVarChar) return;
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;

            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                // tab
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }

            return [screenColumn, column];
        };
    }

    /**
     * @returns {string} the last character preceding the cursor in the editor
     */
    getPrecedingCharacter() {
        var pos = this.selection.getCursor();

        if (pos.column === 0) {
            return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
        }

        var currentLine = this.getLine(pos.row);
        return currentLine[pos.column - 1];
    }

    destroy() {
        if (!this.destroyed) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer.cleanup();
            this.destroyed = true;
        }
        this.endOperation();
        this.$stopWorker();
        this.removeAllListeners();
        if (this.doc) {
            this.doc.off("change", this.$onChange);
        }
        if (this.selection) {
            this.selection.off("changeCursor", this.$onSelectionChange);
            this.selection.off("changeSelection", this.$onSelectionChange);
        }
        this.selection.detach();
    }
}

EditSession.$uid = 0;
EditSession.prototype.$modes = config.$modes;
/**
 * Returns the current [[Document `Document`]] as a string.
 * @method getValue
 * @returns {String}
 * @alias EditSession.toString
 **/
EditSession.prototype.getValue = EditSession.prototype.toString;

EditSession.prototype.$defaultUndoManager = {
    undo: function() {},
    redo: function() {},
    hasUndo: function() {},
    hasRedo: function() {},
    reset: function() {},
    add: function() {},
    addSelection: function() {},
    startNewGroup: function() {},
    addSession: function() {}
};
EditSession.prototype.$overwrite = false;

EditSession.prototype.$mode = null;
EditSession.prototype.$modeId = null;
EditSession.prototype.$scrollTop = 0;
EditSession.prototype.$scrollLeft = 0;
// WRAPMODE
EditSession.prototype.$wrapLimit = 80;
EditSession.prototype.$useWrapMode = false;
EditSession.prototype.$wrapLimitRange = {
    min : null,
    max : null
};
/**
 *
 * @type {null | import("../ace-internal").Ace.LineWidget[]}
 */
EditSession.prototype.lineWidgets = null;
EditSession.prototype.isFullWidth = isFullWidth;

oop.implement(EditSession.prototype, EventEmitter);

// "Tokens"
var CHAR = 1,
    CHAR_EXT = 2,
    PLACEHOLDER_START = 3,
    PLACEHOLDER_BODY =  4,
    PUNCTUATION = 9,
    SPACE = 10,
    TAB = 11,
    TAB_SPACE = 12;
// For every keystroke this gets called once per char in the whole doc!!
// Wouldn't hurt to make it a bit faster for c >= 0x1100
function isFullWidth(c) {
    if (c < 0x1100)
        return false;
    return c >= 0x1100 && c <= 0x115F ||
        c >= 0x11A3 && c <= 0x11A7 ||
        c >= 0x11FA && c <= 0x11FF ||
        c >= 0x2329 && c <= 0x232A ||
        c >= 0x2E80 && c <= 0x2E99 ||
        c >= 0x2E9B && c <= 0x2EF3 ||
        c >= 0x2F00 && c <= 0x2FD5 ||
        c >= 0x2FF0 && c <= 0x2FFB ||
        c >= 0x3000 && c <= 0x303E ||
        c >= 0x3041 && c <= 0x3096 ||
        c >= 0x3099 && c <= 0x30FF ||
        c >= 0x3105 && c <= 0x312D ||
        c >= 0x3131 && c <= 0x318E ||
        c >= 0x3190 && c <= 0x31BA ||
        c >= 0x31C0 && c <= 0x31E3 ||
        c >= 0x31F0 && c <= 0x321E ||
        c >= 0x3220 && c <= 0x3247 ||
        c >= 0x3250 && c <= 0x32FE ||
        c >= 0x3300 && c <= 0x4DBF ||
        c >= 0x4E00 && c <= 0xA48C ||
        c >= 0xA490 && c <= 0xA4C6 ||
        c >= 0xA960 && c <= 0xA97C ||
        c >= 0xAC00 && c <= 0xD7A3 ||
        c >= 0xD7B0 && c <= 0xD7C6 ||
        c >= 0xD7CB && c <= 0xD7FB ||
        c >= 0xF900 && c <= 0xFAFF ||
        c >= 0xFE10 && c <= 0xFE19 ||
        c >= 0xFE30 && c <= 0xFE52 ||
        c >= 0xFE54 && c <= 0xFE66 ||
        c >= 0xFE68 && c <= 0xFE6B ||
        c >= 0xFF01 && c <= 0xFF60 ||
        c >= 0xFFE0 && c <= 0xFFE6;
}
(__webpack_require__(62830)/* .Folding */ .M).call(EditSession.prototype);
(__webpack_require__(30609)/* .BracketMatch */ .k).call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        /**
         * @param {string | boolean | number} value
         * @this {EditSession}
         */
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },
    wrapMethod: {
        /**
         * @param {"code"|"text"|"auto"|boolean} val
         * @this{EditSession}
         */
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: {
        /**
         * @this{EditSession}
         */
        set: function() {
            if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
            }
        },
        initialValue: true
    },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        /**
         * @param {boolean} useWorker
         * @this{EditSession}
         */
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        /**
         * @param tabSize
         * @this{EditSession}
         */
        set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
                this.$modified = true;
                this.$rowLengthCache = [];
                this.$tabSize = tabSize;
                this._signal("changeTabSize");
            }
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: {initialValue: false},
    foldStyle: {
        set: function(val) {this.setFoldStyle(val);},
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val);},
        get: function() {return this.doc.getNewLineMode();},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val); },
        get: function() { return this.$modeId; },
        handlesSet: true
    }
});

exports.f = EditSession;



/***/ }),

/***/ 30609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../edit_session").Point} Point
 */
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

function BracketMatch() {

    /**
     * 
     * @param {Point} position
     * @param {string} [chr]
     * @this {EditSession}
     */
    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };

    /**
     * @param {Point} pos
     * @return {null|Range}
     * @this {EditSession}
     */
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    /**
     * Returns:
     * * null if there is no any bracket at `pos`;
     * * two Ranges if there is opening and closing brackets;
     * * one Range if there is only one bracket
     *
     * @param {Point} pos
     * @param {boolean} [isBackwards]
     * @returns {null|Range[]}
     * @this {EditSession}
     */
    this.getMatchingBracketRanges = function(pos, isBackwards) {
        var line = this.getLine(pos.row);
        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
        var chr = !isBackwards && line.charAt(pos.column - 1);
        var match = chr && chr.match(bracketsRegExp);
        if (!match) {
            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
            pos = {
                row: pos.row,
                column: pos.column + 1
            };
            match = chr && chr.match(bracketsRegExp);
        }

        if (!match)
            return null;

        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
            : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
            return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);

        return [startRange, endRange];
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
    };

    /**
     * 
     * @param {string} bracket
     * @param {Point} position
     * @param {RegExp} [typeRe]
     * @return {Point|null}
     * @this {EditSession}
     */
    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                    .replace(/-close\b/, "-(close|open)")
                + ")+"
            );
        }
        
        // Start searching in token, just before the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }

            // Scan backward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    /**
     *
     * @param {string} bracket
     * @param {Point} position
     * @param {RegExp} [typeRe]
     * @return {Point|null}
     * @this {EditSession}
     */
    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                    .replace(/-open\b/, "-(close|open)")
                + ")+"
            );
        }

        // Start searching in token, after the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }

            // Scan forward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };

    /**
     * Returns [[Range]]'s for matching tags and tag names, if there are any
     * @param {Point} pos
     * @returns {{closeTag: Range, closeTagName: Range, openTag: Range, openTagName: Range} | undefined}
     * @this {EditSession}
     */
    this.getMatchingTags = function (pos) {
        var iterator = new TokenIterator(this, pos.row, pos.column);
        var token = this.$findTagName(iterator);
        if (!token) return;

        var prevToken = iterator.stepBackward();

        if (prevToken.value === '<') {
            return this.$findClosingTag(iterator, token);
        }
        else {
            return this.$findOpeningTag(iterator, token);
        }
    };

    this.$findTagName = function (iterator) {
        var token = iterator.getCurrentToken();
        var found = false;
        var backward = false;
        if (token && token.type.indexOf('tag-name') === -1) {
            do {
                if (backward) token = iterator.stepBackward(); else token = iterator.stepForward();
                if (token) {
                    if (token.value === "/>") {
                        //changing iterator direction for self-closing tags, when cursor is in between tag
                        //name and tag closing
                        backward = true;
                    }
                    else if (token.type.indexOf('tag-name') !== -1) {
                        found = true;
                    }
                }
            } while (token && !found);
        }
        return token;
    };

    this.$findClosingTag = function (iterator, token) {
        var prevToken;
        var currentTag = token.value;
        var tag = token.value;
        var depth = 0;

        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
        );
        token = iterator.stepForward();
        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length
        );
        var foundOpenTagEnd = false;
        do {
            prevToken = token;
            if (prevToken.type.indexOf('tag-close') !== -1 && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                    iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
                ); //Range for `>`
                foundOpenTagEnd = true;
            }
            token = iterator.stepForward();
            if (token) {
                if (token.value === '>' && !foundOpenTagEnd) {
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                        iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
                    ); //Range for `>`
                    foundOpenTagEnd = true;
                }
                if (token.type.indexOf('tag-name') !== -1) {
                    currentTag = token.value;
                    if (tag === currentTag) {
                        if (prevToken.value === '<') {
                            depth++;
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                            if (depth < 0) {//found closing tag
                                iterator.stepBackward();
                                var closeTagStart = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 2
                                ); //Range for </
                                token = iterator.stepForward();
                                var closeTagName = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + token.value.length
                                );
                                if (token.type.indexOf('tag-close') === -1) {
                                    token = iterator.stepForward();
                                }
                                if (token && token.value === '>') {
                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn() + 1
                                    ); //Range for >
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                }
                else if (tag === currentTag && token.value === '/>') { // self-closing tag
                    depth--;
                    if (depth < 0) {//found self-closing tag end
                        //Example: <tagName attr/>
                        //`<tagName ` - opening part of tag consist of `openTagStart`, `openTagName` and `openTagEnd`
                        //`/>` - closing part of tag consist of `closeTagStart`, `closeTagName` and `closeTagEnd`
                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2
                        );
                        var closeTagName = closeTagStart;
                        var closeTagEnd = closeTagName;

                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row,
                            openTagName.end.column + 1
                        );

                    }
                }
            }
        } while (token && depth >= 0);

        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row,
                    openTagEnd.end.column
                ),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row,
                    closeTagEnd.end.column
                ),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };

    this.$findOpeningTag = function (iterator, token) {
        var prevToken = iterator.getCurrentToken();
        var tag = token.value;
        var depth = 0;

        var startRow = iterator.getCurrentTokenRow();
        var startColumn = iterator.getCurrentTokenColumn();
        var endColumn = startColumn + 2;

        //closing tag
        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
        iterator.stepForward();
        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length
        );

        if (token.type.indexOf('tag-close') === -1) {
            token = iterator.stepForward();
        }
        if (!token || token.value !== ">") return;
        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
        ); //Range for >

        iterator.stepBackward();
        iterator.stepBackward();
        do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;

            prevToken = iterator.stepBackward();

            if (token) {
                if (token.type.indexOf('tag-name') !== -1) {
                    if (tag === token.value) {
                        if (prevToken.value === '<') {
                            depth++;
                            if (depth > 0) {//found opening tag
                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                var openTagStart = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 1
                                ); //Range for <
                                do {
                                    token = iterator.stepForward();
                                } while (token && token.value !== '>');
                                var openTagEnd = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 1
                                ); //Range for >
                            }
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                }
                else if (token.value === '/>') { // self-closing tag
                    var stepCount = 0;
                    var tmpToken = prevToken;
                    while (tmpToken) {
                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {
                            depth--;
                            break;
                        }
                        else if (tmpToken.value === '<') {
                            break;
                        }
                        tmpToken = iterator.stepBackward();
                        stepCount++;
                    }
                    for (var i = 0; i < stepCount; i++) {
                        iterator.stepForward();
                    }
                }
            }
        } while (prevToken && depth <= 0);

        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row,
                    openTagEnd.end.column
                ),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row,
                    closeTagEnd.end.column
                ),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
}
exports.k = BracketMatch;


/***/ }),

/***/ 45816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./fold_line").FoldLine} FoldLine
 * @typedef {import("../range").Range} Range
 * @typedef {import("../../ace-internal").Ace.Point} Point
 * @typedef {import("../../ace-internal").Ace.IRange} IRange
 */
var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);

/*
 * Simple fold-data struct.
 **/
class Fold extends RangeList {

    /**
     * @param {Range} range
     * @param {any} placeholder
     */
    constructor(range, placeholder) {
        super();
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;

        this.sameRow = range.start.row == range.end.row;
        /**@type {Fold[]}*/
        this.subFolds = this.ranges = [];
    }
    
    toString() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    }

    /**
     * @param {FoldLine} foldLine
     */
    setFoldLine(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    }

    clone() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    }

    /**
     * @param {Fold} fold
     */
    addSubFold(fold) {
        if (this.range.isEqual(fold))
            return;

        // transform fold to local coordinates
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;

        if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
            else
                firstConsumed = 1;
        }

        // cmp == -1
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        if (cmp == 0)  j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k = firstConsumed; k < last; k++) {
            fold.addSubFold(consumedFolds[k]);
        }
        fold.setFoldLine(this.foldLine);

        return fold;
    }

    /**
     * @param {IRange} range
     */
    restoreRange(range) {
        return restoreRange(range, this.start);
    }

}

/**
 * @param {Point} point
 * @param {Point} anchor
 */
function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
/**
 * @param {IRange} range
 * @param {Point} anchor
 */
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
/**
 * @param {Point} point
 * @param {Point} anchor
 */
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
/**
 * @param {IRange} range
 * @param {Point} anchor
 */
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

exports.a = Fold;


/***/ }),

/***/ 70649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./fold").Fold} Fold
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);

class FoldLine {
    /**
     * If an array is passed in, the folds are expected to be sorted already.
     * @param {FoldLine[]} foldData
     * @param {Fold[]|Fold} folds
     */
    constructor(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
            /**@type {Fold[]} */
            this.folds = folds;
        } else {
            folds = this.folds = [ folds ];
        }

        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column,
            last.end.row, last.end.column);
        this.start = this.range.start;
        this.end   = this.range.end;

        this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
        }, this);
    }
    
    /**
     * Note: This doesn't update wrapData!
     * @param {number} shift
     */
    shiftRow(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    }

    /**
     * @param {Fold} fold
     */
    addFold(fold) {
        if (fold.sameRow) {
            // @ts-expect-error TODO: startRow, endRow are missing in Fold and FoldLine
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    }

    /**
     * @param {number} row
     */
    containsRow(row) {
        return row >= this.start.row && row <= this.end.row;
    }

    /**
     * @param {Function} callback
     * @param {number} endRow
     * @param {number} endColumn
     */
    walk(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            // This fold is after the endRow/Column.
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);

            // If the user requested to stop the walk or endRow/endColumn is
            // inside of this fold (cmp == 0), then end here.
            if (stop || cmp === 0) {
                return;
            }

            // Note the new lastEnd might not be on the same line. However,
            // it's the callback's job to recognize this.
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {{ fold: Fold, kind: string } | null}
     */
    getNextFoldTo(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    }

    /**
     * @param {number} row
     * @param {number} column
     * @param {number} len
     */
    addRemoveChars(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                //throwing here breaks whole editor
                //TODO: properly handle this
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {FoldLine | null}
     */
    split(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;

        // Remove the folds after row/column and create a new FoldLine
        // containing these removed folds.
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    }

    /**
     * @param {FoldLine} foldLineNext
     */
    merge(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        // Remove the foldLineNext - no longer needed, as
        // it's merged now with foldLineNext.
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    }

    toString() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    }

    /**
     * @param {number} idx
     * @return {import("../../ace-internal").Ace.Point}
     */
    idxToPosition(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    }
}

exports.M = FoldLine;


/***/ }),

/***/ 62830:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// @ts-nocheck


var Range = (__webpack_require__(91902)/* .Range */ .Q);
var FoldLine = (__webpack_require__(70649)/* .FoldLine */ .M);
var Fold = (__webpack_require__(45816)/* .Fold */ .a);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);

/**
 * @typedef {import("../edit_session").EditSession & import("../../ace-internal").Ace.Folding} IFolding
 * @typedef {import("../../ace-internal").Ace.Delta } Delta
 */

/**
 * @this {IFolding}
 * @type {IFolding}
 */
function Folding() {
    /**
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     * @param {number} row
     * @param {number} column
     * @param {number} [side]
     * @return {Fold}
     **/
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                    continue;
                } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                    continue;
                }
                return folds[i];
            }
        }
    };

    /**
     * Returns all folds in the given range. Note, that this will return folds
     * @param {Range| Delta} range
     * @returns {Fold[]}
     **/
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                // Range is before foldLine. No intersection. This means,
                // there might be other foldLines that intersect.
                continue;
            }
            else if (cmp == -2) {
                // Range is after foldLine. There can't be any other foldLines then,
                // so let's give up.
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                // WTF-state: Can happen due to -1/+1 to start/end column.
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    /**
     * 
     * @param {Range[]|Range}ranges
     * @returns {Fold[]}
     */
    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            /**@type {Fold[]} */
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    
    /**
     * Returns all folds in the document
     * @returns {Fold[]}
     */
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };

    /**
     * Returns the string between folds at the given position.
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -> "bar"
     *  foo<fold>bar<fold>wol|rd -> "world"
     *  foo<fold>bar<fo|ld>wolrd -> <null>
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the "side" passed with the trim value:
     *
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
     *  @param {number} row
     *  @param {number} column
     *  @param {number} [trim]
     *  @param {FoldLine} [foldLine]
     *  @returns {string | null}
     */
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        // TODO: Refactor to use getNextFoldTo function.
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldLine]
     * @returns {null|FoldLine}
     */
    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };

    /**
     * Returns the fold which starts after or contains docRow
     * @param {number} docRow
     * @param {FoldLine} [startFoldLine]
     * @returns {null|FoldLine}
     */
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    /**
     * 
     * @param {number} first
     * @param {number} last
     * @return {number}
     */
    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            } else if (end >= first){
                if (start >= first) // fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    /**
     * 
     * @param {FoldLine}foldLine
     * @return {FoldLine}
     */
    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };

    /**
     * Adds a new fold.
     *
     * @param {Fold|string} placeholder
     * @param {Range} [range]
     * @returns {Fold}
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     * @this {IFolding}
     */
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        /**@type {Fold}*/
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            // @ts-ignore
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        
        // Check if there are folds in the range we create the new fold for.
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            // Remove the folds from fold data.
            this.removeFolds(folds);
            // Add the removed folds as subfolds on the new fold.
            if (!fold.collapseChildren) {
                folds.forEach(function(subFold) {
                    fold.addSubFold(subFold);
                });
            }
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    // Check if we might have to merge two FoldLines.
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        // We need to merge!
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);

        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });

        return fold;
    };

    /**
     * @param {Fold[]} folds
     */
    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    /**
     * 
     * @param {Fold} fold
     */
    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        // Simple case where there is only one fold in the FoldLine such that
        // the entire fold line can get removed directly.
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        // If the fold is the last fold of the foldLine, just remove it.
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        // If the fold is the first fold of the foldLine, just remove it.
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        // We know there are more then 2 folds and the fold is not at the edge.
        // This means, the fold is somewhere in between.
        //
        // If the fold is in one row, we just can remove it.
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        // The fold goes over more then one row. This means remvoing this fold
        // will cause the fold line to get splitted up. newFoldLine is the second part
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        
        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };

    /**
     * 
     * @param {Fold[]} folds
     */
    this.removeFolds = function(folds) {
        // We need to clone the folds array passed in as it might be the folds
        // array of a fold line and as we call this.removeFold(fold), folds
        // are removed from folds and changes the current index.
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    /**
     * @param {Fold} fold
     */
    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    /**
     * @param {Fold[]}folds
     */
    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    /**
     * 
     * @param {number|null|import("../../ace-internal").Ace.Point|Range|Range[]} [location]
     * @param {boolean} [expandInner]
     * @return {Fold[]| undefined}
     */
    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null) expandInner = true;
        } else if (typeof location == "number") {
            range = new Range(location, 0, location, this.getLine(location).length);
        } else if ("row" in location) {
            range = Range.fromPoints(location, location);
        } else if (Array.isArray(location)) {
            folds = [];
            location.forEach(function(range) {
                folds = folds.concat(this.unfold(range));
            }, this);
            return folds;
        } else {
            range = location;
        }
        
        folds = this.getFoldsInRangeList(range);
        var outermostFolds = folds;
        // if range itself is in a fold, expand that fold instead of removing, 
        // to not accidentally remove sibling folds
        while (
            folds.length == 1
            && Range.comparePoints(folds[0].start, range.start) < 0 
            && Range.comparePoints(folds[0].end, range.end) > 0
        ) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
        }
        
        if (expandInner != false) {
            this.removeFolds(folds);
        } else {
            this.expandFolds(folds);
        }
        if (outermostFolds.length)
            return outermostFolds;
    };

    /**
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @returns {boolean}
     **/
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @return {number}
     */
    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @returns {number}
     */
    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    /**
     * 
     * @param {FoldLine} foldLine
     * @param {number | null} [endRow]
     * @param {number | null} [endColumn]
     * @param {number | null} [startRow]
     * @param {number | null} [startColumn]
     * @return {string}
     */
    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        

        // Build the textline using the FoldLine walker.
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    /**
     * 
     * @param {number} row
     * @param {number | null} endColumn
     * @param {number | null} startRow
     * @param {number | null} startColumn
     * @return {string}
     */
    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    /**
     * @return {FoldLine[]}
     */
    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    /**
     * @param {boolean} [tryToUnfold]
     */
    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    /**
     * 
     * @param {number} row
     * @param {number} column
     * @param {number} [dir]
     * @return {Range | undefined}
     */
    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token && token.type;
        if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
                type += "|doc-start|\\.doc";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type));
                token = iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;

            iterator = new TokenIterator(this, row, column);
            var initState = this.getState(iterator.$row);
            
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (initState.toString() !== state.toString())
                            lastRow = iterator.$row;
                    } else if (iterator.$row > lastRow) {
                        break;
                    }
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            return range;
        }
    };

    /**
     * 
     * @param {number | null} [startRow]
     * @param {number | null} [endRow]
     * @param {number | null} [depth]
     * @param {Function} [test]
     */
    this.foldAll = function(startRow, endRow, depth, test) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;
            
            if (test && !test(row)) continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                range.collapseChildren = depth;
                // addFold can change the range
                this.addFold("...", range);
            }
        }
    };

    /**
     * 
     * @param {number} level
     */
    this.foldToLevel = function(level) {
        this.foldAll();
        while (level-- > 0)
            this.unfold(null, false);
    };

    /**
     *
     */
    this.foldAllComments = function() {
        var session = this;
        this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token.type == "text" && /^\s+$/.test(token.value))
                    continue;
                if (/comment/.test(token.type))
                    return true;
                return false;
            }
        });
    };
    
    // structured folding
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    
    /**
     * @param {string} style
     */
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        
        // reset folding
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    /**
     * @param {import("../../ace-internal").Ace.FoldMode} foldMode
     */
    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;


        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };
    /**
     * @param {number} row
     * @param {boolean} [ignoreCurrent]
     * @return {{range?: Range, firstRange?: Range}}
     */
    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };

    /**
     * 
     * @param {number} row
     * @param {any} e
     */
    this.onFoldWidgetClick = function(row, e) {
        if (e instanceof MouseEvent)
            e = e.domEvent;

        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };

    /**
     * 
     * @param {number} row
     * @param options
     * @return {Fold|*}
     */
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }

        var range = this.getFoldWidgetRange(row, true);
        // sometimes singleline folds can be missed by the code above
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    /**
     * 
     * @param {boolean} [toggleParent]
     */
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        // handle toggleParent
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    /**
     * @param {Delta} delta
     */
    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    /**
     * @param e
     */
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}

exports.M = Folding;


/***/ }),

/***/ 27258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("./virtual_renderer").VirtualRenderer} VirtualRenderer
 * @typedef {import("./selection").Selection} Selection
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.SearchOptions} SearchOptions
 */

var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var useragent = __webpack_require__(74943);
var TextInput = (__webpack_require__(82984)/* .TextInput */ .k);
var MouseHandler = (__webpack_require__(32291)/* .MouseHandler */ .e);
var FoldHandler = (__webpack_require__(99847)/* .FoldHandler */ .e);
var KeyBinding = (__webpack_require__(69957)/* .KeyBinding */ .$);
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
var Search = (__webpack_require__(99427)/* .Search */ .v);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var CommandManager = (__webpack_require__(63379).CommandManager);
var defaultCommands = (__webpack_require__(21604)/* .commands */ .P);
var config = __webpack_require__(76321);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var GutterKeyboardHandler = (__webpack_require__(45545)/* .GutterKeyboardHandler */ .S);
var nls = (__webpack_require__(76321).nls);

var clipboard = __webpack_require__(65217);
var keys = __webpack_require__(29451);


/**
 * The main entry point into the Ace functionality.
 *
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
 *
 * Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
 **/
class Editor {
    /**
     * Creates a new `Editor` object.
     *
     * @param {VirtualRenderer} renderer Associated `VirtualRenderer` that draws everything
     * @param {EditSession} [session] The `EditSession` to refer to
     * @param {Partial<import("../ace-internal").Ace.EditorOptions>} [options] The default options
     **/
    constructor(renderer, session, options) {
        /**@type{EditSession}*/this.session;
        this.$toDestroy = [];

        var container = renderer.getContainerElement();
        /**@type {HTMLElement & {env?:any, value?:any}}*/
        this.container = container;
        /**@type {VirtualRenderer}*/
        this.renderer = renderer;
        /**@type {string}*/
        this.id = "editor" + (++Editor.$uid);
        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            // TODO detect touch event support
            /**@type {MouseHandler}*/
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
        }
        /**@type {KeyBinding}*/
        this.keyBinding = new KeyBinding(this);
        /**@type {Search}*/
        this.$search = new Search().set({
            wrap: true
        });

        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);

        this.$initOperationListeners();

        this._$emitInputEvent = lang.delayedCall(function() {
            this._signal("input", {});
            if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
        }.bind(this));

        this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
        });

        this.setSession(session || options && options.session || new EditSession(""));
        config.resetOptions(this);
        if (options)
            this.setOptions(options);
        config._signal("editor", this);
    }

    $initOperationListeners() {
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);
    }

    startOperation(commandEvent) {
        this.session.startOperation(commandEvent);
    }

    /**
     * @arg e
     */
    endOperation(e) {
        this.session.endOperation(e);
    }

    onStartOperation(commandEvent) {
        this.curOp = this.session.curOp;
        this.curOp.scrollTop = this.renderer.scrollTop;
        this.prevOp = this.session.prevOp;

        if (!commandEvent) {
            this.previousCommand = null;
        }
    }

    /**
     * @arg e
     */
    onEndOperation(e) {
        if (this.curOp && this.session) {
            if (e && e.returnValue === false) {
                this.curOp = null;
                return;
            }

            this._signal("beforeEndOperation");
            if (!this.curOp) return;

            var command = this.curOp.command;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                        /* fall through */
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }

            this.$lastSel = this.session.selection.toJSON();
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    }

    /**
     * @param e
     */
    $historyTracker(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        // previous command was the same
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    }

    /**
     * Sets a new key handler, such as "vim" or "windows".
     * @param {String | import("../ace-internal").Ace.KeyboardHandler | null} keyboardHandler The new key handler
     * @param {() => void} [cb]
     **/
    setKeyboardHandler(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            // @ts-ignore
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    }

    /**
     * Returns the keyboard handler, such as "vim" or "windows".
     * @returns {Object}
     **/
    getKeyboardHandler() {
        return this.keyBinding.getKeyboardHandler();
    }



    /**
     * Sets a new editsession to use. This method also emits the `'changeSession'` event.
     * @param {EditSession} [session] The new session to use
     **/
    setSession(session) {
        if (this.session == session)
            return;

        // make sure operationEnd events are not emitted to wrong session
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            this.session.off("startOperation", this.$onStartOperation);
            this.session.off("endOperation", this.$onEndOperation);

            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);

            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);

            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);

            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);

            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);

            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);

            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);

            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);

            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);

            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);

            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);

            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);

            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);

            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);

            this.$onStartOperation = this.onStartOperation.bind(this);
            this.session.on("startOperation", this.$onStartOperation);
            this.$onEndOperation = this.onEndOperation.bind(this);
            this.session.on("endOperation", this.$onEndOperation);

            this.onChangeMode();

            this.onCursorChange();

            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });

        this.curOp = null;

        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        if (oldSession) oldSession.$editor = null;
        session && session._signal("changeEditor", {editor: this});
        if (session) session.$editor = this;

        if (session && !session.destroyed)
            session.bgTokenizer.scheduleStart();
    }

    /**
     * Returns the current session being used.
     * @returns {EditSession}
     **/
    getSession() {
        return this.session;
    }

    /**
     * Sets the current document to `val`.
     * @param {String} val The new value to set for the document
     * @param {Number} [cursorPos] Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
     *
     * @returns {String} The current document value
     * @related Document.setValue
     **/
    setValue(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    }

    /**
     * Returns the current session's content.
     *
     * @returns {String}
     * @related EditSession.getValue
     **/
    getValue() {
        return this.session.getValue();
    }

    /**
     *
     * Returns the currently highlighted selection.
     * @returns {Selection} The selection object
     **/
    getSelection() {
        return this.selection;
    }

    /**
     * {:VirtualRenderer.onResize}
     * @param {Boolean} [force] If `true`, recomputes the size, even if the height and width haven't changed
     * @related VirtualRenderer.onResize
     **/
    resize(force) {
        this.renderer.onResize(force);
    }

    /**
     * {:VirtualRenderer.setTheme}
     * @param {string | import("../ace-internal").Ace.Theme} theme The path to a theme
     * @param {() => void} [cb] optional callback called when theme is loaded
     **/
    setTheme(theme, cb) {
        this.renderer.setTheme(theme, cb);
    }

    /**
     * {:VirtualRenderer.getTheme}
     *
     * @returns {String} The set theme
     * @related VirtualRenderer.getTheme
     **/
    getTheme() {
        return this.renderer.getTheme();
    }

    /**
     * {:VirtualRenderer.setStyle}
     * @param {String} style A class name
     * @related VirtualRenderer.setStyle
     **/
    setStyle(style) {
        this.renderer.setStyle(style);
    }

    /**
     * {:VirtualRenderer.unsetStyle}
     * @related VirtualRenderer.unsetStyle
     * @param {string} style
     */
    unsetStyle(style) {
        this.renderer.unsetStyle(style);
    }

    /**
     * Gets the current font size of the editor text.
     * @return {string | number}
     */
    getFontSize() {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container).fontSize;
    }

    /**
     * Set a new font size (in pixels) for the editor text.
     * @param {String | number} size A font size ( _e.g._ "12px")
     **/
    setFontSize(size) {
        this.setOption("fontSize", size);
    }

    $highlightBrackets() {
        if (this.$highlightPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightPending = true;
        setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || session.destroyed) return;
            if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                    session.removeMarker(id);
                });
                session.$bracketHighlight = null;
            }
            var pos = self.getCursorPosition();
            var handler = self.getKeyboardHandler();
            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);
            var ranges = session.getMatchingBracketRanges(pos, isBackwards);

            if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();

                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                    var tagNamesRanges = session.getMatchingTags(pos);
                    if (tagNamesRanges) {
                        ranges = [
                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                        ];
                    }
                }
            }
            if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self.session);
            if (!ranges) {
                if (self.getHighlightIndentGuides()) self.renderer.$textLayer.$highlightIndentGuide();
                return;
            }

            var markerType = "ace_bracket";
            if (!Array.isArray(ranges)) {
                ranges = [ranges];
            } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
            }

            // show adjacent ranges as one
            if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }

            session.$bracketHighlight = {
                ranges: ranges,
                markerIds: ranges.map(function(range) {
                    return session.addMarker(range, markerType, "text");
                })
            };
            if (self.getHighlightIndentGuides()) self.renderer.$textLayer.$highlightIndentGuide();
        }, 50);
    }

    /**
     *
     * Brings the current `textInput` into focus.
     **/
    focus() {
        this.textInput.focus();
    }

    /**
     * Returns `true` if the current `textInput` is in focus.
     * @return {Boolean}
     **/
    isFocused() {
        return this.textInput.isFocused();
    }

    /**
     *
     * Blurs the current `textInput`.
     **/
    blur() {
        this.textInput.blur();
    }

    /**
     * Emitted once the editor comes into focus.
     * @internal
     **/
    onFocus(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    }

    /**
     * Emitted once the editor has been blurred.
     * @internal
     **/
    onBlur(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    }

    /**
     */
    $cursorChange() {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
    }

    /**
     * Emitted whenever the document is changed.
     * @param {import("../ace-internal").Ace.Delta} delta Contains a single property, `data`, which has the delta of changes
     * @internal
     **/
    onDocumentChange(delta) {
        // Rerender and emit "change" event.
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);

        // Update cursor because tab characters can influence the cursor position.
        this.$cursorChange();
    }

    /**
     * @internal
     */
    onTokenizerUpdate(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    }

    /**
     * @internal
     */
    onScrollTopChange() {
        this.renderer.scrollToY(this.session.getScrollTop());
    }

    /**
     * @internal
     */
    onScrollLeftChange() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    }

    /**
     * Emitted when the selection changes.
     * @internal
     **/
    onCursorChange() {
        this.$cursorChange();
        this._signal("changeSelection");
    }

    /**
     */
    $updateHighlightActiveLine() {
        var session = this.getSession();
        /**@type {Point|false}*/
        var highlight;
        if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    }

    /**
     * @param e
     * @internal
     */
    onSelectionChange(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    }

    $getSelectionHighLightRegexp() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);

        var needle = line.substring(startColumn, endColumn);
        // maximum allowed size for regular expressions in 32000,
        // but getting close to it has significant impact on the performance
        if (needle.length > 5000 || !/[\w\d]/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re.test(wordWithBoundary))
            return;

        return re;
    }

    /**
     * @internal
     */
    onChangeFrontMarker() {
        this.renderer.updateFrontMarkers();
    }

    /**
     * @internal
     */
    onChangeBackMarker() {
        this.renderer.updateBackMarkers();
    }

    /**
     * @internal
     */
    onChangeBreakpoint() {
        this.renderer.updateBreakpoints();
    }

    /**
     * @internal
     */
    onChangeAnnotation() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    }

    /**
     * @param e
     * @internal
     */
    onChangeMode (e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    }

    /**
     * @internal
     */
    onChangeWrapLimit() {
        this.renderer.updateFull();
    }

    /**
     * @internal
     */
    onChangeWrapMode() {
        this.renderer.onResize(true);
    }


    /**
     * @internal
     */
    onChangeFold() {
        // Update the active line marker as due to folding changes the current
        // line range on the screen might have changed.
        this.$updateHighlightActiveLine();
        // TODO: This might be too much updating. Okay for now.
        this.renderer.updateFull();
    }


    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/
    getSelectedText() {
        return this.session.getTextRange(this.getSelectionRange());
    }


    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/
    getCopyText () {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine= false;
        if (!text && this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                    continue;
                text += this.session.getLine(range.start.row) + nl;
            }
        }
        var e = {text: text};
        this._signal("copy", e);
        clipboard.lineMode = copyLine ? e.text : false;
        return e.text;
    }

    /**
     * Called whenever a text "copy" happens.
     * @internal
     **/
    onCopy() {
        this.commands.exec("copy", this);
    }

    /**
     * Called whenever a text "cut" happens.
     * @internal
     **/
    onCut() {
        this.commands.exec("cut", this);
    }


    /**
     * Called whenever a text "paste" happens.
     * @param {String} text The pasted text
     * @param {any} event
     * @internal
     **/
    onPaste(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    }

    /**
     *
     * @param e
     * @returns {boolean}
     */
    $handlePaste(e) {
        if (typeof e == "string")
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;

        var lineMode = text === clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
                this.insert(text);
        } else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function(range) {
                session.insert({ row: range.start.row, column: 0 }, text);
            });
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;

            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);

            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    session.remove(range);

                session.insert(range.start, lines[i]);
            }
        }
    }

    /**
     *
     * @param {string | string[]} command
     * @param [args]
     * @return {boolean}
     */
    execCommand(command, args) {
        return this.commands.exec(command, this, args);
    }

    /**
     * Inserts `text` into wherever the cursor is pointing.
     * @param {String} text The new text to add
     * @param {boolean} [pasted]
     **/
    insert(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            // Get a transform if the current mode wants one.
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    // keep automatic insertion in a separate delta, unless it is in multiselect mode
                    if (!this.inVirtualSelectionMode) {
                        this.session.mergeUndoDeltas = false;
                        this.mergeNextCommand = false;
                    }
                }
                text = transform.text;

            }
        }

        if (text == "\t")
            text = this.session.getTabString();

        // remove selected text
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }
        if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                session.insert({row: cursor.row+1, column: 0}, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        }
    }

    autoIndent() {
        var session = this.session;
        var mode = session.getMode();

        var ranges = this.selection.isEmpty()
            ? [new Range(0, 0, session.doc.getLength() - 1, 0)]
            : this.selection.getAllRanges();

        /**@type{string|string[]}*/
        var prevLineState = "";
        var prevLine = "";
        var lineIndent = "";
        var tab = session.getTabString();
        for (var i = 0; i < ranges.length; i++) {
            var startRow = ranges[i].start.row;
            var endRow = ranges[i].end.row;

            for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                    prevLineState = session.getState(row - 1);
                    prevLine = session.getLine(row - 1);
                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }

                var line = session.getLine(row);
                var currIndent = mode.$getIndent(line);
                if (lineIndent !== currIndent) {
                    if (currIndent.length > 0) {
                        var range = new Range(row, 0, row, currIndent.length);
                        session.remove(range);
                    }
                    if (lineIndent.length > 0) {
                        session.insert({row: row, column: 0}, lineIndent);
                    }
                }

                mode.autoOutdent(prevLineState, session, row);
            }
        }
    }

    /**
     *
     * @param text
     * @param composition
     * @returns {*}
     * @internal
     */
    onTextInput(text, composition) {
        if (!composition)
            return this.keyBinding.onTextInput(text);

        this.startOperation({command: { name: "insertstring" }});
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
        else
            applyComposition();
        this.endOperation();
    }

    /**
     * @param {string} [text]
     * @param {any} [composition]
     */
    applyComposition(text, composition) {
        if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text && !r.isEmpty())
                this.remove();
        }
        if (text || !this.selection.isEmpty())
            this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
        }
    }

    /**
     * @internal
     */
    onCommandKey(e, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e, hashId, keyCode);
    }

    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     * @related EditSession.setOverwrite
     **/
    setOverwrite(overwrite) {
        this.session.setOverwrite(overwrite);
    }

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     * @returns {Boolean}
     * @related EditSession.getOverwrite
     **/
    getOverwrite() {
        return this.session.getOverwrite();
    }

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     * @related EditSession.toggleOverwrite
     **/
    toggleOverwrite() {
        this.session.toggleOverwrite();
    }

    /**
     * Sets how fast the mouse scrolling should do.
     * @param {Number} speed A value indicating the new speed (in milliseconds)
     **/
    setScrollSpeed(speed) {
        this.setOption("scrollSpeed", speed);
    }

    /**
     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
     * @returns {Number}
     **/
    getScrollSpeed() {
        return this.getOption("scrollSpeed");
    }

    /**
     * Sets the delay (in milliseconds) of the mouse drag.
     * @param {Number} dragDelay A value indicating the new delay
     **/
    setDragDelay(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    }

    /**
     * Returns the current mouse drag delay.
     * @returns {Number}
     **/
    getDragDelay() {
        return this.getOption("dragDelay");
    }


    /**
     * Draw selection markers spanning whole line, or only over selected text. Default value is "line"
     * @param {"fullLine" | "screenLine" | "text" | "line"} val The new selection style "line"|"text"
     **/
    setSelectionStyle(val) {
        this.setOption("selectionStyle", val);
    }

    /**
     * Returns the current selection style.
     * @returns {import("../ace-internal").Ace.EditorOptions["selectionStyle"]}
     **/
    getSelectionStyle() {
        return this.getOption("selectionStyle");
    }

    /**
     * Determines whether or not the current line should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the current line
     **/
    setHighlightActiveLine(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    }
    /**
     * Returns `true` if current lines are always highlighted.
     * @return {Boolean}
     **/
    getHighlightActiveLine() {
        return this.getOption("highlightActiveLine");
    }

    /**
     * @param {boolean} shouldHighlight
     */
    setHighlightGutterLine(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    }

    /**
     * @returns {Boolean}
     */
    getHighlightGutterLine() {
        return this.getOption("highlightGutterLine");
    }

    /**
     * Determines if the currently selected word should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the currently selected word
     **/
    setHighlightSelectedWord(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    }

    /**
     * Returns `true` if currently highlighted words are to be highlighted.
     * @returns {Boolean}
     **/
    getHighlightSelectedWord() {
        return this.$highlightSelectedWord;
    }

    /**
     * @param {boolean} shouldAnimate
     */
    setAnimatedScroll(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    }

    /**
     * @return {boolean}
     */
    getAnimatedScroll(){
        return this.renderer.getAnimatedScroll();
    }

    /**
     * If `showInvisibles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
     **/
    setShowInvisibles(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    }

    /**
     * Returns `true` if invisible characters are being shown.
     * @returns {Boolean}
     **/
    getShowInvisibles() {
        return this.renderer.getShowInvisibles();
    }

    /**
     * @param {boolean} display
     */
    setDisplayIndentGuides(display) {
        this.renderer.setDisplayIndentGuides(display);
    }

    /**
     * @return {boolean}
     */
    getDisplayIndentGuides() {
        return this.renderer.getDisplayIndentGuides();
    }

    /**
     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        this.renderer.setHighlightIndentGuides(highlight);
    }

    /**
     * @return {boolean}
     */
    getHighlightIndentGuides() {
        return this.renderer.getHighlightIndentGuides();
    }

    /**
     * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
     *
     **/
    setShowPrintMargin(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    }

    /**
     * Returns `true` if the print margin is being shown.
     * @returns {Boolean}
     **/
    getShowPrintMargin() {
        return this.renderer.getShowPrintMargin();
    }

    /**
     * Sets the column defining where the print margin should be.
     * @param {Number} showPrintMargin Specifies the new print margin
     *
     **/
    setPrintMarginColumn(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    }

    /**
     * Returns the column number of where the print margin is.
     * @returns {Number}
     **/
    getPrintMarginColumn() {
        return this.renderer.getPrintMarginColumn();
    }

    /**
     * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
     **/
    setReadOnly(readOnly) {
        this.setOption("readOnly", readOnly);
    }

    /**
     * Returns `true` if the editor is set to read-only mode.
     * @returns {Boolean}
     **/
    getReadOnly() {
        return this.getOption("readOnly");
    }

    /**
     * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
     * @param {Boolean} enabled Enables or disables behaviors
     **/
    setBehavioursEnabled(enabled) {
        this.setOption("behavioursEnabled", enabled);
    }

    /**
     * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
     * @returns {Boolean}
     **/
    getBehavioursEnabled() {
        return this.getOption("behavioursEnabled");
    }

    /**
     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
     * when such a character is typed in.
     * @param {Boolean} enabled Enables or disables wrapping behaviors
     **/
    setWrapBehavioursEnabled(enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    }

    /**
     * Returns `true` if the wrapping behaviors are currently enabled.
     * @returns {boolean}
     **/
    getWrapBehavioursEnabled() {
        return this.getOption("wrapBehavioursEnabled");
    }

    /**
     * Indicates whether the fold widgets should be shown or not.
     * @param {Boolean} show Specifies whether the fold widgets are shown
     **/
    setShowFoldWidgets(show) {
        this.setOption("showFoldWidgets", show);

    }
    /**
     * Returns `true` if the fold widgets are shown.
     * @return {Boolean}
     **/
    getShowFoldWidgets() {
        return this.getOption("showFoldWidgets");
    }

    /**
     * @param {boolean} fade
     */
    setFadeFoldWidgets(fade) {
        this.setOption("fadeFoldWidgets", fade);
    }

    /**
     * @returns {boolean}
     */
    getFadeFoldWidgets() {
        return this.getOption("fadeFoldWidgets");
    }

    /**
     * Removes the current selection or one character.
     * @param {'left' | 'right'} [dir] The direction of the deletion to occur, either "left" or "right"
     **/
    remove(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                // @ts-expect-error TODO: possible bug, new_range could be not a Range
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Removes the word directly to the right of the current selection.
     **/
    removeWordRight() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes the word directly to the left of the current selection.
     **/
    removeWordLeft() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the left of the current selection, until the start of the line.
     **/
    removeToLineStart() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();
        if (this.selection.isEmpty())
            this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the right of the current selection, until the end of the line.
     **/
    removeToLineEnd() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Splits the line at the current selection (by inserting an `'\n'`).
     **/
    splitLine() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    }

    /**
     * Set the "ghost" text in provided position. "Ghost" text is a kind of
     * preview text inside the editor which can be used to preview some code
     * inline in the editor such as, for example, code completions.
     *
     * @param {String} text Text to be inserted as "ghost" text
     * @param {Point} [position] Position to insert text to
     */
    setGhostText(text, position) {
        this.renderer.setGhostText(text, position);
    }

    /**
     * Removes "ghost" text currently displayed in the editor.
     */
    removeGhostText() {
        this.renderer.removeGhostText();
    }

    /**
     * Transposes current line.
     **/
    transposeLetters() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    }

    /**
     * Converts the current selection entirely into lowercase.
     **/
    toLowerCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Converts the current selection entirely into uppercase.
     **/
    toUpperCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Inserts an indentation into the current cursor position or indents the selected lines.
     *
     * @related EditSession.indentRows
     **/
    indent() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }

        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    }

    /**
     * Indents the current line.
     * @related EditSession.indentRows
     **/
    blockIndent() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    }

    /**
     * Outdents the current line.
     * @related EditSession.outdentRows
     **/
    blockOutdent() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    }

    // TODO: move out of core when we have good mechanism for managing extensions
    sortLines() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    }

    /**
     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
     **/
    toggleCommentLines() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    }

    toggleBlockComment() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    }

    /**
     * Works like [[EditSession.getTokenAt]], except it returns a number.
     * @returns {any}
     **/
    getNumberAt(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    }

    /**
     * If the character before the cursor is a number, this functions changes its value by `amount`.
     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
     **/
    modifyNumber(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;

        // get the char before the cursor
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        // if the char is a digit
        // @ts-ignore
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            // get the whole number the digit is part of
            var nr = this.getNumberAt(row, column);
            // if number found
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);

                //update number
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);

                //reposition the cursor
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        } else {
            this.toggleWord();
        }
    }

    /**
     */
    toggleWord() {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta < 0) delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function (item, i) {
                itLength = curLength + item.length;
                if (delta >= curLength && delta <= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
        }

        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i < wordPairs.length; i++) {
            var item = wordPairs[i];
            for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                if (firstCondition) {
                    var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                    if (secondCondition) {
                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                            var res = item[negate];
                            if (result.toUpperCase() == result) {
                                res = res.toUpperCase();
                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                            }
                            return res;
                        });
                        this.insert(reg);
                        reg = "";
                    }
                }
            }
        }
    }

    /**
     * Finds link at defined {row} and {column}
     * @returns {String}
     **/
    findLinkAt(row, column) {
        var line = this.session.getLine(row);
        var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
        var columnPosition = column;
        if (columnPosition < 0) columnPosition = 0;
        var previousPosition = 0, currentPosition = 0, match;
        for (let item of wordParts) {
            currentPosition = previousPosition + item.length;
            if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match = item.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                }
            }
            previousPosition = currentPosition;
        }
        return match;
    }

    /**
     * Open valid url under cursor in another tab
     * @returns {Boolean}
     **/
    openLink() {
        var cursor =  this.selection.getCursor();
        var url = this.findLinkAt(cursor.row, cursor.column);
        if (url)
            window.open(url, '_blank');
        return url != null;
    }

    /**
     * Removes all the lines in the current selection
     * @related EditSession.remove
     **/
    removeLines() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    }

    duplicateSelection() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range));
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    }

    /**
     * Shifts all the selected lines down one row.
     *
     * @related EditSession.moveLinesUp
     **/
    moveLinesDown() {
        this.$moveLines(1, false);
    }

    /**
     * Shifts all the selected lines up one row.
     * @related EditSession.moveLinesDown
     **/
    moveLinesUp() {
        this.$moveLines(-1, false);
    }

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     * ```json
     *    { row: newRowLocation, column: newColumnLocation }
     * ```
     * @param {Range} range The range of text you want moved within the document
     * @param {Point} toPosition The location (row and column) where you want to move the text to
     * @param {boolean} [copy]
     *
     * @returns {Range} The new range where the text was moved to.
     * @related EditSession.moveText
     **/
    moveText(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    }

    /**
     * Copies all the selected lines up one row.
     *
     **/
   copyLinesUp() {
        this.$moveLines(-1, true);
    }

    /**
     * Copies all the selected lines down one row.
     * @related EditSession.duplicateLines
     *
     **/
    copyLinesDown() {
        this.$moveLines(1, true);
    }

    /**
     * for internal use
     * @ignore
     *
     **/
    $moveLines(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            // @ts-expect-error TODO: possible bug, no args in parameters
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;

            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }

            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    }

    /**
     * Returns an object indicating the currently selected rows. The object looks like this:
     *
     * ```json
     * { first: range.start.row, last: range.end.row }
     * ```
     *
     * @returns {Object}
     **/
    $getSelectedRows(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    }

    /**
     * @internal
     */
    onCompositionStart(compositionState) {
        this.renderer.showComposition(compositionState);
    }

    /**
     * @internal
     */
    onCompositionUpdate(text) {
        this.renderer.setCompositionText(text);
    }

    /**
     * @internal
     */
    onCompositionEnd() {
        this.renderer.hideComposition();
    }

    /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/
    getFirstVisibleRow() {
        return this.renderer.getFirstVisibleRow();
    }

    /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/
    getLastVisibleRow() {
        return this.renderer.getLastVisibleRow();
    }

    /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @returns {Boolean}
     **/
    isRowVisible(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    }

    /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @returns {Boolean}
     **/
    isRowFullyVisible(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    }

    /**
     * Returns the number of currently visible rows.
     * @returns {Number}
     **/
    $getVisibleRowCount() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    }

    $moveByPage(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    }

    /**
     * Selects the text from the current position of the document until where a "page down" finishes.
     **/
    selectPageDown() {
        this.$moveByPage(1, true);
    }

    /**
     * Selects the text from the current position of the document until where a "page up" finishes.
     **/
    selectPageUp() {
        this.$moveByPage(-1, true);
    }

    /**
     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
     **/
    gotoPageDown() {
       this.$moveByPage(1, false);
    }

    /**
     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
     **/
    gotoPageUp() {
        this.$moveByPage(-1, false);
    }

    /**
     * Scrolls the document to wherever "page down" is, without changing the cursor position.
     **/
    scrollPageDown() {
        this.$moveByPage(1);
    }

    /**
     * Scrolls the document to wherever "page up" is, without changing the cursor position.
     **/
    scrollPageUp() {
        this.$moveByPage(-1);
    }

    /**
     * Moves the editor to the specified row.
     * @related VirtualRenderer.scrollToRow
     * @param {number} row
     */
    scrollToRow(row) {
        this.renderer.scrollToRow(row);
    }

    /**
     * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
     * @param {Number} line The line to scroll to
     * @param {Boolean} center If `true`
     * @param {Boolean} animate If `true` animates scrolling
     * @param {() => void} [callback] Function to be called when the animation has finished
     *
     * @related VirtualRenderer.scrollToLine
     **/
    scrollToLine(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    }

    /**
     * Attempts to center the current selection on the screen.
     **/
    centerSelection() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    }

    /**
     * Gets the current position of the cursor.
     * @returns {Point} An object that looks something like this:
     *
     * ```json
     * { row: currRow, column: currCol }
     * ```
     *
     * @related Selection.getCursor
     **/
    getCursorPosition() {
        return this.selection.getCursor();
    }

    /**
     * Returns the screen position of the cursor.
     * @returns {Point}
     * @related EditSession.documentToScreenPosition
     **/
    getCursorPositionScreen() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    }

    /**
     * {:Selection.getRange}
     * @returns {Range}
     * @related Selection.getRange
     **/
    getSelectionRange() {
        return this.selection.getRange();
    }

    /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/
    selectAll() {
        this.selection.selectAll();
    }

    /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/
    clearSelection() {
        this.selection.clearSelection();
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     * @related Selection.moveCursorTo
     **/
    moveCursorTo(row, column) {
        this.selection.moveCursorTo(row, column);
    }

    /**
     * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
     * @param {Point} pos An object with two properties, row and column
     * @related Selection.moveCursorToPosition
     **/
    moveCursorToPosition(pos) {
        this.selection.moveCursorToPosition(pos);
    }

    /**
     * Moves the cursor's row and column to the next matching bracket or HTML tag.
     * @param {boolean} [select]
     * @param {boolean} [expand]
     */
    jumpToMatching(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var tokenCount = 0;
        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {
            prevToken = iterator.stepBackward();
        }
        var token = prevToken || iterator.stepForward();

        if (!token) return;

        //get next closing tag or bracket
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };

        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                            break;
                    }
                }
            }
            else if (token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }

                if (prevToken.value === '<' && tokenCount > 1) {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }

                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);

        //no match found
        if (!matchType) return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)
                    < 2) range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (!token || token.type.indexOf('tag-name') === -1) return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2
            );

            //find matching tag
            if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                        range = tagsRanges.closeTag;
                        pos = range.start;
                    }
                    else {
                        range = tagsRanges.openTag;
                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column
                            === cursor.column) pos = range.end; else pos = range.start;
                    }
                }
            }

            //we found it
            pos = pos || range.start;
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                }
                else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                }
                else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            }
            else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    }

    /**
     * Moves the cursor to the specified line number, and also into the indicated column.
     * @param {Number} lineNumber The line number to go to
     * @param {Number} [column] A column number to go to
     * @param {Boolean} [animate] If `true` animates scolling
     **/
    gotoLine(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        // todo: find a way to automatically exit multiselect mode
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     * @related Editor.moveCursorTo
     **/
    navigateTo(row, column) {
        this.selection.moveTo(row, column);
    }

    /**
     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateUp(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    }

    /**
     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateDown(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    }

    /**
     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateLeft(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    }

    /**
     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateRight(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
     **/
    navigateLineStart() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
     **/
    navigateLineEnd() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
     **/
    navigateFileEnd() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
     **/
    navigateFileStart() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
     **/
    navigateWordRight() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
     **/
    navigateWordLeft() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    }

    /**
     * Replaces the first occurrence of `options.needle` with the value in `replacement`.
     * @param {String} [replacement] The text to replace with
     * @param {Partial<SearchOptions>} [options] The [[Search `Search`]] options to use
     * @return {number}
     **/
    replace(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }

        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);

        return replaced;
    }

    /**
     * Replaces all occurrences of `options.needle` with the value in `replacement`.
     * @param {String} [replacement] The text to replace with
     * @param {Partial<SearchOptions>} [options] The [[Search `Search`]] options to use
     * @return {number}
     **/
    replaceAll(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);

        return replaced;
    }

    /**
     * @param {import("../ace-internal").Ace.IRange} range
     * @param {string} [replacement]
     */
    $tryReplace(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    }

    /**
     * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
     * @related Search.getOptions
     * @returns {Partial<SearchOptions>}
     **/
    getLastSearchOptions() {
        return this.$search.getOptions();
    }

    /**
     * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
     * @param {String|RegExp|Object} needle The text to search for (optional)
     * @param {Partial<SearchOptions>} [options] An object defining various search properties
     * @param {Boolean} [animate] If `true` animate scrolling
     * @related Search.find
     **/
    find(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        // clear selection if nothing is found
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    }

    /**
     * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
     * @param {Partial<SearchOptions>} [options] search options
     * @param {Boolean} [animate] If `true` animate scrolling
     *
     * @related Editor.find
     **/
    findNext(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    }

    /**
     * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
     * @param {Partial<SearchOptions>} [options] search options
     * @param {Boolean} [animate] If `true` animate scrolling
     *
     * @related Editor.find
     **/
    findPrevious(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    }

    /**
     *
     * @param {Range} range
     * @param {boolean} [animate]
     */
    revealRange(range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    }

    /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/
    undo() {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/
    redo() {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     *
     * Cleans up the entire editor.
     **/
    destroy() {
        if (this.$toDestroy) {
            this.$toDestroy.forEach(function(el) {
                el.destroy();
            });
            this.$toDestroy = null;
        }
        if (this.$mouseHandler)
            this.$mouseHandler.destroy();
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session)
            this.session.destroy();
        if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
        this.removeAllListeners();

    }

    /**
     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/
    setAutoScrollEditorIntoView(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        // needed to not trigger sync reflow
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    }

    $resetCursorStyle() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    }

    /**
     * opens a prompt displaying message
     **/
    prompt(message, options, callback) {
        var editor = this;
        config.loadModule("ace/ext/prompt", function (module) {
            module.prompt(editor, message, options, callback);
        });
    }

}

Editor.$uid = 0;
Editor.prototype.curOp = null;
Editor.prototype.prevOp = {};
// TODO use property on commands instead of this
Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
Editor.prototype.$toggleWordPairs = [
    ["first", "last"],
    ["true", "false"],
    ["yes", "no"],
    ["width", "height"],
    ["top", "bottom"],
    ["right", "left"],
    ["on", "off"],
    ["x", "y"],
    ["get", "set"],
    ["max", "min"],
    ["horizontal", "vertical"],
    ["show", "hide"],
    ["add", "remove"],
    ["up", "down"],
    ["before", "after"],
    ["even", "odd"],
    ["in", "out"],
    ["inside", "outside"],
    ["next", "previous"],
    ["increase", "decrease"],
    ["attach", "detach"],
    ["&&", "||"],
    ["==", "!="]
];

oop.implement(Editor.prototype, EventEmitter);


config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
        },
        initialValue: false
    },
    copyWithEmptySelection: {
        set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    enableAutoIndent: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val);}
    },
    keyboardHandler: {
        set: function(val) { this.setKeyboardHandler(val); },
        get: function() { return this.$keybindingId; },
        handlesSet: true
    },
    value: {
        set: function(val) { this.session.setValue(val); },
        get: function() { return this.getValue(); },
        handlesSet: true,
        hidden: true
    },
    session: {
        set: function(val) { this.setSession(val); },
        get: function() { return this.session; },
        handlesSet: true,
        hidden: true
    },

    showLineNumbers: {
        set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        },
        initialValue: true
    },
    relativeLineNumbers: {
        set: function(value) {
            if (this.$showLineNumbers && value)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        }
    },
    placeholder: {
        /**
         * @param message
         */
        set: function(message) {
            if (!this.$updatePlaceholder) {
                this.$updatePlaceholder = function() {
                    var hasValue = this.session && (this.renderer.$composition ||
                         this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                    if (hasValue && this.renderer.placeholderNode) {
                        this.renderer.off("afterRender", this.$updatePlaceholder);
                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
                        this.renderer.placeholderNode.remove();
                        this.renderer.placeholderNode = null;
                    } else if (!hasValue && !this.renderer.placeholderNode) {
                        this.renderer.on("afterRender", this.$updatePlaceholder);
                        dom.addCssClass(this.container, "ace_hasPlaceholder");
                        var el = dom.createElement("div");
                        el.className = "ace_placeholder";
                        el.textContent = this.$placeholder || "";
                        this.renderer.placeholderNode = el;
                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                    } else if (!hasValue && this.renderer.placeholderNode) {
                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
                    }
                }.bind(this);
                // @ts-ignore
                this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
        }
    },
    enableKeyboardAccessibility: {
        set: function(value) {
            var blurCommand = {
                name: "blurTextInput",
                description: "Set focus to the editor content div to allow tabbing through the page",
                bindKey: "Esc",
                exec: function(editor) {
                    editor.blur();
                    editor.renderer.scroller.focus();
                },
                readOnly: true
            };

            var focusOnEnterKeyup = function (e) {
                if (e.target == this.renderer.scroller && e.keyCode === keys['enter']){
                    e.preventDefault();
                    var row = this.getCursorPosition().row;

                    if (!this.isRowVisible(row))
                        this.scrollToLine(row, true, true);

                    this.focus();
                }
            };
            /**@type {GutterKeyboardHandler}*/
            var gutterKeyboardHandler;

            // If keyboard a11y mode is enabled we:
            // - Enable keyboard operability gutter.
            // - Prevent tab-trapping.
            // - Hide irrelevant elements from assistive technology.
            // - On Windows, set more lines to the textarea.
            // - set aria-label to the text input.
            if (value){
                this.renderer.enableKeyboardAccessibility = true;
                this.renderer.keyboardFocusClassName = "ace_keyboard-focus";

                this.textInput.getElement().setAttribute("tabindex", -1);
                // VoiceOver on Mac OS works best with single line in the textarea, the screen readers on
                // Windows work best with multiple lines in the textarea.
                this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
                this.renderer.scroller.setAttribute("tabindex", 0);
                this.renderer.scroller.setAttribute("role", "group");
                this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
                this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
                this.renderer.scroller.setAttribute("aria-label",
                    nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit")
                );

                this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
                this.commands.addCommand(blurCommand);

                this.renderer.$gutter.setAttribute("tabindex", 0);
                this.renderer.$gutter.setAttribute("aria-hidden", false);
                this.renderer.$gutter.setAttribute("role", "group");
                this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
                this.renderer.$gutter.setAttribute("aria-label",
                    nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit")
                );
                this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);

                this.renderer.content.setAttribute("aria-hidden", true);

                if (!gutterKeyboardHandler)
                    gutterKeyboardHandler = new GutterKeyboardHandler(this);

                gutterKeyboardHandler.addListener();

                this.textInput.setAriaOptions({
                    setLabel: true
                });
            } else {
                this.renderer.enableKeyboardAccessibility = false;

                this.textInput.getElement().setAttribute("tabindex", 0);
                this.textInput.setNumberOfExtraLines(0);
                this.renderer.scroller.setAttribute("tabindex", -1);
                this.renderer.scroller.removeAttribute("role");
                this.renderer.scroller.removeAttribute("aria-roledescription");
                this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
                this.renderer.scroller.removeAttribute("aria-label");

                this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
                this.commands.removeCommand(blurCommand);

                this.renderer.content.removeAttribute("aria-hidden");

                this.renderer.$gutter.setAttribute("tabindex", -1);
                this.renderer.$gutter.setAttribute("aria-hidden", true);
                this.renderer.$gutter.removeAttribute("role");
                this.renderer.$gutter.removeAttribute("aria-roledescription");
                this.renderer.$gutter.removeAttribute("aria-label");
                this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);

                if (gutterKeyboardHandler)
                    gutterKeyboardHandler.removeListener();
            }
        },
        initialValue: false
    },
    textInputAriaLabel: {
        set: function(val) { this.$textInputAriaLabel = val; },
        initialValue: ""
    },
    enableMobileMenu: {
        /**
         * @param {boolean} val
         */
        set: function(val) { this.$enableMobileMenu = val; },
        initialValue: true
    },
    customScrollbar: "renderer",
    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    displayIndentGuides: "renderer",
    highlightIndentGuides: "renderer",
    showGutter: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",
    hasCssTransforms: "renderer",
    maxPixelHeight: "renderer",
    useTextareaForIME: "renderer",
    useResizeObserver: "renderer",
    useSvgGutterIcons: "renderer",
    showFoldedAnnotations: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimeout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    navigateWithinSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});


var relativeNumberRenderer = {
    getText: function(/**@type{EditSession}*/session, /**@type{number}*/row) {
        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
    },
    getWidth: function(session, /**@type{number}*/lastLineNumber, config) {
        return Math.max(
            lastLineNumber.toString().length,
            (config.lastRow + 1).toString().length,
            2
        ) * config.characterWidth;
    },
    update: function(e, /**@type{Editor}*/editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
    },
    attach: function(/**@type{Editor}*/editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on("changeSelection", this.update);
        this.update(null, editor);
    },
    detach: function(/**@type{Editor}*/editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
        editor.off("changeSelection", this.update);
        this.update(null, editor);
    }
};
exports.Editor = Editor;


/***/ }),

/***/ 4126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var dom = __webpack_require__(71435);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var nls = (__webpack_require__(76321).nls);

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }

    // Return the nearest lesser index, "-1" means "0, "-2" means "1", etc.
    return -(first + 1);
}

/**
 * @param {import("../edit_session").EditSession} session
 * @param {number} row
 * @param {number} dir
 */
function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

/**
 * @param {import("../editor").Editor} editor
 * @param {number} dir
 */
exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            displayText: [nls("error-marker.good-state", "Looks good!")],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    gutterAnno.displayText.forEach(function (annoTextLine, i) {
        el.appendChild(dom.createTextNode(annoTextLine));
        if (i < gutterAnno.displayText.length - 1) {
            el.appendChild(dom.createElement("br"));
        }
    });
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        // @ts-ignore
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };

    // @ts-ignore
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString(`
    .error_widget_wrapper {
        background: inherit;
        color: inherit;
        border:none
    }
    .error_widget {
        border-top: solid 2px;
        border-bottom: solid 2px;
        margin: 5px 0;
        padding: 10px 40px;
        white-space: pre-wrap;
    }
    .error_widget.ace_error, .error_widget_arrow.ace_error{
        border-color: #ff5a5a
    }
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{
        border-color: #F1D817
    }
    .error_widget.ace_info, .error_widget_arrow.ace_info{
        border-color: #5a5a5a
    }
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{
        border-color: #5aaa5a
    }
    .error_widget_arrow {
        position: absolute;
        border: solid 5px;
        border-top-color: transparent!important;
        border-right-color: transparent!important;
        border-left-color: transparent!important;
        top: -5px;
    }
`, "error_marker.css", false);


/***/ }),

/***/ 61893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**@type{import("../snippets").snippetManager & {files?: {[key: string]: any}}}*/
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var Autocomplete = (__webpack_require__(26347)/* .Autocomplete */ .jT);
var config = __webpack_require__(76321);
var lang = __webpack_require__(39955);
var util = __webpack_require__(28630);

var textCompleter = __webpack_require__(60565);
/**@type {import("../../ace-internal").Ace.Completer}*/
var keyWordCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
        }
        var state = editor.session.getState(pos.row);
        var completions = session.$mode.getCompletions(state, session, pos, prefix);
        completions = completions.map((el) => {
            el.completerId = keyWordCompleter.id;
            return el;
        });
        callback(null, completions);
    },
    id: "keywordCompleter"
};

var transformSnippetTooltip = function(str) {
    var record = {};
    return str.replace(/\${(\d+)(:(.*?))?}/g, function(_, p1, p2, p3) {
        return (record[p1] = p3 || '');
    }).replace(/\$(\d+?)/g, function (_, p1) {
        return record[p1];
    });
};
/**@type {import("../../ace-internal").Ace.Completer} */
var snippetCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        var scopes = [];

        // set scope to html-tag if we're inside an html tag
        var token = session.getTokenAt(pos.row, pos.column);
        if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
            scopes.push('html-tag');
        else
            scopes = snippetManager.getActiveScopes(editor);

        var snippetMap = snippetManager.snippetMap;
        var completions = [];
        scopes.forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--;) {
                var s = snippets[i];
                var caption = s.name || s.tabTrigger;
                if (!caption)
                    continue;
                completions.push({
                    caption: caption,
                    snippet: s.content,
                    meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                    completerId: snippetCompleter.id
                });
            }
        }, this);
        callback(null, completions);
    },
    getDocTooltip: function(item) {
        if (item.snippet && !item.docHTML) {
            item.docHTML = [
                "<b>", lang.escapeHTML(item.caption), "</b>", "<hr></hr>",
                lang.escapeHTML(transformSnippetTooltip(item.snippet))
            ].join("");
        }
    },
    id: "snippetCompleter"
};

var completers = [snippetCompleter, textCompleter, keyWordCompleter];
// Modifies list of default completers
exports.setCompleters = function(val) {
    completers.length = 0;
    if (val) completers.push.apply(completers, val);
};
exports.addCompleter = function(completer) {
    completers.push(completer);
};

// Exports existing completer so that user can construct his own set of completers.
exports.textCompleter = textCompleter;
exports.keyWordCompleter = keyWordCompleter;
exports.snippetCompleter = snippetCompleter;

var expandSnippet = {
    name: "expandSnippet",
    exec: function(editor) {
        return snippetManager.expandWithTab(editor);
    },
    bindKey: "Tab"
};

var onChangeMode = function(e, editor) {
    loadSnippetsForMode(editor.session.$mode);
};

var loadSnippetsForMode = function(mode) {
    if (typeof mode == "string")
        mode = config.$modes[mode];
    if (!mode)
        return;
    if (!snippetManager.files)
        snippetManager.files = {};
    
    loadSnippetFile(mode.$id, mode.snippetFileId);
    if (mode.modes)
        mode.modes.forEach(loadSnippetsForMode);
};

var loadSnippetFile = function(id, snippetFilePath) {
    if (!snippetFilePath || !id || snippetManager.files[id])
        return;
    snippetManager.files[id] = {};
    config.loadModule(snippetFilePath, function(m) {
        if (!m) return;
        snippetManager.files[id] = m;
        if (!m.snippets && m.snippetText)
            m.snippets = snippetManager.parseSnippetFile(m.snippetText);
        snippetManager.register(m.snippets || [], m.scope);
        if (m.includeScopes) {
            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
            m.includeScopes.forEach(function(x) {
                loadSnippetsForMode("ace/mode/" + x);
            });
        }
    });
};

var doLiveAutocomplete = function(e) {
    var editor = e.editor;
    var hasCompleter = editor.completer && editor.completer.activated;

    // We don't want to autocomplete with no prefix
    if (e.command.name === "backspace") {
        if (hasCompleter && !util.getCompletionPrefix(editor))
            editor.completer.detach();
    }
    else if (e.command.name === "insertstring" && !hasCompleter) {
        lastExecEvent = e;
        var delay = e.editor.$liveAutocompletionDelay;
        if (delay) {
            liveAutocompleteTimer.delay(delay);
        } else {
            showLiveAutocomplete(e);
        }
    }
};

var lastExecEvent;
var liveAutocompleteTimer = lang.delayedCall(function () {
    showLiveAutocomplete(lastExecEvent);
}, 0);

var showLiveAutocomplete = function(e) {
    var editor = e.editor;
    var prefix = util.getCompletionPrefix(editor);
    // Only autocomplete if there's a prefix that can be matched or previous char is trigger character 
    var previousChar = e.args;
    var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);
    if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
        var completer = Autocomplete.for(editor);
        // Set a flag for auto shown
        completer.autoShown = true;
        completer.showPopup(editor);
    }
};

var Editor = (__webpack_require__(27258).Editor);
(__webpack_require__(76321).defineOptions)(Editor.prototype, "editor", {
    enableBasicAutocompletion: {
        /**
         * @param val
         * @this{Editor}
         */
        set: function(val) {
            if (val) {
                if (!this.completers)
                    this.completers = Array.isArray(val)? val: completers;
                this.commands.addCommand(Autocomplete.startCommand);
            } else {
                this.commands.removeCommand(Autocomplete.startCommand);
            }
        },
        value: false
    },
    /**
     * Enable live autocompletion
     */
    enableLiveAutocompletion: {
        /**
         * @param {boolean} val
         * @this {Editor}
         */
        set: function(val) {
            if (val) {
                if (!this.completers)
                    this.completers = Array.isArray(val)? val: completers;
                // On each change automatically trigger the autocomplete
                this.commands.on('afterExec', doLiveAutocomplete);
            } else {
                this.commands.off('afterExec', doLiveAutocomplete);
            }
        },
        value: false
    },
    liveAutocompletionDelay: {
        initialValue: 0
    },
    liveAutocompletionThreshold: {
        initialValue: 0
    },
    enableSnippets: {
        set: function(val) {
            if (val) {
                this.commands.addCommand(expandSnippet);
                this.on("changeMode", onChangeMode);
                onChangeMode(null, this);
            } else {
                this.commands.removeCommand(expandSnippet);
                this.off("changeMode", onChangeMode);
            }
        },
        value: false
    }
});


/***/ }),

/***/ 91772:
/***/ ((module) => {

"use strict";


/**
 * @type {Mode[]}
 */
var modes = [];
/**
 * Suggests a mode based on the file extension present in the given path
 * @param {string} path The path to the file
 * @returns {Mode} Returns an object containing information about the
 *  suggested mode.
 */
function getModeForPath(path) {
    var mode = modesByName.text;
    var fileName = path.split(/[\/\\]/).pop();
    for (var i = 0; i < modes.length; i++) {
        if (modes[i].supportsFile(fileName)) {
            mode = modes[i];
            break;
        }
    }
    return mode;
}

class Mode {
    /**
     * @param {string} name
     * @param {string} caption
     * @param {string} extensions
     */
    constructor(name, caption, extensions) {
        this.name = name;
        this.caption = caption;
        this.mode = "ace/mode/" + name;
        this.extensions = extensions;
        var re;
        if (/\^/.test(extensions)) {
            re = extensions.replace(/\|(\^)?/g, function (a, b) {
                return "$|" + (b ? "^" : "^.*\\.");
            }) + "$";
        }
        else {
            re = "^.*\\.(" + extensions + ")$";
        }

        this.extRe = new RegExp(re, "gi");
    }

    /**
     * @param {string} filename
     * @returns {RegExpMatchArray | null}
     */
    supportsFile(filename) {
        return filename.match(this.extRe);
    }
}

// todo firstlinematch
var supportedModes = {
    ABAP:        ["abap"],
    ABC:         ["abc"],
    ActionScript:["as"],
    ADA:         ["ada|adb"],
    Alda:        ["alda"],
    Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
    Apex:        ["apex|cls|trigger|tgr"],
    AQL:         ["aql"],
    AsciiDoc:    ["asciidoc|adoc"],
    ASL:         ["dsl|asl|asl.json"],
    Assembly_ARM32:["s"],
    Assembly_x86:["asm|a"],
    Astro:       ["astro"],
    AutoHotKey:  ["ahk"],
    BatchFile:   ["bat|cmd"],
    Basic:       ["bas|bak"],
    BibTeX:      ["bib"],
    C_Cpp:       ["cpp|c|cc|cxx|h|hh|hpp|ino"],
    C9Search:    ["c9search_results"],
    Cirru:       ["cirru|cr"],
    Clojure:     ["clj|cljs"],
    Cobol:       ["CBL|COB"],
    coffee:      ["coffee|cf|cson|^Cakefile"],
    ColdFusion:  ["cfm|cfc"],
    Crystal:     ["cr"],
    CSharp:      ["cs"],
    Csound_Document: ["csd"],
    Csound_Orchestra: ["orc"],
    Csound_Score: ["sco"],
    CSS:         ["css"],
    Curly:       ["curly"],
    Cuttlefish:  ["conf"],
    D:           ["d|di"],
    Dart:        ["dart"],
    Diff:        ["diff|patch"],
    Django:      ["djt|html.djt|dj.html|djhtml"],
    Dockerfile:  ["^Dockerfile"],
    Dot:         ["dot"],
    Drools:      ["drl"],
    Edifact:     ["edi"],
    Eiffel:      ["e|ge"],
    EJS:         ["ejs"],
    Elixir:      ["ex|exs"],
    Elm:         ["elm"],
    Erlang:      ["erl|hrl"],
    Flix:        ["flix"],
    Forth:       ["frt|fs|ldr|fth|4th"],
    Fortran:     ["f|f90"],
    FSharp:      ["fsi|fs|ml|mli|fsx|fsscript"],
    FSL:         ["fsl"],
    FTL:         ["ftl"],
    Gcode:       ["gcode"],
    Gherkin:     ["feature"],
    Gitignore:   ["^.gitignore"],
    Glsl:        ["glsl|frag|vert"],
    Gobstones:   ["gbs"],
    golang:      ["go"],
    GraphQLSchema: ["gql"],
    Groovy:      ["groovy"],
    HAML:        ["haml"],
    Handlebars:  ["hbs|handlebars|tpl|mustache"],
    Haskell:     ["hs"],
    Haskell_Cabal: ["cabal"],
    haXe:        ["hx"],
    Hjson:       ["hjson"],
    HTML: ["html|htm|xhtml|we|wpy"],
    HTML_Elixir: ["eex|html.eex"],
    HTML_Ruby:   ["erb|rhtml|html.erb"],
    INI:         ["ini|conf|cfg|prefs"],
    Io:          ["io"],
    Ion:         ["ion"],
    Jack:        ["jack"],
    Jade:        ["jade|pug"],
    Java:        ["java"],
    JavaScript:  ["js|jsm|cjs|mjs"],
    JEXL:        ["jexl"],
    JSON:        ["json"],
    JSON5:       ["json5"],
    JSONiq:      ["jq"],
    JSP:         ["jsp"],
    JSSM:        ["jssm|jssm_state"],
    JSX:         ["jsx"],
    Julia:       ["jl"],
    Kotlin:      ["kt|kts"],
    LaTeX:       ["tex|latex|ltx|bib"],
    Latte:       ["latte"],
    LESS:        ["less"],
    Liquid:      ["liquid"],
    Lisp:        ["lisp"],
    LiveScript:  ["ls"],
    Log:         ["log"],
    LogiQL:      ["logic|lql"],
    Logtalk:     ["lgt"],
    LSL:         ["lsl"],
    Lua:         ["lua"],
    LuaPage:     ["lp"],
    Lucene:      ["lucene"],
    Makefile:    ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
    Markdown:    ["md|markdown"],
    Mask:        ["mask"],
    MATLAB:      ["matlab"],
    Maze:        ["mz"],
    MediaWiki:   ["wiki|mediawiki"],
    MEL:         ["mel"],
    MIPS:        ["s|asm"],
    MIXAL:       ["mixal"],
    MUSHCode:    ["mc|mush"],
    MySQL:       ["mysql"],
    Nasal:       ["nas"],
    Nginx:       ["nginx|conf"],
    Nim:         ["nim"],
    Nix:         ["nix"],
    NSIS:        ["nsi|nsh"],
    Nunjucks:    ["nunjucks|nunjs|nj|njk"],
    ObjectiveC:  ["m|mm"],
    OCaml:       ["ml|mli"],
    Odin:        ["odin"],
    PartiQL:     ["partiql|pql"],
    Pascal:      ["pas|p"],
    Perl:        ["pl|pm"],
    pgSQL:       ["pgsql"],
    PHP:         ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
    PHP_Laravel_blade: ["blade.php"],
    Pig:         ["pig"],
    PLSQL:       ["plsql"],
    Powershell:  ["ps1"],
    Praat:       ["praat|praatscript|psc|proc"],
    Prisma:      ["prisma"],
    Prolog:      ["plg|prolog"],
    Properties:  ["properties"],
    Protobuf:    ["proto"],
    PRQL:        ["prql"],
    Puppet:      ["epp|pp"],
    Python:      ["py"],
    QML:         ["qml"],
    R:           ["r"],
    Raku:        ["raku|rakumod|rakutest|p6|pl6|pm6"],
    Razor:       ["cshtml|asp"],
    RDoc:        ["Rd"],
    Red:         ["red|reds"],
    RHTML:       ["Rhtml"],
    Robot:       ["robot|resource"],
    RST:         ["rst"],
    Ruby:        ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
    Rust:        ["rs"],
    SaC:         ["sac"],
    SASS:        ["sass"],
    SCAD:        ["scad"],
    Scala:       ["scala|sbt"],
    Scheme:      ["scm|sm|rkt|oak|scheme"],
    Scrypt:      ["scrypt"],
    SCSS:        ["scss"],
    SH:          ["sh|bash|^.bashrc"],
    SJS:         ["sjs"],
    Slim:        ["slim|skim"],
    Smarty:      ["smarty|tpl"],
    Smithy:      ["smithy"],
    snippets:    ["snippets"],
    Soy_Template:["soy"],
    Space:       ["space"],
    SPARQL:      ["rq"],
    SQL:         ["sql"],
    SQLServer:   ["sqlserver"],
    Stylus:      ["styl|stylus"],
    SVG:         ["svg"],
    Swift:       ["swift"],
    Tcl:         ["tcl"],
    Terraform:   ["tf", "tfvars", "terragrunt"],
    Tex:         ["tex"],
    Text:        ["txt"],
    Textile:     ["textile"],
    Toml:        ["toml"],
    TSX:         ["tsx"],
    Turtle:      ["ttl"],
    Twig:        ["twig|swig"],
    Typescript:  ["ts|mts|cts|typescript|str"],
    Vala:        ["vala"],
    VBScript:    ["vbs|vb"],
    Velocity:    ["vm"],
    Verilog:     ["v|vh|sv|svh"],
    VHDL:        ["vhd|vhdl"],
    Visualforce: ["vfp|component|page"],
    Vue: ["vue"],
    Wollok:      ["wlk|wpgm|wtest"],
    XML:         ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
    XQuery:      ["xq"],
    YAML:        ["yaml|yml"],
    Zeek:        ["zeek|bro"],
    Zig:         ["zig"]
};

var nameOverrides = {
    ObjectiveC: "Objective-C",
    CSharp: "C#",
    golang: "Go",
    C_Cpp: "C and C++",
    Csound_Document: "Csound Document",
    Csound_Orchestra: "Csound",
    Csound_Score: "Csound Score",
    coffee: "CoffeeScript",
    HTML_Ruby: "HTML (Ruby)",
    HTML_Elixir: "HTML (Elixir)",
    FTL: "FreeMarker",
    PHP_Laravel_blade: "PHP (Blade Template)",
    Perl6: "Perl 6",
    AutoHotKey: "AutoHotkey / AutoIt"
};

/**
 * @type {Record<string, Mode>}
 */
var modesByName = {};
for (var name in supportedModes) {
    var data = supportedModes[name];
    var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
    var filename = name.toLowerCase();
    var mode = new Mode(filename, displayName, data[0]);
    modesByName[filename] = mode;
    modes.push(mode);
}

module.exports = {
    getModeForPath: getModeForPath,
    modes: modes,
    modesByName: modesByName
};


/***/ }),

/***/ 45545:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var keys = __webpack_require__(29451);
var GutterTooltip = (__webpack_require__(83229)/* .GutterTooltip */ .Z);

class GutterKeyboardHandler {
    constructor(editor) {
        this.editor = editor;
        this.gutterLayer = editor.renderer.$gutterLayer;
        this.element = editor.renderer.$gutter;
        this.lines = editor.renderer.$gutterLayer.$lines;

        this.activeRowIndex = null;
        this.activeLane = null;

        this.annotationTooltip = new GutterTooltip(this.editor);
    }

    addListener() {
        this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
        this.element.addEventListener("focusout", this.$blurGutter.bind(this));
        this.editor.on("mousewheel", this.$blurGutter.bind(this));
    }

    removeListener() {
        this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
        this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
        this.editor.off("mousewheel", this.$blurGutter.bind(this));
    }

    $onGutterKeyDown(e) {
        // if the tooltip is open, we only want to respond to commands to close it (like a modal)
        if (this.annotationTooltip.isOpen) {
            e.preventDefault();

            if (e.keyCode === keys["escape"])
                this.annotationTooltip.hideTooltip();

            return;
        }

        // If focus is on the gutter element, set focus to nearest gutter icon on enter press.
        if (e.target === this.element) {
            if (e.keyCode != keys["enter"]) {return;}
            e.preventDefault();

            // Scroll if the cursor is not currently within the viewport.
            var row = this.editor.getCursorPosition().row;       
            if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);

            // After scrolling is completed, find the nearest gutter icon and set focus to it.
            setTimeout(
                /** @this {GutterKeyboardHandler} */
                function () {
                    var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                    var nearestFoldIndex = this.$findNearestFoldWidget(index);
                    var nearestAnnotationIndex = this.$findNearestAnnotation(index);

                    if (nearestFoldIndex === null && nearestAnnotationIndex === null) return;

                    if (nearestFoldIndex === null && nearestAnnotationIndex !== null) {
                        this.activeRowIndex = nearestAnnotationIndex;
                        this.activeLane = "annotation";
                        this.$focusAnnotation(this.activeRowIndex);
                        return;
                    }

                    if (nearestFoldIndex !== null && nearestAnnotationIndex === null) {
                        this.activeRowIndex = nearestFoldIndex;
                        this.activeLane = "fold";
                        this.$focusFoldWidget(this.activeRowIndex);
                        return;
                    }

                    if (Math.abs(nearestAnnotationIndex - index) < Math.abs(nearestFoldIndex - index)) {
                        this.activeRowIndex = nearestAnnotationIndex;
                        this.activeLane = "annotation";
                        this.$focusAnnotation(this.activeRowIndex);
                        return;
                    }
                    else {
                        this.activeRowIndex = nearestFoldIndex;
                        this.activeLane = "fold";
                        this.$focusFoldWidget(this.activeRowIndex);
                        return;
                    }
                }.bind(this), 10);
            return;
        } 

        // After here, foucs is on a gutter icon and we want to interact with them.
        this.$handleGutterKeyboardInteraction(e);

        // Wait until folding is completed and then signal gutterkeydown to the editor.
        setTimeout(function() {
            // Signal to the editor that a key is pressed inside the gutter.
            this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
        }.bind(this), 10);
    }

    $handleGutterKeyboardInteraction(e) {
        // Prevent tabbing when interacting with the gutter icons.
        if (e.keyCode === keys["tab"]){
            e.preventDefault();
            return;
        } 

        // If focus is on a gutter icon, set focus to gutter on escape press.
        if (e.keyCode === keys["escape"]) {
            e.preventDefault();
            this.$blurGutter();
            this.element.focus();
            this.lane = null;
            return;
        }

        if (e.keyCode === keys["up"]) {
            e.preventDefault();
  
            switch (this.activeLane){
                case "fold":
                    this.$moveFoldWidgetUp();
                    break;
                
                case "annotation":
                    this.$moveAnnotationUp();
                    break;
            }
            return;
        }

        if (e.keyCode === keys["down"]) {
            e.preventDefault();

            switch (this.activeLane){
                case "fold":
                    this.$moveFoldWidgetDown();
                    break;
                
                case "annotation":
                    this.$moveAnnotationDown();
                    break;
            }
            return;
        }

        // Try to switch from fold widgets to annotations.
        if (e.keyCode === keys["left"]){
            e.preventDefault();
            this.$switchLane("annotation");
            return;
        }

        // Try to switch from annotations to fold widgets.
        if (e.keyCode === keys["right"]){
            e.preventDefault();
            this.$switchLane("fold");
            return;
        }

        if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]){
            e.preventDefault();

            switch (this.activeLane) {
                case "fold":
                    if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'start') {
                        var rowFoldingWidget = this.$rowIndexToRow(this.activeRowIndex);
                        this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);

                        // After folding, check that the right fold widget is still in focus.
                        // If not (e.g. folding close to bottom of doc), put right widget in focus.
                        setTimeout(
                            /** @this {GutterKeyboardHandler} */
                            function () {
                                if (this.$rowIndexToRow(this.activeRowIndex) !== rowFoldingWidget) {
                                    this.$blurFoldWidget(this.activeRowIndex);
                                    this.activeRowIndex = this.$rowToRowIndex(rowFoldingWidget);
                                    this.$focusFoldWidget(this.activeRowIndex);
                                }
                        }.bind(this), 10);

                        break;
                    } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'end') {
                        /* TO DO: deal with 'end' fold widgets */
                        break;
                    }
                    return; 
                
                case "annotation":
                    var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                    var rect = gutterElement.getBoundingClientRect();
                    var style = this.annotationTooltip.getElement().style;
                    style.left = rect.right + "px";
                    style.top = rect.bottom + "px";
                    this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));                
                    break;
            }
            return;
        }   
    }

    $blurGutter() {
        if (this.activeRowIndex !== null){
            switch (this.activeLane){
                case "fold":
                    this.$blurFoldWidget(this.activeRowIndex);
                    break;

                case "annotation":
                    this.$blurAnnotation(this.activeRowIndex);
                    break;
            }
        }

        if (this.annotationTooltip.isOpen)
            this.annotationTooltip.hideTooltip();

        return;
    }

    $isFoldWidgetVisible(index) {
        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
        var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
        return isRowFullyVisible && isIconVisible;
    }

    $isAnnotationVisible(index) {
        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
        var isIconVisible = this.$getAnnotation(index).style.display !== "none";
        return isRowFullyVisible && isIconVisible;
    }

    $getFoldWidget(index) {
        var cell = this.lines.get(index);
        var element = cell.element;
        return element.childNodes[1];
    }

    $getAnnotation(index) {
        var cell = this.lines.get(index);
        var element = cell.element;
        return element.childNodes[2];
    }

    // Given an index, find the nearest index with a foldwidget
    $findNearestFoldWidget(index) {
        // If fold widget exists at index, return index.
        if (this.$isFoldWidgetVisible(index))
            return index;

        // else, find the nearest index with fold widget within viewport.
        var i = 0;
        while (index - i > 0 || index + i < this.lines.getLength() - 1){
            i++;

            if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
                return index - i;

            if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
                return index + i;
        }

        // If there are no fold widgets within the viewport, return null.
        return null;
    }

    // Given an index, find the nearest index with an annotation.
    $findNearestAnnotation(index) {
        // If annotation exists at index, return index.
        if (this.$isAnnotationVisible(index))
            return index;

        // else, find the nearest index with annotation within viewport.
        var i = 0;
        while (index - i > 0 || index + i < this.lines.getLength() - 1){
            i++;

            if (index - i >= 0 && this.$isAnnotationVisible(index - i))
                return index - i;

            if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
                return index + i;
        }

        // If there are no annotations within the viewport, return null.
        return null;
    }

    $focusFoldWidget(index) {
        if (index == null)
            return;

        var foldWidget = this.$getFoldWidget(index);

        foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
        foldWidget.focus();
    }

    $focusAnnotation(index) {
        if (index == null)
            return;

        var annotation = this.$getAnnotation(index);

        annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
        annotation.focus();
    }

    $blurFoldWidget(index) {
        var foldWidget = this.$getFoldWidget(index);

        foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
        foldWidget.blur();
    }

    $blurAnnotation(index) {
        var annotation = this.$getAnnotation(index);

        annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
        annotation.blur();
    }

    $moveFoldWidgetUp() {
        var index = this.activeRowIndex;

        while (index > 0){
            index--;

            if (this.$isFoldWidgetVisible(index)){
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $moveFoldWidgetDown() {
        var index = this.activeRowIndex;

        while (index < this.lines.getLength() - 1){
            index++;

            if (this.$isFoldWidgetVisible(index)){
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $moveAnnotationUp() {
        var index = this.activeRowIndex;

        while (index > 0){
            index--;

            if (this.$isAnnotationVisible(index)){
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $moveAnnotationDown() {
        var index = this.activeRowIndex;

        while (index < this.lines.getLength() - 1){
            index++;

            if (this.$isAnnotationVisible(index)){
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $switchLane(desinationLane){
        switch (desinationLane) {
            case "annotation":
                if (this.activeLane === "annotation") {break;}
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {break;}

                this.activeLane = "annotation";

                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);

                break;

            case "fold": 
                if (this.activeLane === "fold") {break;}
                var foldWidgetIndex = this.$findNearestFoldWidget(this.activeRowIndex);
                if (foldWidgetIndex == null) {break;}

                this.activeLane = "fold";

                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = foldWidgetIndex;
                this.$focusFoldWidget(this.activeRowIndex);
                
                break;
        }
        return;
    }

    // Convert row index (viewport space) to row (document space).
    $rowIndexToRow(index) {
        var cell = this.lines.get(index);
        if (cell)
            return cell.row;

        return null;
    }

    // Convert row (document space) to row index (viewport space).
    $rowToRowIndex(row) {
        for (var i = 0; i < this.lines.getLength(); i++){
            var cell = this.lines.get(i);
            if (cell.row == row)
                return i;
        }

        return null;
    }
}

exports.S = GutterKeyboardHandler;

/*
 * Custom Ace gutter keyboard event
 */
class GutterKeyboardEvent {
    constructor(domEvent, gutterKeyboardHandler) {
        this.gutterKeyboardHandler = gutterKeyboardHandler;
        this.domEvent = domEvent;
    }

    /**
     * Returns the key that was presssed.
     * 
     * @return {string} the key that was pressed.
     */
    getKey() {
        return keys.keyCodeToString(this.domEvent.keyCode);
    }

    /**
     * Returns the row in the gutter that was focused after the keyboard event was handled.
     * 
     * @return {number} the key that was pressed.
     */
    getRow() {
        return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
    }

    /**
     * Returns whether focus is on the annotation lane after the keyboard event was handled.
     * 
     * @return {boolean} true if focus was on the annotation lane after the keyboard event.
     */
    isInAnnotationLane() {
        return this.gutterKeyboardHandler.activeLane === "annotation";
    }

    /**
     * Returns whether focus is on the fold lane after the keyboard event was handled.
     * 
     * @return {boolean} true if focus was on the fold lane after the keyboard event.
     */
    isInFoldLane() {
        return this.gutterKeyboardHandler.activeLane === "fold";
    }
}

__webpack_unused_export__ = GutterKeyboardEvent;


/***/ }),

/***/ 93050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("../../ace-internal").Ace.Command} Command
 * @typedef {import("../../ace-internal").Ace.CommandLike} CommandLike
*/

/** @type {any} */var keyUtil = __webpack_require__(29451);
var useragent = __webpack_require__(74943);
var KEY_MODS = keyUtil.KEY_MODS;

class MultiHashHandler {
    /**
     * @param {Record<string, CommandLike> | Command[]} [config]
     * @param {string} [platform]
     */
    constructor(config, platform) {
        this.$init(config, platform, false);
    }

    /**
     * @param {Record<string, CommandLike> | Command[]} config
     * @param {string} [platform]
     * @param {boolean} [$singleCommand]
     */
    $init(config, platform, $singleCommand) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        /**@type {Record<string, Command>}*/
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = $singleCommand;
    }

    /**
     * @param {Command} command
     */
    addCommand(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    }

    /**
     * @param {Command | string} command
     * @param {boolean} [keepCommand]
     */
    removeCommand(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];

        // exhaustive search is brute force but since removeCommand is
        // not a performance critical operation this should be OK
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    }

    /**
     * @param {string | { win?: string; mac?: string; position?:number}} key
     * @param {CommandLike | string} command
     * @param {number} [position]
     */
    bindKey(key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || /**@type{string}*/(key)});
        
        /**@type{string}*/(key).split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    }

    /**
     * @param {string} keyId
     * @param {any} command
     * @param {number} position
     */
    _addCommandToBinding(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }
            
            if (typeof position != "number") {
                position = getPosition(command);
            }

            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    }

    /**
     * @param {Record<string, CommandLike> | Command[]} [commands]
     */
    addCommands(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    }

    /**
     * @param {Record<string, CommandLike | string>} commands
     */
    removeCommands(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    }

    /**
     * @param {Record<string, CommandLike | string>} keyList
     */
    bindKeys(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    }

    _buildKeyHash(command) {
        this.bindKey(command.bindKey, command);
    }

    /**
     * Accepts keys in the form ctrl+Enter or ctrl-Enter
     * keys without modifiers or shift only
     * @param {string} keys
     * @returns {{key: string, hashId: number} | false}
     */
    parseKeys(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    }

    /**
     * @param {number} hashId
     * @param {string} keyString
     * @returns {Command}
     */
    findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    }

    /**
     * @param {any} data
     * @param {number} hashId
     * @param {string} keyString
     * @param {number} keyCode
     * @returns {{command: string} | void}
     */
    handleKeyboard(data, hashId, keyString, keyCode) {
        if (keyCode < 0) return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }
        
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    }

    /**
     * @param {any} [editor]
     * @param {any} [data]
     * @returns {string}
     */
    getStatusText(editor, data) {
        return data.$keyChain || "";
    }

}

function getPosition(command) {
    return typeof command == "object" && command.bindKey
        && command.bindKey.position 
        || (command.isDefault ? -100 : 0);
}

class HashHandler extends MultiHashHandler {
    /**
     * @param {Record<string, CommandLike> | Command[]} [config]
     * @param {string} [platform]
     */
    constructor(config, platform) {
        super(config, platform);
        this.$singleCommand = true;
    }
}

HashHandler.call = function(thisArg, config, platform) {
    MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
};
MultiHashHandler.call = function(thisArg, config, platform) {
    MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
};

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;


/***/ }),

/***/ 69957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 * @typedef {import("../../ace-internal").Ace.KeyboardHandler} KeyboardHandler
 */
var keyUtil  = __webpack_require__(29451);
var event = __webpack_require__(19631);


class KeyBinding {
    /**
     * @param {Editor} editor
     */
    constructor(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        /**@type {(KeyboardHandler)[]}*/
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
    }

    /**
     * @param {KeyboardHandler} kb
     */
    setDefaultHandler(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    }

    /**
     * @param {KeyboardHandler} kb
     */
    setKeyboardHandler(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    }

    /**
     * @param {KeyboardHandler & {attach?: (editor: any) => void, detach?: (editor: any) => void;}} [kb]
     * @param {number} [pos]
     */
    addKeyboardHandler(kb, pos) {
        if (!kb)
            return;
        // @ts-ignore
        if (typeof kb == "function" && !kb.handleKeyboard)
            // @ts-ignore
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    }

    /**
     * @param {KeyboardHandler & {attach?: (editor: any) => void, detach?: (editor: any) => void;}} kb
     * @returns {boolean}
     */
    removeKeyboardHandler(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    }

    /**
     * @return {KeyboardHandler}
     */
    getKeyboardHandler() {
        return this.$handlers[this.$handlers.length - 1];
    }

    getStatusText() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    }

    $callKeyboardHandlers(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                // @ts-expect-error TODO: could be wrong arguments amount
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;

            // allow keyboardHandler to consume keys
            if (toExecute.command == "null") {
                success = true;
            } else {
                // @ts-expect-error //TODO: potential wrong arguments amount
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            // do not stop input events to not break repeating
            if (success && e && hashId != -1 &&
                toExecute["passEvent"] != true && toExecute.command["passEvent"] != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }

        if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
        }

        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);

        return success;
    }

    /**
     * @param {any} e
     * @param {number} hashId
     * @param {number} keyCode
     * @return {boolean}
     * @internal
     */
    onCommandKey(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    }

    /**
     * @param {string} text
     * @return {boolean}
     * @internal
     */
    onTextInput(text) {
        return this.$callKeyboardHandlers(-1, text);
    }

}

exports.$ = KeyBinding;


/***/ }),

/***/ 82984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var event = __webpack_require__(19631);
var nls = (__webpack_require__(76321).nls);
var useragent = __webpack_require__(74943);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var clipboard = __webpack_require__(65217);
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;
var HAS_FOCUS_ARGS = useragent.isChrome > 63;
var MAX_LINE_LENGTH = 400;

/**
 * 
 * @type {{[key: string]: any}}
 */
var KEYS = __webpack_require__(29451);
var MODS = KEYS.KEY_MODS;
var isIOS = useragent.isIOS;
var valueResetRegex = isIOS ? /\s/ : /\n/;
var isMobile = useragent.isMobile;

var TextInput;
TextInput= function(parentNode, host) {
    /**@type {HTMLTextAreaElement & {msGetInputContext?: () => {compositionStartOffset: number}, getInputContext?: () => {compositionStartOffset: number}}}*/
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", "false");

    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);

    var copied = false;
    var pasted = false;
    /**@type {(boolean|Object) & {context?: any, useTextareaForIME?: boolean, selectionStart?: number, markerRange?: any}}} */
    var inComposition = false;
    var sendingText = false;
    var tempStyle = '';
    
    if (!isMobile)
        text.style.fontSize = "1px";

    var commandMode = false;
    var ignoreFocusEvents = false;
    
    var lastValue = "";
    var lastSelectionStart = 0;
    var lastSelectionEnd = 0;
    var lastRestoreEnd = 0;
    var rowStart = Number.MAX_SAFE_INTEGER;
    var rowEnd = Number.MIN_SAFE_INTEGER;
    var numberOfExtraLines = 0;
    
    // FOCUS
    // ie9 throws error if document.activeElement is accessed too soon
    try { var isFocused = document.activeElement === text; } catch(e) {}

    // Set number of extra lines in textarea, some screenreaders
    // perform better with extra lines above and below in the textarea.
    this.setNumberOfExtraLines = function(number) {
        rowStart = Number.MAX_SAFE_INTEGER;
        rowEnd =  Number.MIN_SAFE_INTEGER;

        if (number < 0) {
            numberOfExtraLines = 0;
            return;
        }
        
        numberOfExtraLines = number;
    };

    this.setAriaLabel = function() {
        var ariaLabel = "";
        if (host.$textInputAriaLabel) {
            ariaLabel += `${host.$textInputAriaLabel}, `;
        }
        if(host.session) {
            var row = host.session.selection.cursor.row;
            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
        }
        text.setAttribute("aria-label", ariaLabel);
    };

    this.setAriaOptions = function(options) {
        if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
        } else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
        }
        if (options.role) {
            text.setAttribute("role", options.role);
        }     
        if (options.setLabel) {
            text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
            this.setAriaLabel();
        }
    };

    this.setAriaOptions({role: "textbox"});

    event.addListener(text, "blur", function(e) {
        if (ignoreFocusEvents) return;
        host.onBlur(e);
        isFocused = false;
    }, host);
    event.addListener(text, "focus", function(e) {
        if (ignoreFocusEvents) return;
        isFocused = true;
        if (useragent.isEdge) {
            // on edge focus event is fired even if document itself is not focused
            try {
                if (!document.hasFocus())
                    return;
            } catch(e) {}
        }
        host.onFocus(e);
        if (useragent.isEdge)
            setTimeout(resetSelection);
        else
            resetSelection();
    }, host);
    /**
     * 
     * @type {boolean | string}
     */
    this.$focusScroll = false;
    this.focus = function() {
        // On focusing on the textarea, read active row number to assistive tech.
        this.setAriaOptions({
            setLabel: host.renderer.enableKeyboardAccessibility
        });

        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });

        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        try {
            var isTransformed = text.getBoundingClientRect().top != 0;
        } catch(e) {
            // getBoundingClientRect on IE throws error if element is not in the dom tree
            return;
        }
        var ancestors = [];
        if (isTransformed) {
            var t = text.parentElement;
            while (t && t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute("ace_nocontext", "true");
                if (!t.parentElement && t.getRootNode)
                    t = t.getRootNode()["host"];
                else
                    t = t.parentElement;
            }
        }
        text.focus({ preventScroll: true });
        if (isTransformed) {
            ancestors.forEach(function(p) {
                p.removeAttribute("ace_nocontext");
            });
        }
        setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };
    
    host.on("beforeEndOperation", function() {
        var curOp = host.curOp;
        var commandName = curOp && curOp.command && curOp.command.name;
        if (commandName == "insertstring")
            return;
        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
        if (inComposition && isUserAction) {
            // exit composition from commands other than insertstring
            lastValue = text.value = "";
            onCompositionEnd();
        }
        // sync value of textarea
        resetSelection();
    });

    // if cursor changes position, we need to update the label with the correct row
    host.on("changeSelection", this.setAriaLabel);
    
    // Convert from row,column position to the linear position with respect to the current
    // block of lines in the textarea.
    var positionToSelection = function(row, column) {
        var selection = column;

        for (var i = 1; i <= row - rowStart && i < 2*numberOfExtraLines + 1; i++) {
            selection += host.session.getLine(row - i).length + 1;
        }
        return selection;
    };

    var resetSelection = isIOS
    ? function(value) {
        if (!isFocused || (copied && !value) || sendingText) return;
        if (!value) 
            value = "";
        var newValue = "\n ab" + value + "cde fg\n";
        if (newValue != text.value)
            text.value = lastValue = newValue;
        
        var selectionStart = 4;
        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));

        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
        }
        lastSelectionStart = selectionStart;
        lastSelectionEnd = selectionEnd;
    }
    : function() {
        if (inComposition || sendingText)
            return;
        // modifying selection of blured textarea can focus it (chrome mac/linux)
        if (!isFocused && !afterContextMenu)
            return;
        // see https://github.com/ajaxorg/ace/issues/2114
        // this prevents infinite recursion on safari 8
        inComposition = true;
        
        var selectionStart = 0;
        var selectionEnd = 0;
        var line = "";

        if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;

            // We keep 2*numberOfExtraLines + 1 lines in the textarea, if the new active row
            // is within the current block of lines in the textarea we do nothing. If the new row
            // is one row above or below the current block, move up or down to the next block of lines.
            // If the new row is further than 1 row away from the current block grab a new block centered 
            // around the new row.
            if (row === rowEnd + 1) {
                rowStart = rowEnd + 1;
                rowEnd = rowStart + 2*numberOfExtraLines;
            } else if (row === rowStart - 1) {
                rowEnd = rowStart - 1;
                rowStart = rowEnd - 2*numberOfExtraLines;
            } else if (row < rowStart - 1 || row > rowEnd + 1) {
                rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;
                rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2*numberOfExtraLines;
            }
            
            var lines = [];

            for (var i = rowStart; i <= rowEnd; i++) {
                lines.push(host.session.getLine(i));
            }
            
            line = lines.join('\n');

            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);
            
            if (range.start.row < rowStart) {
                var prevLine = host.session.getLine(rowStart - 1);
                selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;
                selectionEnd += prevLine.length + 1;
                line = prevLine + "\n" + line;
            }
            else if (range.end.row > rowEnd) {
                var nextLine = host.session.getLine(rowEnd + 1);
                selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;
                selectionEnd += line.length + 1;
                line = line + "\n" + nextLine;
            }
            else if (isMobile && row > 0) {
                line = "\n" + line;
                selectionEnd += 1;
                selectionStart += 1;
            }

            if (line.length > MAX_LINE_LENGTH) {
                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                    line = line.slice(0, MAX_LINE_LENGTH);
                } else {
                    line = "\n";
                    if (selectionStart == selectionEnd) {
                        selectionStart = selectionEnd = 0;
                    }
                    else {
                        selectionStart = 0;
                        selectionEnd = 1;
                    }
                }
            }
        
            var newValue = line + "\n\n";
            if (newValue != lastValue) {
                text.value = lastValue = newValue;
                lastSelectionStart = lastSelectionEnd = newValue.length;
            }
        }
        
        // contextmenu on mac may change the selection
        if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
        }
        // on firefox this throws if textarea is hidden
        if (
            lastSelectionEnd != selectionEnd 
            || lastSelectionStart != selectionStart 
            || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
        ) {
            try {
                text.setSelectionRange(selectionStart, selectionEnd);
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
            } catch(e){}
        }
        inComposition = false;
    };
    this.resetSelection = resetSelection;

    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length
            && text.value === lastValue && lastValue
            && text.selectionEnd !== lastSelectionEnd;
    };

    var onSelect = function(e) {
        if (inComposition)
            return;
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
        }
    };


    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb;};
    this.getInputHandler = function() {return inputHandler;};
    var afterContextMenu = false;
    
    var sendText = function(value, fromInput) {
        if (afterContextMenu)
            afterContextMenu = false;
        if (pasted) {
            resetSelection();
            if (value)
                host.onPaste(value);
            pasted = false;
            return "";
        } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
        
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
        
            var i = 0;
            while (extendLeft > 0 && lastValue[i] == value[i]) {
                i++;
                extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
            }
            restoreStart -= i-1;
            restoreEnd -= i-1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
                extendLeft = -endIndex;
                endIndex = 0;
            } 
            inserted = inserted.slice(0, endIndex);
            
            // composition update can be called without any change
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                return "";
            sendingText = true;
            
            // some android keyboards converts two spaces into sentence end, which is not useful for code
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
                inserted = "  ";
                shouldReset = true;
            }
            
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                host.onTextInput(inserted);
            } else {
                host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
            }
            sendingText = false;
            
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
        }
    };
    var onInput = function(e) {
        if (inComposition)
            return onCompositionUpdate();
        if (e && e.inputType) {
            if (e.inputType == "historyUndo") return host.execCommand("undo");
            if (e.inputType == "historyRedo") return host.execCommand("redo");
        }
        var data = text.value;
        var inserted = sendText(data, true);
        if (
            data.length > MAX_LINE_LENGTH + 100 
            || valueResetRegex.test(inserted)
            || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd
        ) {
            resetSelection();
        }
    };
    
    var handleClipboardData = function(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window["clipboardData"];
        if (!clipboardData || BROKEN_SETDATA)
            return;
        // using "Text" doesn't work on old webkit but ie needs it
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                // Safari 5 has clipboardData object, but does not handle setData()
                return clipboardData.setData(mime, data) !== false;
            } else {
                return clipboardData.getData(mime);
            }
        } catch(e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            if (isIOS) {
                resetSelection(data);
                copied = data;
                setTimeout(function () {
                    copied = false;
                }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    
    var onCut = function(e) {
        doCopy(e, true);
    };
    
    var onCopy = function(e) {
        doCopy(e, false);
    };
    
    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (clipboard.pasteCancelled())
            return;
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, function(e, hashId, keyCode) {
        // ignore command events during composition as they will 
        // either be handled by ime itself or fired again after ime end
        if (inComposition) return;
        return host.onCommandKey(e, hashId, keyCode);
    }, host);

    event.addListener(text, "select", onSelect, host);
    event.addListener(text, "input", onInput, host);

    event.addListener(text, "cut", onCut, host);
    event.addListener(text, "copy", onCopy, host);
    event.addListener(text, "paste", onPaste, host);


    // Opera has no clipboard events
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        }, host);
    }


    // COMPOSITION
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly) 
            return;
        
        inComposition = {};

        if (commandMode)
            return;
        
        if (e.data)
            inComposition.useTextareaForIME = false;
        
        setTimeout(onCompositionUpdate, 0);
        host._signal("compositionStart");
        host.on("mousedown", cancelComposition);
        
        var range = host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        inComposition.markerRange = range;
        inComposition.selectionStart = lastSelectionStart;
        host.onCompositionStart(inComposition);
        
        if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
        }
        else {
            if (text.msGetInputContext)
                inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
                inComposition.context = text.getInputContext();
        }
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        if (commandMode)
            return cancelComposition();
        
        if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
        }
        else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
                if (inComposition.context) {
                    inComposition.markerRange.start.column = inComposition.selectionStart
                        = inComposition.context.compositionStartOffset;
                }
                inComposition.markerRange.end.column = inComposition.markerRange.start.column
                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        inComposition = false;
        host.onCompositionEnd();
        host.off("mousedown", cancelComposition);
        // note that resetting value of textarea at this point doesn't always work
        // because textarea value can be silently restored
        if (e) onInput();
    };
    

    function cancelComposition() {
        // force end composition
        ignoreFocusEvents = true;
        text.blur();
        text.focus();
        ignoreFocusEvents = false;
    }

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
    
    function onKeyup(e) {
        // workaround for a bug in ie where pressing esc silently moves selection out of textarea
        if (e.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
                lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
        }
        syncComposition();
    }

    event.addListener(text, "compositionstart", onCompositionStart, host);
    event.addListener(text, "compositionupdate", onCompositionUpdate, host);
    event.addListener(text, "keyup", onKeyup, host);
    event.addListener(text, "keydown", syncComposition, host);
    event.addListener(text, "compositionend", onCompositionEnd, host);

    this.getElement = function() {
        return text;
    };
    
    // allows to ignore composition (used by vim keyboard handler in the normal mode)
    // this is useful on mac, where with some keyboard layouts (e.g swedish) ^ starts composition
    this.setCommandMode = function(value) {
        commandMode = value;
        text.readOnly = false;
    };
    
    this.setReadOnly = function(readOnly) {
        if (!commandMode)
            text.readOnly = readOnly;
    };

    this.setCopyWithEmptySelection = function(value) {
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection();
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };
    
    this.moveToMouse = function(e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + (useragent.isIE ? "opacity:0.1;" : "")
            + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        host.renderer.$isMousePressed = true;

        clearTimeout(closeTimeout);
        // on windows context menu is opened after mouseup
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
                host.renderer.$moveTextAreaToCursor();
        }, 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu, host);
    event.addListener(text, "mousedown", function(e) {
        e.preventDefault();
        onContextMenuClose();
    }, host);
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
    event.addListener(text, "contextmenu", onContextMenu, host);
    
    if (isIOS)
        addIosSelectionHandler(parentNode, host, text);

    function addIosSelectionHandler(parentNode, host, text) {
        var typingResetTimeout = null;
        var typing = false;

        text.addEventListener("keydown", function (e) {
            if (typingResetTimeout) clearTimeout(typingResetTimeout);
            typing = true;
        }, true);

        text.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        }, true);
    
        // IOS doesn't fire events for arrow keys, but this unique hack changes everything!
        var detectArrowKeys = function(e) {
            if (document.activeElement !== text) return;
            if (typing || inComposition || host.$mouseHandler.isMousePressed) return;

            if (copied) {
                return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            
            var key = null;
            var modifier = 0;
            // console.log(selectionStart, selectionEnd);
            if (selectionStart == 0) {
                key = KEYS.up;
            } else if (selectionStart == 1) {
                key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                key = KEYS.left;
                modifier = MODS.option;
            } else if (
                selectionStart < lastSelectionStart
                || (
                    selectionStart == lastSelectionStart 
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd
                )
            ) {
                key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                key = KEYS.right;
                modifier = MODS.option;
            } else if (
                selectionEnd > lastSelectionEnd
                || (
                    selectionEnd == lastSelectionEnd 
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd
                )
            ) {
                key = KEYS.right;
            }
            
            if (selectionStart !== selectionEnd)
                modifier |= MODS.shift;

            if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result && host.commands) {
                    key = KEYS.keyCodeToString(key);
                    var command = host.commands.findKeyCommand(modifier, key);
                    if (command)
                        host.execCommand(command);
                }
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                resetSelection("");
            }
        };
        // On iOS, "selectionchange" can only be attached to the document object...
        document.addEventListener("selectionchange", detectArrowKeys);
        host.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
        });
    }

    this.destroy = function() {
        if (text.parentElement)
            text.parentElement.removeChild(text);
    };
};

exports.k = TextInput;
__webpack_unused_export__ = function(_isMobile, _isIOS) {
    isMobile = _isMobile;
    isIOS = _isIOS;
};


/***/ }),

/***/ 50643:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 */
var dom = __webpack_require__(71435);


class Cursor {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);

        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;

        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateOpacity.bind(this);
    }

    /**
     * @param {boolean} [val]
     */
    $updateOpacity(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
    }

    $startCssAnimation() {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.animationDuration = this.blinkInterval + "ms";

        this.$isAnimating = true;
        setTimeout(function() {
            if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
            }
        }.bind(this));
    }
    
    $stopCssAnimation() {
        this.$isAnimating = false;
        dom.removeCssClass(this.element, "ace_animate-blinking");
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        this.session = session;
    }

    /**
     * @param {boolean} blinking
     */
    setBlinking(blinking) {
        if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
        }
    }

    /**
     * @param {number} blinkInterval
     */
    setBlinkInterval(blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    }

    /**
     * @param {boolean} smoothBlinking
     */
    setSmoothBlinking(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
        }
    }

    addCursor() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    }

    removeCursor() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    }

    hideCursor() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    }

    showCursor() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    }

    restartTimer() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();

        if (this.smoothBlinking) {
            this.$isSmoothBlinking = false;
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
        }

        if (this.smoothBlinking) {
            this.$isSmoothBlinking = true;
            setTimeout(function() {
                if (this.$isSmoothBlinking) {
                    dom.addCssClass(this.element, "ace_smooth-blinking");
                }
            }.bind(this));
        }
        
        if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
        } else {
            var blink = /**@this{Cursor}*/function(){
                this.timeoutId = setTimeout(function() {
                    update(false);
                }, 0.6 * this.blinkInterval);
            }.bind(this);
    
            this.intervalId = setInterval(function() {
                update(true);
                blink();
            }, this.blinkInterval);
            blink();
        }
    }

    /**
     * @param {import("../../ace-internal").Ace.Point} [position]
     * @param {boolean} [onScreen]
     */
    getPixelPosition(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);

        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    }

    isCursorInView(pixelPos, config) {
        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
    }

    update(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style = element.style;
            
            if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                    dom.setStyle(style, "display", "none");
                } else {
                    dom.setStyle(style, "display", "block");
                    dom.translate(element, pixelPos.left, pixelPos.top);
                    dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                    dom.setStyle(style, "height", config.lineHeight + "px");
                }
            } else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);

        // cache for textarea and gutter highlight
        this.$pixelPos = pixelPos;
        this.restartTimer();
    }

    /**
     * @param {boolean} overwrite
     */
    $setOverwrite(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    }

    destroy() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    }

}

Cursor.prototype.$padding = 0;
Cursor.prototype.drawCursor = null;


exports.b = Cursor;


/***/ }),

/***/ 31079:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

class Decorator {
    constructor(parent, renderer) {
        this.canvas = dom.createElement("canvas");
        this.renderer = renderer;
        this.pixelRatio = 1;
        this.maxHeight = renderer.layerConfig.maxHeight;
        this.lineHeight = renderer.layerConfig.lineHeight;
        this.canvasHeight = parent.parent.scrollHeight;
        this.heightRatio = this.canvasHeight / this.maxHeight;
        this.canvasWidth = parent.width;
        this.minDecorationHeight = (2 * this.pixelRatio) | 0;
        this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;

        this.canvas.width = this.canvasWidth;
        this.canvas.height = this.canvasHeight;
        this.canvas.style.top = 0 + "px";
        this.canvas.style.right = 0 + "px";
        this.canvas.style.zIndex = 7 + "px";
        this.canvas.style.position = "absolute";
        this.colors = {};
        this.colors.dark = {
            "error": "rgba(255, 18, 18, 1)",
            "warning": "rgba(18, 136, 18, 1)",
            "info": "rgba(18, 18, 136, 1)"
        };

        this.colors.light = {
            "error": "rgb(255,51,51)",
            "warning": "rgb(32,133,72)",
            "info": "rgb(35,68,138)"
        };

        parent.element.appendChild(this.canvas);

    }
    
    $updateDecorators(config) {
        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;
        if (config) {
            this.maxHeight = config.maxHeight;
            this.lineHeight = config.lineHeight;
            this.canvasHeight = config.height;
            var allLineHeight = (config.lastRow + 1) * this.lineHeight;
            if (allLineHeight < this.canvasHeight) {
                this.heightRatio = 1;
            }
            else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
            }
        }
        var ctx = this.canvas.getContext("2d");

        function compare(a, b) {
            if (a.priority < b.priority) return -1;
            if (a.priority > b.priority) return 1;
            return 0;
        }

        var annotations = this.renderer.session.$annotations;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (annotations) {
            var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
            };
            annotations.forEach(function (item) {
                item.priority = priorities[item.type] || null;
            });
            annotations = annotations.sort(compare);
            var foldData = this.renderer.session.$foldData;

            for (let i = 0; i < annotations.length; i++) {
                let row = annotations[i].row;
                let compensateFold = this.compensateFoldRows(row, foldData);
                let currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                let y1 = Math.round(((row - compensateFold) * this.lineHeight * this.heightRatio));
                let y2 = Math.round((((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio));
                const height = y2 - y1;
                if (height < this.minDecorationHeight) {
                    let yCenter = ((y1 + y2) / 2) | 0;
                    if (yCenter < this.halfMinDecorationHeight) {
                        yCenter = this.halfMinDecorationHeight;
                    }
                    else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                        yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                    }
                    y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                    y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                }

                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
            }
        }
        var cursor = this.renderer.session.selection.getCursor();
        if (cursor) {
            let compensateFold = this.compensateFoldRows(cursor.row, foldData);
            let currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, currentY, this.canvasWidth, 2);
        }

    }

    compensateFoldRows(row, foldData) {
        let compensateFold = 0;
        if (foldData && foldData.length > 0) {
            for (let j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                    compensateFold += row - foldData[j].start.row;
                }
                else if (row >= foldData[j].end.row) {
                    compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
            }
        }
        return compensateFold;
    }
}

oop.implement(Decorator.prototype, EventEmitter);

exports.K = Decorator;


/***/ }),

/***/ 22150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

var CHAR_COUNT = 512;
var USE_OBSERVER = typeof ResizeObserver == "function";
var L = 200;

class FontMetrics {

    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);

        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);

        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);


        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);

        this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);

        this.$characterSize = {width: 0, height: 0};


        if (USE_OBSERVER)
            this.$addObserver();
        else
            this.checkForSizeChanges();
    }
    
    $setMeasureNodeStyles(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    }

    /**
     * @param size
     */
    checkForSizeChanges(size) {
        if (size === undefined)
            size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    }

    $addObserver() {
        var self = this;
        this.$observer = new window.ResizeObserver(function(e) {
            // e[0].contentRect is broken on safari when zoomed;
            self.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
    }

    /**
     * @return {number}
     */
    $pollSizeChanges() {
        if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
        var self = this;
        
        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self.checkForSizeChanges();
            event.onIdle(cb, 500);
        }, 500);
    }

    /**
     * @param {boolean} val
     */
    setPolling(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    }

    $measureSizes(node) {
        var size = {
            height: (node || this.$measureNode).clientHeight,
            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
        };
        
        // Size and width can be null if the editor is not visible or
        // detached from the document
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    }

    $measureCharWidth(ch) {
        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    }
    
    getCharacterWidth(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    }

    destroy() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
            this.$observer.disconnect();
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    }

    
    $getZoom(element) {
        if (!element || !element.parentElement) return 1;
        return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
    }
    
    $initTransformMeasureNodes() {
        var t = function(t, l) {
            return ["div", {
                style: "position: absolute;top:" + t + "px;left:" + l + "px;"
            }];
        };
        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
    }
    // general transforms from element coordinates x to screen coordinates u have the form
    // | m1[0] m2[0] t[0] |   | x |       | u |
    // | m1[1] m2[1] t[1] | . | y |  == k | v |
    // | h[0]  h[1]  1    |   | 1 |       | 1 |
    // this function finds the coeeficients of the matrix using positions of four points
    //  
    transformCoordinates(clientPos, elPos) {
        if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
        }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function mul(a, b) { return [a * b[0], a * b[1]]; }

        if (!this.els)
            this.$initTransformMeasureNodes();
        
        function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
        }

        var a = p(this.els[0]);
        var b = p(this.els[1]);
        var c = p(this.els[2]);
        var d = p(this.els[3]);

        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));

        var m1 = mul(1 + h[0], sub(b, a));
        var m2 = mul(1 + h[1], sub(c, a));
        
        if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return  add(mul(1 / k / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
        return mul(L, f);
    }
    
}
FontMetrics.prototype.$characterSize = {width: 0, height: 0};

oop.implement(FontMetrics.prototype, EventEmitter);

exports.X = FontMetrics;


/***/ }),

/***/ 6166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Lines = (__webpack_require__(6406)/* .Lines */ .q);
var nls = (__webpack_require__(76321).nls);

class Gutter{
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);

        this.gutterWidth = 0;

        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);

        this.$lines = new Lines(this.element);
        this.$lines.$offsetCoefficient = 1;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        if (this.session)
            this.session.off("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    }

    /**
     * @param {number} row
     * @param {string} className
     */
    addGutterDecoration(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    }

    /**
     * @param {number} row
     * @param {string} className
     */
    removeGutterDecoration(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    }

    /**
     * @param {any[]} annotations
     */
    setAnnotations(annotations) {
        // iterate over sparse array
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: [], type: [], displayText: []};
           
            var annoText = annotation.text;
            var displayAnnoText = annotation.text;
            var annoType = annotation.type;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1){
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
                rowInfo.displayText.push(displayAnnoText);
            }

            var className = annotation.className;
            if (className) {
                rowInfo.className = className;
            } else if (annoType === "error") {
                rowInfo.className = " ace_error";
            } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_security";
            } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_warning";
            } else if (annoType === "info" && !rowInfo.className) {
                rowInfo.className = " ace_info";
            } else if (annoType === "hint" && !rowInfo.className) {
                rowInfo.className = " ace_hint";
            }
        }
    }

    /**
     * @param {import("../../ace-internal").Ace.Delta} delta
     */
    $updateAnnotations(delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
            // do nothing
        } else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        this.config = config;
        
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
            
        this.oldLastRow = lastRow;
        this.config = config;
        
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
            
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;

        var cell = null;
        var index = -1;
        var row = firstRow;
        
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                    this.$lines.pop();
                    
                break;
            }

            cell = this.$lines.get(++index);
            if (cell) {
                cell.row = row;
            } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
            }

            this.$renderCell(cell, config, fold, row);
            row++;
        }
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    }

    /**
     * @param {LayerConfig} config
     */
    $updateGutterWidth(config) {
        var session = this.session;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
        
        if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineText, config)
            : lastLineText.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            /**@type{any}*/(this.element.parentNode).style.width = 
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._signal("changeGutterWidth", gutterWidth);
        }
    }
    
    $updateCursorRow() {
        if (!this.$highlightGutterLine)
            return;
            
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
            return;
        
        this.$cursorRow = position.row;
    }
    
    updateLineHighlight() {
        if (!this.$highlightGutterLine)
            return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;

        if (this.$cursorCell && this.$cursorCell.row == row)
            return;
        if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                    var fold = this.session.getFoldLine(this.$cursorRow);
                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                        cell = cells[i - 1];
                    else
                        break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
            }
        }
    }

    /**
     * @param {LayerConfig} config
     */
    scrollLines(config) {
        var oldConfig = this.config;
        this.config = config;
        
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        
        this.$lines.moveContainer(config);

        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        
        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldLastRow > lastRow)
            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (lastRow > oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        
        this.updateLineHighlight();
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $renderLines(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);

            row++;
        }
        return fragment;
    }


    /**
     * @param {any} cell
     * @param {LayerConfig} config
     * @param {import("../../ace-internal").Ace.IRange | undefined} fold
     * @param {number} row
     */
    $renderCell(cell, config, fold, row) {
        var element = cell.element;
        
        var session = this.session;
        
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];
        var annotationNode = element.childNodes[2];
        var annotationIconNode = annotationNode.firstChild;

        var firstLineNumber = session.$firstLineNumber;
        
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        
        var lineHeight = config.lineHeight + "px";

        var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
        var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
        
        var rowText = (gutterRenderer
            ? gutterRenderer.getText(session, row)
            : row + firstLineNumber).toString();

        if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                    if (this.$cursorCell)
                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                    this.$cursorCell = cell;
                }
            }
        }
        
        if (breakpoints[row])
            className += breakpoints[row];
        if (decorations[row])
            className += decorations[row];
        if (this.$annotations[row] && row !== foldStart)
            className += this.$annotations[row].className;

        if (foldWidgets) {
            var c = foldWidgets[row];
            // check if cached value is invalidated and we need to recompute
            if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
        }

        if (c) {
            var foldClass = "ace_fold-widget ace_" + c;
            var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
            if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;

                for (var i = row + 1; i <= fold.end.row; i++) {
                    if (!this.$annotations[i]) continue;

                    if (this.$annotations[i].className === " ace_error") {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_error_fold";
                        break;
                    }

                    if (this.$annotations[i].className === " ace_security") {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_security_fold";
                    } else if (
                        this.$annotations[i].className === " ace_warning" &&
                        foldAnnotationClass !== " ace_security_fold"
                    ) {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_warning_fold";
                    }
                }

                className += foldAnnotationClass;
            }
            else
                foldClass += " ace_open";
            if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;

            dom.setStyle(foldWidget.style, "height", lineHeight);
            dom.setStyle(foldWidget.style, "display", "inline-block");

            // Set a11y properties.
            foldWidget.setAttribute("role", "button");
            foldWidget.setAttribute("tabindex", "-1");
            var foldRange = session.getFoldWidgetRange(row);

            // getFoldWidgetRange is optional to be implemented by fold modes, if not available we fall-back.
            if (foldRange)
                foldWidget.setAttribute(
                    "aria-label",
                    nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                        foldRange.start.row + 1,
                        foldRange.end.row + 1
                    ])
                );
            else {
                if (fold)
                    foldWidget.setAttribute(
                        "aria-label",
                        nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                            fold.start.row + 1,
                            fold.end.row + 1
                        ])
                    );
                else
                    foldWidget.setAttribute(
                        "aria-label",
                        nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1])
                    );
            }

            if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
            } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
            }
        } else {
            if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
            }
        }

        if (annotationInFold && this.$showFoldedAnnotations){
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;
            annotationIconNode.className += foldAnnotationClass;

            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch(foldAnnotationClass) {
                case " ace_error_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                    break;

                case " ace_security_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                    break;

                case " ace_warning_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                    break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
        }
        else if (this.$annotations[row]){
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;

            if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
            else 
                element.classList.add(this.$annotations[row].className.replace(" ", ""));

            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch(this.$annotations[row].className) {
                case " ace_error":
                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                    break;

                case " ace_security":
                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                    break;

                case " ace_warning":
                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                    break;

                case " ace_info":
                    ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                    break;

                case " ace_hint":
                    ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                    break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
        }
        else {
            dom.setStyle(annotationNode.style, "display", "none");
            annotationNode.removeAttribute("aria-label");
            annotationNode.removeAttribute("role");
            annotationNode.setAttribute("tabindex", "0");
        }
        if (rowText !== textNode.data) {
            textNode.data = rowText;
        } 

        if (element.className != className)
            element.className = className;
        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
        
        cell.text = rowText;

        // If there are no annotations or fold widgets in the gutter cell, hide it from assistive tech.
        if (annotationNode.style.display === "none" && foldWidget.style.display === "none")
            cell.element.setAttribute("aria-hidden", true);
        else
            cell.element.setAttribute("aria-hidden", false);
        
        return cell;
    }

    /**
     * @param {boolean} highlightGutterLine
     */
    setHighlightGutterLine(highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
    }

    /**
     * @param {boolean} show
     */
    setShowLineNumbers(show) {
        this.$renderer = !show && {
            getWidth: function() {return 0;},
            getText: function() {return "";}
        };
    }
    
    getShowLineNumbers() {
        return this.$showLineNumbers;
    }

    /**
     * @param {boolean} [show]
     */
    setShowFoldWidgets(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    }
    
    getShowFoldWidgets() {
        return this.$showFoldWidgets;
    }

    $computePadding() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(/**@type{Element}*/(this.element.firstChild));
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
            + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
            + (parseInt(style.paddingRight) || 0);
        return this.$padding;
    }

    /**
     * @param {{ x: number; }} point
     */
    getRegion(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    }

}

Gutter.prototype.$fixedWidth = false;
Gutter.prototype.$highlightGutterLine = true;
Gutter.prototype.$renderer = "";
Gutter.prototype.$showLineNumbers = true;
Gutter.prototype.$showFoldWidgets = true;

oop.implement(Gutter.prototype, EventEmitter);

function onCreateCell(element) {
    var textNode = document.createTextNode('');
    element.appendChild(textNode);
    
    var foldWidget = dom.createElement("span");
    element.appendChild(foldWidget);

    var annotationNode = dom.createElement("span");
    element.appendChild(annotationNode);

    var annotationIconNode = dom.createElement("span");
    annotationNode.appendChild(annotationIconNode);
    
    return element;
}

exports.W = Gutter;


/***/ }),

/***/ 6406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
var dom = __webpack_require__(71435);

class Lines {
    /**
     * @param {HTMLElement} element
     * @param {number} [canvasHeight]
     */
    constructor(element, canvasHeight) {
        this.element = element;
        this.canvasHeight = canvasHeight || 500000;
        this.element.style.height = (this.canvasHeight * 2) + "px";

        this.cells = [];
        this.cellCache = [];
        this.$offsetCoefficient = 0;
    }

    /**
     * @param {LayerConfig} config
     */
    moveContainer(config) {
        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
    }

    /**
     * @param {LayerConfig} oldConfig
     * @param {LayerConfig} newConfig
     */
    pageChanged(oldConfig, newConfig) {
        return (
            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)
        );
    }

    /**
     * @param {number} row
     * @param {Partial<LayerConfig>} config
     * @param {EditSession} session
     */
    computeLineTop(row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - (screenPage * this.canvasHeight);
    }

    /**
     * @param {number} row
     * @param {LayerConfig} config
     * @param {EditSession} session
     */
    computeLineHeight(row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
    }
    
    getLength() {
        return this.cells.length;
    }

    /**
     * @param {number} index
     */
    get(index) {
        return this.cells[index];
    }
    
    shift() {
        this.$cacheCell(this.cells.shift());
    }
    
    pop() {
        this.$cacheCell(this.cells.pop());
    }
    
    push(cell) {
        if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
        } else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
        }
    }
    
    unshift(cell) {
        if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
            else
                this.element.appendChild(fragment);
        } else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement("afterbegin", cell.element);
        }
    }
    
    last() {
        if (this.cells.length)
            return this.cells[this.cells.length-1];
        else
            return null;
    }
    
    $cacheCell(cell) {
        if (!cell)
            return;
            
        cell.element.remove();
        this.cellCache.push(cell);
    }
    
    createCell(row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
            var element = dom.createElement("div");
            if (initElement)
                initElement(element);
            
            this.element.appendChild(element);
            
            cell = {
                element: element,
                text: "",
                row: row
            };
        }
        cell.row = row;
        
        return cell;
    }
    
}

exports.q = Lines;


/***/ }),

/***/ 12187:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var dom = __webpack_require__(71435);


class Marker {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        this.session = session;
    }

    /**
     * @param {{ [x: number]: import("../../ace-internal").Ace.MarkerLike; }} markers
     */
    setMarkers(markers) {
        this.markers = markers;
    }

    /**
     * @param {string} className
     * @param {string} css
     */
    elt(className, css) {
        /**@type {any}*/
        var x = this.i != -1 && this.element.childNodes[this.i];
        if (!x) {
            x = document.createElement("div");
            this.element.appendChild(x);
            this.i = -1;
        } else {
            this.i++;
        }
        x.style.cssText = css;
        x.className = className;
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        if (!config) return;

        this.config = config;

        this.i = 0;
        var html;
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        if (this.i !=-1) {
            while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
        }
    }

    /**
     * @param {number} row
     * @param {Partial<LayerConfig>} layerConfig
     */
    $getTop(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    }


    // Draws a marker, which spans a range of text on multiple lines 
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} layerConfig
     * @param {string} [extraStyle]
     */
    drawTextMarker(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0; 
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, 
                clazz + (row == start  ? " ace_start" : "") + " ace_br"
                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                layerConfig, row == end ? 0 : 1, extraStyle);
        }
    }

    // Draws a multi line marker, where lines span the full width
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {LayerConfig} config
     * @param {string} [extraStyle]
     */
    drawMultiLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        // from selection start to the end of the line
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
           var range1 = range.clone();
           range1.end.row = range1.start.row;
           range1.end.column = this.session.getLine(range1.start.row).length;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        } else {
            this.elt(
                clazz + " ace_br1 ace_start",
                "height:"+ height+ "px;"+ "right:" + padding + "px;"+ "top:"+top+ "px;left:"+ left+ "px;" + (extraStyle || "")
            );
        }
        // from start of the last line to the selection end
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
           var range1 = range.clone();
           range1.start.row = range1.end.row;
           range1.start.column = 0;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        } else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;

            this.elt(
                clazz + " ace_br12",
                "height:"+ height+ "px;"+
                "width:"+ width+ "px;"+
                "top:"+ top+ "px;"+
                "left:"+ padding+ "px;"+ (extraStyle || "")
            );
        }
        // all the complete lines
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        this.elt(
            clazz + (radiusClass ? " ace_br" + radiusClass : ""),
            "height:"+ height+ "px;"+
            "right:" + padding + "px;"+
            "top:"+ top+ "px;"+
            "left:"+ padding+ "px;"+ (extraStyle || "")
        );
    }

    // Draws a marker which covers part or whole width of a single screen line
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {number} [extraLength]
     * @param {string} [extraStyle]
     */
    drawSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "width:"+ width+ "px;"+
            "top:"+ top+ "px;"+
            "left:"+ left+ "px;"+ (extraStyle || "")
        );
    }

    // Draws Bidi marker which covers part or whole width of a single screen line
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {number} extraLength
     * @param {string} extraStyle
     */
    drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

        selections.forEach(function(selection) {
            this.elt(
                clazz,
                "height:" + height + "px;" +
                "width:" + (selection.width + (extraLength || 0)) + "px;" +
                "top:" + top + "px;" +
                "left:" + (padding + selection.left) + "px;" + (extraStyle || "")
            );
        }, this);
    }

    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {undefined} [extraStyle]
     */
    drawFullLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    }

    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {undefined} [extraStyle]
     */
    drawScreenLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    }

}

Marker.prototype.$padding = 0;

function getBorderClass(tl, tr, br, bl) {
    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
}

exports.p = Marker;


/***/ }),

/***/ 10694:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 * @typedef {import("../edit_session").EditSession} EditSession
 */
var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var Lines = (__webpack_require__(6406)/* .Lines */ .q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var nls = (__webpack_require__(76321).nls);
const isTextToken = (__webpack_require__(41109)/* .isTextToken */ .t);

class Text {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.dom = dom;
        this.element = this.dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
        this.$lines = new Lines(this.element);
    }
    
    $updateEolChar() {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
        this.element.style.margin = "0 " + padding + "px";
    }
    
    /**
     * @returns {number}
     */
    getLineHeight() {
        return this.$fontMetrics.$characterSize.height || 0;
    }

    /**
     * @returns {number}
     */
    getCharacterWidth() {
        return this.$fontMetrics.$characterSize.width || 0;
    }

    /**
     * @param {any} measure
     */
    $setFontMetrics(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize",
            /**
             * @this {Text}
             */
            function (e) {
                this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    }

    checkForSizeChanges() {
        this.$fontMetrics.checkForSizeChanges();
    }
    $pollSizeChanges() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        /**@type {EditSession}*/
        this.session = session;
        if (session)
            this.$computeTabString();
    }

    /**
     * @param {string} showInvisibles
     */
    setShowInvisibles(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == "string") {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
        } else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
    }

    /**
     * @param {boolean} display
     */
    setDisplayIndentGuides(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    }

    /**
     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        if (this.$highlightIndentGuides === highlight) return false;

        this.$highlightIndentGuides = highlight;
        return highlight;
    }
    
    $computeTabString() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        /**@type{any}*/var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
            } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
            var spaceContent = this.showSpaces
                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                : lang.stringRepeat(" ", this.tabSize);

            var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
            var tabContent = this.showTabs
                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                : spaceContent;

            var span = this.dom.createElement("span");
            span.className = className + spaceClass;
            span.textContent = spaceContent;
            this.$tabStrings[" "] = span;

            var span = this.dom.createElement("span");
            span.className = className + tabClass;
            span.textContent = tabContent;
            this.$tabStrings["\t"] = span;
        }
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    updateLines(config, firstRow, lastRow) {
        // Due to wrap line changes there can be new lines if e.g.
        // the line to updated wrapped in the meantime.
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            return this.update(config);
        }

        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var heightChanged = false;
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            /**@type{any}*/var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(
                    lineElement, row, row == foldStart ? foldLine : false
                );

                if (heightChanged)
                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";

                var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                if (lineElement.style.height != height) {
                    heightChanged = true;
                    lineElement.style.height = height;
                }
            }
            row++;
        }
        if (heightChanged) {
            while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
        }
    }

    /**
     * @param {LayerConfig} config
     */
    scrollLines(config) {
        var oldConfig = this.config;
        this.config = config;

        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);

        this.$lines.moveContainer(config);

        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;

        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (config.lastRow > oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
        this.$highlightIndentGuide();
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $renderLinesFragment(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var line = this.$lines.createCell(row, config, this.session);

            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");

            // Get the tokens per line as there might be some lines in between
            // beeing folded.
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);

            if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
            } else {
                lineEl.className = "ace_line";
            }
            fragment.push(line);

            row++;
        }
        return fragment;
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        this.$lines.moveContainer(config);

        this.config = config;

        var firstRow = config.firstRow;
        var lastRow = config.lastRow;

        var lines = this.$lines;
        while (lines.getLength())
            lines.pop();

        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
    }

    $renderToken(parent, screenColumn, token, value) {
        var self = this;
        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;

        var valueFragment = this.dom.createFragment(this.element);

        var m;
        var i = 0;
        while (m = re.exec(value)) {
            var tab = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];

            if (!self.showSpaces && simpleSpace)
                continue;

            var before = i != m.index ? value.slice(i, m.index) : "";

            i = m.index + m[0].length;

            if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }

            if (tab) {
                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
            } else if (simpleSpace) {
                if (self.showSpaces) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                    valueFragment.appendChild(span);
                } else {
                    valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
            } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
            } else if (cjkSpace) {
                // U+3000 is both invisible AND full-width, so must be handled uniquely
                screenColumn += 1;

                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
            } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
            }
        }

        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));

        if (!isTextToken(token.type)) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var span = this.dom.createElement("span");
            if (token.type == "fold"){
                span.style.width = (token.value.length * this.config.characterWidth) + "px";
                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
            }

            span.className = classes;
            span.appendChild(valueFragment);

            parent.appendChild(span);
        }
        else {
            parent.appendChild(valueFragment);
        }

        return screenColumn + value.length;
    }

    renderIndentGuide(parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            var count = cols/this.tabSize;
            for (var i=0; i<count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        } else if (value[0] == "\t") {
            for (var i=0; i<cols; i++) {
                parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        this.$highlightIndentGuide();
        return value;
    }

    $highlightIndentGuide() {
        if (!this.$highlightIndentGuides || !this.displayIndentGuides) return;
        /**@type {{ indentLevel?: number; start?: number; end?: number; dir?: number; }}*/
        this.$highlightIndentGuideMarker = {
            indentLevel: undefined,
            start: undefined,
            end: undefined,
            dir: undefined
        };
        var lines = this.session.doc.$lines;
        if (!lines) return;

        var cursor = this.session.selection.getCursor();
        var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
        this.$highlightIndentGuideMarker = {
            indentLevel: elementIndentLevel,
            start: cursor.row
        };

        var bracketHighlight = this.session.$bracketHighlight;
        if (bracketHighlight) {
            var ranges = this.session.$bracketHighlight.ranges;
            for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.end = ranges[i].start.row;
                    if (cursor.row > ranges[i].start.row) {
                        this.$highlightIndentGuideMarker.dir = -1;
                    }
                    else {
                        this.$highlightIndentGuideMarker.dir = 1;
                    }
                    break;
                }
            }
        }

        if (!this.$highlightIndentGuideMarker.end) {
            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                    var line = lines[i];
                    var currentIndent = /^\s*/.exec(line)[0].length;
                    if (line !== '') {
                        this.$highlightIndentGuideMarker.end = i;
                        if (currentIndent <= initialIndent) break;
                    }
                }
            }
        }

        this.$renderHighlightIndentGuide();
    }

    $clearActiveIndentGuide() {
        var cells = this.$lines.cells;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            var childNodes = cell.element.childNodes;
            if (childNodes.length > 0) {
                for (var j = 0; j < childNodes.length; j++) {
                    if (childNodes[j].classList && childNodes[j].classList.contains("ace_indent-guide-active")) {
                        childNodes[j].classList.remove("ace_indent-guide-active");
                        break;
                    }
                }
            }
        }
    }

    $setIndentGuideActive(cell, indentLevel) {
        var line = this.session.doc.getLine(cell.row);
        if (line !== "") {
            var childNodes = cell.element.childNodes;
            if (childNodes) {
                let node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide")) node.classList.add(
                    "ace_indent-guide-active");
            }
        }
    }

    $renderHighlightIndentGuide() {
        if (!this.$lines) return;
        var cells = this.$lines.cells;
        this.$clearActiveIndentGuide();
        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
        if (indentLevel !== 0) {
            if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start
                        + 1) {
                        if (cell.row >= this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
            else {
                for (var i = cells.length - 1; i >= 0; i--) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                        if (cell.row <= this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
        }
    }

    $createLineElement(parent) {
        var lineEl = this.dom.createElement("div");
        lineEl.className = "ace_line";
        lineEl.style.height = this.config.lineHeight + "px";

        return lineEl;
    }

    $renderWrappedLine(parent, tokens, splits) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    lineEl = this.$createLineElement();
                    parent.appendChild(lineEl);

                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn, token, value
                    );
                }
            }
        }

        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
    }

    $renderSimpleLine(parent, tokens) {
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                    continue;
            }
            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
        }
    }

    $renderOverflowMessage(parent, screenColumn, token, value, hide) {
        token && this.$renderToken(parent, screenColumn, token,
            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));

        var overflowEl = this.dom.createElement("span");
        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";

        parent.appendChild(overflowEl);
    }

    // row is either first row of foldline or not in fold
    $renderLine(parent, row, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);

        var lastLineEl = parent;
        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
            } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                    lastLineEl = this.$createLineElement();
                    parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
            }
        } else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
        }

        if (this.showEOL && lastLineEl) {
            if (foldLine)
                row = foldLine.end.row;

            var invisibleEl = this.dom.createElement("span");
            invisibleEl.className = "ace_invisible ace_invisible_eol";
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;

            lastLineEl.appendChild(invisibleEl);
        }
    }

    /**
     * @param {number} row
     * @param {import("../../ace-internal").Ace.FoldLine} foldLine
     * @return {import("../../ace-internal").Ace.Token[]}
     */
    $getFoldLineTokens(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                // Check if the token value is longer then the from...to spacing.
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    }

    $useLineGroups() {
        // For the updateLines function to work correctly, it's important that the
        // child nodes of this.element correspond on a 1-to-1 basis to rows in the
        // document (as distinct from lines on the screen). For sessions that are
        // wrapped, this means we need to add a layer to the node hierarchy (tagged
        // with the class name ace_line_group).
        return this.session.getUseWrapMode();
    }
}

Text.prototype.EOF_CHAR = "\xB6";
Text.prototype.EOL_CHAR_LF = "\xAC";
Text.prototype.EOL_CHAR_CRLF = "\xa4";
Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
Text.prototype.TAB_CHAR = "\u2014"; //"\u21E5";
Text.prototype.SPACE_CHAR = "\xB7";
Text.prototype.$padding = 0;
Text.prototype.MAX_LINE_LENGTH = 10000;
Text.prototype.showInvisibles = false;
Text.prototype.showSpaces = false;
Text.prototype.showTabs = false;
Text.prototype.showEOL = false;
Text.prototype.displayIndentGuides = true;
Text.prototype.$highlightIndentGuides = true;
Text.prototype.$tabStrings = [];
Text.prototype.destroy = {};
Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;

oop.implement(Text.prototype, EventEmitter);

exports.E = Text;


/***/ }),

/***/ 41109:
/***/ ((__unused_webpack_module, exports) => {

// Tokens for which Ace just uses a simple TextNode and does not add any special className.
const textTokens = new Set(["text", "rparen", "lparen"]);

exports.t = function(tokenType) {
    return textTokens.has(tokenType);
};


/***/ }),

/***/ 20845:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"no use strict";
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
const reportError = (__webpack_require__(53092)/* .reportError */ .N);
const defaultEnglishMessages = (__webpack_require__(63816)/* .defaultEnglishMessages */ .q);

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
                return !options[key].hidden;
            });
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        //@ts-ignore
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

var messages;
var nlsPlaceholders;

class AppConfig {
    constructor() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
        }

    /**
     * @param {Object} obj
     * @param {string} path
     * @param {{ [key: string]: any }} options
     * @returns {import("../../ace-internal").Ace.AppConfig}
     */
    defineOptions(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });

        // implement option provider interface
        oop.implement(obj, optionsProvider);

        return this;
    }

    /**
     * @param {Object} obj
     */
    resetOptions(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    }

    /**
     * @param {string} path
     * @param {string} name
     * @param {any} value
     */
    setDefaultValue(path, name, value) {
        if (!path) {
            for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                    break;
            if (!this.$defaultOptions[path][name])
                return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    }

    /**
     * @param {string} path
     * @param {{ [key: string]: any; }} optionHash
     */
    setDefaultValues(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    }

    /**
     * @param {any} value
     * @param {{placeholders?: "dollarSigns" | "curlyBrackets"}} [options]
     */
    setMessages(value, options) {
        messages = value;
        if (options && options.placeholders) {
            nlsPlaceholders = options.placeholders;
        }
    }

    /**
     * @param {string} key
     * @param {string} defaultString
     * @param {{ [x: string]: any; }} [params]
     */
    nls(key, defaultString, params) {
        if (!messages[key])  {
            warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
            if (!messages[defaultString]) {
                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
            }
        }

        var translated = messages[key] || messages[defaultString] || defaultString;
        if (params) {
            // We support both $n or {n} as placeholder indicators in the provided translated strings
            if (nlsPlaceholders === "dollarSigns") {
                // Replace $n with the nth element in params
                translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                    if (dollarMatch == "$") return "$";
                    return params[dollarMatch];
                });
            }
            if (nlsPlaceholders === "curlyBrackets") {
                // Replace {n} with the nth element in params
                translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                    return params[curlyBracketMatch];
                });
            }
        }
        return translated;
    }
}
AppConfig.prototype.warn = warn;
AppConfig.prototype.reportError = reportError;

// module loading
oop.implement(AppConfig.prototype, EventEmitter);

exports.o = AppConfig;


/***/ }),

/***/ 50973:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var ArabicAlefBetIntervalsBegine = (/* unused pure expression or super */ null && (['\u0621', '\u0641']));
var ArabicAlefBetIntervalsEnd = (/* unused pure expression or super */ null && (['\u063A', '\u064a']));
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;

var impTab_LTR = [
				/*		L,		R,		EN,		AN,		N,		IL,		Cond */
/* 0 LTR text	*/	[	0,		3,		0,		1,		0,		0,		0	],
/* 1 LTR+AN		*/	[	0,		3,		0,		1,		2,		2,		0	],
/* 2 LTR+AN+N	*/	[	0,		3,		0,		0x11,		2,		0,		1	],
/* 3 RTL text	*/	[	0,		3,		5,		5,		4,		1,		0	],
/* 4 RTL cont	*/	[	0,		3,		0x15,		0x15,		4,		0,		1	],
/* 5 RTL+EN/AN	*/	[	0,		3,		5,		5,		4,		2,		0	]
];

var impTab_RTL = [
		/*		L,		R,		EN,		AN,		N,		IL,		Cond */
/* 0 RTL text	*/	[	2,		0,		1,		1,		0,		1,		0	],
/* 1 RTL+EN/AN	*/	[	2,		0,		1,		1,		0,		2,		0	],
/* 2 LTR text	*/	[	2,		0,		2,		1,		3,		2,		0	],
/* 3 LTR+cont	*/	[	2,		0,		2,		0x21,		3,		1,		1	]
];

var LTR = 0, RTL = 1;

var L = 0; /* left to right */
var R = 1; /* right to left */
var EN = 2; /* European digit */
var AN = 3; /* Arabic-Indic digit */
var ON = 4; /* neutral */
var B = 5; /* block separator */
var S = 6; /* segment separator */
var AL = 7; /* Arabic Letter */
var WS = 8; /* white space */
var CS = 9; /* common digit separator */
var ES = 10; /* European digit separator */
var ET = 11; /* European digit terminator */
var NSM = 12; /* Non Spacing Mark */
var LRE = 13; /* LRE */
var RLE = 14; /* RLE */
var PDF = 15; /* PDF */
var LRO = 16; /* LRO */
var RLO = 17; /* RLO */
var BN = 18; /* Boundary Neutral */

var UnicodeTBL00 = [
BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
];

var UnicodeTBL20 = [
WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
];

function _computeLevels(chars, levels, len, charTypes) {
	var impTab = dir ? impTab_RTL : impTab_LTR
		, prevState = null, newClass = null, newLevel = null, newState = 0
		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

	if (!charTypes) {
		for (i = 0, charTypes = []; i < len; i++) {
			charTypes[i] = _getCharacterType(chars[i]);
		}
	}
	hiLevel = dir;
	lastArabic = false;
	hasUBAT_AL = false;
	hasUBAT_B = false;
	hasUBAT_S = false;
	for (ix = 0; ix < len; ix++){
		prevState = newState;
		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
		newState = impTab[prevState][newClass];
		action = newState & 0xF0;
		newState &= 0x0F;
		levels[ix] = newLevel = impTab[newState][5];
		if (action > 0){
			if (action == 0x10){
				for(i = condPos; i < ix; i++){
					levels[i] = 1;
				}
				condPos = -1;
			} else {
				condPos = -1;
			}
		}
		cond = impTab[newState][6];
		if (cond){
			if(condPos == -1){
				condPos = ix;
			}
		}else{
			if (condPos > -1){
				for(i = condPos; i < ix; i++){
					levels[i] = newLevel;
				}
				condPos = -1;
			}
		}
		if (charTypes[ix] == B){
			levels[ix] = 0;
		}
		hiLevel |= newLevel;
	}
	if (hasUBAT_S){
		for(i = 0; i < len; i++){
			if(charTypes[i] == S){
				levels[i] = dir;
				for(var j = i - 1; j >= 0; j--){
					if(charTypes[j] == WS){
						levels[j] = dir;
					}else{
						break;
					}
				}
			}
		}
	}
}

function _invertLevel(lev, levels, _array) {
	if (hiLevel < lev){
		return;
	}
	if (lev == 1 && dir == RTL && !hasUBAT_B){
		_array.reverse();
		return;
	}
	var len = _array.length, start = 0, end, lo, hi, tmp;
	while(start < len){
		if (levels[start] >= lev){
			end = start + 1;
		while(end < len && levels[end] >= lev){
			end++;
		}
		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
			tmp = _array[lo];
			_array[lo] = _array[hi];
			_array[hi] = tmp;
		}
		start = end;
	}
	start++;
	}
}

function _getCharClass(chars, types, classes, ix) {			
	var cType = types[ix], wType, nType, len, i;
	switch(cType){
		case L:
		case R:
			lastArabic = false;
		case ON:
		case AN:
			return cType;
		case EN:
			return lastArabic ? AN : EN;
		case AL:
			lastArabic = true;
			hasUBAT_AL = true;
			return R;
		case WS:
			return ON;
		case CS:
			if (ix < 1 || (ix + 1) >= types.length ||
				((wType = classes[ix - 1]) != EN && wType != AN) ||
				((nType = types[ix + 1]) != EN && nType != AN)){
				return ON;
			}
			if (lastArabic){nType = AN;}
			return nType == wType ? nType : ON;
		case ES:
			wType = ix > 0 ? classes[ix - 1] : B;
			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
				return EN;
			}
			return ON;
		case ET:
			if (ix > 0 && classes[ix - 1] == EN){
				return EN;
			}
			if (lastArabic){
				return ON;
			}
			i = ix + 1;
			len = types.length;
			while (i < len && types[i] == ET){
				i++;
			}
			if (i < len && types[i] == EN){
				return EN;
			}
			return ON;
		case NSM:
			len = types.length;
			i = ix + 1;
			while (i < len && types[i] == NSM){
				i++;
			}
			if (i < len){
				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
				
				wType = types[i];
				if (rtlCandidate && (wType == R || wType == AL)){
					return R;
				}
			}

			if (ix < 1 || (wType = types[ix - 1]) == B){
				return ON;
			}
			return classes[ix - 1];
		case B:
			lastArabic = false;
			hasUBAT_B = true;
			return dir;
		case S:
			hasUBAT_S = true;
			return ON;
		case LRE:
		case RLE:
		case LRO:
		case RLO:
		case PDF:
			lastArabic = false;
		case BN:
			return ON;
	}
}

function _getCharacterType( ch ) {		
	var uc = ch.charCodeAt(0), hi = uc >> 8;
	
	if (hi == 0) {		
		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
	} else if (hi == 5) {
		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
	} else if (hi == 6) {
		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
			return NSM;
		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
			return AN;
		else if (uc == 0x066A)
			return ET;
		else if (/[\u06f0-\u06f9]/.test(ch))
			return EN;			
		else
			return AL;
	} else if (hi == 0x20 && uc <= 0x205F) {
		return UnicodeTBL20[uc & 0xFF];
	} else if (hi == 0xFE) {
		return (uc >= 0xFE70 ? AL : ON);
	}		
	return ON;	
}

function _isArabicDiacritics( ch ) {
	return (ch >= '\u064b' && ch <= '\u0655');
}

/* Strong LTR character (0 - even), regular width */
exports.L = L;
/* Strong RTL character (1 - odd), Bidi width */
exports.R = R;
/* European digit (2 - even), regular width */
exports.EN = EN;
/* Neutral RTL-by-context character (3 - odd), regular width */
exports.ON_R = 3;
/* Hindi (Arabic) digit (4 - even), Bidi width */
exports.AN = 4;
/* Arabic LamAlef (5 - odd), Half Bidi width */
exports.R_H = 5;
/* invisible EOL (6 - even), zero width */
exports.B = 6;
/* invisible RLE (7 - odd), zero width */
exports.RLE = 7;

exports.DOT = "\xB7";

/**
 * Performs text reordering by implementing Unicode Bidi algorithm
 * with aim to produce logical<->visual map and Bidi levels
 * @param {String} text string to be reordered
 * @param {Array} textCharTypes unicode character types produced by call to 'hasBidiCharacters'
 * @param {Boolean} isRtl 'true' for right-to-left text direction, otherwise 'false'
 *
 * @return {Object} An object containing logicalFromVisual map and Bidi levels
 **/
exports.doBidiReorder = function(text, textCharTypes, isRtl) {
	if (text.length < 2)
		return {};
		
	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
		bidiLevels = new Array(chars.length), levels = []; 

	dir = isRtl ? RTL : LTR;

	_computeLevels(chars, levels, chars.length, textCharTypes);

	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

	_invertLevel(2, levels, logicalFromVisual);
	_invertLevel(1, levels, logicalFromVisual);

	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
		if (textCharTypes[i] === AN) {
			levels[i] = exports.AN;
		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
			levels[i] = exports.ON_R;
		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
			levels[i - 1] = levels[i] = exports.R_H;
			i++;
		}
	}
	/* fix level to mark zero length EOL */
	if (chars[chars.length - 1] === exports.DOT)
		levels[chars.length - 1] = exports.B;
				
	if (chars[0] === '\u202B')
		levels[0] = exports.RLE;
				
	for (var i = 0; i < logicalFromVisual.length; i++) {
		bidiLevels[i] = levels[logicalFromVisual[i]];
	}

	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
};	

/**
 * Performs character classification, to be used in Unicode Bidi algorithm.
 * @param {String} text string to be reordered
 * @param {Array} textCharTypes unicode character types (to be filled by this method)
 *
 * @return {Boolean} 'true' if text contains Bidi characters, otherwise 'false' 
 **/
exports.hasBidiCharacters = function(text, textCharTypes){
	var ret = false;
	for (var i = 0; i < text.length; i++){
		textCharTypes[i] = _getCharacterType(text.charAt(i));
		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
			ret = true;
	}
	return ret;
};

/**
 * Returns visual index corresponding to logical index basing on logicalFromvisual 
 * map provided by Unicode Bidi algorithm.
 * @param {Number} logIdx logical index of character in text buffer
 * @param {Object} rowMap object containing logicalFromVisual map
 *
 * @return {Number} visual index (on display) corresponding to logical index
 **/	
exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
		if (rowMap.logicalFromVisual[i] == logIdx)
			return i;
	}
	return 0;
};


/***/ }),

/***/ 77893:
/***/ ((__unused_webpack_module, exports) => {

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (let key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (let key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};


/***/ }),

/***/ 63816:
/***/ ((__unused_webpack_module, exports) => {

var defaultEnglishMessages = {
    "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
    "autocomplete.popup.aria-label": "Autocomplete suggestions",
    "autocomplete.popup.item.aria-roledescription": "item",
    "autocomplete.loading": "Loading...",
    "editor.scroller.aria-roledescription": "editor",
    "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
    "editor.gutter.aria-roledescription": "editor gutter",
    "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
    "error-marker.good-state": "Looks good!",
    "prompt.recently-used": "Recently used",
    "prompt.other-commands": "Other commands",
    "prompt.no-matching-commands": "No matching commands",
    "search-box.find.placeholder": "Search for",
    "search-box.find-all.text": "All",
    "search-box.replace.placeholder": "Replace with",
    "search-box.replace-next.text": "Replace",
    "search-box.replace-all.text": "All",
    "search-box.toggle-replace.title": "Toggle Replace mode",
    "search-box.toggle-regexp.title": "RegExp Search",
    "search-box.toggle-case.title": "CaseSensitive Search",
    "search-box.toggle-whole-word.title": "Whole Word Search",
    "search-box.toggle-in-selection.title": "Search In Selection",
    "search-box.search-counter": "$0 of $1",
    "text-input.aria-roledescription": "editor",
    "text-input.aria-label": "Cursor at row $0",
    "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
    "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
    "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
    "gutter.code-folding.closed.title": "Unfold code",
    "gutter.code-folding.open.title": "Fold code",
    "gutter.annotation.aria-label.error": "Error, read annotations row $0",
    "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
    "gutter.annotation.aria-label.info": "Info, read annotations row $0",
    "inline-fold.closed.title": "Unfold code",
    "gutter-tooltip.aria-label.error.singular": "error",
    "gutter-tooltip.aria-label.error.plural": "errors",
    "gutter-tooltip.aria-label.warning.singular": "warning",
    "gutter-tooltip.aria-label.warning.plural": "warnings",
    "gutter-tooltip.aria-label.info.singular": "information message",
    "gutter-tooltip.aria-label.info.plural": "information messages",
    "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
    "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
    "gutter-tooltip.aria-label.security.singular": "security finding",
    "gutter-tooltip.aria-label.security.plural": "security findings",
    "gutter-tooltip.aria-label.hint.singular": "suggestion",
    "gutter-tooltip.aria-label.hint.plural": "suggestions"
}

exports.q = defaultEnglishMessages;

/***/ }),

/***/ 71435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var useragent = __webpack_require__(74943); 
var XHTML_NS = "http://www.w3.org/1999/xhtml";

/**
 * 
 * @param {any} arr
 * @param {HTMLElement} [parent]
 * @param [refs]
 * @returns {HTMLElement | Text | any[]} 
 */
exports.buildDom = function buildDom(arr, parent, refs) {
    if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
            parent.appendChild(txt);
        return txt;
    }
    
    if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
        return arr;
    }
    if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
        }
        return els;
    }
    
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
    for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
    if (childIndex == 2) {
        Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
                el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                el[n] = val;
            } else if (n === "ref") {
                if (refs) refs[val] = el;
            } else if (n === "style") {
                if (typeof val == "string") el.style.cssText = val;
            } else if (val != null) {
                el.setAttribute(n, val);
            }
        });
    }
    if (parent)
        parent.appendChild(el);
    return el;
};

/**
 * 
 * @param {Document} [doc]
 * @returns {HTMLHeadElement|HTMLElement}
 */
exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
};


/**
 * @template {keyof HTMLElementTagNameMap} T
 * @param {T | string} tag
 * @param {string} [ns]
 * @returns {HTMLElementTagNameMap[T]}
 */
exports.createElement = function(tag, ns) {
    // @ts-ignore
    return document.createElementNS ?
            document.createElementNS(ns || XHTML_NS, tag) :
            document.createElement(tag);
};

/**
 * @param {HTMLElement} element
 */
exports.removeChildren = function(element) {
    element.innerHTML = "";
};

/**
 * @param {string} textContent
 * @param {HTMLElement} [element]
 * @returns {Text}
 */
exports.createTextNode = function(textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
};

/**
 * @param {HTMLElement} [element]
 * @returns {DocumentFragment}
 */
exports.createFragment = function(element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
};

/**
 * @param {HTMLElement} el
 * @param {string} name
 * @returns {boolean}
 */
exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};

/**
 * Add a CSS class to the list of classes on the given node
 * @param {HTMLElement} el
 * @param {string} name
*/
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};

/**
 * Remove a CSS class from the list of classes on the given node
 * @param {HTMLElement} el
 * @param {string} name
 */
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

/**
 * @param {HTMLElement} el
 * @param {string} name
 * @returns {boolean}
 */
exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};

/**
 * Add or remove a CSS class from the list of classes on the given node
 * depending on the value of <tt>include</tt>
 * @param {HTMLElement} node
 * @param {string} className
 * @param {boolean} include
 */
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

/**
 * @param {string} id
 * @param {Document} [doc]
 * @returns {boolean}
 */
exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if ((sheets = doc.querySelectorAll("style"))) {
        while (index < sheets.length) {
            if (sheets[index++].id === id) {
                return true;
            }
        }
    }
};

/**
 * @param {string} id
 * @param {Document} [doc]
 */
exports.removeElementById = function(id, doc) {
    doc = doc || document;
    if(doc.getElementById(id)) {
        doc.getElementById(id).remove();
    }
};

var strictCSP;
var cssCache = [];
exports.useStrictCSP = function(value) {
    strictCSP = value;
    if (value == false) insertPendingStyles();
    else if (!cssCache) cssCache = [];
};

function insertPendingStyles() {
    var cache = cssCache;
    cssCache = null;
    cache && cache.forEach(function(item) {
        importCssString(item[0], item[1]);
    });
}

/**
 * @param {string} cssText
 * @param {string} [id]
 * @param {any} [target]
 */
function importCssString(cssText, id, target) {
    if (typeof document == "undefined")
        return;
    if (cssCache) {
        if (target) {
            insertPendingStyles();
        } else if (target === false) {
            return cssCache.push([cssText, id]);
        }
    }
    if (strictCSP) return;

    var container = target;
    if (!target || !target.getRootNode) {
        container = document;
    } else {
        container = target.getRootNode();
        if (!container || container == target)
            container = document;
    }
    
    var doc = container.ownerDocument || container;
    
    // If style is already imported return immediately.
    if (id && exports.hasCssString(id, container))
        return null;
    
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    
    var style = exports.createElement("style");
    style.appendChild(doc.createTextNode(cssText));
    if (id)
        style.id = id;

    if (container == doc)
        container = exports.getDocumentHead(doc);
    container.insertBefore(style, container.firstChild);
}
exports.importCssString = importCssString;

/**
 * @param {string} uri
 * @param {Document} [doc]
 */
exports.importCssStylsheet = function(uri, doc) {
    exports.buildDom(["link", {rel: "stylesheet", href: uri}], exports.getDocumentHead(doc));
};

/**
 * @param {Document} [doc]
 * @returns {number}
 */
exports.scrollbarWidth = function(doc) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = (doc && doc.documentElement) || (document && document.documentElement);
    if (!body) return 0;

    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar - withScrollbar;
};

/**
 * @param {Element} element
 * @param [style]
 * @returns {Partial<CSSStyleDeclaration>}
 */
exports.computedStyle = function(element, style) {
    return window.getComputedStyle(element, "") || {};
};

/**
 * 
 * @param {CSSStyleDeclaration} styles
 * @param {string} property
 * @param {string} value
 */
exports.setStyle = function(styles, property, value) {
    if (styles[property] !== value) {
        //console.log("set style", property, styles[property], value);
        styles[property] = value;
    }
};

exports.HAS_CSS_ANIMATION = false;
exports.HAS_CSS_TRANSFORMS = false;
exports.HI_DPI = useragent.isWin
    ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
    : true;

if (useragent.isChromeOS) exports.HI_DPI = false;

if (typeof document !== "undefined") {
    // detect CSS transformation support
    var div = document.createElement("div");
    if (exports.HI_DPI && div.style.transform  !== undefined)
        exports.HAS_CSS_TRANSFORMS = true;
    if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports.HAS_CSS_ANIMATION = true;
    div = null;
}

if (exports.HAS_CSS_TRANSFORMS) {
    exports.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) +"px)";
    };
} else {
    exports.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
    };
}


/***/ }),

/***/ 19631:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/** @type {any} */var keys = __webpack_require__(29451);
var useragent = __webpack_require__(74943);

var pressedKeys = null;
var ts = 0;

var activeListenerOptions;
function detectListenerOptionsSupport() {
    activeListenerOptions = false;
    try {
        document.createComment("").addEventListener("test", function() {}, { 
            get passive() { 
                activeListenerOptions = {passive: false};
                return true;
            }
        });
    } catch(e) {}
}

function getListenerOptions() {
    if (activeListenerOptions == undefined)
        detectListenerOptionsSupport();
    return activeListenerOptions;
}

function EventListener(elem, type, callback) {
    this.elem = elem;
    this.type = type;
    this.callback = callback;
}
EventListener.prototype.destroy = function() {
    removeListener(this.elem, this.type, this.callback);
    this.elem = this.type = this.callback = undefined;
};

/**
 * Adds an event listener to the specified element.
 *
 * @param {any} elem - The element to add the event listener to.
 * @param {string} type - The type of event to listen for.
 * @param {any} callback - The callback function to be executed when the event is triggered.
 * @param {any} [destroyer] - An optional object that will have the created EventListener instance added to its $toDestroy array, allowing it to be easily destroyed later.
 */
var addListener = exports.addListener = function(elem, type, callback, destroyer) {
    elem.addEventListener(type, callback, getListenerOptions());
    if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
};

var removeListener = exports.removeListener = function(elem, type, callback) {
    elem.removeEventListener(type, callback, getListenerOptions());
};

/*
* Prevents propagation and clobbers the default action of the passed event
*/
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
};

/*
 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
 */
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;

    // DOM Event
    return e.button;
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    var ownerDocument = el && el.ownerDocument || document;
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        removeListener(ownerDocument, "mousemove", eventHandler);
        removeListener(ownerDocument, "mouseup", onMouseUp);
        removeListener(ownerDocument, "dragstart", onMouseUp);
    }

    addListener(ownerDocument, "mousemove", eventHandler);
    addListener(ownerDocument, "mouseup", onMouseUp);
    addListener(ownerDocument, "dragstart", onMouseUp);
    
    return onMouseUp;
};

/**
 * @param el
 * @param callback
 * @param [destroyer]
 */
exports.addMouseWheelListener = function(el, callback, destroyer) {
    addListener(el, "wheel",  function(e) {
        var factor = 0.15;
        // workaround for firefox changing deltaMode based on which property is accessed first
        var deltaX = e.deltaX || 0;
        var deltaY = e.deltaY || 0;
        switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
                e.wheelX = deltaX * factor;
                e.wheelY = deltaY * factor;
                break;
            case e.DOM_DELTA_LINE:
                var linePixels = 15;
                e.wheelX = deltaX * linePixels;
                e.wheelY = deltaY * linePixels;
                break;
            case e.DOM_DELTA_PAGE:
                var pagePixels = 150;
                e.wheelX = deltaX * pagePixels;
                e.wheelY = deltaY * pagePixels;
                break;
        }
        callback(e);
    }, destroyer);
};

/**
 * @param elements
 * @param timeouts
 * @param eventHandler
 * @param callbackName
 * @param [destroyer]
 */
exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function(el) {
        addListener(el, "mousedown", onMousedown, destroyer);
    });
};

/** @param {KeyboardEvent|MouseEvent} e */
function getModifierHash(e) {
    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
}

/**
 * @param {KeyboardEvent|MouseEvent} e
 * @returns string
 */
exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

/**
 * @param {(e: KeyboardEvent, hashId: number, keyCode: number)=> void } callback
 * @param {KeyboardEvent} e
 * @param {number} keyCode
 */
function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!keyCode && e.code) {
        keyCode = keys.$codeToKeyCode[e.code] || keyCode;
    }

    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = e.location;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        if (e.location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }

    // If there is no hashId and the keyCode is not a function key, then
    // we don't call the callback as we don't handle a command key here
    // (it's a normal key/character input).
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}

/**
 * @param {EventTarget} el
 * @param {(e: KeyboardEvent, hashId: number, keyCode: number)=>void} callback
 * @param [destroyer]
 */
exports.addCommandKeyListener = function(el, callback, destroyer) {
    var lastDefaultPrevented = null;

    addListener(el, "keydown", function(e) {
        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
        var result = normalizeCommandKeys(callback, e, e.keyCode);
        lastDefaultPrevented = e.defaultPrevented;
        return result;
    }, destroyer);

    addListener(el, "keypress", function(e) {
        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
            exports.stopEvent(e);
            lastDefaultPrevented = null;
        }
    }, destroyer);

    addListener(el, "keyup", function(e) {
        pressedKeys[e.keyCode] = null;
    }, destroyer);

    if (!pressedKeys) {
        resetPressedKeys();
        addListener(window, "focus", resetPressedKeys);
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + (postMessageId++);
        
        var listener = function(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                removeListener(win, "message", listener);
                callback();
            }
        };
        
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
    };
}

exports.$idleBlocked = false;
exports.onIdle = function(cb, timeout) {
    return setTimeout(function handler() {
        if (!exports.$idleBlocked) {
            cb();
        } else {
            setTimeout(handler, 100);
        }
    }, timeout);
};

exports.$idleBlockId = null;
exports.blockIdle = function(delay) {
    if (exports.$idleBlockId)
        clearTimeout(exports.$idleBlockId);
        
    exports.$idleBlocked = true;
    exports.$idleBlockId = setTimeout(function() {
        exports.$idleBlocked = false;
    }, delay || 100);
};

exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window["mozRequestAnimationFrame"]
    || window["webkitRequestAnimationFrame"]
    || window["msRequestAnimationFrame"]
    || window["oRequestAnimationFrame"]);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };


/***/ }),

/***/ 87366:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**@type {any}*/
var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        /*global Promise*/
        return new Promise(function(resolve) {
            callback = resolve;
        });
    }
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    /**@type {any}*/
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};
/**
 * @this {EventEmitter}
 */
EventEmitter.removeAllListeners = function(eventName) {
    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
};

exports.EventEmitter = EventEmitter;


/***/ }),

/***/ 29451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var oop = __webpack_require__(2645);


var Keys = {
    MODIFIER_KEYS: {
        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
        91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
    },

    KEY_MODS: {
        "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
        "super": 8, "meta": 8, "command": 8, "cmd": 8, 
        "control": 1
    },

    FUNCTION_KEYS : {
        8  : "Backspace",
        9  : "Tab",
        13 : "Return",
        19 : "Pause",
        27 : "Esc",
        32 : "Space",
        33 : "PageUp",
        34 : "PageDown",
        35 : "End",
        36 : "Home",
        37 : "Left",
        38 : "Up",
        39 : "Right",
        40 : "Down",
        44 : "Print",
        45 : "Insert",
        46 : "Delete",
        '-13': "NumpadEnter",
        144: "Numlock",
        145: "Scrolllock"
    },

    PRINTABLE_KEYS: {
        32: ' ',  59: ';',  61: '=', 107: '+', 109: '-', 110: '.',
        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
        219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
    }
};

var codeToKeyCode = {
    Command: 224,
    Backspace: 8,
    Tab: 9,
    Return: 13,
    Enter: 13,
    Pause: 19,
    Escape: 27,
    PageUp: 33,
    PageDown: 34,
    End: 35,
    Home: 36,
    Insert: 45,
    Delete: 46,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40,
    // special keys
    Backquote: 192,
    Minus: 189,
    Equal: 187,
    BracketLeft: 219,
    Backslash: 220,
    BracketRight: 221,
    Semicolon: 186,
    Quote: 222,
    Comma: 188,
    Period: 190,
    Slash: 191,
    Space: 32,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    NumpadSubtract: 109,
    NumpadDivide: 111,
    NumpadMultiply: 106
};
for (var i = 0; i < 10; i++) {
    codeToKeyCode["Digit" + i] = 48 + i;
    codeToKeyCode["Numpad" + i] = 96 + i;
    Keys.PRINTABLE_KEYS[48 + i] = "" + i;
    Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
}
for (var i = 65; i < 91; i++) {
    var chr = String.fromCharCode(i + 32);
    codeToKeyCode["Key" + chr.toUpperCase()] = i;
    Keys.PRINTABLE_KEYS[i] = chr;
}
for (var i = 1; i < 13; i++) {
    codeToKeyCode["F" + i] = 111 + i;
    Keys.FUNCTION_KEYS[111 + i] = "F" + i;
}
var modifiers = { 
    Shift: 16,
    Control: 17,
    Alt: 18,
    Meta: 224
};
for (var mod in modifiers) {
    codeToKeyCode[mod] = codeToKeyCode[mod + "Left"]
        = codeToKeyCode[mod + "Right"] = modifiers[mod];
}
exports.$codeToKeyCode = codeToKeyCode;

// workaround for firefox bug
Keys.PRINTABLE_KEYS[173] = '-';

// A reverse map of FUNCTION_KEYS
for (var j in Keys.FUNCTION_KEYS) {
    var name = Keys.FUNCTION_KEYS[j].toLowerCase();
    Keys[name] = parseInt(j, 10);
}

// A reverse map of PRINTABLE_KEYS
for (var j in Keys.PRINTABLE_KEYS) {
    var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
    Keys[name] = parseInt(j, 10);
}

// Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
// variables as well.
oop.mixin(Keys, Keys.MODIFIER_KEYS);
oop.mixin(Keys, Keys.PRINTABLE_KEYS);
oop.mixin(Keys, Keys.FUNCTION_KEYS);

// aliases
Keys.enter = Keys["return"];
Keys.escape = Keys.esc;
Keys.del = Keys["delete"];

(function() {
    var mods = ["cmd", "ctrl", "alt", "shift"];
    for (var i = Math.pow(2, mods.length); i--;) {
        Keys.KEY_MODS[i] = mods.filter(function(x) {
            return i & Keys.KEY_MODS[x];
        }).join("-") + "-";
    }
})();

Keys.KEY_MODS[0] = "";
Keys.KEY_MODS[-1] = "input-";


oop.mixin(exports, Keys);

exports["default"] = exports;

// @ts-ignore
exports.keyCodeToString = function(keyCode) {
    // Language-switching keystroke in Chrome/Linux emits keyCode 0.
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};


/***/ }),

/***/ 39955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.last = function(a) {
    return a[a.length - 1];
};


/** @param {string} string */
exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};
/**
 * @template T
 * @param {T} obj
 * @return {T}
 */
exports.copyObject = function(obj) {
    /** @type Object*/
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = __webpack_require__(77893).deepCopy;

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};

/*
 * splice out of 'array' anything that === 'value'
 */
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};

/* deprecated */
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };

    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};

/**
 * @param {number} [defaultTimeout]
 */
exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };
    /**
     * @param {number} [timeout]
     */
    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    /**
     * @param {number} [timeout]
     */
    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};

exports.supportsLookbehind = function () {
    try {
        new RegExp('(?<=.)');
    } catch (e) {
        return false;
    }
    return true;
};

exports.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;
};


/***/ }),

/***/ 78552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */


var dom = __webpack_require__(71435);

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    /**@type {HTMLScriptElement & {onload?: Function, onreadystatechange?: Function, readyState?: string}}*/
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};

/*
 * Convert a url into a fully qualified absolute URL
 * This function does not work in IE6
 */
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
};


/***/ }),

/***/ 2645:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

/**
 * Implements mixin properties into the prototype of an object.
 * @template T
 * @param {T} obj - The prototype of the target object.
 * @param {Object} mixin - The source object.
 * @returns {T & Object} The merged prototype.
 */
exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

/**
 * Implements mixin properties into the prototype of an object.
 * @template T
 * @param {T} proto - The prototype of the target object.
 * @param {Object} mixin - The source object.
 * @returns {T & Object} The merged prototype.
 */
exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};


/***/ }),

/***/ 53092:
/***/ ((__unused_webpack_module, exports) => {


exports.N = function reportError(msg, data) {
    var e = new Error(msg);
    e["data"] = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
};


/***/ }),

/***/ 58298:
/***/ ((__unused_webpack_module, exports) => {

exports.K = function preventParentScroll(event) {
    event.stopPropagation();
    var target = event.currentTarget;
    var contentOverflows = target.scrollHeight > target.clientHeight;
    if (!contentOverflows) {
        event.preventDefault();
    }
};

/***/ }),

/***/ 74943:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/*
 * I hate doing this, but we need some way to determine if the user is on a Mac
 * The reason is that users have different expectations of their key combinations.
 *
 * Take copy as an example, Mac people expect to use CMD or APPLE + C
 * Windows folks expect to use CTRL + C
 */
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};

/*
 * Return an exports.OS constant
 */
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};

// this can be called in non browser environments (e.g. from ace/requirejs/text)
var _navigator = typeof navigator == "object" ? navigator : {};

var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
var ua = _navigator.userAgent || "";
var appName = _navigator.appName || "";

// Is the user using a browser that identifies itself as Windows
exports.isWin = (os == "win");

// Is the user using a browser that identifies itself as Mac OS
exports.isMac = (os == "mac");

// Is the user using a browser that identifies itself as Linux
exports.isLinux = (os == "linux");

// Windows Store JavaScript apps (aka Metro apps written in HTML5 and JavaScript) do not use the "Microsoft Internet Explorer" string in their user agent, but "MSAppHost" instead.
exports.isIE = 
    (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;

// Is this Firefox or related?
exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);

// Is this Opera 
// @ts-expect-error
exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";

// Is the user using a browser that identifies itself as WebKit 
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports.isChrome || undefined;

exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isAndroid = ua.indexOf("Android") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];

if (exports.isIOS) exports.isMac = true;

exports.isMobile = exports.isIOS || exports.isAndroid;


/***/ }),

/***/ 90563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("./virtual_renderer").VirtualRenderer} VirtualRenderer
 * @typedef {import("../ace-internal").Ace.LineWidget} LineWidget
 */

var dom = __webpack_require__(71435);


class LineWidgets {
    /**
     * @param {EditSession} session
     */
    constructor(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);

        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
    }

    /**
     * @param {number} row
     * @return {number}
     */
    getRowLength(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
            h = 0;
        if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
            return 1 + h;
        } else {
            return this["$wrapData"][row].length + 1 + h;
        }
    }

    /**
     * @return {number}
     */
    $getWidgetScreenLength() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    }

    $onChangeEditor(e) {
        this.attach(e.editor);
    }

    /**
     *
     * @param {Editor} editor
     */
    attach(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        /**@type {Editor} */
        this.editor = editor;

        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    }
    detach(e) {
        var editor = this.editor;
        if (!editor)
            return;

        this.editor = null;
        editor.widgetManager = null;

        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    }

    /**
     *
     * @param e
     * @param {EditSession} session
     */
    updateOnFold(e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            } else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    }

    /**
     *
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    updateOnChange(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;

        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            // return
        } else if (delta.action == "remove") {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                    startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    }

    $updateRows() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    }

    /**
     *
     * @param {LineWidget} w
     * @return {LineWidget}
     */
    $registerLineWidget(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());

        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }

        this.session.lineWidgets[w.row] = w;
        return w;
    }

    /**
     *
     * @param {LineWidget} w
     * @return {LineWidget}
     */
    addLineWidget(w) {
        this.$registerLineWidget(w);
        w.session = this.session;

        if (!this.editor) return w;

        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.text && !w.el) {
            w.el = dom.createElement("div");
            w.el.textContent = w.text;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            if (w.className) {
                dom.addCssClass(w.el, w.className);
            }
            w.el.style.position = "absolute";
            w.el.style.zIndex = "5";
            renderer.container.appendChild(w.el);
            w._inDocument = true;

            if (!w.coverGutter) {
                w.el.style.zIndex = "3";
            }
            if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
            }
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }

        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }

        this.session._emit("changeFold", {data:{start:{row: w.row}}});

        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    }

    /**
     * @param {LineWidget} w
     */
    removeLineWidget(w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            } else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    }

    /**
     *
     * @param {number} row
     * @return {LineWidget[]}
     */
    getWidgetsAtRow(row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    }

    /**
     * @param {LineWidget} w
     * @internal
     */
    onWidgetChanged(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    }

    /**
     * @param {any} e
     * @param {VirtualRenderer} renderer
     */
    measureWidgets(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;

        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }

            w.h = w.el.offsetHeight;

            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }

            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    }

    /**
     * @param {any} e
     * @param {VirtualRenderer} renderer
     */
    renderWidgets(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

        while (first > 0 && !lineWidgets[first])
            first--;

        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            /**@type{LineWidget}*/
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";

            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";

            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }

            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    }

}


exports.G = LineWidgets;


/***/ }),

/***/ 75684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var Behaviour;
Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    /**
     * @this {Behaviour & this}
     */
    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };

    /**
     * @this {Behaviour & this}
     */
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };

    /**
     * @this {Behaviour & this}
     */
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };

    /**
     * @this {Behaviour & this}
     */
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };

    /**
     *
     * @param [filter]
     * @returns {{}|*}
     * @this {Behaviour & this}
     */
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };

}).call(Behaviour.prototype);

exports.Q = Behaviour;


/***/ }),

/***/ 32589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var oop = __webpack_require__(2645);
var Behaviour = (__webpack_require__(75684)/* .Behaviour */ .Q);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var lang = __webpack_require__(39955);

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var defaultQuotes = {'"' : '"', "'" : "'"};

var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};
/**
 * Creates a new Cstyle behaviour object with the specified options.
 * @param {Object} [options] - The options for the Cstyle behaviour object.
 * @param {boolean} [options.braces] - Whether to force braces auto-pairing.
 * @param {boolean} [options.closeDocComment] - enables automatic insertion of closing tags for documentation comments.
 */
var CstyleBehaviour;
CstyleBehaviour = function(options) {
    options = options || {};
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            var token = session.getTokenAt(cursor.row, cursor.column);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            }
            else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
                let excludeTokens = [
                    /tag\-(?:open|name)/, /attribute\-name/
                ];
                if (excludeTokens.some((el) => el.test(token.type)) || /(string)\.quasi/.test(token.type)
                    && token.value[cursor.column - token.start - 1] !== '$') return;

                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                    text: '{}',
                    selection: [1, 1]
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);

                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                // We're escaped.
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;

                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(rightChar);

                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);

                    if ((!shouldPairQuotes && isWordBefore) || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    var charBefore = line[cursor.column - 2];
                    if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))
                        return null;
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;

        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

    if (options.closeDocComment !== false) {
        this.add("doc comment end", "insertion", function (state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
                var cursor = editor.getCursorPosition();
                if (cursor.column === 0) {
                    return;
                }
                var line = session.doc.getLine(cursor.row);
                var nextLine = session.doc.getLine(cursor.row + 1);
                var tokens = session.getTokens(cursor.row);
                var index = 0;
                for (var i = 0; i < tokens.length; i++) {
                    index += tokens[i].value.length;
                    var currentToken = tokens[i];
                    if (index >= cursor.column) {
                        if (index === cursor.column) {
                            if (!/\.doc/.test(currentToken.type)) {
                                return;
                            }
                            if (/\*\//.test(currentToken.value)) {
                                var nextToken = tokens[i + 1];
                                if (!nextToken || !/\.doc/.test(nextToken.type)) {
                                    return;
                                }
                            }
                        }
                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);

                        // Check for the pattern `*/` followed by `/**` within the token
                        var closeDocPos = currentToken.value.indexOf("*/");
                        var openDocPos = currentToken.value.indexOf("/**", closeDocPos > - 1 ? closeDocPos + 2 : 0);

                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                            return;
                        }
                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos
                            && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                            return;
                        }
                        break;
                    }
                }
                var indent = this.$getIndent(line);
                if (/\s*\*/.test(nextLine)) {
                    if (/^\s*\*/.test(line)) {
                        return {
                            text: text + indent + "* ",
                            selection: [1, 2 + indent.length, 1, 2 + indent.length]
                        };
                    }
                    else {
                        return {
                            text: text + indent + " * ",
                            selection: [1, 3 + indent.length, 1, 3 + indent.length]
                        };
                    }

                }
                if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                    return {
                        text: text + indent + " * " + text + " " + indent + "*/",
                        selection: [1, 4 + indent.length, 1, 4 + indent.length]
                    };
                }
            }
        });
    }
};

/**
 * @this {CstyleBehaviour}
 */
// @ts-ignore
CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);

    // Don't insert in the middle of a keyword/identifier/lexical
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
        // Look ahead in case we're at the end of a token
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }

    // Only insert in front of whitespace/comments
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};
CstyleBehaviour["$matchTokenType"] = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour["recordAutoInsert"] = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    // Reset previous state if text or context changed too much
    if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour["recordMaybeInsert"] = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this["isMaybeInsertedClosing"](cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour["popAutoInsertedClosing"] = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports._ = CstyleBehaviour;


/***/ }),

/***/ 51358:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Range = (__webpack_require__(91902)/* .Range */ .Q);

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;

    // must return "" if there's no fold, to enable caching
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel) {
                var token = session.getTokenAt(row, 0);
                if (!token || token.type !== "string")
                    break;
            }

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);


/***/ }),

/***/ 49432:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../../ace-internal").Ace.SyntaxMode} SyntaxMode
 */

var config = __webpack_require__(76321);

var Tokenizer = (__webpack_require__(32934).Tokenizer);

var TextHighlightRules = (__webpack_require__(16387)/* .TextHighlightRules */ .r);
var CstyleBehaviour = (__webpack_require__(32589)/* .CstyleBehaviour */ ._);
var unicode = __webpack_require__(6672);
var lang = __webpack_require__(39955);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

var Mode;
Mode = function() {
    this.HighlightRules = TextHighlightRules;
};

(function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");

    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");

    /**
     * @this {SyntaxMode}
     */
    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    /**
     * @this {SyntaxMode}
     */
    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            /**@type {any}*/
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            /**@type {any}*/
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            /**@type {any}*/
            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                /**@type {any}*/
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                /**@type {any}*/
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                /**@type {any}*/
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            /**@type {any}*/
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };

            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    /**
     * @this {SyntaxMode}
     */
    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        // todo: selection should have ended up in the right place automatically!
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (let i in mapping) {
            if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode)
                    config.$modes[id] = mode = new Mode();
                if (!config.$modes[i])
                    config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
        }

        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

        for (let i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] =
                  /** @this {import("../../ace-internal").Ace.SyntaxMode} */
                  function () {
                      return this.$delegator(functionName, arguments, defaultHandler);
                  };
            }(this));
        }
    };

    /**
     * @this {SyntaxMode}
     */
    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
            if (Array.isArray(state[2])) {
                var language = state[2][state[2].length - 1];
                var mode = this.$modes[language];
                if (mode)
                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
        }

        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    /**
     * @this {SyntaxMode}
     */
    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };

    /**
     * @this {SyntaxMode}
     */
    this.getKeywords = function(append) {
        // this is for autocompletion to pick up regexp'ed keywords
        if (!this.completionKeywords) {
            var rules = this.$tokenizer["rules"];
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                // drop surrounding parens
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };

    /**
     * @this {SyntaxMode}
     */
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    /**
     * @this {SyntaxMode}
     */
    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;


/***/ }),

/***/ 16387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const deepCopy = (__webpack_require__(77893).deepCopy);

/**@type {(new() => Partial<import("../../ace-internal").Ace.HighlightRules>) & {prototype: import("../../ace-internal").Ace.HighlightRules}}*/
var TextHighlightRules;
TextHighlightRules = function() {

    // regexp must not have capturing parentheses
    // regexps are ordered -> the first match is used

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    /**
     * @param {import("../../ace-internal").Ace.HighlightRulesMap} rules
     * @param {string} [prefix]
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    /**
     * @returns {import("../../ace-internal").Ace.HighlightRulesMap}
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getRules = function() {
        return this.$rules;
    };

    /**
     * @param HighlightRules
     * @param prefix
     * @param escapeRules
     * @param states
     * @param append
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        // if (stack[0] === currentState)
        stack.shift();
        return stack.shift() || "start";
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state["processed"] = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    // @ts-ignore
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                    if (includeName === "$self")
                        includeName = "start";
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function(x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }

                if (toInsert) {
                    /**
                     * @type{any[]}
                     */
                    // @ts-ignore
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    // skip included rules since they are already processed
                    //i += args.length - 3;
                    i--;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        this.$keywordList = [];
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; ) {
                var word = list[i];
                this.$keywordList.push(word);
                if (ignoreCase)
                    word = word.toLowerCase(); 
                keywords[word] = className;
            }
        }, this);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
            : function(value) {return keywords[value] || defaultToken; };
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.r = TextHighlightRules;


/***/ }),

/***/ 83229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 */
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var Tooltip = (__webpack_require__(59864)/* .Tooltip */ .m_);
var nls = (__webpack_require__(76321).nls);
var lang = __webpack_require__(39955);

/**
 * @param {MouseHandler} mouseHandler
 * @this {MouseHandler}
 */
function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });

    var tooltipTimeout, mouseEvent;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        tooltip.showTooltip(row);

        if (!tooltip.isOpen)
            return;

        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterRow = mouseEvent.getGutterRow();
            var gutterCell = gutter.$lines.get(gutterRow);
            if (gutterCell) {
                var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
                var rect = gutterElement.getBoundingClientRect();
                var style = tooltip.getElement().style;
                style.left = rect.right + "px";
                style.top = rect.bottom + "px";
            } else {
                moveTooltip(mouseEvent);
            }
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltip.isOpen) {
            tooltip.hideTooltip();
            editor.off("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltip.isOpen || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    }, editor);
    
    editor.on("changeSession", hideTooltip);
    editor.on("input", hideTooltip);
}

exports.Y = GutterHandler;

class GutterTooltip extends Tooltip {
    constructor(editor) {
        super(editor.container);
        this.editor = editor;
        /**@type {Number | Undefined}*/
        this.visibleTooltipRow;
    }

    setPosition(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    }
    
    static get annotationLabels() {
        return {
            error: {
                singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
            },
            security: {
                singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
            },
            warning: {
                singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
            },
            info: {
                singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
            },
            hint: {
                singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
            }
        };
    }

    showTooltip(row) {
        var gutter = this.editor.renderer.$gutterLayer;
        var annotationsInRow = gutter.$annotations[row];
        var annotation;

        if (annotationsInRow)
            annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
            };
        else annotation = {displayText: [], type: []};

        // If the tooltip is for a row which has a closed fold, check whether there are
        // annotations in the folded lines. If so, add a summary to the list of annotations.
        var fold = gutter.session.getFoldLine(row);
        if (fold && gutter.$showFoldedAnnotations) {
            var annotationsInFold = {error: [], security: [], warning: [], info: [], hint: []};
            var severityRank = {error: 1, security: 2, warning: 3, info: 4, hint: 5};
            var mostSevereAnnotationTypeInFold;

            for (let i = row + 1; i <= fold.end.row; i++) {
                if (!gutter.$annotations[i]) continue;

                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
                    var annotationType = gutter.$annotations[i].type[j];
                    annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);

                    if (
                        !mostSevereAnnotationTypeInFold ||
                        severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]
                    ) {
                        mostSevereAnnotationTypeInFold = annotationType;
                    }
                }
            }

            if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
                var summaryFoldedAnnotations = `${GutterTooltip.annotationsToSummaryString(
                    annotationsInFold
                )} in folded code.`;

                annotation.displayText.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
            }
        }

        if (annotation.displayText.length === 0) return this.hideTooltip();

        var annotationMessages = {error: [], security: [], warning: [], info: [], hint: []};
        var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";

        // Construct the contents of the tooltip.
        for (let i = 0; i < annotation.displayText.length; i++) {
            var lineElement = dom.createElement("span");

            var iconElement = dom.createElement("span");
            iconElement.classList.add(...[`ace_${annotation.type[i]}`, iconClassName]);
            iconElement.setAttribute(
                "aria-label",
                `${GutterTooltip.annotationLabels[annotation.type[i].replace("_fold", "")].singular}`
            );
            iconElement.setAttribute("role", "img");
            // Set empty content to the img span to get it to show up
            iconElement.appendChild(dom.createTextNode(" "));

            lineElement.appendChild(iconElement);
            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
            lineElement.appendChild(dom.createElement("br"));

            annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
        }

        // Clear the current tooltip content
        var tooltipElement = this.getElement();
        dom.removeChildren(tooltipElement);

        // Update the tooltip content
        annotationMessages.error.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.security.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.warning.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.info.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.hint.forEach((el) => tooltipElement.appendChild(el));

        tooltipElement.setAttribute("aria-live", "polite");

        if (!this.isOpen) {
            this.setTheme(this.editor.renderer.theme);
            this.setClassName("ace_gutter-tooltip");
        }

        this.show();
        this.visibleTooltipRow = row;
        this.editor._signal("showGutterTooltip", this);
    }

    hideTooltip() {
        if(!this.isOpen){
            return;
        }
        this.$element.removeAttribute("aria-live");
        this.hide();
        this.visibleTooltipRow = undefined;
        this.editor._signal("hideGutterTooltip", this);
    }

    static annotationsToSummaryString(annotations) {
        const summary = [];
        const annotationTypes = ["error", "security", "warning", "info", "hint"];
        for (const annotationType of annotationTypes) {
            if (!annotations[annotationType].length) continue;
            const label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;
            summary.push(`${annotations[annotationType].length} ${label}`);
        }
        return summary.join(", ");
    }
}

exports.Z = GutterTooltip;


/***/ }),

/***/ 88416:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 * @typedef {import("./mouse_event").MouseEvent} MouseEvent
 */
var useragent = __webpack_require__(74943);

var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 550; // milliseconds

class DefaultHandlers {
    /**
     * @param {MouseHandler} mouseHandler
     */
    constructor(mouseHandler) {
        mouseHandler.$clickSelection = null;

        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
            "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

        exports.forEach(function(x) {
            mouseHandler[x] = this[x];
        }, this);

        mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onMouseDown(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            // 2: contextmenu, 1: linux paste
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            // stopping event here breaks contextmenu on ff mac
            // not stoping breaks it on chrome mac
            return;
        }

        this.mousedownEvent.time = Date.now();
        // if this click caused the editor to be focused should not clear the
        // selection
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    }

    /**
     * 
     * @param {import("../../ace-internal").Ace.Position} [pos]
     * @param {boolean} [waitForClickSelection]
     * @this {MouseHandler}
     */
    startSelect(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent) return;
        // allow double/triple click handlers to change selection
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        editor.setStyle("ace_selecting");
        this.setState("select");
    }

    /**
     * @this {MouseHandler}
     */
    select() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    }

    /**
     * @param {string | number} unitName
     * @this {MouseHandler}
     */
    extendSelectionBy(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    }

    /**
     * @this {MouseHandler}
     */
    selectByLinesEnd() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
    }

    /**
     * @this {MouseHandler}
     */
    focusWait() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    }
    
    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onDoubleClick(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onTripleClick(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onQuadClick(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onMouseWheel(ev) {
        if (ev.getAccelKey())
            return;

        // shift wheel to horizontal scroll
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        
        var editor = this.editor;
        
        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
        
        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        
        // touchbar keeps sending scroll events after touchend, if we do not stop these events,
        // users can't scrol editor without scrolling the parent node
        if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }
        
        var direction = Math.abs(vx / vy);
        
        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
            
        if (canScroll) {
            prevScroll.allowed = t;
        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }
        
        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;

        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    }

}
DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;

exports.J = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}


/***/ }),

/***/ 69615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 */
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

/**
 * @param {MouseHandler} mouseHandler
 */
function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var dragImage = dom.createElement("div");
    dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
    dragImage.textContent = "\xa0";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);
    // @ts-ignore
    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));

    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragStart = function(e) {
        // webkit workaround, see this.onMouseDown
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        editor.container.appendChild(dragImage);

        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(function() {
            editor.container.removeChild(dragImage);
        });
        // clear Opera garbage
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                // text was dragged outside the editor
                editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        // dataTransfer object does not save dropEffect across events on IE, so we store it in dragOperation
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        // Opera doesn't trigger dragenter event on drag start
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        // clear selection
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        // move text
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    // copy text
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }

    // sometimes other code on the page can stop dragleave event leaving editor stuck in the drag state
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;

        // IE throws error while dragging from another app
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

/**
 * @this {MouseHandler}
 */
(function() {

    /**
     * @this {MouseHandler & this}
     */
    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.dragReadyEnd = function(e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    /**
     * @this {MouseHandler & this}
     */
    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            // IE does not handle [draggable] attribute set after mousedown
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                // @ts-ignore
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    /**
     * @this {MouseHandler & this}
     */
    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                // https://code.google.com/p/chromium/issues/detail?id=286700
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            // TODO: a better way to prevent default handler without preventing browser default action
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.O = DragdropHandler;


/***/ }),

/***/ 99847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var dom = __webpack_require__(71435);

class FoldHandler {
    constructor(editor) {

        editor.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor.session;

            // If the user clicked on a fold, then expand it.
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
                if (e.getAccelKey())
                    session.removeFold(fold);
                else
                    session.expandFold(fold);

                e.stop();
            }

            var target = e.domEvent && e.domEvent.target;
            if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                    session.setOption("wrap", !session.getUseWrapMode());
                    editor.renderer.scrollCursorIntoView();
                }
            }
        });

        editor.on("gutterclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                    editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                    editor.focus();
                e.stop();
            }
        });

        editor.on("gutterdblclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;

                if (range) {
                    row = range.start.row;
                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                    if (fold) {
                        session.removeFold(fold);
                    } else {
                        session.addFold("...", range);
                        editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                    }
                }
                e.stop();
            }
        });
    }
}

exports.e = FoldHandler;


/***/ }),

/***/ 85519:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

/*
 * Custom Ace mouse event
 */
class MouseEvent {
    constructor(domEvent, editor) {
        /** @type {number} */this.speed;
        /** @type {number} */this.wheelX;
        /** @type {number} */this.wheelY;
        this.domEvent = domEvent;
        this.editor = editor;

        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;

        this.$pos = null;
        this.$inSelection = null;

        this.propagationStopped = false;
        this.defaultPrevented = false;
    }
    
    stopPropagation() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    }
    
    preventDefault() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    }
    
    stop() {
        this.stopPropagation();
        this.preventDefault();
    }

    /**
     * Get the document position below the mouse cursor
     * 
     * @return {Object} 'row' and 'column' of the document position
     */
    getDocumentPosition() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    }

    /**
     * Get the relative position within the gutter.
     * 
     * @return {Number} 'row' within the gutter. 
     */
    getGutterRow() {
        var documentRow = this.getDocumentPosition().row;
        var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
        var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
        return screenRow - screenTopRow;
    }
    
    /**
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */
    inSelection() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    }
    
    /**
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */
    getButton() {
        return event.getButton(this.domEvent);
    }
    
    /**
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */
    getShiftKey() {
        return this.domEvent.shiftKey;
    }

    getAccelKey() {
        return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
    }
}

exports.C = MouseEvent;


/***/ }),

/***/ 32291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 */
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);
var DefaultHandlers = (__webpack_require__(88416)/* .DefaultHandlers */ .J);
var DefaultGutterHandler = (__webpack_require__(83229)/* .GutterHandler */ .Y);
var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);
var DragdropHandler = (__webpack_require__(69615)/* .DragdropHandler */ .O);
var addTouchListeners = (__webpack_require__(55119)/* .addTouchListeners */ .A);
var config = __webpack_require__(76321);

class MouseHandler {
    /**
     * @param {Editor} editor
     */
    constructor(editor) {
        /** @type {boolean} */this.$dragDelay;
        /** @type {boolean} */this.$dragEnabled;
        /** @type {boolean} */this.$mouseMoved;
        /** @type {MouseEvent} */this.mouseEvent;
        /** @type {number} */this.$focusTimeout;
        var _self = this;
        this.editor = editor;

        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);

        var focusEditor = function(e) {
            // because we have to call event.preventDefault() any window on ie and iframes
            // on other browsers do not get focus, so we have to call window.focus() here
            var windowBlurred = !document.hasFocus || !document.hasFocus()
                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
            if (windowBlurred)
                window.focus();
            editor.focus();
            // Without this editor is blurred after double click
            setTimeout(function () {
                if (!editor.isFocused()) editor.focus();
            });
        };

        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
        event.addMultiMouseDownListener([
            mouseTarget,
            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
            editor.textInput && editor.textInput.getElement()
        ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
        addTouchListeners(editor.container, editor);

        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);

        event.addListener(mouseTarget, "mousedown", focusEditor, editor);
        event.addListener(gutterEl, "mousedown", focusEditor, editor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
        }

        editor.on("mousemove", function(e){
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;

            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.session.selection.getRange();
            var renderer = editor.renderer;

            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
            } else {
                renderer.setCursorStyle("");
            }

        }, //@ts-expect-error TODO: seems mistyping - should be boolean
            editor);
    }

    onMouseEvent(name, e) {
        if (!this.editor.session) return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    }

    onMouseMove(name, e) {
        // optimization, because mousemove doesn't have a default handler.
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    }

    /**
     * @param {any} name
     * @param {{ wheelX: number; wheelY: number; }} e
     */
    onMouseWheel(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        //@ts-expect-error TODO: couldn't find this property init in the ace codebase
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    }

    setState(state) {
        this.state = state;
    }

    captureMouse(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;

        // do not move textarea during selection
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            // if editor is loaded inside iframe, and mouseup event is outside
            // we won't recieve it, so we cancel on first mousemove without button
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            editor.off("beforeEndOperation", onOperationEnd);
            clearInterval(timerId);
            if (editor.session) onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            self.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
            editor.endOperation();
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        var onOperationEnd = function(e) {
            if (!self.releaseMouse) return;
            // some touchpads fire mouseup event after a slight delay,
            // which can cause problems if user presses a keyboard shortcut quickly
            if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self[self.state + "End"] && self[self.state + "End"]();
                self.state = "";
                self.releaseMouse();
            }
        };

        editor.on("beforeEndOperation", onOperationEnd);
        editor.startOperation({command: {name: "mouse"}});

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    }
    cancelContextMenu() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    }
    destroy() {
        if (this.releaseMouse) this.releaseMouse();
    }
}

MouseHandler.prototype.releaseMouse = null;

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimeout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.e = MouseHandler;


/***/ }),

/***/ 38610:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

// mouse
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.r = onMouseDown;


/***/ }),

/***/ 55119:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);
var event = __webpack_require__(19631);
var dom = __webpack_require__(71435);

exports.A = function(el, editor) {
    var mode = "scroll";
    var startX;
    var startY;
    var touchStartT;
    var lastT;
    var longTouchTimer;
    var animationTimer;
    var animationSteps = 0;
    var pos;
    var clickCount = 0;
    var vX = 0;
    var vY = 0;
    var pressed;
    var contextMenu;
    
    function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(
                dom.buildDom(isOpen ? ["span",
                    !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                    selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                    selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                    clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                    hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                    canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                    canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
                ] : ["span"]),
                contextMenu.firstChild
            );
        };
        
        var canExecuteCommand = function (/** @type {string} */ cmd) {
            return editor.commands.canExecute(cmd, editor);
        };
        
        var handleClick = function(e) {
            var action = e.target.getAttribute("action");

            if (action == "more" || !isOpen) {
                isOpen = !isOpen;
                return updateMenu();
            }
            if (action == "paste") {
                clipboard.readText().then(function (text) {
                    editor.execCommand(action, text);
                });
            }
            else if (action) {
                if (action == "cut" || action == "copy") {
                    if (clipboard)
                        clipboard.writeText(editor.getCopyText());
                    else
                        document.execCommand("copy");
                }
                editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
                editor.focus();
        };
        contextMenu = dom.buildDom(["div",
            {
                class: "ace_mobile-menu",
                ontouchstart: function(e) {
                    mode = "menu";
                    e.stopPropagation();
                    e.preventDefault();
                    editor.textInput.focus();
                },
                ontouchend: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    handleClick(e);
                },
                onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], editor.container);
    }
    function showContextMenu() {
        if (!editor.getOption("enableMobileMenu")) {
            if (contextMenu) {
                hideContextMenu();
            }
            return;
        }
        if (!contextMenu) createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor.renderer.scrollLeft;
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
        } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
        }
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor.on("input", hideContextMenu);
    }
    function hideContextMenu(e) {
        if (contextMenu)
            contextMenu.style.display = "none";
        editor.off("input", hideContextMenu);
    }

    function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
    }
    function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount >= 2
            ? editor.selection.getLineRange(pos.row)
            : editor.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
        } else {
            editor.selection.selectWord();
        }
        mode = "wait";
    }
    event.addListener(el, "contextmenu", function(e) {
        if (!pressed) return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
    }, editor);
    event.addListener(el, "touchstart", function (e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
        }
        
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h = editor.renderer.layerConfig.lineHeight;
        var w = editor.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        // reset clickCount if the new touch is far from the old one
        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
        
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        
        var ev = new MouseEvent(e, editor);
        pos = ev.getDocumentPosition();

        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
        } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x, y) {
                x = x / w;
                y = y / h - 0.75;
                return x * x + y * y;
            };
            
            if (e.clientX < rect.left) {
                mode = "zoom";
                return;
            }
            
            var diff1 = weightedDistance(
                e.clientX - rect.left - cursorPos.left + offsetLeft,
                e.clientY - rect.top - cursorPos.top + offsetTop
            );
            var diff2 = weightedDistance(
                e.clientX - rect.left - anchorPos.left + offsetLeft,
                e.clientY - rect.top - anchorPos.top + offsetTop
            );
            if (diff1 < 3.5 && diff2 < 3.5)
                mode = diff1 > diff2 ? "cursor" : "anchor";
                
            if (diff2 < 3.5)
                mode = "anchor";
            else if (diff1 < 3.5)
                mode = "cursor";
            else
                mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
    }, editor);

    event.addListener(el, "touchend", function (e) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer) clearInterval(animationTimer);
        if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
        } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
        } else if (mode == "scroll") {
            animate();
            hideContextMenu();
        } else {
            showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
    }, editor);
    event.addListener(el, "touchmove", function (e) {
        if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length > 1 || mode == "zoom") return;

        var touchObj = touches[0];

        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;

        if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
                mode = "cursor";
            else
                return e.preventDefault();
        }

        startX = touchObj.clientX;
        startY = touchObj.clientY;

        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;

        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
            if (dt != 0) {
                vX = wheelX / dt;
                vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
                vX = vY = 0;
            }
        }
        else {
            var ev = new MouseEvent(e, editor);
            var pos = ev.getDocumentPosition();
            if (mode == "cursor")
                editor.selection.moveCursorToPosition(pos);
            else if (mode == "anchor")
                editor.selection.setSelectionAnchor(pos.row, pos.column);
            editor.renderer.scrollCursorIntoView(pos);
            e.preventDefault();
        }
    }, editor);

    function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
            if (Math.abs(vX) < 0.01) vX = 0;
            if (Math.abs(vY) < 0.01) vY = 0;
            if (animationSteps < 20) vX = 0.9 * vX;
            if (animationSteps < 20) vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
                animationSteps = 0;
        }, 10);
    }
};


/***/ }),

/***/ 48369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @typedef {import("./anchor").Anchor} Anchor
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.ScreenCoordinates} ScreenCoordinates
 */

var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Selection = (__webpack_require__(98345)/* .Selection */ .L);
var onMouseDown = (__webpack_require__(38610)/* .onMouseDown */ .r);
var event = __webpack_require__(19631);
var lang = __webpack_require__(39955);
var commands = __webpack_require__(45375);
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);

// Todo: session.find or editor.findVolatile that returns range
var Search = (__webpack_require__(99427)/* .Search */ .v);
var search = new Search();

/**
 * @param {EditSession} session
 * @param {string | RegExp} needle
 * @param {number} dir
 */
function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}

// extend EditSession
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
(function() {
    /**
     * @this {EditSession}
     */
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);

// extend Selection
(function() {
    // list of ranges in reverse addition order
    this.ranges = null;

    // automatically sorted list of ranges
    /**@type {RangeList | null} */
    this.rangeList = null;

    /**
     * Adds a range to a selection by entering multiselect mode, if necessary.
     * @param {Range} range The new range to add
     * @param {Boolean} $blockChangeEvents Whether or not to block changing events
     * @this {Selection}
     **/
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    /**
     * @param {Range} [range]
     * @this {Selection}
     **/
    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };

    /**
     * Removes a Range containing pos (if it exists).
     * @param {Point} pos The position to remove, as a `{row, column}` object
     * @this {Selection}
     **/
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };

    /**
     * Merges overlapping ranges ensuring consistency after changes
     * @this {Selection}
     **/
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
    };

    /**
     * @param {Range} range
     * @this {Selection}
     */
    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    /**
     * @param {Range[]} removed
     * @this {Selection}
     */
    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            // @ts-expect-error TODO: possible bug, no args in parameters
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };

    /**
     * adds multicursor support to selection
     * @this {Selection}
     */
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };

    /**
     * Returns a concatenation of all the ranges.
     * @returns {Range[]}
     * @this {Selection}
     **/
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    /**
     * Splits all the ranges into lines.
     * @this {Selection}
     **/
    this.splitIntoLines = function () {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
                newRanges.push(range.clone());
            } else {
                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                while (++row < endRow)
                    newRanges.push(this.getLineRange(row, true));
                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
                newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--;)
            this.addRange(newRanges[i]);
    };

    /**
     * @this {Selection}
     */
    this.joinSelections = function () {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);

        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
    };

    /**
     * @this {Selection}
     **/
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            // @ts-expect-error TODO: possible bug
            rectSel.forEach(this.addRange, this);
        }
    };

    /**
     * Gets list of ranges composing rectangular block on the screen
     *
     * @param {ScreenCoordinates} screenCursor The cursor to use
     * @param {ScreenCoordinates} screenAnchor The anchor to use
     * @param {Boolean} [includeEmptyLines] If true, this includes ranges inside the block which are empty due to clipping
     * @returns {Range[]}
     * @this {Selection}
     **/
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);

// extend Editor
var Editor = (__webpack_require__(27258).Editor);
(function() {

    /**
     *
     * Updates the cursor and marker layers.
     * @method Editor.updateSelectionMarkers
     * @this {Editor}
     **/
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * Adds the selection and cursor.
     * @param {Range & {marker?}} orientedRange A range containing a cursor
     * @returns {Range & {marker?}}
     * @this {Editor}
     **/
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };

    /**
     * Removes the selection marker.
     * @param {Range & {marker?}} range The selection range added with [[Editor.addSelectionMarker `addSelectionMarker()`]].
     * @this {Editor}
     **/
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    /**
     * @param {(Range & {marker?})[]} ranges
     * @this {Editor}
     */
    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };

    /**
     * Executes a command for each selection range.
     * @param {any} cmd The command to execute
     * @param {String} [args] Any arguments for the command
     * @param {Object|true} [options]
     * @this {Editor}
     **/
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;

        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);

        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);

        return result;
    };

    /**
    * Removes all the selections except the last added one.
    * @this {Editor}
    **/
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    /**
     * @this {Editor}
     * @return {string}
     */
    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };

    /**
     * @param e
     * @param {Anchor} anchor
     * @this {Editor}
     */
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
                this.multiSelect.mergeOverlappingRanges();
        }
    };

    /**
     * Finds and selects all the occurrences of `needle`.
     * @param {String} [needle] The text to find
     * @param {Partial<import("../ace-internal").Ace.SearchOptions>} [options] The search options
     * @param {Boolean} [additive] keeps
     *
     * @returns {Number} The cumulative count of all found matches
     * @this {Editor}
     **/
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);

        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);

        // keep old selection as primary if possible
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);

        return ranges.length;
    };

    /**
     * Adds a cursor above or below the active cursor.
     *
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} [skip] If `true`, removes the active selection range
     *
     * @this {Editor}
     */
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            /**@type {Range & {desiredColumn?: number}}*/
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            /**@type {Range & {desiredColumn?: number}}*/
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };

    /**
     * Transposes the selected ranges.
     * @param {Number} dir The direction to rotate selections
     * @this {Editor}
     **/
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                let tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
    };

    /**
     * Finds the next occurrence of text in an active selection and adds it to the selections.
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} [skip] If `true`, removes the active selection range
     * @param {Boolean} [stopAtFirst]
     * @this {Editor}
     **/
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };

    /**
     * Aligns the cursors or selected text.
     * @this {Editor}
     **/
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        // filter out ranges on same row
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });

        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);

                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    /**
     * @param {string[]} lines
     * @param {boolean} [forceLeft]
     * @return {*}
     * @this {Editor}
     */
    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


/** @param {Point} p1  @param {Point} p2 */
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}


/**
 * patch
 * adds multicursor support to a session
 * @this {Editor}
 * @type {(e: any) => void}
 */
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};

// MultiSelect(editor)
// adds multiple selection support to the editor
// (note: should be called only once for each editor instance)
/**
 * @param {Editor} editor
 */
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

/**
 * @param {Editor} editor
 */
function addAltCursorListeners(editor){
    if (!editor.textInput) return;
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    }, editor);

    event.addListener(el, "keyup", reset, editor);
    event.addListener(el, "blur", reset, editor);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
            // TODO disable menu popping up
            // e && e.preventDefault()
        }
    }
}

exports.MultiSelect = MultiSelect;


(__webpack_require__(76321).defineOptions)(Editor.prototype, "editor", {
    enableMultiselect: {
        /**
         * @param {boolean} val
         * @this {Editor}
         */
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("mousedown", onMouseDown);
            } else {
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});


/***/ }),

/***/ 30214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var oop = __webpack_require__(2645);

class PlaceHolder {
    /**
     * @param {EditSession} session
     * @param {Number} length
     * @param {import("../ace-internal").Ace.Point} pos
     * @param {any[]} others
     * @param {String} mainClass
     * @param {String} othersClass
     **/
    constructor(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate, true);
        this.$others = others;

        this.$onCursorChange = function() {
            setTimeout(function() {
                _self.onCursorChange();
            });
        };

        this.$pos = pos;
        // Used for reset
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();

        session.selection.on("changeCursor", this.$onCursorChange);
    }

    /**
     * PlaceHolder.setup()
     *
     * TODO
     *
     **/
    setup() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;

        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    }

    /**
     * PlaceHolder.showOtherMarkers()
     *
     * TODO
     *
     **/
    showOtherMarkers() {
        if (this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
        });
    }

    /**
     * PlaceHolder.hideOtherMarkers()
     *
     * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
     *
     **/
    hideOtherMarkers() {
        if (!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    }

    /**
     * PlaceHolder@onUpdate(e)
     *
     * Emitted when the place holder updates.
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onUpdate(delta) {
        if (this.$updating)
            return this.updateAnchors(delta);

        var range = delta;
        if (range.start.row !== range.end.row) return;
        if (range.start.row !== this.pos.row) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;

        this.updateAnchors(delta);

        if (inMainRange)
            this.length += lengthDiff;

        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            } else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }

        this.$updating = false;
        this.updateMarkers();
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    updateAnchors(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    }

    updateMarkers() {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    }


    /**
     * PlaceHolder@onCursorChange(e)
     *
     * Emitted when the cursor changes.
     * @param {any} [event]
     * @internal
     */
    onCursorChange(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    }

    /**
     * PlaceHolder.detach()
     *
     * TODO
     *
     **/
    detach() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off("change", this.$onUpdate);
        this.session.selection.off("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    }

    /**
     * PlaceHolder.cancel()
     *
     * TODO
     *
     **/
    cancel() {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    }
}

oop.implement(PlaceHolder.prototype, EventEmitter);

exports.PlaceHolder = PlaceHolder;


/***/ }),

/***/ 91902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.Point} Point
 */
/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogous to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 **/
class Range {
    /**
     * Creates a new `Range` object with the given starting and ending rows and columns.
     * @param {Number} [startRow] The starting row
     * @param {Number} [startColumn] The starting column
     * @param {Number} [endRow] The ending row
     * @param {Number} [endColumn] The ending column
     * @constructor
     **/
    constructor(startRow, startColumn, endRow, endColumn) {
        /**@type {Point}*/
        this.start = {
            row: startRow,
            column: startColumn
        };
        /**@type {Point}*/
        this.end = {
            row: endRow,
            column: endColumn
        };
    }
    
    /**
     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
     * @param {IRange} range A range to check against
     * @return {Boolean}
     **/
    isEqual(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    }

    /**
     * Returns a string containing the range's row and column information, given like this:
     * ```
     *    [start.row/start.column] -> [end.row/end.column]
     * ```
     * @return {String}
     **/
    toString() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    }

    /**
     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
     * ```javascript
     *    this.start.row <= row <= this.end.row &&
     *    this.start.column <= column <= this.end.column
     * ```
     * @param {Number} row A row to check for
     * @param {Number} column A column to check for
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/

    contains(row, column) {
        return this.compare(row, column) == 0;
    }

    /**
     * Compares `this` range (A) with another range (B).
     * @param {IRange} range A range to compare with
     * @related [[Range.compare]]
     * @returns {Number} This method returns one of the following numbers:
     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)
     * * `-1`: (B) begins before (A) but ends inside of (A)
     * * `0`: (B) is completely inside of (A)
     * * `+1`: (B) begins inside of (A) but ends outside of (A)
     * * `+2`: (B) is after (A) and doesn't intersect with (A)
     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)
     **/
    compareRange(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    }

    /**
     * Compares the row and column of `p` with the starting and ending [[Point]]'s of the calling range (by calling [[Range.compare]]).
     * @param {Point} p A point to compare with
     * @related [[Range.compare]]
     * @returns {Number}
     **/
    comparePoint(p) {
        return this.compare(p.row, p.column);
    }

    /**
     * Checks the start and end [[Point]]'s of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
     * @param {IRange} range A range to compare with
     * @returns {Boolean}
     * @related [[Range.comparePoint]]
     **/
    containsRange(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    }

    /**
     * Returns `true` if passed in `range` intersects with the one calling this method.
     * @param {IRange} range A range to compare with
     * @returns {Boolean}
     **/
    intersects(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    }

    /**
     * Returns `true` if the caller's ending row is the same as `row`, and if the caller's ending column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/
    isEnd(row, column) {
        return this.end.row == row && this.end.column == column;
    }

    /**
     * Returns `true` if the caller's starting row is the same as `row`, and if the caller's starting column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/
    isStart(row, column) {
        return this.start.row == row && this.start.column == column;
    }

    /**
     * Sets the starting row and column for the range.
     * @param {Number|Point} row A row to set
     * @param {Number} [column] A column to set
     *
     **/
    setStart(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    }

    /**
     * Sets the starting row and column for the range.
     * @param {Number|Point} row A row to set
     * @param {Number} [column] A column to set
     *
     **/
    setEnd(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/
    inside(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range's starting [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/
    insideStart(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range's ending [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     *
     **/
    insideEnd(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if `row` is greater than the calling range
     * * `-1` if `row` is less then the calling range
     * * `0` otherwise
     *
     * If the starting row of the calling range is equal to `row`, and:
     * * `column` is greater than or equal to the calling range's starting column, this returns `0`
     * * Otherwise, it returns -1
     *
     * If the ending row of the calling range is equal to `row`, and:
     * * `column` is less than or equal to the calling range's ending column, this returns `0`
     * * Otherwise, it returns 1
     **/
    compare(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `-1` if calling range's starting column and calling range's starting row are equal `row` and `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/
    compareStart(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if calling range's ending column and calling range's ending row are equal `row` and `column`.
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     */
    compareEnd(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Compares the `row` and `column` with the start and end [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`
     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/
    compareInside(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
     * @param {Number} firstRow The starting row
     * @param {Number} lastRow The ending row
     * @returns {Range}
    **/
    clipRows(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    }

    /**
     * Changes the `row` and `column` for the calling range for both the starting and ending [[Point]]'s.
     * @param {Number} row A new row to extend to
     * @param {Number} column A new column to extend to
     * @returns {Range} The original range with the new row
    **/
    extend(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    }

    /**
     * Returns `true` if the calling range is empty (starting [[Point]] == ending [[Point]]).
     * @returns {Boolean}
     **/
    isEmpty() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    }

    /**
     * Returns `true` if the range spans across multiple lines.
     * @returns {Boolean}
    **/
    isMultiLine() {
        return (this.start.row !== this.end.row);
    }

    /**
     * Returns a duplicate of the calling range.
     * @returns {Range}
    **/
    clone() {
        return Range.fromPoints(this.start, this.end);
    }

    /**
     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
     * @returns {Range}
    **/
    collapseRows() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    }

    /**
     * Given the current `Range`, this function converts those starting and ending [[Point]]'s into screen positions, and then returns a new `Range` object.
     * @param {EditSession} session The `EditSession` to retrieve coordinates from
     * @returns {Range}
    **/
    toScreenRange(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    }

    /**
     * Shift the calling range by `row` and `column` values.
     * @param {Number} row
     * @param {Number} column
     * @experimental
     */
    moveBy(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    }

}

/**
 * Creates and returns a new `Range` based on the `start` [[Point]] and `end` [[Point]] of the given parameters.
 * @param {Point} start A starting point to use
 * @param {Point} end An ending point to use
 * @returns {Range}
**/
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};

/**
 * Compares `p1` and `p2` [[Point]]'s, useful for sorting
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Number}
 */
Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};

exports.Q = Range;


/***/ }),

/***/ 53509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Point} Point
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var comparePoints = Range.comparePoints;

class RangeList {
    
    constructor() {
        this.ranges = [];
        this.$bias = 1;
    }

    /**
     * @param {Point} pos
     * @param {boolean} [excludeEdges]
     * @param {number} [startIndex]
     * @return {number}
     */
    pointIndex(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    }

    /**
     * @param {Range} range
     */
    add(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    }

    /**
     * @param {Range[]} list
     */
    addList(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    }

    /**
     * @param {Point} pos
     */
    substractPoint(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    }

    // merge overlapping ranges
    merge() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    }

    /**
     * @param {number} row
     * @param {number} column
     */
    contains(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    }

    /**
     * @param {Point} pos
     */
    containsPoint(pos) {
        return this.pointIndex(pos) >= 0;
    }

    /**
     * @param {Point} pos
     */
    rangeAtPoint(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    }


    /**
     * @param {number} startRow
     * @param {number} endRow
     */
    clipRows(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        //@ts-expect-error TODO: potential wrong argument
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    }

    removeAll() {
        return this.ranges.splice(0, this.ranges.length);
    }

    /**
     * @param {EditSession} session
     */
    attach(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    }

    detach() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    $onChange(delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row >= startRow)
                break;
        }
        
        if (delta.action == "insert") {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                    break;
    
                if (r.start.row == startRow && r.start.column >= start.column) {
                    if (r.start.column == start.column && this.$bias <= 0) {
                        // do nothing
                    } else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                    if (r.end.column == start.column && this.$bias < 0) {
                        continue;
                    }
                    // special handling for the case when two ranges share an edge
                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                            r.end.column -= colDiff;
                    }
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                }
            }
        } else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                
                if (r.start.row > endRow)
                    break;
                    
                if (r.end.row < endRow
                    && (
                        startRow < r.end.row 
                        || startRow == r.end.row && start.column < r.end.column
                    )
                ) {
                    r.end.row = startRow;
                    r.end.column = start.column;
                }
                else if (r.end.row == endRow) {
                    if (r.end.column <= end.column) {
                        if (lineDif || r.end.column > start.column) {
                            r.end.column = start.column;
                            r.end.row = start.row;
                        }
                    }
                    else {
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
                else if (r.end.row > endRow) {
                    r.end.row += lineDif;
                }
                
                if (r.start.row < endRow
                    && (
                        startRow < r.start.row 
                        || startRow == r.start.row && start.column < r.start.column
                    )
                ) {
                    r.start.row = startRow;
                    r.start.column = start.column;
                }
                else if (r.start.row == endRow) {
                    if (r.start.column <= end.column) {
                        if (lineDif || r.start.column > start.column) {
                            r.start.column = start.column;
                            r.start.row = start.row;
                        }
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                else if (r.start.row > endRow) {
                    r.start.row += lineDif;
                }
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    }

}

RangeList.prototype.comparePoints = comparePoints;

exports.U = RangeList;


/***/ }),

/***/ 99481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var event = __webpack_require__(19631);

/**
 * Batches changes (that force something to be redrawn) in the background.
 **/
class RenderLoop {
    
    constructor(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.$recursionLimit = 2;
        this.window = win || window;
        var _self = this;
        this._flush = function (ts) {
            _self.pending = false;
            var changes = _self.changes;

            if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
            }

            if (_self.changes) {
                if (_self.$recursionLimit-- < 0) return;
                _self.schedule();
            }
            else {
                _self.$recursionLimit = 2;
            }
        };
    }

    schedule(change) {
        this.changes = this.changes | change;
        if (this.changes && !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
        }
    }

    clear(change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
    }
    
}

exports.x = RenderLoop;


/***/ }),

/***/ 17745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
// on ie maximal element height is smaller than what we get from 4-5K line document
// so scrollbar doesn't work, as a workaround we do not set height higher than MAX_SCROLL_H
// and rescale scrolltop
var MAX_SCROLL_H = 0x8000;

/**
 * An abstract class representing a native scrollbar control.
 **/
class Scrollbar {
    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {string} classSuffix
     **/
    constructor(parent, classSuffix) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;

        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        // on safari scrollbar is not shown for empty elements
        this.inner.textContent = "\xa0";
        this.element.appendChild(this.inner);

        parent.appendChild(this.element);

        this.setVisible(false);
        this.skipEvent = false;

        // @ts-expect-error
        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
    }

    setVisible(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    }
}
oop.implement(Scrollbar.prototype, EventEmitter);

/**
 * Represents a vertical scroll bar.
 **/
class VScrollBar extends Scrollbar {
    /**
     * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-v');
        this.scrollTop = 0;
        this.scrollHeight = 0;

        // in OSX lion the scrollbars appear to have no width. In this case resize the
        // element to show the scrollbar but still pretend that the scrollbar has a width
        // of 0px
        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
        // make element a little bit wider to retain scrollbar when page is zoomed
        renderer.$scrollbarWidth =
            this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width =
            this.element.style.width = (this.width || 15) + 5 + "px";
        this.$minWidth = 0;
    }


    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @internal
     **/

    onScroll() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    }

    /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/
    getWidth() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    }

    /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/
    setHeight(height) {
        this.element.style.height = height + "px";
    }

    /**
     * Sets the scroll height of the scroll bar, in pixels.
     * @param {Number} height The new scroll height
     **/
    setScrollHeight(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
            this.coeff = 1;
        }
        this.inner.style.height = height + "px";
    }


    /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/
    setScrollTop(scrollTop) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    }

}

/**
 * Sets the inner height of the scroll bar, in pixels.
 * @param {Number} height The new inner height
 * @deprecated Use setScrollHeight instead
 **/
VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;

/**
 * Represents a horisontal scroll bar.
 **/
class HScrollBar extends Scrollbar {
    /**
     * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-h');
        this.scrollLeft = 0;

        // in OSX lion the scrollbars appear to have no width. In this case resize the
        // element to show the scrollbar but still pretend that the scrollbar has a width
        // of 0px
        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
        // make element a little bit wider to retain scrollbar when page is zoomed
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height =
            this.element.style.height = (this.height || 15) + 5 + "px";
    }

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @internal
     **/
    onScroll() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    }

    /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/
    getHeight() {
        return this.isVisible ? this.height : 0;
    }

    /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/
    setWidth(width) {
        this.element.style.width = width + "px";
    }

    /**
     * Sets the inner width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @deprecated Use setScrollWidth instead
     **/
    setInnerWidth(width) {
        this.inner.style.width = width + "px";
    }

    /**
     * Sets the scroll width of the scroll bar, in pixels.
     * @param {Number} width The new scroll width
     **/
    setScrollWidth(width) {
        this.inner.style.width = width + "px";
    }

    /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/
    setScrollLeft(scrollLeft) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    }

}


__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = HScrollBar; // backward compatibility

exports.vB = VScrollBar;
exports.V1 = HScrollBar;


/***/ }),

/***/ 50311:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

dom.importCssString(`.ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{
  position: absolute;
  background: rgba(128, 128, 128, 0.6);
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  border: 1px solid #bbb;
  border-radius: 2px;
  z-index: 8;
}
.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {
  position: absolute;
  z-index: 6;
  background: none;
  overflow: hidden!important;
}
.ace_editor>.ace_sb-v {
  z-index: 6;
  right: 0;
  top: 0;
  width: 12px;
}
.ace_editor>.ace_sb-v div {
  z-index: 8;
  right: 0;
  width: 100%;
}
.ace_editor>.ace_sb-h {
  bottom: 0;
  left: 0;
  height: 12px;
}
.ace_editor>.ace_sb-h div {
  bottom: 0;
  height: 100%;
}
.ace_editor>.ace_sb_grabbed {
  z-index: 8;
  background: #000;
}`, "ace_scrollbar.css", false);

/**
 * An abstract class representing a native scrollbar control.
 **/
class ScrollBar {
    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {string} classSuffix
     **/
    constructor(parent, classSuffix) {
        this.element = dom.createElement("div");
        this.element.className = "ace_sb" + classSuffix;
        this.inner = dom.createElement("div");
        this.inner.className = "";
        this.element.appendChild(this.inner);
        this.VScrollWidth = 12;
        this.HScrollHeight = 12;

        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;

        event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
    }

    setVisible(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    }
}

oop.implement(ScrollBar.prototype, EventEmitter);
/**
 * Represents a vertical scroll bar.
 * @class VScrollBar
 **/

/**
 * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
 * @param {Element} parent A DOM element
 * @param {Object} renderer An editor renderer
 *
 * @constructor
 **/
class VScrollBar extends ScrollBar {

    constructor(parent, renderer) {
        super(parent, '-v');
        this.scrollTop = 0;
        this.scrollHeight = 0;
        this.parent = parent;
        this.width = this.VScrollWidth;
        this.renderer = renderer;
        this.inner.style.width = this.element.style.width = (this.width || 15) + "px";
        this.$minWidth = 0;
    }

    /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     * @internal
     **/
    onMouseDown(eType, e) {
        if (eType !== "mousedown") return;

        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }

        if (e.target === this.inner) {
            var self = this;
            var mousePageY = e.clientY;

            var onMouseMove = function (e) {
                mousePageY = e.clientY;
            };

            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startY = e.clientY;
            var startTop = this.thumbTop;

            var onScrollInterval = function () {
                if (mousePageY === undefined) return;
                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self.scrollTop) return;
                self._emit("scroll", {data: scrollTop});
            };

            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
        this._emit("scroll", {data: this.scrollTopFromThumbTop(top)});
        return event.preventDefault(e);
    }

    getHeight() {
        return this.height;
    }

    /**
     * Returns new top for scroll thumb
     * @param {Number}thumbTop
     * @returns {Number}
     **/
    scrollTopFromThumbTop(thumbTop) {
        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
        scrollTop = scrollTop >> 0;
        if (scrollTop < 0) {
            scrollTop = 0;
        }
        else if (scrollTop > this.pageHeight - this.viewHeight) {
            scrollTop = this.pageHeight - this.viewHeight;
        }
        return scrollTop;
    }

    /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/
    getWidth() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    }

    /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/
    setHeight(height) {
        this.height = Math.max(0, height);
        this.slideHeight = this.height;
        this.viewHeight = this.height;

        this.setScrollHeight(this.pageHeight, true);
    }

    /**
     * Sets the inner and scroll height of the scroll bar, in pixels.
     * @param {Number} height The new inner height
     *
     * @param {boolean} force Forcely update height
     **/
    setScrollHeight(height, force) {
        if (this.pageHeight === height && !force) return;
        this.pageHeight = height;
        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;

        if (this.thumbHeight > this.slideHeight) this.thumbHeight = this.slideHeight;
        if (this.thumbHeight < 15) this.thumbHeight = 15;

        this.inner.style.height = this.thumbHeight + "px";

        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {
            this.scrollTop = (this.pageHeight - this.viewHeight);
            if (this.scrollTop < 0) this.scrollTop = 0;
            this._emit("scroll", {data: this.scrollTop});
        }
    }

    /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/
    setScrollTop(scrollTop) {
        this.scrollTop = scrollTop;
        if (scrollTop < 0) scrollTop = 0;
        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
        this.inner.style.top = this.thumbTop + "px";
    }
}

VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;

/**
 * Represents a horizontal scroll bar.
 **/
class HScrollBar extends ScrollBar {
    /**
     * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-h');
        this.scrollLeft = 0;
        this.scrollWidth = 0;
        this.height = this.HScrollHeight;
        this.inner.style.height = this.element.style.height = (this.height || 12) + "px";
        this.renderer = renderer;
    }

    /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     * @internal
     **/
    onMouseDown(eType, e) {
        if (eType !== "mousedown") return;

        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }


        if (e.target === this.inner) {
            var self = this;
            var mousePageX = e.clientX;

            var onMouseMove = function (e) {
                mousePageX = e.clientX;
            };

            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startX = e.clientX;
            var startLeft = this.thumbLeft;

            var onScrollInterval = function () {
                if (mousePageX === undefined) return;
                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self.scrollLeft) return;
                self._emit("scroll", {data: scrollLeft});
            };

            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }

        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
        this._emit("scroll", {data: this.scrollLeftFromThumbLeft(left)});
        return event.preventDefault(e);
    }

    /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/
    getHeight() {
        return this.isVisible ? this.height : 0;
    }

    /**
     * Returns new left for scroll thumb
     * @param {Number} thumbLeft
     * @returns {Number}
     **/
    scrollLeftFromThumbLeft(thumbLeft) {
        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
        scrollLeft = scrollLeft >> 0;
        if (scrollLeft < 0) {
            scrollLeft = 0;
        }
        else if (scrollLeft > this.pageWidth - this.viewWidth) {
            scrollLeft = this.pageWidth - this.viewWidth;
        }
        return scrollLeft;
    }

    /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/
    setWidth(width) {
        this.width = Math.max(0, width);
        this.element.style.width = this.width + "px";
        this.slideWidth = this.width;
        this.viewWidth = this.width;

        this.setScrollWidth(this.pageWidth, true);
    }

    /**
     * Sets the inner and scroll width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @param {boolean} force Forcely update width
     **/
     setScrollWidth(width, force) {
        if (this.pageWidth === width && !force) return;
        this.pageWidth = width;
        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;

        if (this.thumbWidth > this.slideWidth) this.thumbWidth = this.slideWidth;
        if (this.thumbWidth < 15) this.thumbWidth = 15;
        this.inner.style.width = this.thumbWidth + "px";

        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {
            this.scrollLeft = (this.pageWidth - this.viewWidth);
            if (this.scrollLeft < 0) this.scrollLeft = 0;
            this._emit("scroll", {data: this.scrollLeft});
        }
    }


    /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/
    setScrollLeft(scrollLeft) {
        this.scrollLeft = scrollLeft;
        if (scrollLeft < 0) scrollLeft = 0;
        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
        this.inner.style.left = (this.thumbLeft) + "px";
    }

}

HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;

__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = HScrollBar; // backward compatibility

exports.vB = VScrollBar;
exports.V1 = HScrollBar;


/***/ }),

/***/ 99427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.SearchOptions} SearchOptions
 */
var lang = __webpack_require__(39955);
var oop = __webpack_require__(2645);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

/**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 **/
class Search {

    constructor() {
        /**@type {Partial<SearchOptions>}*/
        this.$options = {};
    }

    /**
     * Sets the search options via the `options` parameter.
     * @param {Partial<SearchOptions>} options An object containing all the new search properties
     * @returns {Search}
     * @chainable
    **/
    set(options) {
        oop.mixin(this.$options, options);
        return this;
    }

    /**
     * [Returns an object containing all the search options.]{: #Search.getOptions}
     * @returns {Partial<SearchOptions>}
    **/
    getOptions() {
        return lang.copyObject(this.$options);
    }

    /**
     * Sets the search options via the `options` parameter.
     * @param {Partial<SearchOptions>} options object containing all the search propertie
     * @related Search.set
    **/
    setOptions(options) {
        this.$options = options;
    }

    /**
     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     * @returns {Range | null | false}
     **/
    find(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && /**@type{Range}*/(options.start).start
                && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/(options.start))
            ) {
                firstRange = null;
                return false;
            }

            return true;
        });

        return firstRange;
    }

    /**
     * Searches for all occurrances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     * @returns {Range[]}
    **/
    findAll(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;

                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;

                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.end.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;

            var endRow = range.end.row - range.start.row;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;

            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    }

    /**
     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
     * @param {String} input The text to search in
     * @param {any} replacement The replacing text
     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
     * If `options.needle` was not found, this function returns `null`.
     *
     *
     * @returns {String}
    **/
    replace(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        if (!options.regExp) {
            replacement = replacement.replace(/\$/g, "$$$$");
        }

        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }

        return replacement;
    }

    /**
     *
     * @param {Partial<SearchOptions>} options
     * @param {boolean} [$disableFakeMultiline]
     * @return {RegExp|boolean|*[]|*}
     */
    $assembleRegExp(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        var modifier = options.caseSensitive ? "gm" : "gmi";

        try {
            new RegExp(needle, "u");
            options.$supportsUnicodeFlag = true;
            modifier += "u";
        } catch (e) {
            options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\{2}/gu
        }

        if (options.wholeWord)
            needle = addWordBoundary(needle, options);

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            /**@type {RegExp|false}*/
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    }

    /**
     * @param {string} needle
     * @param {string} modifier
     */
    $assembleMultilineRegExp(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        return re;
    }

    /**
     * @param {EditSession} session
     */
    $matchIterator(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var supportsUnicodeFlag = re.unicode;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        if (backwards) {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }

        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength()) return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1) return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset) return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                        if (last >= line.length) break;
                        re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    }
                    if (m.index + length > endIndex)
                        break;
                    matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                        return true;
                }
            };
        }
        else {
            var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m;
                re.lastIndex = startIndex;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row,last + length))
                        return true;
                    if (!length) {
                        re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                        if (last >= line.length) return false;
                    }
                }
            };
        }
        return {forEach: forEach};
    }

}

/**
 *
 * @param {string} needle
 * @param {Partial<SearchOptions>} options
 * @return {string}
 */
function addWordBoundary(needle, options) {
    let supportsLookbehind = lang.supportsLookbehind();

    function wordBoundary(c, firstChar = true) {
        let wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]","u") : new RegExp("\\w");

        if (wordRegExp.test(c) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
                if (firstChar) return "(?<=^|[^\\p{L}\\p{N}_])";
                return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
        }
        return "";
    }

    let needleArray = Array.from(needle);
    let firstChar = needleArray[0];
    let lastChar = needleArray[needleArray.length - 1];

    return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
}

exports.v = Search;


/***/ }),

/***/ 10464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./layer/marker").Marker} Marker
 * @typedef {import("./edit_session").EditSession} EditSession
 */
var lang = __webpack_require__(39955);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

class SearchHighlight {
    /**
     * @param {any} regExp
     * @param {string} clazz
     */
    constructor(regExp, clazz, type = "text") {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type;
    }
    
    setRegexp(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    }

    /**
     * @param {any} html
     * @param {Marker} markerLayer
     * @param {EditSession} session
     * @param {Partial<import("../ace-internal").Ace.LayerConfig>} config
     */
    update(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;
        var renderedMarkerRanges = {};

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString]) continue;

                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(
                    html, rangeToAddMarkerTo, this.clazz, config);
            }
        }
    }

}

// needed to prevent long lines from freezing the browser
SearchHighlight.prototype.MAX_RANGES = 500;

exports.V = SearchHighlight;


/***/ }),

/***/ 98345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./anchor").Anchor} Anchor
 * @typedef {import("../ace-internal").Ace.Point} Point
 */

class Selection {
    /**
     * Creates a new `Selection` object.
     * @param {EditSession} session The session to use
     * @constructor
     **/
    constructor(session) {
        /**@type {EditSession}*/
        this.session = session;
        /**@type {import("./document").Document}*/
        this.doc = session.getDocument();
    
        this.clearSelection();
        /**@type {Anchor}*/
        this.cursor = this.lead = this.doc.createAnchor(0, 0);
        /**@type {Anchor}*/
        this.anchor = this.doc.createAnchor(0, 0);
        this.$silent = false;
    
        var self = this;
        this.cursor.on("change", function(e) {
            self.$cursorChanged = true;
            if (!self.$silent)
                self._emit("changeCursor");
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self.$desiredColumn = null;
        });
    
        this.anchor.on("change", function() {
            self.$anchorChanged = true;
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
        });
    }
    
    /**
     * Returns `true` if the selection is empty.
     * @returns {Boolean}
     **/
   isEmpty() {
        return this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        );
    }

    /**
     * Returns `true` if the selection is a multi-line.
     * @returns {Boolean}
     **/
    isMultiLine() {
        return !this.$isEmpty && this.anchor.row != this.cursor.row;
    }

    /**
     * Returns an object containing the `row` and `column` current position of the cursor.
     * @returns {Point}
     **/
    getCursor() {
        return this.lead.getPosition();
    }

    /**
     * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
     * @param {Number} row The new row
     * @param {Number} column The new column
     *
     **/
    setAnchor(row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
    }


    /**
     * Returns an object containing the `row` and `column` of the calling selection anchor.
     *
     * @returns {Point}
     * @related Anchor.getPosition
     **/
    getAnchor() {
        if (this.$isEmpty)
            return this.getSelectionLead();

        return this.anchor.getPosition();
    }


    /**
     * Returns an object containing the `row` and `column` of the calling selection lead.
     * @returns {Object}
     **/
    getSelectionLead() {
        return this.lead.getPosition();
    }

    /**
     * Returns `true` if the selection is going backwards in the document.
     * @returns {Boolean}
     **/
    isBackwards() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    }

    /**
     * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
     * @returns {Range}
     **/
    getRange() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.$isEmpty)
            return Range.fromPoints(lead, lead);

        return this.isBackwards()
            ? Range.fromPoints(lead, anchor)
            : Range.fromPoints(anchor, lead);
    }

    /**
     * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
     **/
    clearSelection() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    }

    /**
     * Selects all the text in the document.
     **/
    selectAll() {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
    }

    /**
     * Sets the selection to the provided range.
     * @param {import("../ace-internal").Ace.IRange} range The range of text to select
     * @param {Boolean} [reverse] Indicates if the range should go backwards (`true`) or not
     **/
    setRange(range, reverse) {
        var start = reverse ? range.end : range.start;
        var end = reverse ? range.start : range.end;
        this.$setSelection(start.row, start.column, end.row, end.column);
    }

    /**
     * @param {number} anchorRow
     * @param {number} anchorColumn
     * @param {number} cursorRow
     * @param {number} cursorColumn
     */
    $setSelection(anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
            return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
            this._emit("changeCursor");
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
    }

    $moveSelection(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    }

    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     **/
    selectTo(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    }

    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Point} pos An object containing the row and column
     **/
    selectToPosition(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    }

    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     **/
    moveTo(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    }

    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Object} pos An object containing the row and column
     **/
    moveToPosition(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    }


    /**
     * Moves the selection up one row.
     **/
    selectUp() {
        this.$moveSelection(this.moveCursorUp);
    }

    /**
     * Moves the selection down one row.
     **/
    selectDown() {
        this.$moveSelection(this.moveCursorDown);
    }

    /**
     * Moves the selection right one column.
     **/
    selectRight() {
        this.$moveSelection(this.moveCursorRight);
    }

    /**
     * Moves the selection left one column.
     **/
    selectLeft() {
        this.$moveSelection(this.moveCursorLeft);
    }

    /**
     * Moves the selection to the beginning of the current line.
     **/
    selectLineStart() {
        this.$moveSelection(this.moveCursorLineStart);
    }

    /**
     * Moves the selection to the end of the current line.
     **/
    selectLineEnd() {
        this.$moveSelection(this.moveCursorLineEnd);
    }

    /**
     * Moves the selection to the end of the file.
     **/
    selectFileEnd() {
        this.$moveSelection(this.moveCursorFileEnd);
    }

    /**
     * Moves the selection to the start of the file.
     **/
    selectFileStart() {
        this.$moveSelection(this.moveCursorFileStart);
    }

    /**
     * Moves the selection to the first word on the right.
     **/
    selectWordRight() {
        this.$moveSelection(this.moveCursorWordRight);
    }

    /**
     * Moves the selection to the first word on the left.
     **/
    selectWordLeft() {
        this.$moveSelection(this.moveCursorWordLeft);
    }

    /**
     * Moves the selection to highlight the entire word.
     * @related EditSession.getWordRange
     **/
    getWordRange(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    }

    /**
     * Selects an entire word boundary.
     **/
    selectWord() {
        this.setSelectionRange(this.getWordRange());
    }

    /**
     * Selects a word, including its right whitespace.
     * @related EditSession.getAWordRange
     **/
    selectAWord() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    }

    getLineRange(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    }

    /**
     * Selects the entire line.
     **/
    selectLine() {
        this.setSelectionRange(this.getLineRange());
    }

    /**
     * Moves the cursor up one row.
     **/
    moveCursorUp() {
        this.moveCursorBy(-1, 0);
    }

    /**
     * Moves the cursor down one row.
     **/
    moveCursorDown() {
        this.moveCursorBy(1, 0);
    }

    /**
     *
     * Returns `true` if moving the character next to the cursor in the specified direction is a soft tab.
     * @param {Point} cursor the current cursor position
     * @param {Number} tabSize the tab size
     * @param {Number} direction 1 for right, -1 for left
     */
    wouldMoveIntoSoftTab(cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;

        if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
    }

    /**
     * Moves the cursor left one column.
     **/
    moveCursorLeft() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            // cursor is a line (start
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            } else {
                this.moveCursorBy(0, -1);
            }
        }
    }

    /**
     * Moves the cursor right one column.
     **/
    moveCursorRight() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            /**
             * @type {Point}
             */
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            } else {
                this.moveCursorBy(0, 1);
            }
        }
    }

    /**
     * Moves the cursor to the start of the line.
     **/
    moveCursorLineStart() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);

        // Determ the doc-position of the first character at the screen line.
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);

        // Determ the line
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        // TODO find better way for emacs mode to override selection behaviors
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    }

    /**
     * Moves the cursor to the end of the line.
     **/
    moveCursorLineEnd() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    }

    /**
     * Moves the cursor to the end of the file.
     **/
    moveCursorFileEnd() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    }

    /**
     * Moves the cursor to the start of the file.
     **/
    moveCursorFileStart() {
        this.moveCursorTo(0, 0);
    }

    /**
     * Moves the cursor to the word on the right.
     **/
    moveCursorLongWordRight() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip folds
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }

        // first skip space
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }

        // if at line end proceed with next line
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }

        // advance to the end of the next token
        if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    }

    /**
    *
    * Moves the cursor to the word on the left.
    **/
    moveCursorLongWordLeft() {
        var row = this.lead.row;
        var column = this.lead.column;

        // skip folds
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip whitespace
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }

        // if at begin of the line proceed in line above
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }

        // move to the begin of the word
        if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    }

    $shortWordEndIndex(rightOfCursor) {
        var index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    }

    moveCursorShortWordRight() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    }

    moveCursorShortWordLeft() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    }

    moveCursorWordRight() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    }

    moveCursorWordLeft() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    }

    /**
     * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
     * @param {Number} rows The number of rows to move by
     * @param {Number} chars The number of characters to move by
     *
     * @related EditSession.documentToScreenPosition
     **/
    moveCursorBy(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        var offsetX;

        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }

            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
                rows -= widget.rowsAbove || 0;
            else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);

        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {

        }

        // move the cursor and update the desired column
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    }

    /**
     * Moves the selection to the position indicated by its `row` and `column`.
     * @param {Point} position The position to move to
     **/
    moveCursorToPosition(position) {
        this.moveCursorTo(position.row, position.column);
    }

    /**
     * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} [keepDesiredColumn] [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
     **/
    moveCursorTo(row, column, keepDesiredColumn) {
        // Ensure the row/column is not inside of a fold.
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        // do not allow putting cursor in the middle of surrogate pairs
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    }

    /**
     * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
     **/
    moveCursorToScreen(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    }

    // remove listeners from document
    detach() {
        this.lead.detach();
        this.anchor.detach();
    }

    /**
     * @param {Range & {desiredColumn?: number}} range
     */
    fromOrientedRange(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    }

    /**
     * @param {Range & {desiredColumn?: number}} [range]
     */
    toOrientedRange(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    }

    /**
     * Saves the current cursor position and calls `func` that can change the cursor
     * postion. The result is the range of the starting and eventual cursor position.
     * Will reset the cursor position.
     * @param {Function} func The callback that should change the cursor position
     * @returns {Range}
     **/
    getRangeOfMovements(func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
        } catch(e) {
            return Range.fromPoints(start, start);
        } finally {
            this.moveCursorToPosition(start);
        }
    }

    /**
     * 
     * @returns {Range|Range[]}
     */
    toJSON() {
        if (this.rangeCount) {
            /**@type{Range|Range[]}*/var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            /**@type{Range|Range[]}*/var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    }

    /**
     * 
     * @param data
     */
    fromJSON(data) {
        if (data.start == undefined) {
            if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else {
                data = data[0];
            }
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    }

    /**
     * 
     * @param data
     * @return {boolean}
     */
    isEqual(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    }

}

/**
 * Left for backward compatibility
 * @deprecated
 */
Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
/**
 * Left for backward compatibility
 * @deprecated
 */
Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;

Selection.prototype.setSelectionRange = Selection.prototype.setRange;

oop.implement(Selection.prototype, EventEmitter);
exports.L = Selection;


/***/ }),

/***/ 51509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef Snippet
 * @property {string} [content]
 * @property {string} [replaceBefore]
 * @property {string} [replaceAfter]
 * @property {RegExp} [startRe]
 * @property {RegExp} [endRe]
 * @property {RegExp} [triggerRe]
 * @property {RegExp} [endTriggerRe]
 * @property {string} [trigger]
 * @property {string} [endTrigger]
 * @property {string[]} [matchBefore]
 * @property {string[]} [matchAfter]
 * @property {string} [name]
 * @property {string} [tabTrigger]
 * @property {string} [guard]
 * @property {string} [endGuard]
 */
var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var lang = __webpack_require__(39955);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);
var HashHandler = (__webpack_require__(93050).HashHandler);
var Tokenizer = (__webpack_require__(32934).Tokenizer);
var clipboard = __webpack_require__(65217);

var VARIABLES = {
    CURRENT_WORD: function(editor) {
        return editor.session.getTextRange(editor.session.getWordRange());
    },
    SELECTION: function(editor, name, indentation) {
        var text = editor.session.getTextRange();
        if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
        return text;
    },
    CURRENT_LINE: function(editor) {
        return editor.session.getLine(editor.getCursorPosition().row);
    },
    PREV_LINE: function(editor) {
        return editor.session.getLine(editor.getCursorPosition().row - 1);
    },
    LINE_INDEX: function(editor) {
        return editor.getCursorPosition().row;
    },
    LINE_NUMBER: function(editor) {
        return editor.getCursorPosition().row + 1;
    },
    SOFT_TABS: function(editor) {
        return editor.session.getUseSoftTabs() ? "YES" : "NO";
    },
    TAB_SIZE: function(editor) {
        return editor.session.getTabSize();
    },
    CLIPBOARD: function(editor) {
        return clipboard.getText && clipboard.getText();
    },
    // filenames
    FILENAME: function(editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
    },
    FILENAME_BASE: function(editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
    },
    DIRECTORY: function(editor) {
        return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
    },
    FILEPATH: function(editor) { return "/not implemented.txt"; },
    WORKSPACE_NAME: function() { return "Unknown"; },
    FULLNAME: function() { return "Unknown"; },
    // comments
    BLOCK_COMMENT_START: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment && mode.blockComment.start || "";
    },
    BLOCK_COMMENT_END: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment && mode.blockComment.end || "";
    },
    LINE_COMMENT: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.lineCommentStart || "";
    },
    // dates
    CURRENT_YEAR: date.bind(null, {year: "numeric"}),
    CURRENT_YEAR_SHORT: date.bind(null, {year: "2-digit"}),
    CURRENT_MONTH: date.bind(null, {month: "numeric"}),
    CURRENT_MONTH_NAME: date.bind(null, {month: "long"}),
    CURRENT_MONTH_NAME_SHORT: date.bind(null, {month: "short"}),
    CURRENT_DATE: date.bind(null, {day: "2-digit"}),
    CURRENT_DAY_NAME: date.bind(null, {weekday: "long"}),
    CURRENT_DAY_NAME_SHORT: date.bind(null, {weekday: "short"}),
    CURRENT_HOUR: date.bind(null, {hour: "2-digit", hour12: false}),
    CURRENT_MINUTE: date.bind(null, {minute: "2-digit"}),
    CURRENT_SECOND: date.bind(null, {second: "2-digit"})
};

VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;

function date(dateFormat) {
    var str = new Date().toLocaleString("en-us", dateFormat);
    return str.length == 1 ? "0" + str : str;
}

class SnippetManager {
    constructor() {
        this.snippetMap = {};
        this.snippetNameMap = {};
        this.variables = VARIABLES;
    }


    /**
     * @return {Tokenizer}
     */
    getTokenizer() {
        return SnippetManager["$tokenizer"] || this.createTokenizer();
    }

    createTokenizer() {
        function TabstopToken(str) {
            str = str.substr(1);
            if (/^\d+$/.test(str))
                return [{tabstopId: parseInt(str, 10)}];
            return [{text: str}];
        }
        function escape(ch) {
            return "(?:[^\\\\" + ch + "]|\\\\.)";
        }
        var formatMatcher = {
            regex: "/(" + escape("/") + "+)/",
            onMatch: function(val, state, stack) {
                var ts = stack[0];
                ts.fmtString = true;
                ts.guard = val.slice(1, -1);
                ts.flag = "";
                return "";
            },
            next: "formatString"
        };

        SnippetManager["$tokenizer"] = new Tokenizer({
            start: [
                {regex: /\\./, onMatch: function(val, state, stack) {
                    var ch = val[1];
                    if (ch == "}" && stack.length) {
                        val = ch;
                    } else if ("`$\\".indexOf(ch) != -1) {
                        val = ch;
                    }
                    return [val];
                }},
                {regex: /}/, onMatch: function(val, state, stack) {
                    return [stack.length ? stack.shift() : val];
                }},
                {regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken},
                {regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                    var t = TabstopToken(str.substr(1));
                    stack.unshift(t[0]);
                    return t;
                }, next: "snippetVar"},
                {regex: /\n/, token: "newline", merge: false}
            ],
            snippetVar: [
                {regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                    var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                        return operator.length == 2 ? operator[1] : "\x00";
                    }).split("\x00").map(function(value){
                        return {value: value};
                    });
                    stack[0].choices = choices;
                    return [choices[0]];
                }, next: "start"},
                formatMatcher,
                {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start"}
            ],
            formatString: [
                {regex: /:/, onMatch: function(val, state, stack) {
                    if (stack.length && stack[0].expectElse) {
                        stack[0].expectElse = false;
                        stack[0].ifEnd = {elseEnd: stack[0]};
                        return [stack[0].ifEnd];
                    }
                    return ":";
                }},
                {regex: /\\./, onMatch: function(val, state, stack) {
                    var ch = val[1];
                    if (ch == "}" && stack.length)
                        val = ch;
                    else if ("`$\\".indexOf(ch) != -1)
                        val = ch;
                    else if (ch == "n")
                        val = "\n";
                    else if (ch == "t")
                        val = "\t";
                    else if ("ulULE".indexOf(ch) != -1)
                        val = {changeCase: ch, local: ch > "a"};
                    return [val];
                }},
                {regex: "/\\w*}", onMatch: function(val, state, stack) {
                    var next = stack.shift();
                    if (next)
                        next.flag = val.slice(1, -1);
                    this.next = next && next.tabstopId ? "start" : "";
                    return [next || val];
                }, next: "start"},
                {regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                    return [{text: val.slice(1)}];
                }},
                {regex: /\${\w+/, onMatch: function(val, state, stack) {
                    var token = {text: val.slice(2)};
                    stack.unshift(token);
                    return [token];
                }, next: "formatStringVar"},
                {regex: /\n/, token: "newline", merge: false},
                {regex: /}/, onMatch: function(val, state, stack) {
                    var next = stack.shift();
                    this.next = next && next.tabstopId ? "start" : "";
                    return [next || val];
                }, next: "start"}
            ],
            formatStringVar: [
                {regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                    var ts = stack[0];
                    ts.formatFunction = val.slice(2, -1);
                    return [stack.shift()];
                }, next: "formatString"},
                formatMatcher,
                {regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                    if (val[1] == "+")
                        stack[0].ifEnd = stack[0];
                    if (val[1] == "?")
                        stack[0].expectElse = true;
                }, next: "formatString"},
                {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString"}
            ]
        });
        return SnippetManager["$tokenizer"];
    }

    tokenizeTmSnippet(str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
            return x.value || x;
        });
    }

    getVariableValue(editor, name, indentation) {
        if (/^\d+$/.test(name))
            return (this.variables.__ || {})[name] || "";
        if (/^[A-Z]\d+$/.test(name))
            return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";

        name = name.replace(/^TM_/, "");
        if (!this.variables.hasOwnProperty(name))
            return "";
        var value = this.variables[name];
        if (typeof value == "function")
            value = this.variables[name](editor, name, indentation);
        return value == null ? "" : value;
    }

    // returns string formatted according to http://manual.macromates.com/en/regular_expressions#replacement_string_syntax_format_strings
    tmStrFormat(str, ch, editor) {
        if (!ch.fmt) return str;
        var flag = ch.flag || "";
        var re = ch.guard;
        re = new RegExp(re, flag.replace(/[^gim]/g, ""));
        var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
        var _self = this;
        var formatted = str.replace(re, function() {
            var oldArgs = _self.variables.__;
            _self.variables.__ = [].slice.call(arguments);
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = "E";
            for (var i  = 0; i < fmtParts.length; i++) {
                var ch = fmtParts[i];
                if (typeof ch == "object") {
                    fmtParts[i] = "";
                    if (ch.changeCase && ch.local) {
                        var next = fmtParts[i + 1];
                        if (next && typeof next == "string") {
                            if (ch.changeCase == "u")
                                fmtParts[i] = next[0].toUpperCase();
                            else
                                fmtParts[i] = next[0].toLowerCase();
                            fmtParts[i + 1] = next.substr(1);
                        }
                    } else if (ch.changeCase) {
                        gChangeCase = ch.changeCase;
                    }
                } else if (gChangeCase == "U") {
                    fmtParts[i] = ch.toUpperCase();
                } else if (gChangeCase == "L") {
                    fmtParts[i] = ch.toLowerCase();
                }
            }
            _self.variables.__ = oldArgs;
            return fmtParts.join("");
        });
        return formatted;
    }

    tmFormatFunction(str, ch, editor) {
        if (ch.formatFunction == "upcase")
            return str.toUpperCase();
        if (ch.formatFunction == "downcase")
            return str.toLowerCase();
        return str;
    }

    resolveVariables(snippet, editor) {
        var result = [];
        var indentation = "";
        var afterNewLine = true;
        for (var i = 0; i < snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                    afterNewLine = true;
                    indentation = "";
                }
                else if (afterNewLine) {
                    indentation = /^\t*/.exec(ch)[0];
                    afterNewLine = /\S/.test(ch);
                }
                continue;
            }
            if (!ch)  continue;
            afterNewLine = false;

            if (ch.fmtString) {
                var j = snippet.indexOf(ch, i + 1);
                if (j == -1) j = snippet.length;
                ch.fmt = snippet.slice(i + 1, j);
                i = j;
            }

            if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                    value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                    value = this.tmFormatFunction(value, ch, editor);

                if (value && !ch.ifEnd) {
                    result.push(value);
                    gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                    gotoNext(ch.ifEnd);
                }
            } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
            } else if (ch.tabstopId != null) {
                result.push(ch);
            } else if (ch.changeCase != null) {
                result.push(ch);
            }
        }
        function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1)
                i = i1;
        }
        return result;
    }

    getDisplayTextForSnippet(editor, snippetText) {
        var processedSnippet = processSnippetText.call(this, editor, snippetText);
        return processedSnippet.text;
    }

    insertSnippetForSelection(editor, snippetText, options={}) {
        var processedSnippet = processSnippetText.call(this, editor, snippetText, options);

        var range = editor.getSelectionRange();
        var end = editor.session.replace(range, processedSnippet.text);

        var tabstopManager = new TabstopManager(editor);
        var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
        //@ts-expect-error TODO: potential wrong arguments
        tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
    }
    insertSnippet(editor, snippetText, options={}) {
        var self = this;
        if (editor.inVirtualSelectionMode)
            return self.insertSnippetForSelection(editor, snippetText, options);

        editor.forEachSelection(function() {
            self.insertSnippetForSelection(editor, snippetText, options);
        }, null, {keepOrder: true});

        if (editor.tabstopManager)
            editor.tabstopManager.tabNext();
    }

    $getScope(editor) {
        var scope = editor.session.$mode.$id || "";
        scope = scope.split("/").pop();
        if (scope === "html" || scope === "php") {
            // PHP is actually HTML
            if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
            var c = editor.getCursorPosition();
            var state = editor.session.getState(c.row);
            if (typeof state === "object") {
                state = state[0];
            }
            if (state.substring) {
                if (state.substring(0, 3) == "js-")
                    scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                    scope = "css";
                else if (state.substring(0, 4) == "php-")
                    scope = "php";
            }
        }

        return scope;
    }

    getActiveScopes(editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] && snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
        }
        scopes.push("_");
        return scopes;
    }

    expandWithTab(editor, options) {
        var self = this;
        var result = editor.forEachSelection(function() {
            return self.expandSnippetForSelection(editor, options);
        }, null, {keepOrder: true});
        if (result && editor.tabstopManager)
            editor.tabstopManager.tabNext();
        return result;
    }

    expandSnippetForSelection(editor, options) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);

        var snippetMap = this.snippetMap;
        /**@type {Snippet}*/
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
        }, this);
        if (!snippet)
            return false;
        if (options && options.dryRun)
            return true;
        editor.session.doc.removeInLine(cursor.row,
            cursor.column - snippet.replaceBefore.length,
            cursor.column + snippet.replaceAfter.length
        );

        this.variables.M__ = snippet.matchBefore;
        this.variables.T__ = snippet.matchAfter;
        this.insertSnippetForSelection(editor, snippet.content);

        this.variables.M__ = this.variables.T__ = null;
        return true;
    }

    /**
     * @param {Snippet[]} snippetList
     * @param {string} before
     * @param {string} after
     * @return {Snippet}
     */
    findMatchingSnippet(snippetList, before, after) {
        for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe && !s.startRe.test(before))
                continue;
            if (s.endRe && !s.endRe.test(after))
                continue;
            if (!s.startRe && !s.endRe)
                continue;

            s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
            return s;
        }
    }


    /**
     * @param {any[]} snippets
     * @param {string} scope
     */
    register(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;

        if (!snippets)
            snippets = [];

        function wrapRegexp(src) {
            if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";

            return src || "";
        }
        function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
                re = guard + re;
                if (re && re[re.length - 1] != "$")
                    re = re + "$";
            } else {
                re = re + guard;
                if (re && re[0] != "^")
                    re = "^" + re;
            }
            return new RegExp(re);
        }

        function addSnippet(s) {
            if (!s.scope)
                s.scope = scope || "_";
            scope = s.scope;
            if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
            }

            var map = snippetNameMap[scope];
            if (s.name) {
                var old = map[s.name];
                if (old)
                    self.unregister(old);
                map[s.name] = s;
            }
            snippetMap[scope].push(s);

            if (s.prefix)
                s.tabTrigger = s.prefix;

            if (!s.content && s.body)
                s.content = Array.isArray(s.body) ? s.body.join("\n") : s.body;

            if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                    s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
            }

            if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                return;

            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger);

            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger);
        }

        if (Array.isArray(snippets)) {
            snippets.forEach(addSnippet);
        } else {
            Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
            });
        }

        // @ts-ignore
        this._signal("registerSnippets", {scope: scope});
    }
    unregister(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;

        function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope||scope];
            if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope||scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                    map.splice(i, 1);
            }
        }
        if (snippets.content)
            removeSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(removeSnippet);
    }
    parseSnippetFile(str) {
        str = str.replace(/\r/g, "");
        var list = [], /**@type{Snippet}*/snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
            if (m[1]) {
                try {
                    snippet = JSON.parse(m[1]);
                    list.push(snippet);
                } catch (e) {}
            } if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
            } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                    var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                    snippet.guard = guardRe.exec(val)[1];
                    snippet.trigger = guardRe.exec(val)[1];
                    snippet.endTrigger = guardRe.exec(val)[1];
                    snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                    snippet.tabTrigger = val.match(/^\S*/)[0];
                    if (!snippet.name)
                        snippet.name = val;
                } else if (key) {
                    snippet[key] = val;
                }
            }
        }
        return list;
    }
    getSnippetByName(name, editor) {
        var snippetMap = this.snippetNameMap;
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = snippets[name];
            return !!snippet;
        }, this);
        return snippet;
    }
}

oop.implement(SnippetManager.prototype, EventEmitter);

var processSnippetText = function(editor, snippetText, options={}) {
    var cursor = editor.getCursorPosition();
    var line = editor.session.getLine(cursor.row);
    var tabString = editor.session.getTabString();
    var indentString = line.match(/^\s*/)[0];

    if (cursor.column < indentString.length)
        indentString = indentString.slice(0, cursor.column);

    snippetText = snippetText.replace(/\r/g, "");
    var tokens = this.tokenizeTmSnippet(snippetText);
    tokens = this.resolveVariables(tokens, editor);
    // indent
    tokens = tokens.map(function(x) {
        if (x == "\n" && !options.excludeExtraIndent)
            return x + indentString;
        if (typeof x == "string")
            return x.replace(/\t/g, tabString);
        return x;
    });
    // tabstop values
    var tabstops = [];
    tokens.forEach(function(p, i) {
        if (typeof p != "object")
            return;
        var id = p.tabstopId;
        var ts = tabstops[id];
        if (!ts) {
            ts = tabstops[id] = [];
            ts.index = id;
            ts.value = "";
            ts.parents = {};
        }
        if (ts.indexOf(p) !== -1)
            return;
        if (p.choices && !ts.choices)
            ts.choices = p.choices;
        ts.push(p);
        var i1 = tokens.indexOf(p, i + 1);
        if (i1 === -1)
            return;

        var value = tokens.slice(i + 1, i1);
        var isNested = value.some(function(t) {return typeof t === "object";});
        if (isNested && !ts.value) {
            ts.value = value;
        } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
            ts.value = value.join("");
        }
    });

    // expand tabstop values
    tabstops.forEach(function(ts) {ts.length = 0;});
    var expanding = {};
    function copyValue(val) {
        var copy = [];
        for (var i = 0; i < val.length; i++) {
            var p = val[i];
            if (typeof p == "object") {
                if (expanding[p.tabstopId])
                    continue;
                var j = val.lastIndexOf(p, i - 1);
                p = copy[j] || {tabstopId: p.tabstopId};
            }
            copy[i] = p;
        }
        return copy;
    }
    for (var i = 0; i < tokens.length; i++) {
        var p = tokens[i];
        if (typeof p != "object")
            continue;
        var id = p.tabstopId;
        var ts = tabstops[id];
        var i1 = tokens.indexOf(p, i + 1);
        if (expanding[id]) {
            // if reached closing bracket clear expanding state
            if (expanding[id] === p) {
                delete expanding[id];
                Object.keys(expanding).forEach(function(parentId) {
                    ts.parents[parentId] = true;
                });
            }
            // otherwise just ignore recursive tabstop
            continue;
        }
        expanding[id] = p;
        var value = ts.value;
        if (typeof value !== "string")
            value = copyValue(value);
        else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
        tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));

        if (ts.indexOf(p) === -1)
            ts.push(p);
    }

    // convert to plain text
    var row = 0, column = 0;
    var text = "";
    tokens.forEach(function(t) {
        if (typeof t === "string") {
            var lines = t.split("\n");
            if (lines.length > 1){
                column = lines[lines.length - 1].length;
                row += lines.length - 1;
            } else
                column += t.length;
            text += t;
        } else if (t) {
            if (!t.start)
                t.start = {row: row, column: column};
            else
                t.end = {row: row, column: column};
        }
    });

    return {
        text,
        tabstops,
        tokens
    };
};

class TabstopManager {
    constructor(editor) {
        this.index = 0;
        this.ranges = [];
        this.tabstops = [];
        if (editor.tabstopManager)
            return editor.tabstopManager;
        editor.tabstopManager = this;
        this.$onChange = this.onChange.bind(this);
        this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
        this.$onChangeSession = this.onChangeSession.bind(this);
        this.$onAfterExec = this.onAfterExec.bind(this);
        this.attach(editor);
    }

    attach(editor) {
        this.$openTabstops = null;
        this.selectedTabstop = null;

        this.editor = editor;
        this.session = editor.session;
        this.editor.on("change", this.$onChange);
        this.editor.on("changeSelection", this.$onChangeSelection);
        this.editor.on("changeSession", this.$onChangeSession);
        this.editor.commands.on("afterExec", this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    }
    detach() {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges.length = 0;
        this.tabstops.length = 0;
        this.selectedTabstop = null;
        this.editor.off("change", this.$onChange);
        this.editor.off("changeSelection", this.$onChangeSelection);
        this.editor.off("changeSession", this.$onChangeSession);
        this.editor.commands.off("afterExec", this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.session = null;
        this.editor = null;
    }
    /**
     * @internal
     */
    onChange(delta) {
        var isRemove = delta.action[0] == "r";
        var selectedTabstop = this.selectedTabstop || {};
        var parents = selectedTabstop.parents || {};
        var tabstops = this.tabstops.slice();
        for (var i = 0; i < tabstops.length; i++) {
            var ts = tabstops[i];
            var active = ts == selectedTabstop || parents[ts.index];
            ts.rangeList.$bias = active ? 0 : 1;

            if (delta.action == "remove" && ts !== selectedTabstop) {
                var parentActive = ts.parents && ts.parents[selectedTabstop.index];
                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                for (var j = 0; j < toRemove.length; j++)
                    this.removeRange(toRemove[j]);
            }
            ts.rangeList.$onChange(delta);
        }
        var session = this.session;
        if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
            this.detach();
    }
    updateLinkedFields() {
        var ts = this.selectedTabstop;
        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
            return;
        this.$inChange = true;
        var session = this.session;
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = 0; i < ts.length; i++) {
            var range = ts[i];
            if (!range.linked)
                continue;
            var original = range.original;
            var fmt = exports.N.tmStrFormat(text, original, this.editor);
            session.replace(range, fmt);
        }
        this.$inChange = false;
    }
    /**
     * @internal
     */
    onAfterExec(e) {
        if (e.command && !e.command.readOnly)
            this.updateLinkedFields();
    }
    /**
     * @internal
     */
    onChangeSelection() {
        if (!this.editor)
            return;
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = 0; i < this.ranges.length; i++) {
            if (this.ranges[i].linked)
                continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead && containsAnchor)
                return;
        }
        this.detach();
    }
    /**
     * @internal
     */
    onChangeSession() {
        this.detach();
    }
    tabNext(dir) {
        var max = this.tabstops.length;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 1), max);
        if (index == max)
            index = 0;
        this.selectTabstop(index);
        this.updateTabstopMarkers();
        if (index === 0) {
            this.detach();
        }
    }
    selectTabstop(index) {
        this.$openTabstops = null;
        var ts = this.tabstops[this.index];
        if (ts)
            this.addTabstopMarkers(ts);
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length)
            return;

        this.selectedTabstop = ts;
        var range = ts.firstNonLinked || ts;
        if (ts.choices) range.cursor = range.start;
        if (!this.editor.inVirtualSelectionMode) {
            var sel = this.editor.multiSelect;
            sel.toSingleRange(range);
            for (var i = 0; i < ts.length; i++) {
                if (ts.hasLinkedRanges && ts[i].linked)
                    continue;
                sel.addRange(ts[i].clone(), true);
            }
        } else {
            this.editor.selection.fromOrientedRange(range);
        }

        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        if (this.selectedTabstop && this.selectedTabstop.choices)
            this.editor.execCommand("startAutocomplete", {matches: this.selectedTabstop.choices});
    }
    addTabstops(tabstops, start, end) {
        var useLink = this.useLink || !this.editor.getOption("enableMultiselect");

        if (!this.$openTabstops)
            this.$openTabstops = [];
        // add final tabstop if missing
        if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
        }

        var i = this.index;
        var arg = [i + 1, 0];
        var ranges = this.ranges;
        var snippetId = this.snippetId = (this.snippetId || 0) + 1;
        tabstops.forEach(function(ts, index) {
            var dest = this.$openTabstops[index] || ts;
            dest.snippetId = snippetId;
            for (var i = 0; i < ts.length; i++) {
                var p = ts[i];
                /**@type {Range & {original?: Range, tabstop?: any, linked?: boolean}}}*/
                var range = Range.fromPoints(p.start, p.end || p.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts)
                    dest.unshift(range);
                else
                    dest[i] = range;
                if (p.fmtString || (dest.firstNonLinked && useLink)) {
                    range.linked = true;
                    dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                    dest.firstNonLinked = range;
            }
            if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
            if (dest === ts) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
            }
            this.addTabstopMarkers(dest);
            dest.rangeList = dest.rangeList || new RangeList();
            dest.rangeList.$bias = 0;
            dest.rangeList.addList(dest);
        }, this);

        if (arg.length > 2) {
            // when adding new snippet inside existing one, make sure 0 tabstop is at the end
            if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
            this.tabstops.splice.apply(this.tabstops, arg);
        }
    }

    addTabstopMarkers(ts) {
        var session = this.session;
        ts.forEach(function(range) {
            if  (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
        });
    }
    removeTabstopMarkers(ts) {
        var session = this.session;
        ts.forEach(function(range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
        });
    }
    updateTabstopMarkers() {
        if (!this.selectedTabstop) return;
        var currentSnippetId =  this.selectedTabstop.snippetId;
        // back to the parent snippet tabstops if $0
        if ( this.selectedTabstop.index === 0) {
            currentSnippetId--;
        }
        this.tabstops.forEach(function(ts) {
            // show marker only for the tabstops of the currently active snippet
            if (ts.snippetId === currentSnippetId) this.addTabstopMarkers(ts);
            else this.removeTabstopMarkers(ts);
        }, this);
    }
    removeRange(range) {
        var i = range.tabstop.indexOf(range);
        if (i != -1) range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        if (i != -1) this.ranges.splice(i, 1);
        i = range.tabstop.rangeList.ranges.indexOf(range);
        if (i != -1) range.tabstop.splice(i, 1);
        this.session.removeMarker(range.markerId);
        if (!range.tabstop.length) {
            i = this.tabstops.indexOf(range.tabstop);
            if (i != -1)
                this.tabstops.splice(i, 1);
            if (!this.tabstops.length)
                this.detach();
        }
    }
}


TabstopManager.prototype.keyboardHandler = new HashHandler();
TabstopManager.prototype.keyboardHandler.bindKeys({
    "Tab": function(editor) {
        if (exports.N && exports.N.expandWithTab(editor))
            return;
        editor.tabstopManager.tabNext(1);
        editor.renderer.scrollCursorIntoView();
    },
    "Shift-Tab": function(editor) {
        editor.tabstopManager.tabNext(-1);
        editor.renderer.scrollCursorIntoView();
    },
    "Esc": function(editor) {
        editor.tabstopManager.detach();
    }
});


var movePoint = function(point, diff) {
    if (point.row == 0)
        point.column += diff.column;
    point.row += diff.row;
};

var moveRelative = function(point, start) {
    if (point.row == start.row)
        point.column -= start.column;
    point.row -= start.row;
};


dom.importCssString(`
.ace_snippet-marker {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    background: rgba(194, 193, 208, 0.09);
    border: 1px dotted rgba(211, 208, 235, 0.62);
    position: absolute;
}`, "snippets.css", false);

exports.N = new SnippetManager();


var Editor = (__webpack_require__(27258).Editor);
(function() {
    this.insertSnippet = function(content, options) {
        return exports.N.insertSnippet(this, content, options);
    };
    this.expandSnippet = function(options) {
        return exports.N.expandWithTab(this, options);
    };
}).call(Editor.prototype);


/***/ }),

/***/ 59781:
/***/ ((module) => {

module.exports = `.ace-tm .ace_gutter {
  background: #f0f0f0;
  color: #333;
}

.ace-tm .ace_print-margin {
  width: 1px;
  background: #e8e8e8;
}

.ace-tm .ace_fold {
    background-color: #6B72E6;
}

.ace-tm {
  background-color: #FFFFFF;
  color: black;
}

.ace-tm .ace_cursor {
  color: black;
}
        
.ace-tm .ace_invisible {
  color: rgb(191, 191, 191);
}

.ace-tm .ace_storage,
.ace-tm .ace_keyword {
  color: blue;
}

.ace-tm .ace_constant {
  color: rgb(197, 6, 11);
}

.ace-tm .ace_constant.ace_buildin {
  color: rgb(88, 72, 246);
}

.ace-tm .ace_constant.ace_language {
  color: rgb(88, 92, 246);
}

.ace-tm .ace_constant.ace_library {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_invalid {
  background-color: rgba(255, 0, 0, 0.1);
  color: red;
}

.ace-tm .ace_support.ace_function {
  color: rgb(60, 76, 114);
}

.ace-tm .ace_support.ace_constant {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_support.ace_type,
.ace-tm .ace_support.ace_class {
  color: rgb(109, 121, 222);
}

.ace-tm .ace_keyword.ace_operator {
  color: rgb(104, 118, 135);
}

.ace-tm .ace_string {
  color: rgb(3, 106, 7);
}

.ace-tm .ace_comment {
  color: rgb(76, 136, 107);
}

.ace-tm .ace_comment.ace_doc {
  color: rgb(0, 102, 255);
}

.ace-tm .ace_comment.ace_doc.ace_tag {
  color: rgb(128, 159, 191);
}

.ace-tm .ace_constant.ace_numeric {
  color: rgb(0, 0, 205);
}

.ace-tm .ace_variable {
  color: rgb(49, 132, 149);
}

.ace-tm .ace_xml-pe {
  color: rgb(104, 104, 91);
}

.ace-tm .ace_entity.ace_name.ace_function {
  color: #0000A2;
}


.ace-tm .ace_heading {
  color: rgb(12, 7, 255);
}

.ace-tm .ace_list {
  color:rgb(185, 6, 144);
}

.ace-tm .ace_meta.ace_tag {
  color:rgb(0, 22, 142);
}

.ace-tm .ace_string.ace_regex {
  color: rgb(255, 0, 0)
}

.ace-tm .ace_marker-layer .ace_selection {
  background: rgb(181, 213, 255);
}
.ace-tm.ace_multiselect .ace_selection.ace_start {
  box-shadow: 0 0 3px 0px white;
}
.ace-tm .ace_marker-layer .ace_step {
  background: rgb(252, 255, 0);
}

.ace-tm .ace_marker-layer .ace_stack {
  background: rgb(164, 229, 101);
}

.ace-tm .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgb(192, 192, 192);
}

.ace-tm .ace_marker-layer .ace_active-line {
  background: rgba(0, 0, 0, 0.07);
}

.ace-tm .ace_gutter-active-line {
    background-color : #dcdcdc;
}

.ace-tm .ace_marker-layer .ace_selected-word {
  background: rgb(250, 250, 255);
  border: 1px solid rgb(200, 200, 250);
}

.ace-tm .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;
}

.ace-tm .ace_indent-guide-active {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;
}
`;


/***/ }),

/***/ 87983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = __webpack_require__(59781);
exports.$id = "ace/theme/textmate";

var dom = __webpack_require__(71435);
dom.importCssString(exports.cssText, exports.cssClass, false);


/***/ }),

/***/ 99339:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var Range = (__webpack_require__(91902)/* .Range */ .Q);

/**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 **/
class TokenIterator {
    /**
     * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
     * @param {EditSession} session The session to associate with
     * @param {Number} initialRow The row to start the tokenizing at
     * @param {Number} initialColumn The column to start the tokenizing at
     **/
    constructor(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);

        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
    }
    
    /**
     * Moves iterator position to the start of previous token.
     * @returns {import("../ace-internal").Ace.Token|null}
     **/ 
    stepBackward() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    }

    /**
     * Moves iterator position to the start of next token.
     * @returns {import("../ace-internal").Ace.Token|null}
     **/   
    stepForward() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    }
 
    /**
     * 
     * Returns current token.
     * @returns {import("../ace-internal").Ace.Token}
     **/      
    getCurrentToken() {
        return this.$rowTokens[this.$tokenIndex];
    }

    /**
     * 
     * Returns the current row.
     * @returns {Number}
     **/      
    getCurrentTokenRow() {
        return this.$row;
    }

    /**
     * 
     * Returns the current column.
     * @returns {Number}
     **/     
    getCurrentTokenColumn() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        
        // If a column was cached by EditSession.getTokenAt, then use it
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    }

    /**
     * Return the current token position.
     * @returns {import("../ace-internal").Ace.Point}
     */
    getCurrentTokenPosition() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    }
    
    /**
     * Return the current token range.
     * @returns {Range}
     */
    getCurrentTokenRange() {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    }
    
}

exports.TokenIterator = TokenIterator;


/***/ }),

/***/ 32934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const reportError = (__webpack_require__(53092)/* .reportError */ .N);

// tokenizing lines longer than this makes editor very slow
var MAX_TOKEN_COUNT = 2000;
/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 **/
class Tokenizer {
    /**
     * Constructs a new tokenizer based on the given rules and flags.
     * @param {Object} rules The highlighting rules
     **/
    constructor(rules) {
        /**@type {RegExp}*/
        this.splitRegex;
        this.states = rules;

        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = {defaultToken: "text"};
            var flag = "g";

            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                    mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                    flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                    flag += "u";
                if (rule.regex == null)
                    continue;

                if (rule.regex instanceof RegExp)
                    rule.regex = rule.regex.toString().slice(1, -1);

                // Count number of matching groups. 2 extra groups from the full match
                // And the catch-all on the end (used to force a match);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                    if (rule.token.length == 1 || matchcount == 1) {
                        rule.token = rule.token[0];
                    } else if (matchcount - 1 != rule.token.length) {
                        this.reportError("number of classes and regexp groups doesn't match", {
                            rule: rule,
                            groupCount: matchcount - 1
                        });
                        rule.token = rule.token[0];
                    } else {
                        rule.tokenArray = rule.token;
                        rule.token = null;
                        rule.onMatch = this.$arrayTokens;
                    }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                    if (matchcount > 1)
                        rule.onMatch = this.$applyToken;
                    else
                        rule.onMatch = rule.token;
                }

                if (matchcount > 1) {
                    if (/\\\d/.test(rule.regex)) {
                        // Replace any backreferences and offset appropriately.
                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                        });
                    } else {
                        matchcount = 1;
                        adjustedregex = this.removeCapturingGroups(rule.regex);
                    }
                    if (!rule.splitRegex && typeof rule.token != "string")
                        splitterRurles.push(rule); // flag will be known only at the very end
                }

                mapping[matchTotal] = i;
                matchTotal += matchcount;

                ruleRegExps.push(adjustedregex);

                // makes property access faster
                if (!rule.onMatch)
                    rule.onMatch = null;
            }

            if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
            }

            splitterRurles.forEach(function(rule) {
                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
            }, this);

            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
    }

    /**
     * @param {number} m
     */
    $setMaxTokenCount(m) {
        MAX_TOKEN_COUNT = m | 0;
    }

    /**
     * @param {string} str
     * @return {import("../ace-internal").Ace.Token[]}
     */
    $applyToken(str) {
        var values = this.splitRegex.exec(str).slice(1);
        //@ts-ignore
        var types = this.token.apply(this, values);

        // required for compatibility with old modes
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    }

    /**
     * @param {string} str
     * @return {import("../ace-internal").Ace.Token[] | string}
     */
    $arrayTokens(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        //@ts-ignore
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    }

    /**
     * @param {string} src
     * @returns {string}
     */
    removeCapturingGroups(src) {
        var r = src.replace(
            /\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    }

    /**
     * @param {string} src
     * @param {string} flag
     */
    createSplitterRegexp(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        
        // this is needed for regexps that can match in multiple ways
        if (src.charAt(0) != "^") src = "^" + src;
        if (src.charAt(src.length - 1) != "$") src += "$";
        
        return new RegExp(src, (flag||"").replace("g", ""));
    }

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     * @param {string} line
     * @param {string | string[]} startState
     * @returns {{tokens:import("../ace-internal").Ace.Token[], state: string|string[]}}
     */
    getLineTokens(line, startState) {
        if (startState && typeof startState != "string") {
            /**@type {any[]}*/
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        } else
            var stack = [];

        var currentState = /**@type{string}*/(startState) || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                // chrome doens't show contents of text nodes with very long text
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 500),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    }
}

Tokenizer.prototype.reportError = reportError;
exports.Tokenizer = Tokenizer;


/***/ }),

/***/ 59864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

/**
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("./mouse/mouse_event").MouseEvent} MouseEvent
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var preventParentScroll = (__webpack_require__(58298)/* .preventParentScroll */ .K);

var CLASSNAME = "ace_tooltip";

class Tooltip {
    /**
     * @param {Element} parentNode
     **/
    constructor(parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
    }

    $init() {
        this.$element = dom.createElement("div");
        this.$element.className = CLASSNAME;
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    }

    /**
     * @returns {HTMLElement}
     **/
    getElement() {
        return this.$element || this.$init();
    }

    /**
     * @param {String} text
     **/
    setText(text) {
        this.getElement().textContent = text;
    }

    /**
     * @param {String} html
     **/
    setHtml(html) {
        this.getElement().innerHTML = html;
    }

    /**
     * @param {Number} x
     * @param {Number} y
     **/
    setPosition(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    }

    /**
     * @param {String} className
     **/
    setClassName(className) {
        dom.addCssClass(this.getElement(), className);
    }

    /**
     * @param {import("../ace-internal").Ace.Theme} theme
     */
    setTheme(theme) {
        this.$element.className = CLASSNAME + " " +
            (theme.isDark? "ace_dark " : "") + (theme.cssClass || "");
    }

    /**
     * @param {String} [text]
     * @param {Number} [x]
     * @param {Number} [y]
     **/
    show(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    }

    hide(e) {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.getElement().className = CLASSNAME;
            this.isOpen = false;
        }
    }

    /**
     * @returns {Number}
     **/
    getHeight() {
        return this.getElement().offsetHeight;
    }

    /**
     * @returns {Number}
     **/
    getWidth() {
        return this.getElement().offsetWidth;
    }

    destroy() {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    }

}

class PopupManager {
    constructor () {
        /**@type{Tooltip[]} */
        this.popups = [];
    }

    /**
     * @param {Tooltip} popup
     */
    addPopup(popup) {
        this.popups.push(popup);
        this.updatePopups();
    }

    /**
     * @param {Tooltip} popup
     */
    removePopup(popup) {
        const index = this.popups.indexOf(popup);
        if (index !== -1) {
            this.popups.splice(index, 1);
            this.updatePopups();
        }
    }

    updatePopups() {
        // @ts-expect-error TODO: could be actually an error
        this.popups.sort((a, b) => b.priority - a.priority);
        let visiblepopups = [];

        for (let popup of this.popups) {
            let shouldDisplay = true;
            for (let visiblePopup of visiblepopups) {
                if (this.doPopupsOverlap(visiblePopup, popup)) {
                    shouldDisplay = false;
                    break;
                }
            }

            if (shouldDisplay) {
                visiblepopups.push(popup);
            } else {
                popup.hide();
            }
        }
    }

    /**
     * @param {Tooltip} popupA
     * @param {Tooltip} popupB
     * @return {boolean}
     */
    doPopupsOverlap (popupA, popupB) {
        const rectA = popupA.getElement().getBoundingClientRect();
        const rectB = popupB.getElement().getBoundingClientRect();

        return (rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom
            > rectB.top);
    }
}

var popupManager = new PopupManager();
__webpack_unused_export__ = popupManager;

exports.m_ = Tooltip;


class HoverTooltip extends Tooltip {
    constructor(parentNode=document.body) {
        super(parentNode);

        this.timeout = undefined;
        this.lastT = 0;
        this.idleTime = 350;
        this.lastEvent = undefined;

        this.onMouseOut = this.onMouseOut.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.waitForHover = this.waitForHover.bind(this);
        this.hide = this.hide.bind(this);

        var el = this.getElement();
        el.style.whiteSpace = "pre-wrap";
        el.style.pointerEvents = "auto";
        el.addEventListener("mouseout", this.onMouseOut);
        el.tabIndex = -1;

        el.addEventListener("blur", function() {
            if (!el.contains(document.activeElement)) this.hide();
        }.bind(this));

        el.addEventListener("wheel", preventParentScroll);
    }

    /**
     * @param {Editor} editor
     */
    addToEditor(editor) {
        editor.on("mousemove", this.onMouseMove);
        editor.on("mousedown", this.hide);
        editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
    }

    /**
     * @param {Editor} editor
     */
    removeFromEditor(editor) {
        editor.off("mousemove", this.onMouseMove);
        editor.off("mousedown", this.hide);
        editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }

    /**
     * @param {MouseEvent} e
     * @param {Editor} editor
     * @internal
     */
    onMouseMove(e, editor) {
        this.lastEvent = e;
        this.lastT = Date.now();
        var isMousePressed = editor.$mouseHandler.isMousePressed;
        if (this.isOpen) {
            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
            if (
                !this.range
                || !this.range.contains(pos.row, pos.column)
                || isMousePressed
                || this.isOutsideOfText(this.lastEvent)
            ) {
                this.hide();
            }
        }
        if (this.timeout || isMousePressed) return;
        this.lastEvent = e;
        this.timeout = setTimeout(this.waitForHover, this.idleTime);
    }
    waitForHover() {
        if (this.timeout) clearTimeout(this.timeout);
        var dt = Date.now() - this.lastT;
        if (this.idleTime - dt > 10) {
            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
            return;
        }

        this.timeout = null;
        if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
            this.$gatherData(this.lastEvent, this.lastEvent.editor);
        }
    }

    /**
     * @param {MouseEvent} e
     */
    isOutsideOfText(e) {
        var editor = e.editor;
        var docPos = e.getDocumentPosition();
        var line = editor.session.getLine(docPos.row);
        if (docPos.column == line.length) {
            var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
            var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
            if (
                clippedPos.column != screenPos.column
                || clippedPos.row != screenPos.row
            ) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param {(event: MouseEvent, editor: Editor) => void} value
     */
    setDataProvider(value) {
        this.$gatherData = value;
    }

    /**
     * @param {Editor} editor
     * @param {Range} range
     * @param {HTMLElement} domNode
     * @param {MouseEvent} startingEvent
     */
    showForRange(editor, range, domNode, startingEvent) {
        var MARGIN = 10;
        if (startingEvent && startingEvent != this.lastEvent) return;
        if (this.isOpen && document.activeElement == this.getElement()) return;

        var renderer = editor.renderer;
        if (!this.isOpen) {
            popupManager.addPopup(this);
            this.$registerCloseEvents();
            this.setTheme(renderer.theme);
        }
        this.isOpen = true;

        this.addMarker(range, editor.session);
        this.range = Range.fromPoints(range.start, range.end);
        var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);

        var rect = renderer.scroller.getBoundingClientRect();
        // clip position to visible area of the editor
        if (position.pageX < rect.left)
            position.pageX = rect.left;

        var element = this.getElement();
        element.innerHTML = "";
        element.appendChild(domNode);

        element.style.maxHeight = "";
        element.style.display = "block";

        // measure the size of tooltip, without constraints on its height
        var labelHeight = element.clientHeight;
        var labelWidth = element.clientWidth;
        var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;

        // if tooltip fits above the line, or space below the line is smaller, show tooltip above
        let isAbove = true;
        if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
            isAbove = false;
        }

        element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
        element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
        element.style.bottom = isAbove ?  window.innerHeight - position.pageY  + "px" : "";

        // try to align tooltip left with the range, but keep it on screen
        element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
    }

    /**
     * @param {Range} range
     * @param {EditSession} [session]
     */
    addMarker(range, session) {
        if (this.marker) {
            this.$markerSession.removeMarker(this.marker);
        }
        this.$markerSession = session;
        this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
    }

    hide(e) {
        if (!e && document.activeElement == this.getElement())
            return;
        if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))
            return;
        this.lastEvent = null;
        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = null;
        this.addMarker(null);
        if (this.isOpen) {
            this.$removeCloseEvents();
            this.getElement().style.display = "none";
            this.isOpen = false;
            popupManager.removePopup(this);
        }
    }

    $registerCloseEvents() {
        window.addEventListener("keydown", this.hide, true);
        window.addEventListener("wheel", this.hide, true);
        window.addEventListener("mousedown", this.hide, true);
    }

    $removeCloseEvents() {
        window.removeEventListener("keydown", this.hide, true);
        window.removeEventListener("wheel", this.hide, true);
        window.removeEventListener("mousedown", this.hide, true);
    }

    /**
     * @internal
     */
    onMouseOut(e) {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.lastEvent = null;
        if (!this.isOpen) return;

        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;

        if (e && e.currentTarget.contains(e.relatedTarget)) return;
        if (!e.relatedTarget.classList.contains("ace_content")) this.hide();
    }
}

__webpack_unused_export__ = HoverTooltip;


/***/ }),

/***/ 79870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 */

/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 **/
class UndoManager {
    /**
     * Resets the current undo state and creates a new `UndoManager`.
     **/
    constructor() {
        /**@type {boolean}*/
        this.$keepRedoStack;
        this.$maxRev = 0;
        this.$fromUndo = false;
        this.$undoDepth = Infinity;
        this.reset();
    }

    /**
     * 
     * @param {EditSession} session
     */
    addSession(session) {
        this.$session = session;
    }
    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     *
     * - `args[0]` is an array of deltas
     * - `args[1]` is the document to associate with
     *
     * @param {import("../ace-internal").Ace.Delta} delta
     * @param {boolean} allowMerge
     * @param {EditSession} [session]
     **/
    add(delta, allowMerge, session) {
        if (this.$fromUndo) return;
        if (delta == this.$lastDelta) return;
        if (!this.$keepRedoStack) this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            var undoStackLength = this.$undoStack.length;
            if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
            }
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == "remove" || delta.action == "insert")
            this.$lastDelta = delta;
        this.lastDeltas.push(delta);
    }

    /**
     * 
     * @param {any} selection
     * @param {number} [rev]
     */
    addSelection(selection, rev) {
        this.selections.push({
            value: selection,
            rev: rev || this.$rev
        });
    }
    
    startNewGroup() {
        this.lastDeltas = null;
        return this.$rev;
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     */
    markIgnored(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id <= from)
                break;
            if (delta.id < to)
                delta.ignore = true;
        }
        this.lastDeltas = null;
    }

    /**
     * 
     * @param {number} rev
     * @param {boolean} [after]
     * @return {{ value: string, rev: number }}
     */
    getSelection(rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--;) {
            var selection = stack[i];
            if (selection.rev < rev) {
                if (after)
                    selection = stack[i + 1];
                return selection;
            }
        }
    }

    /**
     * @return {number}
     */
    getRevision() {
        return this.$rev;
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     * @return {import("../ace-internal").Ace.Delta[]}
     */
    getDeltas(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id < to && !end)
                end = i+1;
            if (delta.id <= from) {
                start = i + 1;
                break;
            }
        }
        return stack.slice(start, end);
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     */
    getChangedRanges(from, to) {
        if (to == null) to = this.$rev + 1;
    }

    /**
     *
     * @param {number} from
     * @param {number} [to]
     */
    getChangedLines(from, to) {
        if (to == null) to = this.$rev + 1;
        
    }

    /**
     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
     * @param {EditSession} session
     * @param {Boolean} [dontSelect] {:dontSelect}
     **/
    undo(session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        
        if (!rearrangeUndoStack(stack, stack.length))
            return;
        
        if (!session)
            session = this.$session;
        
        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
            this.$redoStack = [];
        
        this.$fromUndo = true;
        
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
        }
        
        this.$fromUndo = false;

        return undoSelectionRange;
    }
    
    /**
     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
     * @param {EditSession} session
     * @param {Boolean} [dontSelect] {:dontSelect}
     *
     **/
    redo(session, dontSelect) {
        this.lastDeltas = null;
        
        if (!session)
            session = this.$session;
        
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
            }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        
        if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        
        return redoSelectionRange;
    }
    
    $syncRev() {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id = nextDelta && nextDelta[0].id || 0;
        this.$redoStackBaseRev = id;
        this.$rev = id;
    }

    /**
     * Destroys the stack of undo and redo redo operations.
     **/
    reset() {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
    }

    
    /**
     * Returns `true` if there are undo operations left to perform.
     * @returns {Boolean}
     **/
    canUndo() {
        return this.$undoStack.length > 0;
    }

    /**
     * Returns `true` if there are redo operations left to perform.
     * @returns {Boolean}
     **/
    canRedo() {
        return this.$redoStack.length > 0;
    }

    /**
     * Marks the current status clean
     * @param {number} [rev]
     */
    bookmark(rev) {
        if (rev == undefined)
            rev = this.$rev;
        this.mark = rev;
    }

    /**
     * Returns if the current status is clean
     * @returns {Boolean}
     **/
    isAtBookmark() {
        return this.$rev === this.mark;
    }
    
    /**
     * Returns an object which can be safely stringified into JSON
     * @returns {object}
     */
    toJSON() {
        return {
            $redoStack: this.$redoStack,
            $undoStack: this.$undoStack
        };
    }

    // NOTE: The above and below function require you to JSON.stringify and JSON.parse externally.
    
    /**
     * Takes in an object which was returned from the toJSON method above,
     * and resets the current undoManager instance to use the previously exported
     * instance state.
     * @param {object} json 
     */
    fromJSON(json) {
        this.reset();
        this.$undoStack = json.$undoStack;
        this.$redoStack = json.$redoStack;
    }


    /**
     * @param {Delta} delta
     */
    $prettyPrint(delta) {
        if (delta) return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
    }
}


UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
UndoManager.prototype.markClean = UndoManager.prototype.bookmark;

/**
 * @param {any[]} stack
 * @param {number} pos
 */
function rearrangeUndoStack(stack, pos) {
    for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
            while(i < pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            return true;
        }
    }
}

var Range = (__webpack_require__(91902)/* .Range */ .Q);
var cmp = Range.comparePoints;
var comparePoints = Range.comparePoints;

/**
 * @param {Delta} delta
 */
function $updateMarkers(delta) {
    var isInsert = delta.action == "insert";
    var start = delta.start;
    var end = delta.end;
    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
    if (isInsert) end = start;

    for (var i in this.marks) {
        var point = this.marks[i];
        var cmp = comparePoints(point, start);
        if (cmp < 0) {
            continue; // delta starts after the range
        }
        if (cmp === 0) {
            if (isInsert) {
                if (point.bias == 1) {
                    cmp = 1;
                }
                else {
                    point.bias == -1;
                    continue;
                }
            }
        }
        var cmp2 = isInsert ? cmp : comparePoints(point, end);
        if (cmp2 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
        }
        if (!isInsert && cmp2 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp2 === 0)
                point.bias = 1;
        }
    }
}

/**
 * @param {Point} pos
 */
function clonePos(pos) {
    return {row: pos.row,column: pos.column};
}

/**
 * @param {Delta} d
 */
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
    };
}
function stringifyDelta(d) {
    d = d || this;
    if (Array.isArray(d)) {
        return d.map(stringifyDelta).join("\n");
    }
    var type = "";
    if (d.action) {
        type = d.action == "insert" ? "+" : "-";
        type += "[" + d.lines + "]";
    } else if (d.value) {
        if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
        } else {
            type = stringifyRange(d.value);
        }
    }
    if (d.start) {
        type += stringifyRange(d);
    }
    if (d.id || d.rev) {
        type += "\t(" + (d.id || d.rev) + ")";
    }
    return type;
}

/**
 * @param {Range} r
 * @return {string}
 */
function stringifyRange(r) {
    return r.start.row + ":" + r.start.column 
        + "=>" + r.end.row + ":" + r.end.column;
}
/*
 * i i  d1  d2
 *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       d1.s < d2.s < d1.e // can split
 * 
 * i r  d1  d2
 *      |/  |\  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       else // can't swap
 * 
 * r i  d1  d2
 *      |\  |/  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       // no else
 * 
 * r r  d1  d2
 *      |\  |\  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       d2.s < d1.s < d2.e // can split
 */

/**
 * @param {Delta} d1
 * @param {Delta} d2
 */
function swap(d1, d2) {
    var i1 = d1.action == "insert";
    var i2 = d2.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    }
    return [d2, d1];
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                // rollback, we have to undo ds2 first
                while (i < ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }                
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore = 
    ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}

/*
      d2          xform(d1, c1) = [d2, c2]
    o<---o        xform(c1, d1) = [c2, d2]
 c2 |    | d1     
    o<---o
      c1
*/
/**
 * 
 * @param {Delta} d1
 * @param {Delta} c1
 */
function xform(d1, c1) {
    var i1 = d1.action == "insert";
    var i2 = c1.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
        } else {
            shift(d1, c1, 1);
        }
    } else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
        } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, +1);
        } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, +1);
        }
    } else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, +1);
        } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, +1);
        }
    } else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
        } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
                before = d1;
                d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
                after = splitDelta(d1, c1.end);
            }

            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
                d1.lines = after.lines;
                d1.start = after.start;
                d1.end = after.end;
                after = d1;
            }

            return [c1, before, after].filter(Boolean);
        }
    }
    return [c1, d1];
}

/**
 * 
 * @param {IRange} d1
 * @param {IRange} d2
 * @param {number} dir
 */
function shift(d1, d2, dir) {
    shiftPos(d1.start, d2.start, d2.end, dir);
    shiftPos(d1.end, d2.start, d2.end, dir);
}

/**
 * 
 * @param {Point} pos
 * @param {Point} start
 * @param {Point} end
 * @param {number} dir
 */
function shiftPos(pos, start, end, dir) {
    if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
    }
    pos.row += dir * (end.row - start.row);
}

/**
 * 
 * @param {Delta} c
 * @param {Point} pos
 * @return {Delta}
 */
function splitDelta(c, pos) {
    var lines = c.lines;
    var end = c.end;
    c.end = clonePos(pos);    
    var rowsBefore = c.end.row - c.start.row;
    var otherLines = lines.splice(rowsBefore, lines.length);
    
    var col = rowsBefore ? pos.column : pos.column - c.start.column;
    lines.push(otherLines[0].substring(0, col));
    otherLines[0] = otherLines[0].substr(col)   ; 
    var rest = {
        start: clonePos(pos),
        end: end,
        lines: otherLines,
        action: c.action
    };
    return rest;
}

/**
 * @param {any[]} redoStack
 * @param {Delta} d
 */
function moveDeltasByOne(redoStack, d) {
    d = cloneDelta(d);
    for (var j = redoStack.length; j--;) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
                if (xformed[2]) {
                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                    i++;
                } else if (!xformed[1]) {
                    deltaSet.splice(i, 1);
                    i--;
                }
            }
        }
        if (!deltaSet.length) {
            redoStack.splice(j, 1); 
        }
    }
    return redoStack;
}

function rebaseRedoStack(redoStack, deltaSets) {
    for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
        }
    }
}
exports.a = UndoManager;


/***/ }),

/***/ 6672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// generated by tool/unicode.js
var wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];

var code = 0;
var str = [];
for (var i = 0; i < wordChars.length; i += 2) {
    str.push(code += wordChars[i]);
    if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
}

exports.wordChars = String.fromCharCode.apply(null, str);


/***/ }),

/***/ 21016:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.Theme} Theme
 */
var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var config = __webpack_require__(76321);
var GutterLayer = (__webpack_require__(6166)/* .Gutter */ .W);
var MarkerLayer = (__webpack_require__(12187)/* .Marker */ .p);
var TextLayer = (__webpack_require__(10694)/* .Text */ .E);
var CursorLayer = (__webpack_require__(50643)/* .Cursor */ .b);
var HScrollBar = (__webpack_require__(17745)/* .HScrollBar */ .V1);
var VScrollBar = (__webpack_require__(17745)/* .VScrollBar */ .vB);
var HScrollBarCustom = (__webpack_require__(50311)/* .HScrollBar */ .V1);
var VScrollBarCustom = (__webpack_require__(50311)/* .VScrollBar */ .vB);
var RenderLoop = (__webpack_require__(99481)/* .RenderLoop */ .x);
var FontMetrics = (__webpack_require__(22150)/* .FontMetrics */ .X);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var editorCss = __webpack_require__(53120);
var Decorator = (__webpack_require__(31079)/* .Decorator */ .K);

var useragent = __webpack_require__(74943);
const isTextToken = (__webpack_require__(41109)/* .isTextToken */ .t);

dom.importCssString(editorCss, "ace_editor.css", false);

/**
 * The class that is responsible for drawing everything you see on the screen!
 * @related editor.renderer
 **/
class VirtualRenderer {
    /**
     * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
     * @param {HTMLElement | null} [container] The root element of the editor
     * @param {String} [theme] The starting theme

     **/
    constructor(container, theme) {
        var _self = this;
        this.container = container || dom.createElement("div");

        dom.addCssClass(this.container, "ace_editor");
        if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");

        this.setTheme(theme);
        if (config.get("useStrictCSP") == null)
            config.set("useStrictCSP", false);

        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.$gutter.setAttribute("aria-hidden", "true");
        /**@type {HTMLElement}*/
        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";

        this.container.appendChild(this.scroller);
        /**@type {HTMLElement}*/
        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);

        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

        this.$markerBack = new MarkerLayer(this.content);
        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;

        this.$markerFront = new MarkerLayer(this.content);

        this.$cursorLayer = new CursorLayer(this.content);

        // Indicates whether the horizontal scrollbar is visible
        this.$horizScroll = false;
        this.$vScroll = false;

        this.scrollBar =
            this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });

        this.scrollTop = 0;
        this.scrollLeft = 0;

        this.cursorPos = {
            row : 0,
            column : 0
        };

        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.on("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
        });

        this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
        };

        this.layerConfig = {
            width : 1,
            padding : 0,
            firstRow : 0,
            firstRowScreen: 0,
            lastRow : 0,
            lineHeight : 0,
            characterWidth : 0,
            minHeight : 1,
            maxHeight : 1,
            offset : 0,
            height : 1,
            gutterOffset: 1
        };

        this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };

        this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };

        this.$keepTextAreaAtCursor = !useragent.isIOS;

        this.$loop = new RenderLoop(
            this.$renderChanges.bind(this),
            this.container.ownerDocument.defaultView
        );
        this.$loop.schedule(this.CHANGE_FULL);

        this.updateCharacterSize();
        this.setPadding(4);
        this.$addResizeObserver();
        config.resetOptions(this);
        config._signal("renderer", this);
    }


    // this.$logChanges = function(changes) {
    //     var a = ""
    //     if (changes & this.CHANGE_CURSOR) a += " cursor";
    //     if (changes & this.CHANGE_MARKER) a += " marker";
    //     if (changes & this.CHANGE_GUTTER) a += " gutter";
    //     if (changes & this.CHANGE_SCROLL) a += " scroll";
    //     if (changes & this.CHANGE_LINES) a += " lines";
    //     if (changes & this.CHANGE_TEXT) a += " text";
    //     if (changes & this.CHANGE_SIZE) a += " size";
    //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
    //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
    //     if (changes & this.CHANGE_FULL) a += " full";
    //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
    //     console.log(a.trim())
    // };

    updateCharacterSize() {
        // @ts-expect-error TODO: missing property initialization anywhere in codebase
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            // @ts-expect-error TODO: missing property initialization anywhere in codebase
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        // set explicit line height to avoid normal resolving to different values based on text
        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
    }

    /**
     *
     * Associates the renderer with an [[EditSession `EditSession`]].
     * @param {EditSession} session The session to associate with
     **/
    setSession(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;

        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;

        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    }

    /**
     * Triggers a partial update of the text, from the range given by the two parameters.
     * @param {Number} firstRow The first row to update
     * @param {Number} lastRow The last row to update
     * @param {boolean} [force]
     **/
    updateLines(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        // If the change happened offscreen above us then it's possible
        // that a new line wrap will affect the position of the lines on our
        // screen so they need redrawn.
        // TODO: better solution is to not change scroll position when text is changed outside of visible area
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    }

    /**
     * @internal
     */
    onChangeNewLineMode() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    }

    /**
     * @internal
     */
    onChangeTabSize() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    }

    /**
     * Triggers a full update of the text, for all the rows.
     **/
    updateText() {
        this.$loop.schedule(this.CHANGE_TEXT);
    }

    /**
     * Triggers a full update of all the layers, for all the rows.
     * @param {Boolean} [force] If `true`, forces the changes through

     **/
    updateFull(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    }

    /**
     * Updates the font size.
     **/
    updateFontSize() {
        this.$textLayer.checkForSizeChanges();
    }

    $updateSizeAsync() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    }
    /**
     * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
     * @param {Boolean} [force] If `true`, recomputes the size, even if the height and width haven't changed
     * @param {Number} [gutterWidth] The width of the gutter in pixels
     * @param {Number} [width] The width of the editor in pixels
     * @param {Number} [height] The hiehgt of the editor, in pixels
     * @internal
     **/
    onResize(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        // `|| el.scrollHeight` is required for autosizing editors on ie
        // where elements with clientHeight = 0 also have clientWidth = 0
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!height && this.$maxLines && this.lineHeight > 1) {
            // if we are supposed to fit to content set height at least to 1
            // so that render does not exit early before calling $autosize
            if (!el.style.height || el.style.height == "0px") {
                el.style.height = "1px";
                height = el.clientHeight || el.scrollHeight;
            }
        }
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        if (this.$resizeTimer) this.$resizeTimer.cancel();

        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        // reset cached values on scrollbars, needs to be removed when switching to non-native scrollbars
        // see https://github.com/ajaxorg/ace/issues/2195
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        if (this.$customScrollbar) {
            this.$updateCustomScrollbar(true);
        }
    }

    /**
     * @param [force]
     * @param [gutterWidth]
     * @param [width]
     * @param [height]
     * @return {number}

     */
    $updateCachedSize(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();

            this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;

            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

            this.gutterWidth = gutterWidth;

            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");

            var right = this.scrollBarV.getWidth() + "px";
            dom.setStyle(this.scrollBarH.element.style, "right", right);
            dom.setStyle(this.scroller.style, "right", right);
            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());

            this.scrollBarH.setWidth(size.scrollerWidth);

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
            }
        }

        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    }

    /**
     *
     * @param {number} width
     * @internal
     */
    onGutterResize(width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
        }
    }

    /**
     * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.

     **/
    adjustWrapLimit() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    }

    /**
     * Identifies whether you want to have an animated scroll or not.
     * @param {Boolean} shouldAnimate Set to `true` to show animated scrolls

     **/
    setAnimatedScroll(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    }

    /**
     * Returns whether an animated scroll happens or not.
     * @returns {Boolean}

     **/
    getAnimatedScroll() {
        return this.$animatedScroll;
    }

    /**
     * Identifies whether you want to show invisible characters or not.
     * @param {Boolean} showInvisibles Set to `true` to show invisibles

     **/
    setShowInvisibles(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    }

    /**
     * Returns whether invisible characters are being shown or not.
     * @returns {Boolean}

     **/
    getShowInvisibles() {
        return this.getOption("showInvisibles");
    }

    /**
     * @return {boolean}

     */
    getDisplayIndentGuides() {
        return this.getOption("displayIndentGuides");
    }

    /**
     * @param {boolean} display

     */
    setDisplayIndentGuides(display) {
        this.setOption("displayIndentGuides", display);
    }

    /**

     * @return {boolean}
     */
    getHighlightIndentGuides() {
        return this.getOption("highlightIndentGuides");
    }

    /**

     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        this.setOption("highlightIndentGuides", highlight);
    }

    /**
     * Identifies whether you want to show the print margin or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin

     **/
    setShowPrintMargin(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    }

    /**
     * Returns whether the print margin is being shown or not.
     * @returns {Boolean}

     **/
    getShowPrintMargin() {
        return this.getOption("showPrintMargin");
    }
    /**
     * Identifies whether you want to show the print margin column or not.
     * @param {number} printMarginColumn Set to `true` to show the print margin column

     **/
    setPrintMarginColumn(printMarginColumn) {
        this.setOption("printMarginColumn", printMarginColumn);
    }

    /**
     * Returns whether the print margin column is being shown or not.
     * @returns {number}

     **/
    getPrintMarginColumn() {
        return this.getOption("printMarginColumn");
    }

    /**
     * Returns `true` if the gutter is being shown.
     * @returns {Boolean}

     **/
    getShowGutter(){
        return this.getOption("showGutter");
    }

    /**
     * Identifies whether you want to show the gutter or not.
     * @param {Boolean} show Set to `true` to show the gutter

     **/
    setShowGutter(show){
        return this.setOption("showGutter", show);
    }

    /**

     * @returns {boolean}
     */
    getFadeFoldWidgets(){
        return this.getOption("fadeFoldWidgets");
    }

    /**

     * @param {boolean} show
     */
    setFadeFoldWidgets(show) {
        this.setOption("fadeFoldWidgets", show);
    }

    /**
      *
     * @param {boolean} shouldHighlight
     */
    setHighlightGutterLine(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    }

    /**

     * @returns {boolean}
     */
    getHighlightGutterLine() {
        return this.getOption("highlightGutterLine");
    }

    /**

     */
    $updatePrintMargin() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";

        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    }

    /**
     *
     * Returns the root element containing this renderer.
     * @returns {HTMLElement}
     **/
    getContainerElement() {
        return this.container;
    }

    /**
     *
     * Returns the element that the mouse events are attached to
     * @returns {HTMLElement}
     **/
    getMouseEventTarget() {
        return this.scroller;
    }

    /**
     *
     * Returns the element to which the hidden text area is added.
     * @returns {HTMLElement}
     **/
    getTextAreaContainer() {
        return this.container;
    }

    // move text input over the cursor
    // this is required for IME
    /**

     */
    $moveTextAreaToCursor() {
        if (this.$isMousePressed) return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor && !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
            return;
        if (composition && composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);

        var config = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config.offset;

        var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
        if (posTop < 0 || posTop > config.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
        }

        var w = 1;
        var maxTop = this.$size.height - h;
        if (!composition) {
            posTop += this.lineHeight;
        }
        else {
            if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
            }
            else {
                posTop += this.lineHeight + 2;
            }
        }

        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth + this.margin.left;

        dom.setStyle(style, "height", h + "px");
        dom.setStyle(style, "width", w + "px");
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
    }

    /**
     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
     * @returns {Number}
     **/
    getFirstVisibleRow() {
        return this.layerConfig.firstRow;
    }

    /**
     *
     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    getFirstFullyVisibleRow() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    }

    /**
     *
     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    getLastFullyVisibleRow() {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    }

    /**
     *
     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
     * @returns {Number}
     **/
    getLastVisibleRow() {
        return this.layerConfig.lastRow;
    }

    /**
     * Sets the padding for all the layers.
     * @param {Number} padding A new padding value (in pixels)

     **/
    setPadding(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    }

    /**
     *
     * @param {number} [top]
     * @param {number} [bottom]
     * @param {number} [left]
     * @param {number} [right]

     */
    setScrollMargin(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    }

    /**
     *
     * @param {number} [top]
     * @param {number} [bottom]
     * @param {number} [left]
     * @param {number} [right]

     */
    setMargin(top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
    }

    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}

     **/
    getHScrollBarAlwaysVisible() {
        return this.$hScrollBarAlwaysVisible;
    }

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible

     **/
    setHScrollBarAlwaysVisible(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    }
    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}

     **/
    getVScrollBarAlwaysVisible() {
        return this.$vScrollBarAlwaysVisible;
    }

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/
    setVScrollBarAlwaysVisible(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    }

    /**

     */
    $updateScrollBarV() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    }
    $updateScrollBarH() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    }

    freeze() {
        this.$frozen = true;
    }

    unfreeze() {
        this.$frozen = false;
    }

    /**
     *
     * @param {number} changes
     * @param {boolean} [force]
     * @returns {number}

     */
    $renderChanges(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return;
        }
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        // this.$logChanges(changes);

        this._signal("beforeRender", changes);

        if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

        var config = this.layerConfig;
        // text, scrolling and resize changes can cause the view port size to change
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            // If a change is made offscreen and wrapMode is on, then the onscreen
            // lines may have been pushed down. If so, the first screen row will not
            // have changed, but the first actual row will. In that case, adjust
            // scrollTop so that the cursor and onscreen content stays in the same place.
            // TODO: find a better way to handle this, that works non wrapped case and doesn't compute layerConfig twice
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                    // this check is needed as a workaround for the documentToScreenRow returning -1 if document.length == 0
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
            }
            config = this.layerConfig;
            // update scrollbar first to not lose scroll position when gutter calls resize
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();

            dom.translate(this.content, -this.scrollLeft, -config.offset);

            var width = config.width + 2 * this.$padding + "px";
            var height = config.minHeight + "px";

            dom.setStyle(this.content.style, "width", width);
            dom.setStyle(this.content.style, "height", height);
        }

        // horizontal scrolling
        if (changes & this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
            if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
        }

        // full
        if (changes & this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }

        // scrolling
        if (changes & this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                    this.$gutterLayer.update(config);
                else
                    this.$gutterLayer.scrollLines(config);
            }
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
                // @ts-expect-error TODO: potential wrong param
                this.$gutterLayer.updateLineHighlight(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender", changes);
    }

    /**

     */
    $autosize() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight,
            Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;

        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
        var vScroll = !hideScrollbars && height > maxHeight;

        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }

            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            // this.$loop.changes = 0;
            this.desiredHeight = desiredHeight;

            this._signal("autosize");
        }
    }

    /**

     * @returns {number}
     */
    $computeLayerConfig() {
        var session = this.session;
        var size = this.$size;

        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();

        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        // autoresize only after updating hscroll to include scrollbar height in desired height
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var minHeight = size.scrollerHeight + this.lineHeight;

        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;

        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft,
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;

        // Map lines on the screen to lines in the document.
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);

        // Check if firstRow is inside of a foldLine. If true, then use the first
        // row of the foldLine.
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged)
            changes = this.CHANGE_H_SCROLL;
        // Horizontal scrollbar visibility may have changed, which changes
        // the client height of the scroller
        if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }

        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height : this.$size.scrollerHeight
        };

        if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
        // For debugging.
        // console.log(JSON.stringify(this.layerConfig));

        return changes;
    }

    /**
     * @returns {boolean | undefined}

     */
    $updateLines() {
        if (!this.$changedLines) return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }

        // if the last row is unknown -> redraw everything
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }

        // else update only the changed rows
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    }

    /**
     *
     * @returns {number}

     */
    $getLongestLine() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    }

    /**
     * Schedules an update to all the front markers in the document.
     **/
    updateFrontMarkers() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    }

    /**
     *
     * Schedules an update to all the back markers in the document.
     **/
    updateBackMarkers() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    }

    /**
     *
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    addGutterDecoration(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    }

    /**
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    removeGutterDecoration(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    }

    /**
     *
     * Redraw breakpoints.
     * @param {any} [rows]
     */
    updateBreakpoints(rows) {
        this._rows = rows;
        this.$loop.schedule(this.CHANGE_GUTTER);
    }

    /**
     * Sets annotations for the gutter.
     * @param {import("../ace-internal").Ace.Annotation[]} annotations An array containing annotations
     *
     **/
    setAnnotations(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    }

    /**
     *
     * Updates the cursor icon.
     **/
    updateCursor() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    }

    /**
     *
     * Hides the cursor icon.
     **/
    hideCursor() {
        this.$cursorLayer.hideCursor();
    }

    /**
     *
     * Shows the cursor icon.
     **/
    showCursor() {
        this.$cursorLayer.showCursor();
    }

    /**
     *
     * @param {Point} anchor
     * @param {Point} lead
     * @param {number} [offset]
     */
    scrollSelectionIntoView(anchor, lead, offset) {
        // first scroll anchor into view then scroll lead into view
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    }

    /**
     *
     * Scrolls the cursor into the first visibile area of the editor
     * @param {Point} [cursor]
     * @param {number} [offset]
     * @param {{ top?: any; bottom?: any; }} [$viewMargin]
     */
    scrollCursorIntoView(cursor, offset, $viewMargin) {
        // the editor is not visible
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var newLeft = pos.left;
        var newTop = pos.top;

        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

        if (this.$scrollAnimation) {
            this.$stopAnimation = true;
        }

        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

        if (currentTop + topMargin > newTop) {
            if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
            if (newTop === 0)
                newTop = -this.scrollMargin.top;
            this.session.setScrollTop(newTop);
        } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop -  this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }

        var currentLeft = this.scrollLeft;
        // Show 2 context characters of the line when moving to it
        var twoCharsWidth = 2 * this.layerConfig.characterWidth;

        if (newLeft - twoCharsWidth < currentLeft) {
            newLeft -= twoCharsWidth;
            if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
            }
            this.session.setScrollLeft(newLeft);
        } else {
            newLeft += twoCharsWidth;
            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
            } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        }
    }

    /**
     * {:EditSession.getScrollTop}
     * @related EditSession.getScrollTop
     * @returns {Number}
     **/
    getScrollTop() {
        return this.session.getScrollTop();
    }

    /**
     * {:EditSession.getScrollLeft}
     * @related EditSession.getScrollLeft
     * @returns {Number}
     **/
    getScrollLeft() {
        return this.session.getScrollLeft();
    }

    /**
     * Returns the first visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    getScrollTopRow() {
        return this.scrollTop / this.lineHeight;
    }

    /**
     * Returns the last visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    getScrollBottomRow() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    }

    /**
     * Gracefully scrolls from the top of the editor to the row indicated.
     * @param {Number} row A row id
     *
     * @related EditSession.setScrollTop
     **/
    scrollToRow(row) {
        this.session.setScrollTop(row * this.lineHeight);
    }

    /**
     *
     * @param {Point} cursor
     * @param {number} [alignment]
     * @returns {number}
     */
    alignCursor(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    }

    /**
     *
     * @param {number} fromValue
     * @param {number} toValue
     * @returns {*[]}
     */
    $calcSteps(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    }

    /**
     * Gracefully scrolls the editor to the row indicated.
     * @param {Number} line A line number
     * @param {Boolean} center If `true`, centers the editor the to indicated line
     * @param {Boolean} animate If `true` animates scrolling
     * @param {() => void} [callback] Function to be called after the animation has finished

     **/
    scrollToLine(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    }

    /**
     *
     * @param fromValue
     * @param [callback]

     */
    animateScrolling(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;

        if (fromValue == toValue)
            return;

        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }

        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        // trick session to think it's already scrolled to not loose toValue
        _self.session.$scrollTop = toValue;

        function endAnimation() {
            // @ts-ignore
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            _self.$stopAnimation = false;
            callback && callback();
        }

        this.$timer = setInterval(function() {
            if (_self.$stopAnimation) {
                endAnimation();
                return;
            }

            if (!_self.session)
                return clearInterval(_self.$timer);
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                // do this on separate step to not get spurious scroll event from scrollbar
                endAnimation();
            }
        }, 10);
    }

    /**
     * Scrolls the editor to the y pixel indicated.
     * @param {Number} scrollTop The position to scroll to
     **/
    scrollToY(scrollTop) {
        // after calling scrollBar.setScrollTop
        // scrollbar sends us event with same scrollTop. ignore it
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    }

    /**
     * Scrolls the editor across the x-axis to the pixel indicated.
     * @param {Number} scrollLeft The position to scroll to
     **/
    scrollToX(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    }

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} x The x value to scroll to
     * @param {Number} y The y value to scroll to
     **/
    scrollTo(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(x);
    }

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     **/
    scrollBy(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    }

    /**
     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     * @returns {Boolean}
     **/
    isScrollableBy(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     * @returns {import("../ace-internal").Ace.ScreenCoordinates}

     */
    pixelToScreenCoordinates(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     * @returns {Point}

     */
    screenToTextCoordinates(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);

        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    }

    /**
     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
     * @param {Number} row The document row position
     * @param {Number} column The document column position
     *
     * @returns {{ pageX: number, pageY: number}}
     **/
    textToScreenCoordinates(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
             ? this.session.$bidiHandler.getPosLeft(pos.column)
             : Math.round(pos.column * this.characterWidth));

        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    }

    /**
     *
     * Focuses the current container.
     **/
    visualizeFocus() {
        dom.addCssClass(this.container, "ace_focus");
    }

    /**
     *
     * Blurs the current container.
     **/
    visualizeBlur() {
        dom.removeCssClass(this.container, "ace_focus");
    }

    /**
     * @param {Object} composition

     **/
    showComposition(composition) {
        this.$composition = composition;
        if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == undefined)
            composition.useTextareaForIME = this.$useTextareaForIME;

        if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = "none";
        }
        else {
            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        }
    }

    /**
     * @param {String} text A string of text to use
     *
     * Sets the inner text of the current composition to `text`.

     **/
    setCompositionText(text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
    }

    /**
     *
     * Hides the current composition.

     **/
    hideComposition() {
        if (!this.$composition)
            return;

        if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);

        dom.removeCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = "";
    }

    /**
     * @param {string} text
     * @param {Point} [position]
     */
    setGhostText(text, position) {
        var cursor = this.session.selection.cursor;
        var insertPosition = position || { row: cursor.row, column: cursor.column };

        this.removeGhostText();

        var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
        this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);

        this.$ghostText = {
            text: text,
            position: {
                row: insertPosition.row,
                column: insertPosition. column
            }
        };

        var widgetDiv = dom.createElement("div");
        if (textChunks.length > 1) {
            // If there are tokens to the right of the cursor, hide those.
            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);

            var lastLineDiv;
            textChunks.slice(1).forEach(el => {
                var chunkDiv = dom.createElement("div");
                var chunkSpan = dom.createElement("span");
                chunkSpan.className = "ace_ghost_text";

                // If the line is wider than the viewport, wrap the line
                if (el.wrapped) chunkDiv.className = "ghost_text_line_wrapped";

                // If a given line doesn't have text (e.g. it's a line of whitespace), set a space as the
                // textcontent so that browsers render the empty line div.
                if (el.text.length === 0) el.text = " ";

                chunkSpan.appendChild(dom.createTextNode(el.text));
                chunkDiv.appendChild(chunkSpan);
                widgetDiv.appendChild(chunkDiv);

                // Overwrite lastLineDiv every iteration so at the end it points to
                // the last added element.
                lastLineDiv = chunkDiv;
            });

            // Add the hidden tokens to the last line of the ghost text.
            hiddenTokens.forEach(token => {
                var element = dom.createElement("span");
                if (!isTextToken(token.type)) element.className = "ace_" + token.type.replace(/\./g, " ace_");
                element.appendChild(dom.createTextNode(token.value));
                lastLineDiv.appendChild(element);
            });

            this.$ghostTextWidget = {
                el: widgetDiv,
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text_container"
            };
            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);

            // Check wether the line widget fits in the part of the screen currently in view
            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
            var el = this.container;
            var height = el.getBoundingClientRect().height;
            var ghostTextHeight = textChunks.length * this.lineHeight;
            var fitsY = ghostTextHeight < (height - pixelPosition.top);

            // If it fits, no action needed
            if (fitsY) return;

            // If it can fully fit in the screen, scroll down until it fits on the screen
            // if it cannot fully fit, scroll so that the row with the cursor
            // is at the top of the screen.
            if (ghostTextHeight < height) {
                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
            } else {
                this.scrollToRow(insertPosition.row);
            }
        }

    }

    /**
     * Calculates and organizes text into wrapped chunks. Initially splits the text by newline characters,
     * then further processes each line based on display tokens and session settings for tab size and wrapping limits.
     *
     * @param {string} text
     * @param {Point} position
     * @return {{text: string, wrapped: boolean}[]}
     */
    $calculateWrappedTextChunks(text, position) {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth) - 2;
        limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small

        var textLines = text.split(/\r?\n/);
        var textChunks = [];
        for (var i = 0; i < textLines.length; i++) {
            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);

            if (wrapSplits.length > 0) {
                var start = 0;
                wrapSplits.push(textLines[i].length);

                for (var j = 0; j < wrapSplits.length; j++) {
                    let textSlice = textLines[i].slice(start, wrapSplits[j]);
                    textChunks.push({text: textSlice, wrapped: true});
                    start = wrapSplits[j];
                }
            }
            else {
                textChunks.push({text: textLines[i], wrapped: false});
            }
        }
        return textChunks;
    }

    removeGhostText() {
        if (!this.$ghostText) return;

        var position = this.$ghostText.position;
        this.removeExtraToken(position.row, position.column);
        if (this.$ghostTextWidget) {
            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
            this.$ghostTextWidget = null;
        }
        this.$ghostText = null;
    }

    /**
     * @param {string} text
     * @param {string} type
     * @param {number} row
     * @param {number} [column]
     */
    addToken(text, type, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = {type: type, value: text};
        var tokens = session.getTokens(row);
        if (column == null || !tokens.length) {
            tokens.push(newToken);
        } else {
            var l = 0;
            for (var i =0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                    var diff = token.value.length - (l - column);
                    var before = token.value.slice(0, diff);
                    var after = token.value.slice(diff);

                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});
                    break;
                }
            }
        }
        this.updateLines(row, row);
    }

    // Hide all non-ghost-text tokens to the right of a given position.
    hideTokensAfterPosition(row, column) {
        var tokens = this.session.getTokens(row);
        var l = 0;
        var hasPassedCursor = false;
        var hiddenTokens = [];
        // Loop over all tokens and track at what position in the line they end.
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            l += token.value.length;

            if (token.type === "ghost_text") continue;

            // If we've already passed the current cursor position, mark all of them as hidden.
            if (hasPassedCursor) {
                hiddenTokens.push({type: token.type, value: token.value});
                token.type = "hidden_token";
                continue;
            }
            // We call this method after we call addToken, so we are guaranteed a new token starts at the cursor position.
            // Once we reached that point in the loop, flip the flag.
            if (l === column) {
                hasPassedCursor = true;
            }
        }
        this.updateLines(row, row);
        return hiddenTokens;
    }

    removeExtraToken(row, column) {
        this.session.bgTokenizer.lines[row] = null;
        this.updateLines(row, row);
    }

    /**
     * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
     * @param {String | Theme} [theme] The path to a theme
     * @param {() => void} [cb] optional callback

     **/
    setTheme(theme, cb) {
        var _self = this;
        /**@type {any}*/
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            // @ts-ignore
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        /**
         * @param {Theme} module
         */
        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            if (module.$id)
                _self.$themeId = module.$id;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container
            );
            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
            /**@type {any}*/
            var padding = "padding" in module ? module.padding
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);

            // this is kept only for backwards compatibility
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);

            // force re-measure of the gutter width
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();

            // workaround for safari not redrawing the editor
            // https://github.com/ajaxorg/ace/issues/5569
            if (useragent.isSafari && _self.scroller) {
                _self.scroller.style.background = "red";
                _self.scroller.style.background = "";
            }
        }
    }

    /**
     * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
     * @returns {String}
     **/
    getTheme() {
        return this.$themeId;
    }

    // Methods allows to add / remove CSS classnames to the editor element.
    // This feature can be used by plug-ins to provide a visual indication of
    // a certain mode that editor is in.

    /**
     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
     * @param {String} style A class name
     * @param {boolean}[include]
     **/
    setStyle(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    }

    /**
     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
     * @param {String} style A class name
     *
     **/
    unsetStyle(style) {
        dom.removeCssClass(this.container, style);
    }

    /**
     * @param {string} style
     */
    setCursorStyle(style) {
        dom.setStyle(this.scroller.style, "cursor", style);
    }

    /**
     * @param {String} cursorStyle A css cursor style
     **/
    setMouseCursor(cursorStyle) {
        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
    }

    attachToShadowRoot() {
        dom.importCssString(editorCss, "ace_editor.css", this.container);
    }

    /**
     * Destroys the text and cursor layers for this renderer.

     **/
    destroy() {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = "";
        this.setOption("useResizeObserver", false);
    }

    /**
     *
     * @param {boolean} [val]
     */
    $updateCustomScrollbar(val) {
        var _self = this;
        this.$horizScroll = this.$vScroll = null;
        this.scrollBarV.element.remove();
        this.scrollBarH.element.remove();
        if (this.$scrollDecorator) {
            delete this.$scrollDecorator;
        }
        if (val === true) {
            /**@type {import("../ace-internal").Ace.VScrollbar}*/
            this.scrollBarV = new VScrollBarCustom(this.container, this);
            /**@type {import("../ace-internal").Ace.HScrollbar}*/
            this.scrollBarH = new HScrollBarCustom(this.container, this);
            this.scrollBarV.setHeight(this.$size.scrollerHeight);
            this.scrollBarH.setWidth(this.$size.scrollerWidth);

            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.$scrollDecorator = new Decorator(this.scrollBarV, this);
            this.$scrollDecorator.$updateDecorators();
        }
        else {
            this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
        }
    }

    /**

     */
    $addResizeObserver() {
        if (!window.ResizeObserver || this.$resizeObserver) return;
        var self = this;
        this.$resizeTimer = lang.delayedCall(function() {
            if (!self.destroyed)  self.onResize();
        }, 50);
        this.$resizeObserver = new window.ResizeObserver(function(e) {
            var w = e[0].contentRect.width;
            var h = e[0].contentRect.height;
            if (
                Math.abs(self.$size.width - w) > 1
                || Math.abs(self.$size.height - h) > 1
            ) {
                self.$resizeTimer.delay();
            } else {
                self.$resizeTimer.cancel();
            }
        });
        this.$resizeObserver.observe(this.container);
    }

}

VirtualRenderer.prototype.CHANGE_CURSOR = 1;
VirtualRenderer.prototype.CHANGE_MARKER = 2;
VirtualRenderer.prototype.CHANGE_GUTTER = 4;
VirtualRenderer.prototype.CHANGE_SCROLL = 8;
VirtualRenderer.prototype.CHANGE_LINES = 16;
VirtualRenderer.prototype.CHANGE_TEXT = 32;
VirtualRenderer.prototype.CHANGE_SIZE = 64;
VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
VirtualRenderer.prototype.CHANGE_FULL = 512;
VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
VirtualRenderer.prototype.$changes = 0;
VirtualRenderer.prototype.$padding = null;
VirtualRenderer.prototype.$frozen = false;
VirtualRenderer.prototype.STEPS = 8;

oop.implement(VirtualRenderer.prototype, EventEmitter);

config.defineOptions(VirtualRenderer.prototype, "renderer", {
    useResizeObserver: {
        /**
         * @param value
         * @this{VirtualRenderer}
         */
        set: function(value) {
            if (!value && this.$resizeObserver) {
                this.$resizeObserver.disconnect();
                this.$resizeTimer.cancel();
                this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
                this.$addResizeObserver();
            }
        }
    },
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    useSvgGutterIcons: {
        set: function(value){
            this.$gutterLayer.$useSvgGutterIcons = value;
        },
        initialValue: false
    },
    showFoldedAnnotations: {
        set: function(value){
            this.$gutterLayer.$showFoldedAnnotations = value;
        },
        initialValue: false
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
                this.$textLayer.$highlightIndentGuide();
            }
            else {
                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize: {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            if (!(this.$minLines < 0x1ffffffffffff))
                this.$minLines = 0;
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function(val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    customScrollbar: {
        set: function(val) {
            this.$updateCustomScrollbar(val);
        },
        initialValue: false
    },
    theme: {
        set: function(val) { this.setTheme(val); },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    },
    hasCssTransforms: {
    },
    useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
    }
});

exports.VirtualRenderer = VirtualRenderer;


/***/ }),

/***/ 28402:
/***/ ((__unused_webpack_module, exports) => {

// not implemented
var WorkerClient;
WorkerClient = function() {
    this.attachToDocument = function() {};
    this.on = function() {};
    this.terminate = function() {};
};

exports.WorkerClient = WorkerClient;


/***/ }),

/***/ 43956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true)
    module.exports = factory(__webpack_require__(19631), __webpack_require__(29451), __webpack_require__(93050), __webpack_require__(74943), __webpack_require__(51826), __webpack_require__(10776), __webpack_require__(27258), __webpack_require__(21016), __webpack_require__(91772), __webpack_require__(61893), __webpack_require__(2645), __webpack_require__(87366));
  else { var i, a; }
})(self, (__WEBPACK_EXTERNAL_MODULE__517__, __WEBPACK_EXTERNAL_MODULE__863__, __WEBPACK_EXTERNAL_MODULE__736__, __WEBPACK_EXTERNAL_MODULE__493__, __WEBPACK_EXTERNAL_MODULE__910__, __WEBPACK_EXTERNAL_MODULE__444__, __WEBPACK_EXTERNAL_MODULE__254__, __WEBPACK_EXTERNAL_MODULE__748__, __WEBPACK_EXTERNAL_MODULE__292__, __WEBPACK_EXTERNAL_MODULE__685__, __WEBPACK_EXTERNAL_MODULE__387__, __WEBPACK_EXTERNAL_MODULE__540__) => {
  return (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        286: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `.toggle-block {
    position: absolute;
    /*border: 1px solid black;*/
}


.toggle-bar {
    display:flex;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
    cursor: pointer;
}
.toggleBlockDragging {
    pointer-events: none;
    overflow-y: hidden;
}
.toggleBlockDragging  .title{
    pointer-events: none;
}

.toggle-bar .title {
    position: absolute;
    top: auto;
    left: auto;
    width: auto;
    height: auto;
}

.toggle-bar-h {
    width: 20px;
    height: 100%;
}

.toggle-bar-v {
    height: 20px;
    width: 100%;
}
.toggle-bar-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.toggle-bar-v div {
    margin-top: -2px;
    height: 5px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/accordion.css"], "names": [], "mappings": "AAAA;IACI,kBAAkB;IAClB,2BAA2B;AAC/B;;;AAGA;IACI,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,oBAAoB;IACpB,kBAAkB;AACtB;AACA;IACI,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,UAAU;IACV,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,WAAW;AACf;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf", "sourcesContent": [".toggle-block {\n    position: absolute;\n    /*border: 1px solid black;*/\n}\n\n\n.toggle-bar {\n    display:flex;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n    user-select: none;\n    cursor: pointer;\n}\n.toggleBlockDragging {\n    pointer-events: none;\n    overflow-y: hidden;\n}\n.toggleBlockDragging  .title{\n    pointer-events: none;\n}\n\n.toggle-bar .title {\n    position: absolute;\n    top: auto;\n    left: auto;\n    width: auto;\n    height: auto;\n}\n\n.toggle-bar-h {\n    width: 20px;\n    height: 100%;\n}\n\n.toggle-bar-v {\n    height: 20px;\n    width: 100%;\n}\n.toggle-bar-h div {\n    margin-left: -2px;\n    width: 5px;\n    height: 100%\n}\n.toggle-bar-v div {\n    margin-top: -2px;\n    height: 5px;\n}"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        216: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `.ace-tree-wrapper {
    height: 100%;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/ace-tree.css"], "names": [], "mappings": "AAAA;IACI,YAAY;AAChB", "sourcesContent": [".ace-tree-wrapper {\n    height: 100%;\n}"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        382: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `.blackbutton {
    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);
    border: 1px solid #042440;
    border-radius: 3px;
    color: #d0e3ce;
    text-shadow: 0;
    height: 27px;
    line-height: 27px;
    padding: 0 11px;
    text-align: center;
    cursor: default;
    font-weight: normal;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.blackbuttonDisabled {
    color: rgba(220, 235, 219, 0.5);
}
.blackbuttonFocus {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;
}
.blackbuttonOver {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;
}
.blackbuttonDown {
    box-shadow: 0 0 3px 2px #343434 inset;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/button.css"], "names": [], "mappings": "AAAA;IACI,gGAAgG;IAChG,wFAAwF;IACxF,yBAAyB;IACzB,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,YAAY;IACZ,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,eAAe;IACf,mBAAmB;IACnB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,+BAA+B;AACnC;AACA;IACI,oIAAoI;AACxI;AACA;IACI,sIAAsI;AAC1I;AACA;IACI,qCAAqC;AACzC", "sourcesContent": [".blackbutton {\n    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);\n    border: 1px solid #042440;\n    border-radius: 3px;\n    color: #d0e3ce;\n    text-shadow: 0;\n    height: 27px;\n    line-height: 27px;\n    padding: 0 11px;\n    text-align: center;\n    cursor: default;\n    font-weight: normal;\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\n}\n.blackbuttonDisabled {\n    color: rgba(220, 235, 219, 0.5);\n}\n.blackbuttonFocus {\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;\n}\n.blackbuttonOver {\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;\n}\n.blackbuttonDown {\n    box-shadow: 0 0 3px 2px #343434 inset;\n}"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        593: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(62);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
            var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
              /* asset import */
              __webpack_require__2(952),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
            ___CSS_LOADER_EXPORT___.push([module2.id, `.black_dropdown {
    display: inline-block;
    position: relative;
    overflow: hidden;
    height: 21px;
    border-radius: 3px;
    border: 1px solid #1c1c1c;
    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);
    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);
    text-shadow: none;
    min-height: 19px !important;
    max-height: 19px !important;
}
.black_dropdown .lbl {
    position: relative;
    overflow: hidden;
    height: 17px;
    padding: 4px 0 0 6px;
    margin: 0 19px 0 0;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    color: #c0dabe;
    line-height: 13px;
    border-right: 1px solid #1c1c1c;
    cursor: default;
    white-space: nowrap;
}
.black_dropdown .button {
    width: 19px;
    border-left: 1px solid #4d4c4d;
    bottom: 0;
    position: absolute;
    top: 0;
    right: 0;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-size: 9px 13px;
    background-position: 4px 4px;
}
.black_dropdownOver {
    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);
}
.black_dropdownDown {
    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/dropdown.css"], "names": [], "mappings": "AAAA;IACI,qBAAqB;IACrB,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,kBAAkB;IAClB,yBAAyB;IACzB,mEAAmE;IACnE,iGAAiG;IACjG,iBAAiB;IACjB,2BAA2B;IAC3B,2BAA2B;AAC/B;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,oBAAoB;IACpB,kBAAkB;IAClB,yCAAyC;IACzC,eAAe;IACf,cAAc;IACd,iBAAiB;IACjB,+BAA+B;IAC/B,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,WAAW;IACX,8BAA8B;IAC9B,SAAS;IACT,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,4BAA4B;IAC5B,yDAAmE;IACnE,yBAAyB;IACzB,4BAA4B;AAChC;AACA;IACI,iEAAiE;AACrE;AACA;IACI,mEAAmE;AACvE", "sourcesContent": [".black_dropdown {\n    display: inline-block;\n    position: relative;\n    overflow: hidden;\n    height: 21px;\n    border-radius: 3px;\n    border: 1px solid #1c1c1c;\n    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);\n    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);\n    text-shadow: none;\n    min-height: 19px !important;\n    max-height: 19px !important;\n}\n.black_dropdown .lbl {\n    position: relative;\n    overflow: hidden;\n    height: 17px;\n    padding: 4px 0 0 6px;\n    margin: 0 19px 0 0;\n    font-family: Arial, Helvetica, sans-serif;\n    font-size: 12px;\n    color: #c0dabe;\n    line-height: 13px;\n    border-right: 1px solid #1c1c1c;\n    cursor: default;\n    white-space: nowrap;\n}\n.black_dropdown .button {\n    width: 19px;\n    border-left: 1px solid #4d4c4d;\n    bottom: 0;\n    position: absolute;\n    top: 0;\n    right: 0;\n    background-repeat: no-repeat;\n    background-image: url(../images/dropdown-dark-glossy/button@1x.png);\n    background-size: 9px 13px;\n    background-position: 4px 4px;\n}\n.black_dropdownOver {\n    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);\n}\n.black_dropdownDown {\n    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);\n}"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        0: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `body {
    font-family: Tahoma, sans-serif;
}

body.disableIframe iframe {pointer-events: none;}

.splitter {
    background: var(--splitter-color);
    z-index:10;
    position: absolute;
}

.splitter-h {
    width: 1px;
    cursor: ew-resize;
}

.splitter-v {
    height: 1px;
    cursor: ns-resize;
    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);
}
.splitter-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.splitter-v div {
    margin-top: -2px;
    height: 5px;
}
.splitter-h:hover {

}
.splitter-v:hover {

}
.splitter:hover {

}
.box {
    overflow: hidden;
}

.menuToolBar {
    display: flex;
    height: 30px;
    background: #787878;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}

.findbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}


.fullScreenParent {overflow: visible}
.fullScreenNode {
    position: fixed!important;
    z-index: 1!important;
}
.fullScreenSibling {
    z-index: 0!important;
}


body {
    overflow: hidden!important;
    width: 100%;
    height: 100%;
}

.consoleCloseBtn {
    background-repeat: no-repeat;
    background-size: 22px 66px;
    cursor: pointer;
    padding-right: 5px;
}

div.consoleCloseBtn:hover {
    color: #35cc95;
}

.buttons {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    z-index: 1000;
    padding: 0px;
    position: absolute;
    right: 3px;
    top: 0px;
    height: 24px;
}

.animateBoxes {
    transition-duration: 0.15s;
    transition-property: top, left, width, height, transform;
    transition-timing-function: cubic-bezier(.10, .10, .25, .90);
}


.animateBoxes * {
    transition-duration: inherit;
    transition-property: top, left, width, height, transform;
    transition-timing-function: inherit;
}


.tabPanel {
    background: whitesmoke;
}

.inheritCursor *{
    cursor: inherit;
}

.panelbar {
    background-color: var(--toolbar-background);
    position: absolute;
    box-sizing: border-box;
}
.panelbar.top, .tabbar {
    border-bottom: 1px solid var(--splitter-color);
    box-sizing: border-box;
}
.panelbar.bottom {
    border-top: 1px solid var(--splitter-color);
}

body {
    --toolbar-background: #f3f3f3;
    --splitter-color: #d0d0d0;
    --hover-background: #eaeaea;
}

.spacer {
    flex: 1
}
.panelbar {
    display: flex;
    align-items: center;
    padding: 4px;
}
.panelbar>* {
    margin: 0 4px
}
.panelbar> button {
    padding: 5px;
}
.panelbar> button, .panelbar> input  {
    border: none;
    color: #333
}
.panelbar> *:active,
.panelbar> *:focus {
    outline: 1px solid lightblue;
    outline-offset: 1px
}
.panelbar> button {
    background: transparent;
    color: #0da6ff;
}
.panelbar> button:hover  {
    background: var(--hover-background);
    color: black
}
.panelbar> button[disabled] {
    pointer-events: none;
    color: gray!important;
}

.ace_editor.ace_listBox {
    background: var(--toolbar-background)!important;
    font-family: inherit;
    border: none;
}


.ace_listBox .ace_ {
    margin-left: 1em;
}
.ace_listBox .ace_header {
    font-weight: bold;
    margin-left: 0;
}

iframe {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/layout.css"], "names": [], "mappings": "AAAA;IACI,+BAA+B;AACnC;;AAEA,2BAA2B,oBAAoB,CAAC;;AAEhD;IACI,iCAAiC;IACjC,UAAU;IACV,kBAAkB;AACtB;;AAEA;IACI,UAAU;IACV,iBAAiB;AACrB;;AAEA;IACI,WAAW;IACX,iBAAiB;IACjB,iDAAiD;AACrD;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;;AAGA,mBAAmB,iBAAiB;AACpC;IACI,yBAAyB;IACzB,oBAAoB;AACxB;AACA;IACI,oBAAoB;AACxB;;;AAGA;IACI,0BAA0B;IAC1B,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,4BAA4B;IAC5B,0BAA0B;IAC1B,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,yBAAyB;IACzB,aAAa;IACb,YAAY;IACZ,kBAAkB;IAClB,UAAU;IACV,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,wDAAwD;IACxD,4DAA4D;AAChE;;;AAGA;IACI,4BAA4B;IAC5B,wDAAwD;IACxD,mCAAmC;AACvC;;;AAGA;IACI,sBAAsB;AAC1B;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,2CAA2C;IAC3C,kBAAkB;IAClB,sBAAsB;AAC1B;AACA;IACI,8CAA8C;IAC9C,sBAAsB;AAC1B;AACA;IACI,2CAA2C;AAC/C;;AAEA;IACI,6BAA6B;IAC7B,yBAAyB;IACzB,2BAA2B;AAC/B;;AAEA;IACI;AACJ;AACA;IACI,aAAa;IACb,mBAAmB;IACnB,YAAY;AAChB;AACA;IACI;AACJ;AACA;IACI,YAAY;AAChB;AACA;IACI,YAAY;IACZ;AACJ;AACA;;IAEI,4BAA4B;IAC5B;AACJ;AACA;IACI,uBAAuB;IACvB,cAAc;AAClB;AACA;IACI,mCAAmC;IACnC;AACJ;AACA;IACI,oBAAoB;IACpB,qBAAqB;AACzB;;AAEA;IACI,+CAA+C;IAC/C,oBAAoB;IACpB,YAAY;AAChB;;;AAGA;IACI,gBAAgB;AACpB;AACA;IACI,iBAAiB;IACjB,cAAc;AAClB;;AAEA;IACI,SAAS;IACT,UAAU;IACV,SAAS;IACT,eAAe;IACf,aAAa;IACb,wBAAwB;AAC5B", "sourcesContent": ["body {\n    font-family: Tahoma, sans-serif;\n}\n\nbody.disableIframe iframe {pointer-events: none;}\n\n.splitter {\n    background: var(--splitter-color);\n    z-index:10;\n    position: absolute;\n}\n\n.splitter-h {\n    width: 1px;\n    cursor: ew-resize;\n}\n\n.splitter-v {\n    height: 1px;\n    cursor: ns-resize;\n    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);\n}\n.splitter-h div {\n    margin-left: -2px;\n    width: 5px;\n    height: 100%\n}\n.splitter-v div {\n    margin-top: -2px;\n    height: 5px;\n}\n.splitter-h:hover {\n\n}\n.splitter-v:hover {\n\n}\n.splitter:hover {\n\n}\n.box {\n    overflow: hidden;\n}\n\n.menuToolBar {\n    display: flex;\n    height: 30px;\n    background: #787878;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n\n.findbar {\n    display:flex;\n    height:30px;\n    background: #665a82;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n\n\n.fullScreenParent {overflow: visible}\n.fullScreenNode {\n    position: fixed!important;\n    z-index: 1!important;\n}\n.fullScreenSibling {\n    z-index: 0!important;\n}\n\n\nbody {\n    overflow: hidden!important;\n    width: 100%;\n    height: 100%;\n}\n\n.consoleCloseBtn {\n    background-repeat: no-repeat;\n    background-size: 22px 66px;\n    cursor: pointer;\n    padding-right: 5px;\n}\n\ndiv.consoleCloseBtn:hover {\n    color: #35cc95;\n}\n\n.buttons {\n    display: flex;\n    align-items: center;\n    justify-content: flex-end;\n    z-index: 1000;\n    padding: 0px;\n    position: absolute;\n    right: 3px;\n    top: 0px;\n    height: 24px;\n}\n\n.animateBoxes {\n    transition-duration: 0.15s;\n    transition-property: top, left, width, height, transform;\n    transition-timing-function: cubic-bezier(.10, .10, .25, .90);\n}\n\n\n.animateBoxes * {\n    transition-duration: inherit;\n    transition-property: top, left, width, height, transform;\n    transition-timing-function: inherit;\n}\n\n\n.tabPanel {\n    background: whitesmoke;\n}\n\n.inheritCursor *{\n    cursor: inherit;\n}\n\n.panelbar {\n    background-color: var(--toolbar-background);\n    position: absolute;\n    box-sizing: border-box;\n}\n.panelbar.top, .tabbar {\n    border-bottom: 1px solid var(--splitter-color);\n    box-sizing: border-box;\n}\n.panelbar.bottom {\n    border-top: 1px solid var(--splitter-color);\n}\n\nbody {\n    --toolbar-background: #f3f3f3;\n    --splitter-color: #d0d0d0;\n    --hover-background: #eaeaea;\n}\n\n.spacer {\n    flex: 1\n}\n.panelbar {\n    display: flex;\n    align-items: center;\n    padding: 4px;\n}\n.panelbar>* {\n    margin: 0 4px\n}\n.panelbar> button {\n    padding: 5px;\n}\n.panelbar> button, .panelbar> input  {\n    border: none;\n    color: #333\n}\n.panelbar> *:active,\n.panelbar> *:focus {\n    outline: 1px solid lightblue;\n    outline-offset: 1px\n}\n.panelbar> button {\n    background: transparent;\n    color: #0da6ff;\n}\n.panelbar> button:hover  {\n    background: var(--hover-background);\n    color: black\n}\n.panelbar> button[disabled] {\n    pointer-events: none;\n    color: gray!important;\n}\n\n.ace_editor.ace_listBox {\n    background: var(--toolbar-background)!important;\n    font-family: inherit;\n    border: none;\n}\n\n\n.ace_listBox .ace_ {\n    margin-left: 1em;\n}\n.ace_listBox .ace_header {\n    font-weight: bold;\n    margin-left: 0;\n}\n\niframe {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font-size: 100%;\n    font: inherit;\n    vertical-align: baseline;\n}"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        807: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(62);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
            var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
              /* asset import */
              __webpack_require__2(784),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_URL_IMPORT_1___ = new URL(
              /* asset import */
              __webpack_require__2(560),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_URL_IMPORT_2___ = new URL(
              /* asset import */
              __webpack_require__2(937),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_URL_IMPORT_3___ = new URL(
              /* asset import */
              __webpack_require__2(147),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
            var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
            var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
            var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
            ___CSS_LOADER_EXPORT___.push([module2.id, `.menuButton {
    height: 100%;
    box-sizing: border-box;
    overflow: visible;
    cursor: default;
    position: relative;
    display: inline-block;
    font-family: Tahoma, Arial;
    font-size: 12px;
    line-height: 14px;
    color: #cecece;
    padding: 4px 7px 0 7px;
    text-shadow: #292a2b 0px 1px 0px;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
}
.menuButtonOver, .menuButton:hover {
    background-color: #333333;
    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    color: #d4d4d4;
}
.menuButton.menuButtonDown {
    font-weight: normal;
    background-color: #494949;
    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    border: 0;
    border-width: 0;
    padding: 4px 7px 0 7px;
    z-index: 100000000;
}
.menuButtonDisabled.menuButton .label {
    color: #999999;
}
.menuButtonIcon {
    padding-left: 24px;
}
.menuButtonIcon .icon {
    display: block;
}
.menuButtonEmpty {
    padding-left: 7px;
}
.menuButtonEmpty .icon {
    left: 0;
    top: 0;
}
.menuButtonDisabled {
    color: gray;
}
.menuButton.btn {
    min-width: 12px;
    font-weight: bold;
    background-position: 2px 50%;
}


.menu {
    margin: -1px 0 0 0;
    padding: 3px 0 3px 0;
    z-index: 10000;
    position: absolute;
    overflow: visible;
    font-family: Tahoma, Arial;
    font-size: 11px;
    line-height: 14px;
    color: #f1f1f1;
    cursor: default;
    display: none;
    border: 1px solid #00040a;
    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);
    background-color: #494949;
    text-shadow: 0px 1px 0px #2c2c2c;
    border-radius: 0;
}
.menu > div.menu_item {
    padding: 3px 16px 5px 23px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}
.menu > div.menu_item.update {
    background-color: #748512;
    font-weight: bold;
    color: #f1f1f1;
    text-shadow: none;
}
.menu > div.menu_item.hover {
    background-color: #262626;
    color: #a0b42a;
}
.menu > div.menu_divider {
    overflow: visible;
    padding: 0;
    font-size: 1px;
    margin: 2px 3px;
    border-top: 1px solid #353535;
    border-bottom: 1px solid #565656;
    height: 0;
}
.menu > div.menu_item > .shortcut {
    right: 15px;
    margin-top: 0px;
    z-index: 10;
    text-align: right;
    padding-left: 15px;
    float: right;
}
.menu > div.submenu > .shortcut {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
    width: 4px;
    height: 7px;
    display: block;
    position: absolute;
    right: 8px;
    margin: 4px 0 0 0;
    z-index: 10;
}
.menu > div.submenu.hover > span {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
}
.menu > div.menu_item.disabled {
    color: #808080;
    text-shadow: none;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.menu > div.menu_item > u {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 3px;
    margin-top: -1px;
}
.menu > div.menu_item > a {
    float: left;
}
.menu > div.menu_item.selected > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.disabled > u {
    opacity: 0.2;
}
.menu > div.menu_item.checked.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}

.menu_searchbox {
    height: auto;
    width: auto;
    border: 1px solid #be1100;
    background-color: #653b13;
    color: white;
    position: absolute;
    font-family: Tahoma, Arial;
    font-size: 12px;
}

.menu-completion-highlight {
    color: #2d69c7;
}
.searchbtn_close {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_3___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}
.searchbtn_close:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.searchbtn_filter {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}

.searchbtn_filter:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.menu_no_result {
    padding: 3px 10px 5px 20px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/menu.css"], "names": [], "mappings": "AAAA;IACI,YAAY;IACZ,sBAAsB;IACtB,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;IACrB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,sBAAsB;IACtB,gCAAgC;IAChC,yBAAyB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,iBAAiB;AAC/F;AACA;IACI,yBAAyB;IACzB,+FAA+F;IAC/F,cAAc;AAClB;AACA;IACI,mBAAmB;IACnB,yBAAyB;IACzB,iGAAiG;IACjG,SAAS;IACT,eAAe;IACf,sBAAsB;IACtB,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,iBAAiB;AACrB;AACA;IACI,OAAO;IACP,MAAM;AACV;AACA;IACI,WAAW;AACf;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,4BAA4B;AAChC;;;AAGA;IACI,kBAAkB;IAClB,oBAAoB;IACpB,cAAc;IACd,kBAAkB;IAClB,iBAAiB;IACjB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,eAAe;IACf,aAAa;IACb,yBAAyB;IACzB,gDAAgD;IAChD,yBAAyB;IACzB,gCAAgC;IAChC,gBAAgB;AACpB;AACA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB;AACA;IACI,yBAAyB;IACzB,iBAAiB;IACjB,cAAc;IACd,iBAAiB;AACrB;AACA;IACI,yBAAyB;IACzB,cAAc;AAClB;AACA;IACI,iBAAiB;IACjB,UAAU;IACV,cAAc;IACd,eAAe;IACf,6BAA6B;IAC7B,gCAAgC;IAChC,SAAS;AACb;AACA;IACI,WAAW;IACX,eAAe;IACf,WAAW;IACX,iBAAiB;IACjB,kBAAkB;IAClB,YAAY;AAChB;AACA;IACI,yEAAoE;IACpE,UAAU;IACV,WAAW;IACX,cAAc;IACd,kBAAkB;IAClB,UAAU;IACV,iBAAiB;IACjB,WAAW;AACf;AACA;IACI,yEAAoE;AACxE;AACA;IACI,cAAc;IACd,iBAAiB;IACjB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,SAAS;IACT,gBAAgB;AACpB;AACA;IACI,WAAW;AACf;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,YAAY;AAChB;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,yBAAyB;IACzB,yBAAyB;IACzB,YAAY;IACZ,kBAAkB;IAClB,0BAA0B;IAC1B,eAAe;AACnB;;AAEA;IACI,cAAc;AAClB;AACA;IACI,mEAA+Q;IAC/Q,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;AACA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,mEAAsD;IACtD,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;;AAEA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB", "sourcesContent": ['.menuButton {\n    height: 100%;\n    box-sizing: border-box;\n    overflow: visible;\n    cursor: default;\n    position: relative;\n    display: inline-block;\n    font-family: Tahoma, Arial;\n    font-size: 12px;\n    line-height: 14px;\n    color: #cecece;\n    padding: 4px 7px 0 7px;\n    text-shadow: #292a2b 0px 1px 0px;\n    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;\n}\n.menuButtonOver, .menuButton:hover {\n    background-color: #333333;\n    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\n    color: #d4d4d4;\n}\n.menuButton.menuButtonDown {\n    font-weight: normal;\n    background-color: #494949;\n    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\n    border: 0;\n    border-width: 0;\n    padding: 4px 7px 0 7px;\n    z-index: 100000000;\n}\n.menuButtonDisabled.menuButton .label {\n    color: #999999;\n}\n.menuButtonIcon {\n    padding-left: 24px;\n}\n.menuButtonIcon .icon {\n    display: block;\n}\n.menuButtonEmpty {\n    padding-left: 7px;\n}\n.menuButtonEmpty .icon {\n    left: 0;\n    top: 0;\n}\n.menuButtonDisabled {\n    color: gray;\n}\n.menuButton.btn {\n    min-width: 12px;\n    font-weight: bold;\n    background-position: 2px 50%;\n}\n\n\n.menu {\n    margin: -1px 0 0 0;\n    padding: 3px 0 3px 0;\n    z-index: 10000;\n    position: absolute;\n    overflow: visible;\n    font-family: Tahoma, Arial;\n    font-size: 11px;\n    line-height: 14px;\n    color: #f1f1f1;\n    cursor: default;\n    display: none;\n    border: 1px solid #00040a;\n    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);\n    background-color: #494949;\n    text-shadow: 0px 1px 0px #2c2c2c;\n    border-radius: 0;\n}\n.menu > div.menu_item {\n    padding: 3px 16px 5px 23px;\n    white-space: nowrap;\n    cursor: default;\n    z-index: 1100000;\n    height: 13px;\n}\n.menu > div.menu_item.update {\n    background-color: #748512;\n    font-weight: bold;\n    color: #f1f1f1;\n    text-shadow: none;\n}\n.menu > div.menu_item.hover {\n    background-color: #262626;\n    color: #a0b42a;\n}\n.menu > div.menu_divider {\n    overflow: visible;\n    padding: 0;\n    font-size: 1px;\n    margin: 2px 3px;\n    border-top: 1px solid #353535;\n    border-bottom: 1px solid #565656;\n    height: 0;\n}\n.menu > div.menu_item > .shortcut {\n    right: 15px;\n    margin-top: 0px;\n    z-index: 10;\n    text-align: right;\n    padding-left: 15px;\n    float: right;\n}\n.menu > div.submenu > .shortcut {\n    background: url("../images/submenu_arrow.gif") no-repeat right -15px;\n    width: 4px;\n    height: 7px;\n    display: block;\n    position: absolute;\n    right: 8px;\n    margin: 4px 0 0 0;\n    z-index: 10;\n}\n.menu > div.submenu.hover > span {\n    background: url("../images/submenu_arrow.gif") no-repeat right -15px;\n}\n.menu > div.menu_item.disabled {\n    color: #808080;\n    text-shadow: none;\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\n}\n.menu > div.menu_item > u {\n    width: 16px;\n    height: 16px;\n    position: absolute;\n    left: 3px;\n    margin-top: -1px;\n}\n.menu > div.menu_item > a {\n    float: left;\n}\n.menu > div.menu_item.selected > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.selected:hover > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.checked > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.checked:hover > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.disabled > u {\n    opacity: 0.2;\n}\n.menu > div.menu_item.checked.disabled > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.selected.disabled > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n\n.menu_searchbox {\n    height: auto;\n    width: auto;\n    border: 1px solid #be1100;\n    background-color: #653b13;\n    color: white;\n    position: absolute;\n    font-family: Tahoma, Arial;\n    font-size: 12px;\n}\n\n.menu-completion-highlight {\n    color: #2d69c7;\n}\n.searchbtn_close {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\n    border-radius: 50%;\n    border: 0 none;\n    color: #656565;\n    cursor: pointer;\n    font: 16px/16px Arial;\n    padding: 0;\n    height: 14px;\n    width: 14px; \n    display: inline-block;\n}\n.searchbtn_close:hover {\n    background-color: #656565;\n    background-position: 50% 100%;\n    color: white;\n}\n\n.searchbtn_filter {\n    background: url("../images/check.gif") no-repeat 50% 0;\n    border-radius: 50%;\n    border: 0 none;\n    color: #656565;\n    cursor: pointer;\n    font: 16px/16px Arial;\n    padding: 0;\n    height: 14px;\n    width: 14px; \n    display: inline-block;\n}\n\n.searchbtn_filter:hover {\n    background-color: #656565;\n    background-position: 50% 100%;\n    color: white;\n}\n\n.menu_no_result {\n    padding: 3px 10px 5px 20px;\n    white-space: nowrap;\n    cursor: default;\n    z-index: 1100000;\n    height: 13px;\n}'], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        174: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `.panelbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}
.panelbar.vertical {
}

.panelbar.vertical .panelButton {
}
.panelbar.vertical.right .panelButton {
}

.panelButton {
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    transition: 0.5s background-color;
    border-left: #b3b3b3 solid 1px;
    user-select: none;
    height: 30px;
    width: 30px;
    position: absolute;
}
.panelButton:hover {
    background: #e0e0e0;
    border-radius: 10px 10px 0 0;
}
.panelButton.selected {
    background-color: #e7e7e7;
}
.panelButton.active {
    background-color: whitesmoke!important;
    border-radius: 10px 10px 0 0;
}
.panelTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
`, "", { "version": 3, "sources": ["webpack://./assets/styles/panel.css"], "names": [], "mappings": "AAAA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;IACI,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,iCAAiC;IACjC,8BAA8B;IAC9B,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,4BAA4B;AAChC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,sCAAsC;IACtC,4BAA4B;AAChC;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB", "sourcesContent": [".panelbar {\n    display:flex;\n    height:30px;\n    background: #665a82;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n.panelbar.vertical {\n}\n\n.panelbar.vertical .panelButton {\n}\n.panelbar.vertical.right .panelButton {\n}\n\n.panelButton {\n    cursor: default;\n    display:flex;\n    align-items: center;\n    padding: 0 10px;\n    box-sizing: border-box;\n    transition: 0.5s background-color;\n    border-left: #b3b3b3 solid 1px;\n    user-select: none;\n    height: 30px;\n    width: 30px;\n    position: absolute;\n}\n.panelButton:hover {\n    background: #e0e0e0;\n    border-radius: 10px 10px 0 0;\n}\n.panelButton.selected {\n    background-color: #e7e7e7;\n}\n.panelButton.active {\n    background-color: whitesmoke!important;\n    border-radius: 10px 10px 0 0;\n}\n.panelTitle {\n    flex: 1;\n    padding: 0 2px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n"], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        915: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(62);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
            var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
              /* asset import */
              __webpack_require__2(553),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_URL_IMPORT_1___ = new URL(
              /* asset import */
              __webpack_require__2(592),
              __webpack_require__2.b
            );
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
            var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
            ___CSS_LOADER_EXPORT___.push([module2.id, `.cboffline {
    width: 55px;
    height: 21px;
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat 0 -21px;
    display: inline-block;
}
.cbofflineDown {
    background-position: 0 0px;
}
.cbofflineChecked {
    background-position: 0 0px;
}

.checkbox {
    display: inline-block;
    width: 16px;
    height: 17px;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
    background-size: 16px 136px;
    background-position: 0 0;
}

.checkboxOver {
    background-position: 0 -17px;
}

.checkboxDown {
    background-position: 0 -34px;
}

.checkboxChecked {
    background-position: 0 -51px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/switcher.css"], "names": [], "mappings": "AAAA;IACI,WAAW;IACX,YAAY;IACZ,qEAAuD;IACvD,qBAAqB;AACzB;AACA;IACI,0BAA0B;AAC9B;AACA;IACI,0BAA0B;AAC9B;;AAEA;IACI,qBAAqB;IACrB,WAAW;IACX,YAAY;IACZ,4BAA4B;IAC5B,yDAAwD;IACxD,2BAA2B;IAC3B,wBAAwB;AAC5B;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC", "sourcesContent": ['.cboffline {\n    width: 55px;\n    height: 21px;\n    background: url("../images/sync.png") no-repeat 0 -21px;\n    display: inline-block;\n}\n.cbofflineDown {\n    background-position: 0 0px;\n}\n.cbofflineChecked {\n    background-position: 0 0px;\n}\n\n.checkbox {\n    display: inline-block;\n    width: 16px;\n    height: 17px;\n    background-repeat: no-repeat;\n    background-image: url("../images/checkbox_black@1x.png");\n    background-size: 16px 136px;\n    background-position: 0 0;\n}\n\n.checkboxOver {\n    background-position: 0 -17px;\n}\n\n.checkboxDown {\n    background-position: 0 -34px;\n}\n\n.checkboxChecked {\n    background-position: 0 -51px;\n}'], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        129: (
          /***/
          (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              /* harmony export */
              A: () => __WEBPACK_DEFAULT_EXPORT__
              /* harmony export */
            });
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(1);
            var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(935);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, `.tabContainer {
    align-items: stretch;
    height: 30px;
}

.tabPlusButton {
    --color: #ababab;
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 8px;
    color: transparent;
}
.tabPlusButton:after {
    content: "";
    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);
        position: absolute;
    width: 12px;
    height: 12px;
    top: 8px;
}
.tabPlusButton:hover:after {
    --color: #35cc95

}

.tabPlusButton:active {
    color: darkgreen
}

.tabScroller {
    overflow: hidden;
    position: relative;
}
.tab.changed>.tabCloseButton {
    background: #afafaf;
    border: transparent;
}

.tabbar {
    display:flex;
    background: var(--toolbar-background);
    color: #333;
    align-items: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
}
.tab {
    font-size: 12px;
    height: 100%;
    /*min-width: 100px;*/
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    background: var(--toolbar-background);
    border-left: transparent solid 1px;
    border-right: transparent solid 1px;
    user-select: none;
    position: absolute;
}

.tab.selected.active:after {
    content: "";
    border-bottom: 2px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}
.tab.focused.active:after {
    content: "";
    border-bottom: 3px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}

.tab.scrolledLeft {
    border-color: var(--splitter-color);
    box-shadow: 0px 0px 2px 0px #d0d0d0;
}
.tabIcon {
    display: none;
}

.tabLeftOverflow {

}
.tabRightOverflow {

}
.tabDragging {
    display: flex;
    box-sizing: border-box;
    transition: 0.5s background-color;
    user-select: none;
    z-index: 100000;
    pointer-events: none;
    position: absolute;
}

.tab:hover {
    background: var(--hover-background);
}
.tab.selected {
    background-color: #e7e7e7;
}
.tab.active {
    background-color: whitesmoke;
}
 .tabDragging > .tab.active {
    background-color: #e7e7e7;
}

.tabCloseButton {
    transform: rotate(45deg);
    width: 11px;
    height: 11px;
    display: inline-block;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0;
    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);
}


.tabCloseButton:hover {
    background-color: #ababab;
    border: 1px solid #ababab;
    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);

}

.tab.active .tabCloseButton,
.tab:hover .tabCloseButton,
.tabCloseButton.changed {
    opacity: 1
}

.tabIcon {
    color: yellow;
    padding: 0 4px 0 0;
}
.tab.active .tabIcon {
    color: orange
}
.tabTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}



.tabbar.vertical .tab {
    transform: rotate(180deg);
}


.split-area {
    position: absolute;
    background: rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0, 0, 0, 0.2);
    z-index: 100000;
    pointer-events: none;
    box-sizing: border-box;
    cursor: default;
}

.dark.split-area {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;
    outline: 1px solid black;
}

.tab-editor {
    position: absolute;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/tab.css"], "names": [], "mappings": "AAAA;IACI,oBAAoB;IACpB,YAAY;AAChB;;AAEA;IACI,gBAAgB;IAChB,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,YAAY;IACZ,kBAAkB;AACtB;AACA;IACI,WAAW;IACX;uGACmG;QAC/F,kBAAkB;IACtB,WAAW;IACX,YAAY;IACZ,QAAQ;AACZ;AACA;IACI;;AAEJ;;AAEA;IACI;AACJ;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,mBAAmB;AACvB;;AAEA;IACI,YAAY;IACZ,qCAAqC;IACrC,WAAW;IACX,oBAAoB;IACpB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,YAAY;IACZ,oBAAoB;IACpB,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,qCAAqC;IACrC,kCAAkC;IAClC,mCAAmC;IACnC,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;AACA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;IACnC,mCAAmC;AACvC;AACA;IACI,aAAa;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;IACI,aAAa;IACb,sBAAsB;IACtB,iCAAiC;IACjC,iBAAiB;IACjB,eAAe;IACf,oBAAoB;IACpB,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;AACvC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,4BAA4B;AAChC;CACC;IACG,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;IACxB,WAAW;IACX,YAAY;IACZ,qBAAqB;IACrB,mBAAmB;IACnB,eAAe;IACf,UAAU;IACV;6FACyF;AAC7F;;;AAGA;IACI,yBAAyB;IACzB,yBAAyB;IACzB;uFACmF;;AAEvF;;AAEA;;;IAGI;AACJ;;AAEA;IACI,aAAa;IACb,kBAAkB;AACtB;AACA;IACI;AACJ;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;;;AAIA;IACI,yBAAyB;AAC7B;;;AAGA;IACI,kBAAkB;IAClB,+BAA+B;IAC/B,oCAAoC;IACpC,eAAe;IACf,oBAAoB;IACpB,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,qCAAqC;IACrC,0CAA0C;IAC1C,qDAAqD;IACrD,wBAAwB;AAC5B;;AAEA;IACI,kBAAkB;AACtB", "sourcesContent": ['.tabContainer {\n    align-items: stretch;\n    height: 30px;\n}\n\n.tabPlusButton {\n    --color: #ababab;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    padding: 8px;\n    color: transparent;\n}\n.tabPlusButton:after {\n    content: "";\n    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);\n        position: absolute;\n    width: 12px;\n    height: 12px;\n    top: 8px;\n}\n.tabPlusButton:hover:after {\n    --color: #35cc95\n\n}\n\n.tabPlusButton:active {\n    color: darkgreen\n}\n\n.tabScroller {\n    overflow: hidden;\n    position: relative;\n}\n.tab.changed>.tabCloseButton {\n    background: #afafaf;\n    border: transparent;\n}\n\n.tabbar {\n    display:flex;\n    background: var(--toolbar-background);\n    color: #333;\n    align-items: stretch;\n    overflow: hidden;\n    position: absolute;\n    user-select: none;\n}\n.tab {\n    font-size: 12px;\n    height: 100%;\n    /*min-width: 100px;*/\n    cursor: default;\n    display:flex;\n    align-items: center;\n    padding: 0 10px;\n    box-sizing: border-box;\n    background: var(--toolbar-background);\n    border-left: transparent solid 1px;\n    border-right: transparent solid 1px;\n    user-select: none;\n    position: absolute;\n}\n\n.tab.selected.active:after {\n    content: "";\n    border-bottom: 2px solid rgb(127, 127, 191);\n    width: calc(100% - 22px);\n    bottom: 0;\n    position: absolute;\n}\n.tab.focused.active:after {\n    content: "";\n    border-bottom: 3px solid rgb(127, 127, 191);\n    width: calc(100% - 22px);\n    bottom: 0;\n    position: absolute;\n}\n\n.tab.scrolledLeft {\n    border-color: var(--splitter-color);\n    box-shadow: 0px 0px 2px 0px #d0d0d0;\n}\n.tabIcon {\n    display: none;\n}\n\n.tabLeftOverflow {\n\n}\n.tabRightOverflow {\n\n}\n.tabDragging {\n    display: flex;\n    box-sizing: border-box;\n    transition: 0.5s background-color;\n    user-select: none;\n    z-index: 100000;\n    pointer-events: none;\n    position: absolute;\n}\n\n.tab:hover {\n    background: var(--hover-background);\n}\n.tab.selected {\n    background-color: #e7e7e7;\n}\n.tab.active {\n    background-color: whitesmoke;\n}\n .tabDragging > .tab.active {\n    background-color: #e7e7e7;\n}\n\n.tabCloseButton {\n    transform: rotate(45deg);\n    width: 11px;\n    height: 11px;\n    display: inline-block;\n    border-radius: 10px;\n    cursor: pointer;\n    opacity: 0;\n    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);\n}\n\n\n.tabCloseButton:hover {\n    background-color: #ababab;\n    border: 1px solid #ababab;\n    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);\n\n}\n\n.tab.active .tabCloseButton,\n.tab:hover .tabCloseButton,\n.tabCloseButton.changed {\n    opacity: 1\n}\n\n.tabIcon {\n    color: yellow;\n    padding: 0 4px 0 0;\n}\n.tab.active .tabIcon {\n    color: orange\n}\n.tabTitle {\n    flex: 1;\n    padding: 0 2px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n\n\n.tabbar.vertical .tab {\n    transform: rotate(180deg);\n}\n\n\n.split-area {\n    position: absolute;\n    background: rgba(0, 0, 0, 0.05);\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    z-index: 100000;\n    pointer-events: none;\n    box-sizing: border-box;\n    cursor: default;\n}\n\n.dark.split-area {\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid rgba(255, 255, 255, 0.3);\n    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;\n    outline: 1px solid black;\n}\n\n.tab-editor {\n    position: absolute;\n}'], "sourceRoot": "" }]);
            const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
          }
        ),
        /***/
        935: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = function(cssWithMappingToString) {
              var list = [];
              list.toString = function toString() {
                return this.map(function(item) {
                  var content = "";
                  var needLayer = typeof item[5] !== "undefined";
                  if (item[4]) {
                    content += "@supports (".concat(item[4], ") {");
                  }
                  if (item[2]) {
                    content += "@media ".concat(item[2], " {");
                  }
                  if (needLayer) {
                    content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
                  }
                  content += cssWithMappingToString(item);
                  if (needLayer) {
                    content += "}";
                  }
                  if (item[2]) {
                    content += "}";
                  }
                  if (item[4]) {
                    content += "}";
                  }
                  return content;
                }).join("");
              };
              list.i = function i(modules, media, dedupe, supports, layer) {
                if (typeof modules === "string") {
                  modules = [[null, modules, void 0]];
                }
                var alreadyImportedModules = {};
                if (dedupe) {
                  for (var k = 0; k < this.length; k++) {
                    var id = this[k][0];
                    if (id != null) {
                      alreadyImportedModules[id] = true;
                    }
                  }
                }
                for (var _k = 0; _k < modules.length; _k++) {
                  var item = [].concat(modules[_k]);
                  if (dedupe && alreadyImportedModules[item[0]]) {
                    continue;
                  }
                  if (typeof layer !== "undefined") {
                    if (typeof item[5] === "undefined") {
                      item[5] = layer;
                    } else {
                      item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
                      item[5] = layer;
                    }
                  }
                  if (media) {
                    if (!item[2]) {
                      item[2] = media;
                    } else {
                      item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
                      item[2] = media;
                    }
                  }
                  if (supports) {
                    if (!item[4]) {
                      item[4] = "".concat(supports);
                    } else {
                      item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
                      item[4] = supports;
                    }
                  }
                  list.push(item);
                }
              };
              return list;
            };
          }
        ),
        /***/
        62: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = function(url, options) {
              if (!options) {
                options = {};
              }
              if (!url) {
                return url;
              }
              url = String(url.__esModule ? url.default : url);
              if (/^['"].*['"]$/.test(url)) {
                url = url.slice(1, -1);
              }
              if (options.hash) {
                url += options.hash;
              }
              if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
                return '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"');
              }
              return url;
            };
          }
        ),
        /***/
        1: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = function(item) {
              var content = item[1];
              var cssMapping = item[3];
              if (!cssMapping) {
                return content;
              }
              if (typeof btoa === "function") {
                var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
                var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
                var sourceMapping = "/*# ".concat(data, " */");
                return [content].concat([sourceMapping]).join("\n");
              }
              return [content].join("\n");
            };
          }
        ),
        /***/
        532: (
          /***/
          function(module2) {
            (function webpackUniversalModuleDefinition2(root, factory) {
              if (true)
                module2.exports = factory();
              else { var i, a; }
            })(this, () => {
              return (
                /******/
                (() => {
                  var __webpack_modules__2 = {
                    /***/
                    217: (
                      /***/
                      (module22) => {
                        "use strict";
                        var $cancelT;
                        module22.exports = {
                          lineMode: false,
                          pasteCancelled: function() {
                            if ($cancelT && $cancelT > Date.now() - 50)
                              return true;
                            return $cancelT = false;
                          },
                          cancel: function() {
                            $cancelT = Date.now();
                          }
                        };
                      }
                    ),
                    /***/
                    379: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var oop = __webpack_require__2(645);
                        var MultiHashHandler = __webpack_require__2(50).O;
                        var EventEmitter = __webpack_require__2(366).b;
                        var CommandManager = function(platform, commands) {
                          MultiHashHandler.call(this, commands, platform);
                          this.byName = this.commands;
                          this.setDefaultHandler("exec", function(e) {
                            if (!e.args) {
                              return e.command.exec(e.editor, {}, e.event, true);
                            }
                            return e.command.exec(e.editor, e.args, e.event, false);
                          });
                        };
                        oop.inherits(CommandManager, MultiHashHandler);
                        (function() {
                          oop.implement(this, EventEmitter);
                          this.exec = function(command, editor, args) {
                            if (Array.isArray(command)) {
                              for (var i = command.length; i--; ) {
                                if (this.exec(command[i], editor, args))
                                  return true;
                              }
                              return false;
                            }
                            if (typeof command === "string")
                              command = this.commands[command];
                            if (!command)
                              return false;
                            if (editor && editor.$readOnly && !command.readOnly)
                              return false;
                            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
                              return false;
                            var e = { editor, command, args };
                            e.returnValue = this._emit("exec", e);
                            this._signal("afterExec", e);
                            return e.returnValue === false ? false : true;
                          };
                          this.toggleRecording = function(editor) {
                            if (this.$inReplay)
                              return;
                            editor && editor._emit("changeStatus");
                            if (this.recording) {
                              this.macro.pop();
                              this.off("exec", this.$addCommandToMacro);
                              if (!this.macro.length)
                                this.macro = this.oldMacro;
                              return this.recording = false;
                            }
                            if (!this.$addCommandToMacro) {
                              this.$addCommandToMacro = function(e) {
                                this.macro.push([e.command, e.args]);
                              }.bind(this);
                            }
                            this.oldMacro = this.macro;
                            this.macro = [];
                            this.on("exec", this.$addCommandToMacro);
                            return this.recording = true;
                          };
                          this.replay = function(editor) {
                            if (this.$inReplay || !this.macro)
                              return;
                            if (this.recording)
                              return this.toggleRecording(editor);
                            try {
                              this.$inReplay = true;
                              this.macro.forEach(function(x) {
                                if (typeof x == "string")
                                  this.exec(x, editor);
                                else
                                  this.exec(x[0], editor, x[1]);
                              }, this);
                            } finally {
                              this.$inReplay = false;
                            }
                          };
                          this.trimMacro = function(m) {
                            return m.map(function(x) {
                              if (typeof x[0] != "string")
                                x[0] = x[0].name;
                              if (!x[1])
                                x = x[0];
                              return x;
                            });
                          };
                        }).call(CommandManager.prototype);
                        exports2.F = CommandManager;
                      }
                    ),
                    /***/
                    50: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var __webpack_unused_export__;
                        var keyUtil = __webpack_require__2(451);
                        var useragent = __webpack_require__2(943);
                        var KEY_MODS = keyUtil.KEY_MODS;
                        function HashHandler(config, platform) {
                          this.platform = platform || (useragent.isMac ? "mac" : "win");
                          this.commands = {};
                          this.commandKeyBinding = {};
                          this.addCommands(config);
                          this.$singleCommand = true;
                        }
                        function MultiHashHandler(config, platform) {
                          HashHandler.call(this, config, platform);
                          this.$singleCommand = false;
                        }
                        MultiHashHandler.prototype = HashHandler.prototype;
                        (function() {
                          this.addCommand = function(command) {
                            if (this.commands[command.name])
                              this.removeCommand(command);
                            this.commands[command.name] = command;
                            if (command.bindKey)
                              this._buildKeyHash(command);
                          };
                          this.removeCommand = function(command, keepCommand) {
                            var name = command && (typeof command === "string" ? command : command.name);
                            command = this.commands[name];
                            if (!keepCommand)
                              delete this.commands[name];
                            var ckb = this.commandKeyBinding;
                            for (var keyId in ckb) {
                              var cmdGroup = ckb[keyId];
                              if (cmdGroup == command) {
                                delete ckb[keyId];
                              } else if (Array.isArray(cmdGroup)) {
                                var i = cmdGroup.indexOf(command);
                                if (i != -1) {
                                  cmdGroup.splice(i, 1);
                                  if (cmdGroup.length == 1)
                                    ckb[keyId] = cmdGroup[0];
                                }
                              }
                            }
                          };
                          this.bindKey = function(key, command, position) {
                            if (typeof key == "object" && key) {
                              if (position == void 0)
                                position = key.position;
                              key = key[this.platform];
                            }
                            if (!key)
                              return;
                            if (typeof command == "function")
                              return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
                            key.split("|").forEach(function(keyPart) {
                              var chain = "";
                              if (keyPart.indexOf(" ") != -1) {
                                var parts = keyPart.split(/\s+/);
                                keyPart = parts.pop();
                                parts.forEach(function(keyPart2) {
                                  var binding2 = this.parseKeys(keyPart2);
                                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                                  chain += (chain ? " " : "") + id2;
                                  this._addCommandToBinding(chain, "chainKeys");
                                }, this);
                                chain += " ";
                              }
                              var binding = this.parseKeys(keyPart);
                              var id = KEY_MODS[binding.hashId] + binding.key;
                              this._addCommandToBinding(chain + id, command, position);
                            }, this);
                          };
                          function getPosition(command) {
                            return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
                          }
                          this._addCommandToBinding = function(keyId, command, position) {
                            var ckb = this.commandKeyBinding, i;
                            if (!command) {
                              delete ckb[keyId];
                            } else if (!ckb[keyId] || this.$singleCommand) {
                              ckb[keyId] = command;
                            } else {
                              if (!Array.isArray(ckb[keyId])) {
                                ckb[keyId] = [ckb[keyId]];
                              } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                                ckb[keyId].splice(i, 1);
                              }
                              if (typeof position != "number") {
                                position = getPosition(command);
                              }
                              var commands = ckb[keyId];
                              for (i = 0; i < commands.length; i++) {
                                var other = commands[i];
                                var otherPos = getPosition(other);
                                if (otherPos > position)
                                  break;
                              }
                              commands.splice(i, 0, command);
                            }
                          };
                          this.addCommands = function(commands) {
                            commands && Object.keys(commands).forEach(function(name) {
                              var command = commands[name];
                              if (!command)
                                return;
                              if (typeof command === "string")
                                return this.bindKey(command, name);
                              if (typeof command === "function")
                                command = { exec: command };
                              if (typeof command !== "object")
                                return;
                              if (!command.name)
                                command.name = name;
                              this.addCommand(command);
                            }, this);
                          };
                          this.removeCommands = function(commands) {
                            Object.keys(commands).forEach(function(name) {
                              this.removeCommand(commands[name]);
                            }, this);
                          };
                          this.bindKeys = function(keyList) {
                            Object.keys(keyList).forEach(function(key) {
                              this.bindKey(key, keyList[key]);
                            }, this);
                          };
                          this._buildKeyHash = function(command) {
                            this.bindKey(command.bindKey, command);
                          };
                          this.parseKeys = function(keys) {
                            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
                              return x;
                            });
                            var key = parts.pop();
                            var keyCode = keyUtil[key];
                            if (keyUtil.FUNCTION_KEYS[keyCode])
                              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
                            else if (!parts.length)
                              return { key, hashId: -1 };
                            else if (parts.length == 1 && parts[0] == "shift")
                              return { key: key.toUpperCase(), hashId: -1 };
                            var hashId = 0;
                            for (var i = parts.length; i--; ) {
                              var modifier = keyUtil.KEY_MODS[parts[i]];
                              if (modifier == null) {
                                if (typeof console != "undefined")
                                  console.error("invalid modifier " + parts[i] + " in " + keys);
                                return false;
                              }
                              hashId |= modifier;
                            }
                            return { key, hashId };
                          };
                          this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                            var key = KEY_MODS[hashId] + keyString;
                            return this.commandKeyBinding[key];
                          };
                          this.handleKeyboard = function(data, hashId, keyString, keyCode) {
                            if (keyCode < 0)
                              return;
                            var key = KEY_MODS[hashId] + keyString;
                            var command = this.commandKeyBinding[key];
                            if (data.$keyChain) {
                              data.$keyChain += " " + key;
                              command = this.commandKeyBinding[data.$keyChain] || command;
                            }
                            if (command) {
                              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                                data.$keyChain = data.$keyChain || key;
                                return { command: "null" };
                              }
                            }
                            if (data.$keyChain) {
                              if ((!hashId || hashId == 4) && keyString.length == 1)
                                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
                              else if (hashId == -1 || keyCode > 0)
                                data.$keyChain = "";
                            }
                            return { command };
                          };
                          this.getStatusText = function(editor, data) {
                            return data.$keyChain || "";
                          };
                        }).call(HashHandler.prototype);
                        __webpack_unused_export__ = HashHandler;
                        exports2.O = MultiHashHandler;
                      }
                    ),
                    /***/
                    957: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var keyUtil = __webpack_require__2(451);
                        var event = __webpack_require__2(631);
                        var KeyBinding = function(editor) {
                          this.$editor = editor;
                          this.$data = { editor };
                          this.$handlers = [];
                          this.setDefaultHandler(editor.commands);
                        };
                        (function() {
                          this.setDefaultHandler = function(kb) {
                            this.removeKeyboardHandler(this.$defaultHandler);
                            this.$defaultHandler = kb;
                            this.addKeyboardHandler(kb, 0);
                          };
                          this.setKeyboardHandler = function(kb) {
                            var h = this.$handlers;
                            if (h[h.length - 1] == kb)
                              return;
                            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                              this.removeKeyboardHandler(h[h.length - 1]);
                            this.addKeyboardHandler(kb, 1);
                          };
                          this.addKeyboardHandler = function(kb, pos) {
                            if (!kb)
                              return;
                            if (typeof kb == "function" && !kb.handleKeyboard)
                              kb.handleKeyboard = kb;
                            var i = this.$handlers.indexOf(kb);
                            if (i != -1)
                              this.$handlers.splice(i, 1);
                            if (pos == void 0)
                              this.$handlers.push(kb);
                            else
                              this.$handlers.splice(pos, 0, kb);
                            if (i == -1 && kb.attach)
                              kb.attach(this.$editor);
                          };
                          this.removeKeyboardHandler = function(kb) {
                            var i = this.$handlers.indexOf(kb);
                            if (i == -1)
                              return false;
                            this.$handlers.splice(i, 1);
                            kb.detach && kb.detach(this.$editor);
                            return true;
                          };
                          this.getKeyboardHandler = function() {
                            return this.$handlers[this.$handlers.length - 1];
                          };
                          this.getStatusText = function() {
                            var data = this.$data;
                            var editor = data.editor;
                            return this.$handlers.map(function(h) {
                              return h.getStatusText && h.getStatusText(editor, data) || "";
                            }).filter(Boolean).join(" ");
                          };
                          this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
                            var toExecute;
                            var success = false;
                            var commands = this.$editor.commands;
                            for (var i = this.$handlers.length; i--; ) {
                              toExecute = this.$handlers[i].handleKeyboard(
                                this.$data,
                                hashId,
                                keyString,
                                keyCode,
                                e
                              );
                              if (!toExecute || !toExecute.command)
                                continue;
                              if (toExecute.command == "null") {
                                success = true;
                              } else {
                                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                              }
                              if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                                event.stopEvent(e);
                              }
                              if (success)
                                break;
                            }
                            if (!success && hashId == -1) {
                              toExecute = { command: "insertstring" };
                              success = commands.exec("insertstring", this.$editor, keyString);
                            }
                            if (success && this.$editor._signal)
                              this.$editor._signal("keyboardActivity", toExecute);
                            return success;
                          };
                          this.onCommandKey = function(e, hashId, keyCode) {
                            var keyString = keyUtil.keyCodeToString(keyCode);
                            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                          };
                          this.onTextInput = function(text) {
                            return this.$callKeyboardHandlers(-1, text);
                          };
                        }).call(KeyBinding.prototype);
                        exports2.$ = KeyBinding;
                      }
                    ),
                    /***/
                    984: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var __webpack_unused_export__;
                        var event = __webpack_require__2(631);
                        var useragent = __webpack_require__2(943);
                        var dom = __webpack_require__2(435);
                        var lang = __webpack_require__2(955);
                        var clipboard = __webpack_require__2(217);
                        var BROKEN_SETDATA = useragent.isChrome < 18;
                        var USE_IE_MIME_TYPE = useragent.isIE;
                        var HAS_FOCUS_ARGS = useragent.isChrome > 63;
                        var MAX_LINE_LENGTH = 400;
                        var KEYS = __webpack_require__2(451);
                        var MODS = KEYS.KEY_MODS;
                        var isIOS = useragent.isIOS;
                        var valueResetRegex = isIOS ? /\s/ : /\n/;
                        var isMobile = useragent.isMobile;
                        var TextInput = function(parentNode, host) {
                          var text = dom.createElement("textarea");
                          text.className = "ace_text-input";
                          text.setAttribute("wrap", "off");
                          text.setAttribute("autocorrect", "off");
                          text.setAttribute("autocapitalize", "off");
                          text.setAttribute("spellcheck", false);
                          text.style.opacity = "0";
                          parentNode.insertBefore(text, parentNode.firstChild);
                          var copied = false;
                          var pasted = false;
                          var inComposition = false;
                          var sendingText = false;
                          var tempStyle = "";
                          if (!isMobile)
                            text.style.fontSize = "1px";
                          var commandMode = false;
                          var ignoreFocusEvents = false;
                          var lastValue = "";
                          var lastSelectionStart = 0;
                          var lastSelectionEnd = 0;
                          var lastRestoreEnd = 0;
                          try {
                            var isFocused = document.activeElement === text;
                          } catch (e) {
                          }
                          this.setAriaOptions = function(options) {
                            if (options.activeDescendant) {
                              text.setAttribute("aria-haspopup", "true");
                              text.setAttribute("aria-autocomplete", "list");
                              text.setAttribute("aria-activedescendant", options.activeDescendant);
                            } else {
                              text.setAttribute("aria-haspopup", "false");
                              text.setAttribute("aria-autocomplete", "both");
                              text.removeAttribute("aria-activedescendant");
                            }
                            if (options.role) {
                              text.setAttribute("role", options.role);
                            }
                          };
                          this.setAriaOptions({ role: "textbox" });
                          event.addListener(text, "blur", function(e) {
                            if (ignoreFocusEvents)
                              return;
                            host.onBlur(e);
                            isFocused = false;
                          }, host);
                          event.addListener(text, "focus", function(e) {
                            if (ignoreFocusEvents)
                              return;
                            isFocused = true;
                            if (useragent.isEdge) {
                              try {
                                if (!document.hasFocus())
                                  return;
                              } catch (e2) {
                              }
                            }
                            host.onFocus(e);
                            if (useragent.isEdge)
                              setTimeout(resetSelection);
                            else
                              resetSelection();
                          }, host);
                          this.$focusScroll = false;
                          this.focus = function() {
                            if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
                              return text.focus({ preventScroll: true });
                            var top = text.style.top;
                            text.style.position = "fixed";
                            text.style.top = "0px";
                            try {
                              var isTransformed = text.getBoundingClientRect().top != 0;
                            } catch (e) {
                              return;
                            }
                            var ancestors = [];
                            if (isTransformed) {
                              var t = text.parentElement;
                              while (t && t.nodeType == 1) {
                                ancestors.push(t);
                                t.setAttribute("ace_nocontext", true);
                                if (!t.parentElement && t.getRootNode)
                                  t = t.getRootNode().host;
                                else
                                  t = t.parentElement;
                              }
                            }
                            text.focus({ preventScroll: true });
                            if (isTransformed) {
                              ancestors.forEach(function(p) {
                                p.removeAttribute("ace_nocontext");
                              });
                            }
                            setTimeout(function() {
                              text.style.position = "";
                              if (text.style.top == "0px")
                                text.style.top = top;
                            }, 0);
                          };
                          this.blur = function() {
                            text.blur();
                          };
                          this.isFocused = function() {
                            return isFocused;
                          };
                          host.on("beforeEndOperation", function() {
                            var curOp = host.curOp;
                            var commandName = curOp && curOp.command && curOp.command.name;
                            if (commandName == "insertstring")
                              return;
                            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
                            if (inComposition && isUserAction) {
                              lastValue = text.value = "";
                              onCompositionEnd();
                            }
                            resetSelection();
                          });
                          var resetSelection = isIOS ? function(value) {
                            if (!isFocused || copied && !value || sendingText)
                              return;
                            if (!value)
                              value = "";
                            var newValue = "\n ab" + value + "cde fg\n";
                            if (newValue != text.value)
                              text.value = lastValue = newValue;
                            var selectionStart = 4;
                            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
                            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                              text.setSelectionRange(selectionStart, selectionEnd);
                            }
                            lastSelectionStart = selectionStart;
                            lastSelectionEnd = selectionEnd;
                          } : function() {
                            if (inComposition || sendingText)
                              return;
                            if (!isFocused && !afterContextMenu)
                              return;
                            inComposition = true;
                            var selectionStart = 0;
                            var selectionEnd = 0;
                            var line = "";
                            if (host.session) {
                              var selection = host.selection;
                              var range = selection.getRange();
                              var row = selection.cursor.row;
                              selectionStart = range.start.column;
                              selectionEnd = range.end.column;
                              line = host.session.getLine(row);
                              if (range.start.row != row) {
                                var prevLine = host.session.getLine(row - 1);
                                selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                                selectionEnd += prevLine.length + 1;
                                line = prevLine + "\n" + line;
                              } else if (range.end.row != row) {
                                var nextLine = host.session.getLine(row + 1);
                                selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
                                selectionEnd += line.length + 1;
                                line = line + "\n" + nextLine;
                              } else if (isMobile && row > 0) {
                                line = "\n" + line;
                                selectionEnd += 1;
                                selectionStart += 1;
                              }
                              if (line.length > MAX_LINE_LENGTH) {
                                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                                  line = line.slice(0, MAX_LINE_LENGTH);
                                } else {
                                  line = "\n";
                                  if (selectionStart == selectionEnd) {
                                    selectionStart = selectionEnd = 0;
                                  } else {
                                    selectionStart = 0;
                                    selectionEnd = 1;
                                  }
                                }
                              }
                            }
                            var newValue = line + "\n\n";
                            if (newValue != lastValue) {
                              text.value = lastValue = newValue;
                              lastSelectionStart = lastSelectionEnd = newValue.length;
                            }
                            if (afterContextMenu) {
                              lastSelectionStart = text.selectionStart;
                              lastSelectionEnd = text.selectionEnd;
                            }
                            if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
                              try {
                                text.setSelectionRange(selectionStart, selectionEnd);
                                lastSelectionStart = selectionStart;
                                lastSelectionEnd = selectionEnd;
                              } catch (e) {
                              }
                            }
                            inComposition = false;
                          };
                          this.resetSelection = resetSelection;
                          if (isFocused)
                            host.onFocus();
                          var isAllSelected = function(text2) {
                            return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
                          };
                          var onSelect = function(e) {
                            if (inComposition)
                              return;
                            if (copied) {
                              copied = false;
                            } else if (isAllSelected(text)) {
                              host.selectAll();
                              resetSelection();
                            } else if (isMobile && text.selectionStart != lastSelectionStart) {
                              resetSelection();
                            }
                          };
                          var inputHandler = null;
                          this.setInputHandler = function(cb) {
                            inputHandler = cb;
                          };
                          this.getInputHandler = function() {
                            return inputHandler;
                          };
                          var afterContextMenu = false;
                          var sendText = function(value, fromInput) {
                            if (afterContextMenu)
                              afterContextMenu = false;
                            if (pasted) {
                              resetSelection();
                              if (value)
                                host.onPaste(value);
                              pasted = false;
                              return "";
                            } else {
                              var selectionStart = text.selectionStart;
                              var selectionEnd = text.selectionEnd;
                              var extendLeft = lastSelectionStart;
                              var extendRight = lastValue.length - lastSelectionEnd;
                              var inserted = value;
                              var restoreStart = value.length - selectionStart;
                              var restoreEnd = value.length - selectionEnd;
                              var i = 0;
                              while (extendLeft > 0 && lastValue[i] == value[i]) {
                                i++;
                                extendLeft--;
                              }
                              inserted = inserted.slice(i);
                              i = 1;
                              while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
                                i++;
                                extendRight--;
                              }
                              restoreStart -= i - 1;
                              restoreEnd -= i - 1;
                              var endIndex = inserted.length - i + 1;
                              if (endIndex < 0) {
                                extendLeft = -endIndex;
                                endIndex = 0;
                              }
                              inserted = inserted.slice(0, endIndex);
                              if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                                return "";
                              sendingText = true;
                              var shouldReset = false;
                              if (useragent.isAndroid && inserted == ". ") {
                                inserted = "  ";
                                shouldReset = true;
                              }
                              if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                                host.onTextInput(inserted);
                              } else {
                                host.onTextInput(inserted, {
                                  extendLeft,
                                  extendRight,
                                  restoreStart,
                                  restoreEnd
                                });
                              }
                              sendingText = false;
                              lastValue = value;
                              lastSelectionStart = selectionStart;
                              lastSelectionEnd = selectionEnd;
                              lastRestoreEnd = restoreEnd;
                              return shouldReset ? "\n" : inserted;
                            }
                          };
                          var onInput = function(e) {
                            if (inComposition)
                              return onCompositionUpdate();
                            if (e && e.inputType) {
                              if (e.inputType == "historyUndo")
                                return host.execCommand("undo");
                              if (e.inputType == "historyRedo")
                                return host.execCommand("redo");
                            }
                            var data = text.value;
                            var inserted = sendText(data, true);
                            if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
                              resetSelection();
                            }
                          };
                          var handleClipboardData = function(e, data, forceIEMime) {
                            var clipboardData = e.clipboardData || window.clipboardData;
                            if (!clipboardData || BROKEN_SETDATA)
                              return;
                            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                            try {
                              if (data) {
                                return clipboardData.setData(mime, data) !== false;
                              } else {
                                return clipboardData.getData(mime);
                              }
                            } catch (e2) {
                              if (!forceIEMime)
                                return handleClipboardData(e2, data, true);
                            }
                          };
                          var doCopy = function(e, isCut) {
                            var data = host.getCopyText();
                            if (!data)
                              return event.preventDefault(e);
                            if (handleClipboardData(e, data)) {
                              if (isIOS) {
                                resetSelection(data);
                                copied = data;
                                setTimeout(function() {
                                  copied = false;
                                }, 10);
                              }
                              isCut ? host.onCut() : host.onCopy();
                              event.preventDefault(e);
                            } else {
                              copied = true;
                              text.value = data;
                              text.select();
                              setTimeout(function() {
                                copied = false;
                                resetSelection();
                                isCut ? host.onCut() : host.onCopy();
                              });
                            }
                          };
                          var onCut = function(e) {
                            doCopy(e, true);
                          };
                          var onCopy = function(e) {
                            doCopy(e, false);
                          };
                          var onPaste = function(e) {
                            var data = handleClipboardData(e);
                            if (clipboard.pasteCancelled())
                              return;
                            if (typeof data == "string") {
                              if (data)
                                host.onPaste(data, e);
                              if (useragent.isIE)
                                setTimeout(resetSelection);
                              event.preventDefault(e);
                            } else {
                              text.value = "";
                              pasted = true;
                            }
                          };
                          event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
                          event.addListener(text, "select", onSelect, host);
                          event.addListener(text, "input", onInput, host);
                          event.addListener(text, "cut", onCut, host);
                          event.addListener(text, "copy", onCopy, host);
                          event.addListener(text, "paste", onPaste, host);
                          if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
                            event.addListener(parentNode, "keydown", function(e) {
                              if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                                return;
                              switch (e.keyCode) {
                                case 67:
                                  onCopy(e);
                                  break;
                                case 86:
                                  onPaste(e);
                                  break;
                                case 88:
                                  onCut(e);
                                  break;
                              }
                            }, host);
                          }
                          var onCompositionStart = function(e) {
                            if (inComposition || !host.onCompositionStart || host.$readOnly)
                              return;
                            inComposition = {};
                            if (commandMode)
                              return;
                            if (e.data)
                              inComposition.useTextareaForIME = false;
                            setTimeout(onCompositionUpdate, 0);
                            host._signal("compositionStart");
                            host.on("mousedown", cancelComposition);
                            var range = host.getSelectionRange();
                            range.end.row = range.start.row;
                            range.end.column = range.start.column;
                            inComposition.markerRange = range;
                            inComposition.selectionStart = lastSelectionStart;
                            host.onCompositionStart(inComposition);
                            if (inComposition.useTextareaForIME) {
                              lastValue = text.value = "";
                              lastSelectionStart = 0;
                              lastSelectionEnd = 0;
                            } else {
                              if (text.msGetInputContext)
                                inComposition.context = text.msGetInputContext();
                              if (text.getInputContext)
                                inComposition.context = text.getInputContext();
                            }
                          };
                          var onCompositionUpdate = function() {
                            if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                              return;
                            if (commandMode)
                              return cancelComposition();
                            if (inComposition.useTextareaForIME) {
                              host.onCompositionUpdate(text.value);
                            } else {
                              var data = text.value;
                              sendText(data);
                              if (inComposition.markerRange) {
                                if (inComposition.context) {
                                  inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
                                }
                                inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                              }
                            }
                          };
                          var onCompositionEnd = function(e) {
                            if (!host.onCompositionEnd || host.$readOnly)
                              return;
                            inComposition = false;
                            host.onCompositionEnd();
                            host.off("mousedown", cancelComposition);
                            if (e)
                              onInput();
                          };
                          function cancelComposition() {
                            ignoreFocusEvents = true;
                            text.blur();
                            text.focus();
                            ignoreFocusEvents = false;
                          }
                          var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
                          function onKeyup(e) {
                            if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                              if (!inComposition)
                                lastValue = text.value;
                              lastSelectionStart = lastSelectionEnd = -1;
                              resetSelection();
                            }
                            syncComposition();
                          }
                          event.addListener(text, "compositionstart", onCompositionStart, host);
                          event.addListener(text, "compositionupdate", onCompositionUpdate, host);
                          event.addListener(text, "keyup", onKeyup, host);
                          event.addListener(text, "keydown", syncComposition, host);
                          event.addListener(text, "compositionend", onCompositionEnd, host);
                          this.getElement = function() {
                            return text;
                          };
                          this.setCommandMode = function(value) {
                            commandMode = value;
                            text.readOnly = false;
                          };
                          this.setReadOnly = function(readOnly) {
                            if (!commandMode)
                              text.readOnly = readOnly;
                          };
                          this.setCopyWithEmptySelection = function(value) {
                          };
                          this.onContextMenu = function(e) {
                            afterContextMenu = true;
                            resetSelection();
                            host._emit("nativecontextmenu", { target: host, domEvent: e });
                            this.moveToMouse(e, true);
                          };
                          this.moveToMouse = function(e, bringToFront) {
                            if (!tempStyle)
                              tempStyle = text.style.cssText;
                            text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
                            var rect = host.container.getBoundingClientRect();
                            var style = dom.computedStyle(host.container);
                            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                            var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                            var maxTop = rect.bottom - top - text.clientHeight - 2;
                            var move = function(e2) {
                              dom.translate(text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
                            };
                            move(e);
                            if (e.type != "mousedown")
                              return;
                            host.renderer.$isMousePressed = true;
                            clearTimeout(closeTimeout);
                            if (useragent.isWin)
                              event.capture(host.container, move, onContextMenuClose);
                          };
                          this.onContextMenuClose = onContextMenuClose;
                          var closeTimeout;
                          function onContextMenuClose() {
                            clearTimeout(closeTimeout);
                            closeTimeout = setTimeout(function() {
                              if (tempStyle) {
                                text.style.cssText = tempStyle;
                                tempStyle = "";
                              }
                              host.renderer.$isMousePressed = false;
                              if (host.renderer.$keepTextAreaAtCursor)
                                host.renderer.$moveTextAreaToCursor();
                            }, 0);
                          }
                          var onContextMenu = function(e) {
                            host.textInput.onContextMenu(e);
                            onContextMenuClose();
                          };
                          event.addListener(text, "mouseup", onContextMenu, host);
                          event.addListener(text, "mousedown", function(e) {
                            e.preventDefault();
                            onContextMenuClose();
                          }, host);
                          event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
                          event.addListener(text, "contextmenu", onContextMenu, host);
                          if (isIOS)
                            addIosSelectionHandler(parentNode, host, text);
                          function addIosSelectionHandler(parentNode2, host2, text2) {
                            var typingResetTimeout = null;
                            var typing = false;
                            text2.addEventListener("keydown", function(e) {
                              if (typingResetTimeout)
                                clearTimeout(typingResetTimeout);
                              typing = true;
                            }, true);
                            text2.addEventListener("keyup", function(e) {
                              typingResetTimeout = setTimeout(function() {
                                typing = false;
                              }, 100);
                            }, true);
                            var detectArrowKeys = function(e) {
                              if (document.activeElement !== text2)
                                return;
                              if (typing || inComposition || host2.$mouseHandler.isMousePressed)
                                return;
                              if (copied) {
                                return;
                              }
                              var selectionStart = text2.selectionStart;
                              var selectionEnd = text2.selectionEnd;
                              var key = null;
                              var modifier = 0;
                              if (selectionStart == 0) {
                                key = KEYS.up;
                              } else if (selectionStart == 1) {
                                key = KEYS.home;
                              } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                                key = KEYS.end;
                              } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                                key = KEYS.left;
                                modifier = MODS.option;
                              } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                key = KEYS.left;
                              } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                                key = KEYS.down;
                              } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                                key = KEYS.right;
                                modifier = MODS.option;
                              } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                key = KEYS.right;
                              }
                              if (selectionStart !== selectionEnd)
                                modifier |= MODS.shift;
                              if (key) {
                                var result = host2.onCommandKey({}, modifier, key);
                                if (!result && host2.commands) {
                                  key = KEYS.keyCodeToString(key);
                                  var command = host2.commands.findKeyCommand(modifier, key);
                                  if (command)
                                    host2.execCommand(command);
                                }
                                lastSelectionStart = selectionStart;
                                lastSelectionEnd = selectionEnd;
                                resetSelection("");
                              }
                            };
                            document.addEventListener("selectionchange", detectArrowKeys);
                            host2.on("destroy", function() {
                              document.removeEventListener("selectionchange", detectArrowKeys);
                            });
                          }
                          this.destroy = function() {
                            if (text.parentElement)
                              text.parentElement.removeChild(text);
                          };
                        };
                        exports2.k = TextInput;
                        __webpack_unused_export__ = function(_isMobile, _isIOS) {
                          isMobile = _isMobile;
                          isIOS = _isIOS;
                        };
                      }
                    ),
                    /***/
                    845: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "no use strict";
                        var oop = __webpack_require__2(645);
                        var EventEmitter = __webpack_require__2(366).b;
                        var optionsProvider = {
                          setOptions: function(optList) {
                            Object.keys(optList).forEach(function(key) {
                              this.setOption(key, optList[key]);
                            }, this);
                          },
                          getOptions: function(optionNames) {
                            var result = {};
                            if (!optionNames) {
                              var options = this.$options;
                              optionNames = Object.keys(options).filter(function(key) {
                                return !options[key].hidden;
                              });
                            } else if (!Array.isArray(optionNames)) {
                              result = optionNames;
                              optionNames = Object.keys(result);
                            }
                            optionNames.forEach(function(key) {
                              result[key] = this.getOption(key);
                            }, this);
                            return result;
                          },
                          setOption: function(name, value) {
                            if (this["$" + name] === value)
                              return;
                            var opt = this.$options[name];
                            if (!opt) {
                              return warn('misspelled option "' + name + '"');
                            }
                            if (opt.forwardTo)
                              return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
                            if (!opt.handlesSet)
                              this["$" + name] = value;
                            if (opt && opt.set)
                              opt.set.call(this, value);
                          },
                          getOption: function(name) {
                            var opt = this.$options[name];
                            if (!opt) {
                              return warn('misspelled option "' + name + '"');
                            }
                            if (opt.forwardTo)
                              return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                            return opt && opt.get ? opt.get.call(this) : this["$" + name];
                          }
                        };
                        function warn(message) {
                          if (typeof console != "undefined" && console.warn)
                            console.warn.apply(console, arguments);
                        }
                        function reportError(msg, data) {
                          var e = new Error(msg);
                          e.data = data;
                          if (typeof console == "object" && console.error)
                            console.error(e);
                          setTimeout(function() {
                            throw e;
                          });
                        }
                        var AppConfig = function() {
                          this.$defaultOptions = {};
                        };
                        (function() {
                          oop.implement(this, EventEmitter);
                          this.defineOptions = function(obj, path, options) {
                            if (!obj.$options)
                              this.$defaultOptions[path] = obj.$options = {};
                            Object.keys(options).forEach(function(key) {
                              var opt = options[key];
                              if (typeof opt == "string")
                                opt = { forwardTo: opt };
                              opt.name || (opt.name = key);
                              obj.$options[opt.name] = opt;
                              if ("initialValue" in opt)
                                obj["$" + opt.name] = opt.initialValue;
                            });
                            oop.implement(obj, optionsProvider);
                            return this;
                          };
                          this.resetOptions = function(obj) {
                            Object.keys(obj.$options).forEach(function(key) {
                              var opt = obj.$options[key];
                              if ("value" in opt)
                                obj.setOption(key, opt.value);
                            });
                          };
                          this.setDefaultValue = function(path, name, value) {
                            if (!path) {
                              for (path in this.$defaultOptions)
                                if (this.$defaultOptions[path][name])
                                  break;
                              if (!this.$defaultOptions[path][name])
                                return false;
                            }
                            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                            if (opts[name]) {
                              if (opts.forwardTo)
                                this.setDefaultValue(opts.forwardTo, name, value);
                              else
                                opts[name].value = value;
                            }
                          };
                          this.setDefaultValues = function(path, optionHash) {
                            Object.keys(optionHash).forEach(function(key) {
                              this.setDefaultValue(path, key, optionHash[key]);
                            }, this);
                          };
                          this.warn = warn;
                          this.reportError = reportError;
                        }).call(AppConfig.prototype);
                        exports2.o = AppConfig;
                      }
                    ),
                    /***/
                    435: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var useragent = __webpack_require__2(943);
                        var XHTML_NS = "http://www.w3.org/1999/xhtml";
                        exports2.buildDom = function buildDom(arr, parent, refs) {
                          if (typeof arr == "string" && arr) {
                            var txt = document.createTextNode(arr);
                            if (parent)
                              parent.appendChild(txt);
                            return txt;
                          }
                          if (!Array.isArray(arr)) {
                            if (arr && arr.appendChild && parent)
                              parent.appendChild(arr);
                            return arr;
                          }
                          if (typeof arr[0] != "string" || !arr[0]) {
                            var els = [];
                            for (var i = 0; i < arr.length; i++) {
                              var ch = buildDom(arr[i], parent, refs);
                              ch && els.push(ch);
                            }
                            return els;
                          }
                          var el = document.createElement(arr[0]);
                          var options = arr[1];
                          var childIndex = 1;
                          if (options && typeof options == "object" && !Array.isArray(options))
                            childIndex = 2;
                          for (var i = childIndex; i < arr.length; i++)
                            buildDom(arr[i], el, refs);
                          if (childIndex == 2) {
                            Object.keys(options).forEach(function(n) {
                              var val = options[n];
                              if (n === "class") {
                                el.className = Array.isArray(val) ? val.join(" ") : val;
                              } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                                el[n] = val;
                              } else if (n === "ref") {
                                if (refs)
                                  refs[val] = el;
                              } else if (n === "style") {
                                if (typeof val == "string")
                                  el.style.cssText = val;
                              } else if (val != null) {
                                el.setAttribute(n, val);
                              }
                            });
                          }
                          if (parent)
                            parent.appendChild(el);
                          return el;
                        };
                        exports2.getDocumentHead = function(doc) {
                          if (!doc)
                            doc = document;
                          return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
                        };
                        exports2.createElement = function(tag, ns) {
                          return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
                        };
                        exports2.removeChildren = function(element) {
                          element.innerHTML = "";
                        };
                        exports2.createTextNode = function(textContent, element) {
                          var doc = element ? element.ownerDocument : document;
                          return doc.createTextNode(textContent);
                        };
                        exports2.createFragment = function(element) {
                          var doc = element ? element.ownerDocument : document;
                          return doc.createDocumentFragment();
                        };
                        exports2.hasCssClass = function(el, name) {
                          var classes = (el.className + "").split(/\s+/g);
                          return classes.indexOf(name) !== -1;
                        };
                        exports2.addCssClass = function(el, name) {
                          if (!exports2.hasCssClass(el, name)) {
                            el.className += " " + name;
                          }
                        };
                        exports2.removeCssClass = function(el, name) {
                          var classes = el.className.split(/\s+/g);
                          while (true) {
                            var index = classes.indexOf(name);
                            if (index == -1) {
                              break;
                            }
                            classes.splice(index, 1);
                          }
                          el.className = classes.join(" ");
                        };
                        exports2.toggleCssClass = function(el, name) {
                          var classes = el.className.split(/\s+/g), add = true;
                          while (true) {
                            var index = classes.indexOf(name);
                            if (index == -1) {
                              break;
                            }
                            add = false;
                            classes.splice(index, 1);
                          }
                          if (add)
                            classes.push(name);
                          el.className = classes.join(" ");
                          return add;
                        };
                        exports2.setCssClass = function(node, className, include) {
                          if (include) {
                            exports2.addCssClass(node, className);
                          } else {
                            exports2.removeCssClass(node, className);
                          }
                        };
                        exports2.hasCssString = function(id, doc) {
                          var index = 0, sheets;
                          doc = doc || document;
                          if (sheets = doc.querySelectorAll("style")) {
                            while (index < sheets.length) {
                              if (sheets[index++].id === id) {
                                return true;
                              }
                            }
                          }
                        };
                        exports2.removeElementById = function(id, doc) {
                          doc = doc || document;
                          if (doc.getElementById(id)) {
                            doc.getElementById(id).remove();
                          }
                        };
                        var strictCSP;
                        var cssCache = [];
                        exports2.useStrictCSP = function(value) {
                          strictCSP = value;
                          if (value == false)
                            insertPendingStyles();
                          else if (!cssCache)
                            cssCache = [];
                        };
                        function insertPendingStyles() {
                          var cache = cssCache;
                          cssCache = null;
                          cache && cache.forEach(function(item) {
                            importCssString(item[0], item[1]);
                          });
                        }
                        function importCssString(cssText, id, target) {
                          if (typeof document == "undefined")
                            return;
                          if (cssCache) {
                            if (target) {
                              insertPendingStyles();
                            } else if (target === false) {
                              return cssCache.push([cssText, id]);
                            }
                          }
                          if (strictCSP)
                            return;
                          var container = target;
                          if (!target || !target.getRootNode) {
                            container = document;
                          } else {
                            container = target.getRootNode();
                            if (!container || container == target)
                              container = document;
                          }
                          var doc = container.ownerDocument || container;
                          if (id && exports2.hasCssString(id, container))
                            return null;
                          if (id)
                            cssText += "\n/*# sourceURL=ace/css/" + id + " */";
                          var style = exports2.createElement("style");
                          style.appendChild(doc.createTextNode(cssText));
                          if (id)
                            style.id = id;
                          if (container == doc)
                            container = exports2.getDocumentHead(doc);
                          container.insertBefore(style, container.firstChild);
                        }
                        exports2.importCssString = importCssString;
                        exports2.importCssStylsheet = function(uri, doc) {
                          exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
                        };
                        exports2.scrollbarWidth = function(doc) {
                          var inner = exports2.createElement("ace_inner");
                          inner.style.width = "100%";
                          inner.style.minWidth = "0px";
                          inner.style.height = "200px";
                          inner.style.display = "block";
                          var outer = exports2.createElement("ace_outer");
                          var style = outer.style;
                          style.position = "absolute";
                          style.left = "-10000px";
                          style.overflow = "hidden";
                          style.width = "200px";
                          style.minWidth = "0px";
                          style.height = "150px";
                          style.display = "block";
                          outer.appendChild(inner);
                          var body = doc && doc.documentElement || document && document.documentElement;
                          if (!body)
                            return 0;
                          body.appendChild(outer);
                          var noScrollbar = inner.offsetWidth;
                          style.overflow = "scroll";
                          var withScrollbar = inner.offsetWidth;
                          if (noScrollbar === withScrollbar) {
                            withScrollbar = outer.clientWidth;
                          }
                          body.removeChild(outer);
                          return noScrollbar - withScrollbar;
                        };
                        exports2.computedStyle = function(element, style) {
                          return window.getComputedStyle(element, "") || {};
                        };
                        exports2.setStyle = function(styles, property, value) {
                          if (styles[property] !== value) {
                            styles[property] = value;
                          }
                        };
                        exports2.HAS_CSS_ANIMATION = false;
                        exports2.HAS_CSS_TRANSFORMS = false;
                        exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
                        if (useragent.isChromeOS)
                          exports2.HI_DPI = false;
                        if (typeof document !== "undefined") {
                          var div = document.createElement("div");
                          if (exports2.HI_DPI && div.style.transform !== void 0)
                            exports2.HAS_CSS_TRANSFORMS = true;
                          if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
                            exports2.HAS_CSS_ANIMATION = true;
                          div = null;
                        }
                        if (exports2.HAS_CSS_TRANSFORMS) {
                          exports2.translate = function(element, tx, ty) {
                            element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
                          };
                        } else {
                          exports2.translate = function(element, tx, ty) {
                            element.style.top = Math.round(ty) + "px";
                            element.style.left = Math.round(tx) + "px";
                          };
                        }
                      }
                    ),
                    /***/
                    631: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var keys = __webpack_require__2(451);
                        var useragent = __webpack_require__2(943);
                        var pressedKeys = null;
                        var ts = 0;
                        var activeListenerOptions;
                        function detectListenerOptionsSupport() {
                          activeListenerOptions = false;
                          try {
                            document.createComment("").addEventListener("test", function() {
                            }, {
                              get passive() {
                                activeListenerOptions = { passive: false };
                              }
                            });
                          } catch (e) {
                          }
                        }
                        function getListenerOptions() {
                          if (activeListenerOptions == void 0)
                            detectListenerOptionsSupport();
                          return activeListenerOptions;
                        }
                        function EventListener(elem, type, callback) {
                          this.elem = elem;
                          this.type = type;
                          this.callback = callback;
                        }
                        EventListener.prototype.destroy = function() {
                          removeListener(this.elem, this.type, this.callback);
                          this.elem = this.type = this.callback = void 0;
                        };
                        var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
                          elem.addEventListener(type, callback, getListenerOptions());
                          if (destroyer)
                            destroyer.$toDestroy.push(new EventListener(elem, type, callback));
                        };
                        var removeListener = exports2.removeListener = function(elem, type, callback) {
                          elem.removeEventListener(type, callback, getListenerOptions());
                        };
                        exports2.stopEvent = function(e) {
                          exports2.stopPropagation(e);
                          exports2.preventDefault(e);
                          return false;
                        };
                        exports2.stopPropagation = function(e) {
                          if (e.stopPropagation)
                            e.stopPropagation();
                        };
                        exports2.preventDefault = function(e) {
                          if (e.preventDefault)
                            e.preventDefault();
                        };
                        exports2.getButton = function(e) {
                          if (e.type == "dblclick")
                            return 0;
                          if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
                            return 2;
                          return e.button;
                        };
                        exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
                          var ownerDocument = el && el.ownerDocument || document;
                          function onMouseUp(e) {
                            eventHandler && eventHandler(e);
                            releaseCaptureHandler && releaseCaptureHandler(e);
                            removeListener(ownerDocument, "mousemove", eventHandler);
                            removeListener(ownerDocument, "mouseup", onMouseUp);
                            removeListener(ownerDocument, "dragstart", onMouseUp);
                          }
                          addListener(ownerDocument, "mousemove", eventHandler);
                          addListener(ownerDocument, "mouseup", onMouseUp);
                          addListener(ownerDocument, "dragstart", onMouseUp);
                          return onMouseUp;
                        };
                        exports2.addMouseWheelListener = function(el, callback, destroyer) {
                          addListener(el, "wheel", function(e) {
                            var factor = 0.15;
                            var deltaX = e.deltaX || 0;
                            var deltaY = e.deltaY || 0;
                            switch (e.deltaMode) {
                              case e.DOM_DELTA_PIXEL:
                                e.wheelX = deltaX * factor;
                                e.wheelY = deltaY * factor;
                                break;
                              case e.DOM_DELTA_LINE:
                                var linePixels = 15;
                                e.wheelX = deltaX * linePixels;
                                e.wheelY = deltaY * linePixels;
                                break;
                              case e.DOM_DELTA_PAGE:
                                var pagePixels = 150;
                                e.wheelX = deltaX * pagePixels;
                                e.wheelY = deltaY * pagePixels;
                                break;
                            }
                            callback(e);
                          }, destroyer);
                        };
                        exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
                          var clicks = 0;
                          var startX, startY, timer;
                          var eventNames = {
                            2: "dblclick",
                            3: "tripleclick",
                            4: "quadclick"
                          };
                          function onMousedown(e) {
                            if (exports2.getButton(e) !== 0) {
                              clicks = 0;
                            } else if (e.detail > 1) {
                              clicks++;
                              if (clicks > 4)
                                clicks = 1;
                            } else {
                              clicks = 1;
                            }
                            if (useragent.isIE) {
                              var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                              if (!timer || isNewClick)
                                clicks = 1;
                              if (timer)
                                clearTimeout(timer);
                              timer = setTimeout(function() {
                                timer = null;
                              }, timeouts[clicks - 1] || 600);
                              if (clicks == 1) {
                                startX = e.clientX;
                                startY = e.clientY;
                              }
                            }
                            e._clicks = clicks;
                            eventHandler[callbackName]("mousedown", e);
                            if (clicks > 4)
                              clicks = 0;
                            else if (clicks > 1)
                              return eventHandler[callbackName](eventNames[clicks], e);
                          }
                          if (!Array.isArray(elements))
                            elements = [elements];
                          elements.forEach(function(el) {
                            addListener(el, "mousedown", onMousedown, destroyer);
                          });
                        };
                        var getModifierHash = function(e) {
                          return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
                        };
                        exports2.getModifierString = function(e) {
                          return keys.KEY_MODS[getModifierHash(e)];
                        };
                        function normalizeCommandKeys(callback, e, keyCode) {
                          var hashId = getModifierHash(e);
                          if (!useragent.isMac && pressedKeys) {
                            if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                              hashId |= 8;
                            if (pressedKeys.altGr) {
                              if ((3 & hashId) != 3)
                                pressedKeys.altGr = 0;
                              else
                                return;
                            }
                            if (keyCode === 18 || keyCode === 17) {
                              var location = "location" in e ? e.location : e.keyLocation;
                              if (keyCode === 17 && location === 1) {
                                if (pressedKeys[keyCode] == 1)
                                  ts = e.timeStamp;
                              } else if (keyCode === 18 && hashId === 3 && location === 2) {
                                var dt = e.timeStamp - ts;
                                if (dt < 50)
                                  pressedKeys.altGr = true;
                              }
                            }
                          }
                          if (keyCode in keys.MODIFIER_KEYS) {
                            keyCode = -1;
                          }
                          if (!hashId && keyCode === 13) {
                            var location = "location" in e ? e.location : e.keyLocation;
                            if (location === 3) {
                              callback(e, hashId, -keyCode);
                              if (e.defaultPrevented)
                                return;
                            }
                          }
                          if (useragent.isChromeOS && hashId & 8) {
                            callback(e, hashId, keyCode);
                            if (e.defaultPrevented)
                              return;
                            else
                              hashId &= ~8;
                          }
                          if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                            return false;
                          }
                          return callback(e, hashId, keyCode);
                        }
                        exports2.addCommandKeyListener = function(el, callback, destroyer) {
                          if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                            var lastKeyDownKeyCode = null;
                            addListener(el, "keydown", function(e) {
                              lastKeyDownKeyCode = e.keyCode;
                            }, destroyer);
                            addListener(el, "keypress", function(e) {
                              return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                            }, destroyer);
                          } else {
                            var lastDefaultPrevented = null;
                            addListener(el, "keydown", function(e) {
                              pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                              var result = normalizeCommandKeys(callback, e, e.keyCode);
                              lastDefaultPrevented = e.defaultPrevented;
                              return result;
                            }, destroyer);
                            addListener(el, "keypress", function(e) {
                              if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                                exports2.stopEvent(e);
                                lastDefaultPrevented = null;
                              }
                            }, destroyer);
                            addListener(el, "keyup", function(e) {
                              pressedKeys[e.keyCode] = null;
                            }, destroyer);
                            if (!pressedKeys) {
                              resetPressedKeys();
                              addListener(window, "focus", resetPressedKeys);
                            }
                          }
                        };
                        function resetPressedKeys() {
                          pressedKeys = /* @__PURE__ */ Object.create(null);
                        }
                        if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                          var postMessageId = 1;
                          exports2.nextTick = function(callback, win) {
                            win = win || window;
                            var messageName = "zero-timeout-message-" + postMessageId++;
                            var listener = function(e) {
                              if (e.data == messageName) {
                                exports2.stopPropagation(e);
                                removeListener(win, "message", listener);
                                callback();
                              }
                            };
                            addListener(win, "message", listener);
                            win.postMessage(messageName, "*");
                          };
                        }
                        exports2.$idleBlocked = false;
                        exports2.onIdle = function(cb, timeout) {
                          return setTimeout(function handler() {
                            if (!exports2.$idleBlocked) {
                              cb();
                            } else {
                              setTimeout(handler, 100);
                            }
                          }, timeout);
                        };
                        exports2.$idleBlockId = null;
                        exports2.blockIdle = function(delay) {
                          if (exports2.$idleBlockId)
                            clearTimeout(exports2.$idleBlockId);
                          exports2.$idleBlocked = true;
                          exports2.$idleBlockId = setTimeout(function() {
                            exports2.$idleBlocked = false;
                          }, delay || 100);
                        };
                        exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
                        if (exports2.nextFrame)
                          exports2.nextFrame = exports2.nextFrame.bind(window);
                        else
                          exports2.nextFrame = function(callback) {
                            setTimeout(callback, 17);
                          };
                      }
                    ),
                    /***/
                    366: (
                      /***/
                      (__unused_webpack_module, exports2) => {
                        "use strict";
                        var EventEmitter = {};
                        var stopPropagation = function() {
                          this.propagationStopped = true;
                        };
                        var preventDefault = function() {
                          this.defaultPrevented = true;
                        };
                        EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
                          this._eventRegistry || (this._eventRegistry = {});
                          this._defaultHandlers || (this._defaultHandlers = {});
                          var listeners = this._eventRegistry[eventName] || [];
                          var defaultHandler = this._defaultHandlers[eventName];
                          if (!listeners.length && !defaultHandler)
                            return;
                          if (typeof e != "object" || !e)
                            e = {};
                          if (!e.type)
                            e.type = eventName;
                          if (!e.stopPropagation)
                            e.stopPropagation = stopPropagation;
                          if (!e.preventDefault)
                            e.preventDefault = preventDefault;
                          listeners = listeners.slice();
                          for (var i = 0; i < listeners.length; i++) {
                            listeners[i](e, this);
                            if (e.propagationStopped)
                              break;
                          }
                          if (defaultHandler && !e.defaultPrevented)
                            return defaultHandler(e, this);
                        };
                        EventEmitter._signal = function(eventName, e) {
                          var listeners = (this._eventRegistry || {})[eventName];
                          if (!listeners)
                            return;
                          listeners = listeners.slice();
                          for (var i = 0; i < listeners.length; i++)
                            listeners[i](e, this);
                        };
                        EventEmitter.once = function(eventName, callback) {
                          var _self = this;
                          this.on(eventName, function newCallback() {
                            _self.off(eventName, newCallback);
                            callback.apply(null, arguments);
                          });
                          if (!callback) {
                            return new Promise(function(resolve) {
                              callback = resolve;
                            });
                          }
                        };
                        EventEmitter.setDefaultHandler = function(eventName, callback) {
                          var handlers = this._defaultHandlers;
                          if (!handlers)
                            handlers = this._defaultHandlers = { _disabled_: {} };
                          if (handlers[eventName]) {
                            var old = handlers[eventName];
                            var disabled = handlers._disabled_[eventName];
                            if (!disabled)
                              handlers._disabled_[eventName] = disabled = [];
                            disabled.push(old);
                            var i = disabled.indexOf(callback);
                            if (i != -1)
                              disabled.splice(i, 1);
                          }
                          handlers[eventName] = callback;
                        };
                        EventEmitter.removeDefaultHandler = function(eventName, callback) {
                          var handlers = this._defaultHandlers;
                          if (!handlers)
                            return;
                          var disabled = handlers._disabled_[eventName];
                          if (handlers[eventName] == callback) {
                            if (disabled)
                              this.setDefaultHandler(eventName, disabled.pop());
                          } else if (disabled) {
                            var i = disabled.indexOf(callback);
                            if (i != -1)
                              disabled.splice(i, 1);
                          }
                        };
                        EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
                          this._eventRegistry = this._eventRegistry || {};
                          var listeners = this._eventRegistry[eventName];
                          if (!listeners)
                            listeners = this._eventRegistry[eventName] = [];
                          if (listeners.indexOf(callback) == -1)
                            listeners[capturing ? "unshift" : "push"](callback);
                          return callback;
                        };
                        EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
                          this._eventRegistry = this._eventRegistry || {};
                          var listeners = this._eventRegistry[eventName];
                          if (!listeners)
                            return;
                          var index = listeners.indexOf(callback);
                          if (index !== -1)
                            listeners.splice(index, 1);
                        };
                        EventEmitter.removeAllListeners = function(eventName) {
                          if (!eventName)
                            this._eventRegistry = this._defaultHandlers = void 0;
                          if (this._eventRegistry)
                            this._eventRegistry[eventName] = void 0;
                          if (this._defaultHandlers)
                            this._defaultHandlers[eventName] = void 0;
                        };
                        exports2.b = EventEmitter;
                      }
                    ),
                    /***/
                    451: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        /*! @license
                        ==========================================================================
                        SproutCore -- JavaScript Application Framework
                        copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
                        
                        Permission is hereby granted, free of charge, to any person obtaining a
                        copy of this software and associated documentation files (the "Software"),
                        to deal in the Software without restriction, including without limitation
                        the rights to use, copy, modify, merge, publish, distribute, sublicense,
                        and/or sell copies of the Software, and to permit persons to whom the
                        Software is furnished to do so, subject to the following conditions:
                        
                        The above copyright notice and this permission notice shall be included in
                        all copies or substantial portions of the Software.
                        
                        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
                        DEALINGS IN THE SOFTWARE.
                        
                        SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
                        
                        For more information about SproutCore, visit http://www.sproutcore.com
                        
                        
                        ==========================================================================
                        @license */
                        var oop = __webpack_require__2(645);
                        var Keys = function() {
                          var ret = {
                            MODIFIER_KEYS: {
                              16: "Shift",
                              17: "Ctrl",
                              18: "Alt",
                              224: "Meta",
                              91: "MetaLeft",
                              92: "MetaRight",
                              93: "ContextMenu"
                            },
                            KEY_MODS: {
                              "ctrl": 1,
                              "alt": 2,
                              "option": 2,
                              "shift": 4,
                              "super": 8,
                              "meta": 8,
                              "command": 8,
                              "cmd": 8,
                              "control": 1
                            },
                            FUNCTION_KEYS: {
                              8: "Backspace",
                              9: "Tab",
                              13: "Return",
                              19: "Pause",
                              27: "Esc",
                              32: "Space",
                              33: "PageUp",
                              34: "PageDown",
                              35: "End",
                              36: "Home",
                              37: "Left",
                              38: "Up",
                              39: "Right",
                              40: "Down",
                              44: "Print",
                              45: "Insert",
                              46: "Delete",
                              96: "Numpad0",
                              97: "Numpad1",
                              98: "Numpad2",
                              99: "Numpad3",
                              100: "Numpad4",
                              101: "Numpad5",
                              102: "Numpad6",
                              103: "Numpad7",
                              104: "Numpad8",
                              105: "Numpad9",
                              "-13": "NumpadEnter",
                              112: "F1",
                              113: "F2",
                              114: "F3",
                              115: "F4",
                              116: "F5",
                              117: "F6",
                              118: "F7",
                              119: "F8",
                              120: "F9",
                              121: "F10",
                              122: "F11",
                              123: "F12",
                              144: "Numlock",
                              145: "Scrolllock"
                            },
                            PRINTABLE_KEYS: {
                              32: " ",
                              48: "0",
                              49: "1",
                              50: "2",
                              51: "3",
                              52: "4",
                              53: "5",
                              54: "6",
                              55: "7",
                              56: "8",
                              57: "9",
                              59: ";",
                              61: "=",
                              65: "a",
                              66: "b",
                              67: "c",
                              68: "d",
                              69: "e",
                              70: "f",
                              71: "g",
                              72: "h",
                              73: "i",
                              74: "j",
                              75: "k",
                              76: "l",
                              77: "m",
                              78: "n",
                              79: "o",
                              80: "p",
                              81: "q",
                              82: "r",
                              83: "s",
                              84: "t",
                              85: "u",
                              86: "v",
                              87: "w",
                              88: "x",
                              89: "y",
                              90: "z",
                              107: "+",
                              109: "-",
                              110: ".",
                              186: ";",
                              187: "=",
                              188: ",",
                              189: "-",
                              190: ".",
                              191: "/",
                              192: "`",
                              219: "[",
                              220: "\\",
                              221: "]",
                              222: "'",
                              111: "/",
                              106: "*"
                            }
                          };
                          ret.PRINTABLE_KEYS[173] = "-";
                          var name, i;
                          for (i in ret.FUNCTION_KEYS) {
                            name = ret.FUNCTION_KEYS[i].toLowerCase();
                            ret[name] = parseInt(i, 10);
                          }
                          for (i in ret.PRINTABLE_KEYS) {
                            name = ret.PRINTABLE_KEYS[i].toLowerCase();
                            ret[name] = parseInt(i, 10);
                          }
                          oop.mixin(ret, ret.MODIFIER_KEYS);
                          oop.mixin(ret, ret.PRINTABLE_KEYS);
                          oop.mixin(ret, ret.FUNCTION_KEYS);
                          ret.enter = ret["return"];
                          ret.escape = ret.esc;
                          ret.del = ret["delete"];
                          (function() {
                            var mods = ["cmd", "ctrl", "alt", "shift"];
                            for (var i2 = Math.pow(2, mods.length); i2--; ) {
                              ret.KEY_MODS[i2] = mods.filter(function(x) {
                                return i2 & ret.KEY_MODS[x];
                              }).join("-") + "-";
                            }
                          })();
                          ret.KEY_MODS[0] = "";
                          ret.KEY_MODS[-1] = "input-";
                          return ret;
                        }();
                        oop.mixin(exports2, Keys);
                        exports2.keyCodeToString = function(keyCode) {
                          var keyString = Keys[keyCode];
                          if (typeof keyString != "string")
                            keyString = String.fromCharCode(keyCode);
                          return keyString.toLowerCase();
                        };
                      }
                    ),
                    /***/
                    955: (
                      /***/
                      (__unused_webpack_module, exports2) => {
                        "use strict";
                        exports2.last = function(a) {
                          return a[a.length - 1];
                        };
                        exports2.stringReverse = function(string) {
                          return string.split("").reverse().join("");
                        };
                        exports2.stringRepeat = function(string, count) {
                          var result = "";
                          while (count > 0) {
                            if (count & 1)
                              result += string;
                            if (count >>= 1)
                              string += string;
                          }
                          return result;
                        };
                        var trimBeginRegexp = /^\s\s*/;
                        var trimEndRegexp = /\s\s*$/;
                        exports2.stringTrimLeft = function(string) {
                          return string.replace(trimBeginRegexp, "");
                        };
                        exports2.stringTrimRight = function(string) {
                          return string.replace(trimEndRegexp, "");
                        };
                        exports2.copyObject = function(obj) {
                          var copy = {};
                          for (var key in obj) {
                            copy[key] = obj[key];
                          }
                          return copy;
                        };
                        exports2.copyArray = function(array) {
                          var copy = [];
                          for (var i = 0, l = array.length; i < l; i++) {
                            if (array[i] && typeof array[i] == "object")
                              copy[i] = this.copyObject(array[i]);
                            else
                              copy[i] = array[i];
                          }
                          return copy;
                        };
                        exports2.deepCopy = function deepCopy(obj) {
                          if (typeof obj !== "object" || !obj)
                            return obj;
                          var copy;
                          if (Array.isArray(obj)) {
                            copy = [];
                            for (var key = 0; key < obj.length; key++) {
                              copy[key] = deepCopy(obj[key]);
                            }
                            return copy;
                          }
                          if (Object.prototype.toString.call(obj) !== "[object Object]")
                            return obj;
                          copy = {};
                          for (var key in obj)
                            copy[key] = deepCopy(obj[key]);
                          return copy;
                        };
                        exports2.arrayToMap = function(arr) {
                          var map = {};
                          for (var i = 0; i < arr.length; i++) {
                            map[arr[i]] = 1;
                          }
                          return map;
                        };
                        exports2.createMap = function(props) {
                          var map = /* @__PURE__ */ Object.create(null);
                          for (var i in props) {
                            map[i] = props[i];
                          }
                          return map;
                        };
                        exports2.arrayRemove = function(array, value) {
                          for (var i = 0; i <= array.length; i++) {
                            if (value === array[i]) {
                              array.splice(i, 1);
                            }
                          }
                        };
                        exports2.escapeRegExp = function(str) {
                          return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
                        };
                        exports2.escapeHTML = function(str) {
                          return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
                        };
                        exports2.getMatchOffsets = function(string, regExp) {
                          var matches = [];
                          string.replace(regExp, function(str) {
                            matches.push({
                              offset: arguments[arguments.length - 2],
                              length: str.length
                            });
                          });
                          return matches;
                        };
                        exports2.deferredCall = function(fcn) {
                          var timer = null;
                          var callback = function() {
                            timer = null;
                            fcn();
                          };
                          var deferred = function(timeout) {
                            deferred.cancel();
                            timer = setTimeout(callback, timeout || 0);
                            return deferred;
                          };
                          deferred.schedule = deferred;
                          deferred.call = function() {
                            this.cancel();
                            fcn();
                            return deferred;
                          };
                          deferred.cancel = function() {
                            clearTimeout(timer);
                            timer = null;
                            return deferred;
                          };
                          deferred.isPending = function() {
                            return timer;
                          };
                          return deferred;
                        };
                        exports2.delayedCall = function(fcn, defaultTimeout) {
                          var timer = null;
                          var callback = function() {
                            timer = null;
                            fcn();
                          };
                          var _self = function(timeout) {
                            if (timer == null)
                              timer = setTimeout(callback, timeout || defaultTimeout);
                          };
                          _self.delay = function(timeout) {
                            timer && clearTimeout(timer);
                            timer = setTimeout(callback, timeout || defaultTimeout);
                          };
                          _self.schedule = _self;
                          _self.call = function() {
                            this.cancel();
                            fcn();
                          };
                          _self.cancel = function() {
                            timer && clearTimeout(timer);
                            timer = null;
                          };
                          _self.isPending = function() {
                            return timer;
                          };
                          return _self;
                        };
                      }
                    ),
                    /***/
                    552: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        /*
                         * based on code from:
                         *
                         * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
                         * Available via the MIT or new BSD license.
                         * see: http://github.com/jrburke/requirejs for details
                         */
                        var dom = __webpack_require__2(435);
                        exports2.get = function(url, callback) {
                          var xhr = new XMLHttpRequest();
                          xhr.open("GET", url, true);
                          xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                              callback(xhr.responseText);
                            }
                          };
                          xhr.send(null);
                        };
                        exports2.loadScript = function(path, callback) {
                          var head = dom.getDocumentHead();
                          var s = document.createElement("script");
                          s.src = path;
                          head.appendChild(s);
                          s.onload = s.onreadystatechange = function(_, isAbort) {
                            if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                              s = s.onload = s.onreadystatechange = null;
                              if (!isAbort)
                                callback();
                            }
                          };
                        };
                        exports2.qualifyURL = function(url) {
                          var a = document.createElement("a");
                          a.href = url;
                          return a.href;
                        };
                      }
                    ),
                    /***/
                    645: (
                      /***/
                      (__unused_webpack_module, exports2) => {
                        "use strict";
                        exports2.inherits = function(ctor, superCtor) {
                          ctor.super_ = superCtor;
                          ctor.prototype = Object.create(superCtor.prototype, {
                            constructor: {
                              value: ctor,
                              enumerable: false,
                              writable: true,
                              configurable: true
                            }
                          });
                        };
                        exports2.mixin = function(obj, mixin) {
                          for (var key in mixin) {
                            obj[key] = mixin[key];
                          }
                          return obj;
                        };
                        exports2.implement = function(proto, mixin) {
                          exports2.mixin(proto, mixin);
                        };
                      }
                    ),
                    /***/
                    943: (
                      /***/
                      (__unused_webpack_module, exports2) => {
                        "use strict";
                        exports2.OS = {
                          LINUX: "LINUX",
                          MAC: "MAC",
                          WINDOWS: "WINDOWS"
                        };
                        exports2.getOS = function() {
                          if (exports2.isMac) {
                            return exports2.OS.MAC;
                          } else if (exports2.isLinux) {
                            return exports2.OS.LINUX;
                          } else {
                            return exports2.OS.WINDOWS;
                          }
                        };
                        var _navigator = typeof navigator == "object" ? navigator : {};
                        var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
                        var ua = _navigator.userAgent || "";
                        var appName = _navigator.appName || "";
                        exports2.isWin = os == "win";
                        exports2.isMac = os == "mac";
                        exports2.isLinux = os == "linux";
                        exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
                        exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
                        exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
                        exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
                        exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
                        exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
                        exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
                        exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
                        exports2.isAndroid = ua.indexOf("Android") >= 0;
                        exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
                        exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
                        if (exports2.isIOS)
                          exports2.isMac = true;
                        exports2.isMobile = exports2.isIOS || exports2.isAndroid;
                      }
                    ),
                    /***/
                    481: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var event = __webpack_require__2(631);
                        var RenderLoop = function(onRender, win) {
                          this.onRender = onRender;
                          this.pending = false;
                          this.changes = 0;
                          this.$recursionLimit = 2;
                          this.window = win || window;
                          var _self = this;
                          this._flush = function(ts) {
                            _self.pending = false;
                            var changes = _self.changes;
                            if (changes) {
                              event.blockIdle(100);
                              _self.changes = 0;
                              _self.onRender(changes);
                            }
                            if (_self.changes) {
                              if (_self.$recursionLimit-- < 0)
                                return;
                              _self.schedule();
                            } else {
                              _self.$recursionLimit = 2;
                            }
                          };
                        };
                        (function() {
                          this.schedule = function(change) {
                            this.changes = this.changes | change;
                            if (this.changes && !this.pending) {
                              event.nextFrame(this._flush);
                              this.pending = true;
                            }
                          };
                          this.clear = function(change) {
                            var changes = this.changes;
                            this.changes = 0;
                            return changes;
                          };
                        }).call(RenderLoop.prototype);
                        exports2.x = RenderLoop;
                      }
                    ),
                    /***/
                    745: (
                      /***/
                      (__unused_webpack_module, exports2, __webpack_require__2) => {
                        "use strict";
                        var __webpack_unused_export__;
                        var oop = __webpack_require__2(645);
                        var dom = __webpack_require__2(435);
                        var event = __webpack_require__2(631);
                        var EventEmitter = __webpack_require__2(366).b;
                        var MAX_SCROLL_H = 32768;
                        var ScrollBar = function(parent) {
                          this.element = dom.createElement("div");
                          this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
                          this.inner = dom.createElement("div");
                          this.inner.className = "ace_scrollbar-inner";
                          this.inner.textContent = "\xA0";
                          this.element.appendChild(this.inner);
                          parent.appendChild(this.element);
                          this.setVisible(false);
                          this.skipEvent = false;
                          event.addListener(this.element, "scroll", this.onScroll.bind(this));
                          event.addListener(this.element, "mousedown", event.preventDefault);
                        };
                        (function() {
                          oop.implement(this, EventEmitter);
                          this.setVisible = function(isVisible) {
                            this.element.style.display = isVisible ? "" : "none";
                            this.isVisible = isVisible;
                            this.coeff = 1;
                          };
                        }).call(ScrollBar.prototype);
                        var VScrollBar = function(parent, renderer) {
                          ScrollBar.call(this, parent);
                          this.scrollTop = 0;
                          this.scrollHeight = 0;
                          renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
                          this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
                          this.$minWidth = 0;
                        };
                        oop.inherits(VScrollBar, ScrollBar);
                        (function() {
                          this.classSuffix = "-v";
                          this.onScroll = function() {
                            if (!this.skipEvent) {
                              this.scrollTop = this.element.scrollTop;
                              if (this.coeff != 1) {
                                var h = this.element.clientHeight / this.scrollHeight;
                                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                              }
                              this._emit("scroll", { data: this.scrollTop });
                            }
                            this.skipEvent = false;
                          };
                          this.getWidth = function() {
                            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
                          };
                          this.setHeight = function(height) {
                            this.element.style.height = height + "px";
                          };
                          this.setInnerHeight = /**
                          * Sets the scroll height of the scroll bar, in pixels.
                          * @param {Number} height The new scroll height
                          **/
                          this.setScrollHeight = function(height) {
                            this.scrollHeight = height;
                            if (height > MAX_SCROLL_H) {
                              this.coeff = MAX_SCROLL_H / height;
                              height = MAX_SCROLL_H;
                            } else if (this.coeff != 1) {
                              this.coeff = 1;
                            }
                            this.inner.style.height = height + "px";
                          };
                          this.setScrollTop = function(scrollTop) {
                            if (this.scrollTop != scrollTop) {
                              this.skipEvent = true;
                              this.scrollTop = scrollTop;
                              this.element.scrollTop = scrollTop * this.coeff;
                            }
                          };
                        }).call(VScrollBar.prototype);
                        var HScrollBar = function(parent, renderer) {
                          ScrollBar.call(this, parent);
                          this.scrollLeft = 0;
                          this.height = renderer.$scrollbarWidth;
                          this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
                        };
                        oop.inherits(HScrollBar, ScrollBar);
                        (function() {
                          this.classSuffix = "-h";
                          this.onScroll = function() {
                            if (!this.skipEvent) {
                              this.scrollLeft = this.element.scrollLeft;
                              this._emit("scroll", { data: this.scrollLeft });
                            }
                            this.skipEvent = false;
                          };
                          this.getHeight = function() {
                            return this.isVisible ? this.height : 0;
                          };
                          this.setWidth = function(width) {
                            this.element.style.width = width + "px";
                          };
                          this.setInnerWidth = function(width) {
                            this.inner.style.width = width + "px";
                          };
                          this.setScrollWidth = function(width) {
                            this.inner.style.width = width + "px";
                          };
                          this.setScrollLeft = function(scrollLeft) {
                            if (this.scrollLeft != scrollLeft) {
                              this.skipEvent = true;
                              this.scrollLeft = this.element.scrollLeft = scrollLeft;
                            }
                          };
                        }).call(HScrollBar.prototype);
                        __webpack_unused_export__ = VScrollBar;
                        exports2.lc = VScrollBar;
                        exports2.zy = HScrollBar;
                        __webpack_unused_export__ = VScrollBar;
                        __webpack_unused_export__ = HScrollBar;
                      }
                    ),
                    /***/
                    677: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          function bindKey(win, mac) {
                            return {
                              win,
                              mac
                            };
                          }
                          exports3.commands = [
                            {
                              name: "selectAll",
                              bindKey: bindKey("Ctrl-A", "Command-A"),
                              exec: function(editor) {
                                editor.selectAll();
                              }
                            },
                            {
                              name: "centerselection",
                              bindKey: bindKey(null, "Ctrl-L"),
                              exec: function(editor) {
                                editor.centerSelection();
                              }
                            },
                            {
                              name: "closeOrlevelUp",
                              bindKey: bindKey("Left", "Left|Ctrl-B"),
                              exec: function(editor) {
                                editor.navigateLevelUp(true);
                              }
                            },
                            ,
                            {
                              name: "levelUp",
                              bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-B"),
                              exec: function(editor) {
                                editor.navigateLevelUp();
                              }
                            },
                            {
                              name: "levelDown",
                              bindKey: bindKey("Right", "Right|Ctrl-F"),
                              exec: function(editor) {
                                editor.navigateLevelDown();
                              }
                            },
                            {
                              name: "goToStart",
                              editorKey: bindKey("Ctrl-Home", "Ctrl-Home"),
                              bindKey: bindKey("Home|Ctrl-Home", "Home|Ctrl-Home"),
                              exec: function(editor) {
                                editor.navigateStart();
                              }
                            },
                            {
                              name: "goToEnd",
                              editorKey: bindKey("Ctrl-End", "Ctrl-End"),
                              bindKey: bindKey("End|Ctrl-End", "End|Ctrl-End"),
                              exec: function(editor) {
                                editor.navigateEnd();
                              }
                            },
                            {
                              name: "closeAllFromSelected",
                              bindKey: bindKey("Ctrl-Left", "Ctrl-Left"),
                              exec: function(ed) {
                                ed.provider.close(ed.selection.getCursor(), true);
                              }
                            },
                            {
                              name: "openAllFromSelected",
                              bindKey: bindKey("Ctrl-Right", "Ctrl-Right"),
                              exec: function(ed) {
                                ed.provider.open(ed.selection.getCursor(), true);
                              }
                            },
                            {
                              name: "pageup",
                              bindKey: "Option-PageUp",
                              exec: function(editor) {
                                editor.scrollPageUp();
                              }
                            },
                            {
                              name: "gotopageup",
                              bindKey: "PageUp",
                              exec: function(editor) {
                                editor.gotoPageUp();
                              }
                            },
                            {
                              name: "pagedown",
                              bindKey: "Option-PageDown",
                              exec: function(editor) {
                                editor.scrollPageDown();
                              }
                            },
                            {
                              name: "gotopageDown",
                              bindKey: "PageDown",
                              exec: function(editor) {
                                editor.gotoPageDown();
                              }
                            },
                            {
                              name: "scrollup",
                              bindKey: bindKey("Ctrl-Up", null),
                              exec: function(e) {
                                e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                              }
                            },
                            {
                              name: "scrolldown",
                              bindKey: bindKey("Ctrl-Down", null),
                              exec: function(e) {
                                e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                              }
                            },
                            {
                              name: "insertstring",
                              exec: function(e, args) {
                                e.insertSting(args);
                              }
                            },
                            {
                              name: "goUp",
                              bindKey: bindKey("Up", "Up|Ctrl-P"),
                              exec: function(editor) {
                                editor.selection.moveSelection(-1);
                              }
                            },
                            {
                              name: "goDown",
                              bindKey: bindKey("Down", "Down|Ctrl-N"),
                              exec: function(editor) {
                                editor.selection.moveSelection(1);
                              }
                            },
                            {
                              name: "selectUp",
                              bindKey: bindKey("Shift-Up", "Shift-Up"),
                              exec: function(editor) {
                                editor.selection.moveSelection(-1, true);
                              }
                            },
                            {
                              name: "selectDown",
                              bindKey: bindKey("Shift-Down", "Shift-Down"),
                              exec: function(editor) {
                                editor.selection.moveSelection(1, true);
                              }
                            },
                            {
                              name: "selectToUp",
                              bindKey: bindKey("Ctrl-Up", "Ctrl-Up"),
                              exec: function(editor) {
                                editor.selection.moveSelection(-1, false, true);
                              }
                            },
                            {
                              name: "selectToDown",
                              bindKey: bindKey("Ctrl-Down", "Ctrl-Down"),
                              exec: function(editor) {
                                editor.selection.moveSelection(1, false, true);
                              }
                            },
                            {
                              name: "selectMoreUp",
                              bindKey: bindKey("Ctrl-Shift-Up", "Ctrl-Shift-Up"),
                              exec: function(editor) {
                                editor.selection.moveSelection(-1, true, true);
                              }
                            },
                            {
                              name: "selectMoreDown",
                              bindKey: bindKey("Ctrl-Shift-Down", "Ctrl-Shift-Down"),
                              exec: function(editor) {
                                editor.selection.moveSelection(1, true, true);
                              }
                            },
                            {
                              name: "rename",
                              bindKey: "F2",
                              exec: function(tree) {
                                tree.edit && tree.edit.startRename();
                              }
                            },
                            {
                              name: "chose",
                              bindKey: "Enter",
                              exec: function(tree) {
                                tree._emit("afterChoose");
                              }
                            },
                            {
                              name: "delete",
                              bindKey: "Delete",
                              exec: function(tree) {
                                tree._emit("delete");
                              }
                            },
                            {
                              name: "foldOther",
                              bindKey: bindKey("Alt-0", "Command-Option-0"),
                              exec: function(tree) {
                                tree.provider.close(tree.provider.root, true);
                                tree.reveal(tree.selection.getCursor());
                              }
                            }
                          ];
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    614: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "no use strict";
                          var lang = __webpack_require__2(955);
                          var oop = __webpack_require__2(645);
                          var net = __webpack_require__2(552);
                          var AppConfig = __webpack_require__2(845).o;
                          module3.exports = exports3 = new AppConfig();
                          var global = /* @__PURE__ */ function() {
                            return this;
                          }();
                          var options = {
                            packaged: false,
                            workerPath: null,
                            modePath: null,
                            themePath: null,
                            basePath: "",
                            suffix: ".js",
                            $moduleUrls: {}
                          };
                          exports3.get = function(key) {
                            if (!options.hasOwnProperty(key))
                              throw new Error("Unknown config key: " + key);
                            return options[key];
                          };
                          exports3.set = function(key, value) {
                            if (!options.hasOwnProperty(key))
                              throw new Error("Unknown config key: " + key);
                            options[key] = value;
                          };
                          exports3.all = function() {
                            return lang.copyObject(options);
                          };
                          exports3.moduleUrl = function(name, component) {
                            if (options.$moduleUrls[name])
                              return options.$moduleUrls[name];
                            var parts = name.split("/");
                            component = component || parts[parts.length - 2] || "";
                            var base = parts[parts.length - 1].replace(component, "").replace(/(^[\-_])|([\-_]$)/, "");
                            if (!base && parts.length > 1)
                              base = parts[parts.length - 2];
                            var path = options[component + "Path"];
                            if (path == null)
                              path = options.basePath;
                            if (path && path.slice(-1) != "/")
                              path += "/";
                            return path + component + "-" + base + this.get("suffix");
                          };
                          exports3.setModuleUrl = function(name, subst) {
                            return options.$moduleUrls[name] = subst;
                          };
                          exports3.$loading = {};
                          exports3.loadModule = function(moduleName, onLoad) {
                            debugger;
                          };
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    768: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          exports3.isDark = false;
                          exports3.cssClass = "ace_tree-light";
                          exports3.cssText = __webpack_require__2(28);
                          var dom = __webpack_require__2(435);
                          dom.importCssString(exports3.cssText, exports3.cssClass);
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    950: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var Scrollable = __webpack_require__2(541);
                          var dom = __webpack_require__2(435);
                          var escapeHTML = __webpack_require__2(955).escapeHTML;
                          var DataProvider = function(root) {
                            this.rowHeight = 25;
                            this.setRoot(root);
                          };
                          (function() {
                            this.rowHeight = void 0;
                            this.rowHeightInner = void 0;
                            this.$indentSize = 10;
                            oop.implement(this, Scrollable);
                            this.$sortNodes = true;
                            this.setRoot = function(root) {
                              if (Array.isArray(root))
                                root = {
                                  items: root
                                };
                              this.root = root || {};
                              if (this.root.$depth == void 0) {
                                this.root.$depth = -1;
                              }
                              if (this.root.$depth < 0) {
                                this.visibleItems = [];
                                this.open(this.root);
                                this.visibleItems.unshift();
                              } else {
                                this.visibleItems = [
                                  this.root
                                ];
                              }
                              this.$selectedNode = this.root;
                              this._signal("setRoot");
                              this._signal("change");
                            };
                            this.open = this.expand = function(node, deep, silent) {
                              if (typeof deep != "number")
                                deep = deep ? 100 : 0;
                              if (!node)
                                return;
                              var items = this.visibleItems;
                              if (this.isOpen(node) && (node !== this.root || items.length))
                                return;
                              var ch = this.getChildren(node);
                              if (this.loadChildren && this.shouldLoadChildren(node, ch)) {
                                var timer = setTimeout(function() {
                                  node.status = "loading";
                                  this._signal("change", node);
                                }.bind(this), 100);
                                this.loadChildren(node, function(err, ch2) {
                                  clearTimeout(timer);
                                  this.collapse(node, null, true);
                                  node.status = "loaded";
                                  if (!err)
                                    this.expand(node, null, false);
                                }.bind(this));
                                this.setOpen(node, true);
                                return;
                              }
                              this.setOpen(node, true);
                              var i = items.indexOf(node);
                              if (!ch) {
                                this._signal("change", node);
                                return;
                              }
                              if (i === -1 && items.length || this.forceEmpty)
                                return;
                              ch = [
                                i + 1,
                                0
                              ].concat(ch);
                              items.splice.apply(items, ch);
                              for (var j = 2; j < ch.length; j++) {
                                var childNode = ch[j];
                                if (this.isOpen(childNode)) {
                                  this.setOpen(childNode, false);
                                  this.open(childNode, deep - 1, silent);
                                } else if (deep > 0) {
                                  this.open(childNode, deep - 1, silent);
                                }
                              }
                              this.rows = items.length;
                              silent || this._signal("expand", node);
                            };
                            this.close = this.collapse = function(node, deep, silent) {
                              if (typeof deep != "number")
                                deep = deep ? 1e3 : 0;
                              var items = this.visibleItems;
                              var isRoot = node === this.root;
                              if (isRoot) {
                                this.setOpen(node, false);
                                if (deep) {
                                  for (var i = 0; i < items.length; i++) {
                                    var ch = items[i];
                                    if (!ch.isRoot) {
                                      if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                                        this.setOpen(ch, false);
                                        silent || this._signal("collapse", ch);
                                      }
                                    }
                                  }
                                }
                                items.length = 0;
                                if (isRoot)
                                  this.open(this.root, 0, silent);
                                return;
                              }
                              if (!node || !this.isOpen(node))
                                return;
                              var i = items.indexOf(node);
                              if (i === -1)
                                return;
                              var thisDepth = node.$depth;
                              var deletecount = 0;
                              for (var t = i + 1; t < items.length; t++) {
                                if (items[t].$depth > thisDepth)
                                  deletecount++;
                                else
                                  break;
                              }
                              if (deep) {
                                for (var j = 0; j < deletecount; j++) {
                                  var ch = items[j + i];
                                  if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                                    this.setOpen(ch, false);
                                    silent || this._signal("collapse", ch);
                                  }
                                }
                              }
                              items.splice(i + 1, deletecount);
                              this.setOpen(node, false);
                              silent || this._signal("collapse", node);
                              if (isRoot)
                                this.open(this.root, 0, silent);
                            };
                            this.toggleNode = function(node, deep, silent) {
                              if (node && this.isOpen(node))
                                this.close(node, deep, silent);
                              else
                                this.open(node, deep, silent);
                            };
                            this.sort = function(children, compare) {
                              if (!compare) {
                                compare = alphanumCompare;
                              }
                              return children.sort(function(a, b) {
                                var aChildren = a.children || a.map;
                                var bChildren = b.children || b.map;
                                if (aChildren && !bChildren)
                                  return -1;
                                if (!aChildren && bChildren)
                                  return 1;
                                return compare(a.label || "", b.label || "");
                              });
                            };
                            this.setFilter = function(fn) {
                              this.$filterFn = fn;
                              this.setRoot(this.root);
                            };
                            this.getChildren = function(node) {
                              var children = node.children;
                              if (!children) {
                                if (node.status === "pending")
                                  return;
                                if (node.map) {
                                  children = Object.keys(node.map).map(function(key) {
                                    var ch2 = node.map[key];
                                    ch2.parent = node;
                                    return ch2;
                                  });
                                } else if (node.items) {
                                  children = node.items;
                                }
                                if (children) {
                                  node.children = children;
                                }
                              }
                              var ch = children && children[0] && children[0];
                              if (ch) {
                                var d = node.$depth + 1 || 0;
                                children.forEach(function(n) {
                                  n.$depth = d;
                                  n.parent = node;
                                });
                              }
                              if (this.$filterFn) {
                                children = children && children.filter(this.$filterFn);
                              }
                              if (this.$sortNodes && !node.$sorted) {
                                children && this.sort(children);
                              }
                              return children;
                            };
                            this.loadChildren = null;
                            this.shouldLoadChildren = function(node, ch) {
                              return node.status === "pending";
                            };
                            this.hasChildren = function(node) {
                              if (node.children)
                                return node.children.length !== 0;
                              return node.map || node.status === "pending" || node.items && node.items.length;
                            };
                            this.findNodeByPath = function() {
                            };
                            this.getSibling = function(node, dir) {
                              if (!dir)
                                dir = 1;
                              var parent = node.parent;
                              var ch = this.getChildren(parent);
                              var pos = ch.indexOf(node);
                              return ch[pos + dir];
                            };
                            this.getNodeAtIndex = function(i) {
                              return this.visibleItems[i];
                            };
                            this.getIndexForNode = function(node) {
                              return this.visibleItems.indexOf(node);
                            };
                            this.getMinIndex = function() {
                              return 0;
                            };
                            this.getMaxIndex = function() {
                              return this.visibleItems.length - 1;
                            };
                            this.setOpen = function(node, val) {
                              return node.isOpen = val;
                            };
                            this.isOpen = function(node) {
                              return node.isOpen;
                            };
                            this.isVisible = function(node) {
                              return this.visibleItems.indexOf(node) !== -1;
                            };
                            this.isSelected = function(node) {
                              return node.isSelected;
                            };
                            this.setSelected = function(node, val) {
                              return node.isSelected = !!val;
                            };
                            this.isSelectable = function(node) {
                              return !node || !(node.noSelect || node.$depth < 0);
                            };
                            this.isAncestor = function(node, child) {
                              do {
                                if (child == node)
                                  return true;
                              } while (child = child.parent);
                              return false;
                            };
                            this.setAttribute = function(node, name, value) {
                              node[name] = value;
                              this._signal("change", node);
                            };
                            this.getDataRange = function(rows, columns, callback) {
                              var view = this.visibleItems.slice(rows.start, rows.start + rows.length);
                              callback(null, view, false);
                              return view;
                            };
                            this.getRange = function(top, bottom) {
                              var start = Math.floor(top / this.rowHeight);
                              var end = Math.ceil(bottom / this.rowHeight) + 1;
                              var range = this.visibleItems.slice(start, end);
                              range.count = start;
                              range.size = this.rowHeight * range.count;
                              return range;
                            };
                            this.getTotalHeight = function(top, bottom) {
                              return this.rowHeight * this.visibleItems.length;
                            };
                            this.getNodePosition = function(node) {
                              var i = this.visibleItems.indexOf(node);
                              if (i == -1 && node && node.parent) {
                                i = this.visibleItems.indexOf(node.parent);
                              }
                              var top = i * this.rowHeight;
                              var height = this.rowHeight;
                              return {
                                top,
                                height
                              };
                            };
                            this.findItemAtOffset = function(offset, clip) {
                              var index = Math.floor(offset / this.rowHeight);
                              if (clip)
                                index = Math.min(Math.max(0, index), this.visibleItems.length - 1);
                              return this.visibleItems[index];
                            };
                            this.getIconHTML = function(node) {
                              return "";
                            };
                            this.getClassName = function(node) {
                              return (node.className || "") + (node.status == "loading" ? " loading" : "");
                            };
                            this.setClass = function(node, name, include) {
                              node.className = node.className || "";
                              dom.setCssClass(node, name, include);
                              this._signal("changeClass");
                            };
                            this.redrawNode = null;
                            this.getCaptionHTML = function(node) {
                              return escapeHTML(node.label || node.name || (typeof node == "string" ? node : ""));
                            };
                            this.getContentHTML = null;
                            this.getEmptyMessage = function() {
                              return this.emptyMessage || "";
                            };
                            this.getText = function(node) {
                              return node.label || node.name || "";
                            };
                            this.getRowIndent = function(node) {
                              return node.$depth;
                            };
                            this.hideAllNodes = function() {
                              this.visibleItems = [];
                              this.forceEmpty = true;
                              this.setRoot(this.root);
                            };
                            this.showAllNodes = function() {
                              this.forceEmpty = false;
                              this.setRoot(this.root);
                            };
                          }).call(DataProvider.prototype);
                          function alphanumCompare(a, b) {
                            var caseOrder = 0;
                            for (var x = 0, l = Math.min(a.length, b.length); x < l; x++) {
                              var ch1 = a.charCodeAt(x);
                              var ch2 = b.charCodeAt(x);
                              if (ch1 < 58 && ch2 < 58 && ch1 > 47 && ch2 > 47) {
                                var num1 = 0, num2 = 0;
                                var n = x;
                                do {
                                  num1 = 10 * num1 + (ch1 - 48);
                                  ch1 = a.charCodeAt(++n);
                                } while (ch1 > 47 && ch1 < 58);
                                n = x;
                                do {
                                  num2 = 10 * num2 + (ch2 - 48);
                                  ch2 = b.charCodeAt(++n);
                                } while (ch2 > 47 && ch2 < 58);
                                if (num1 === num2)
                                  x = n - 1;
                                else
                                  return num1 - num2;
                              } else if (ch1 !== ch2) {
                                var ch1L = a[x].toLowerCase();
                                var ch2L = b[x].toLowerCase();
                                if (ch1L < ch2L)
                                  return -1;
                                if (ch1L > ch2L)
                                  return 1;
                                if (!caseOrder)
                                  caseOrder = ch2 - ch1;
                              }
                            }
                            return caseOrder || a.length - b.length;
                          }
                          DataProvider.alphanumCompare = alphanumCompare;
                          DataProvider.prototype.alphanumCompare = alphanumCompare;
                          DataProvider.variableHeightRowMixin = function() {
                            var reset = function() {
                              this.$cachedTotalHeight = 0;
                            }.bind(this);
                            this.on("collapse", reset);
                            this.on("expand", reset);
                            this.getNodePosition = function(node) {
                              var i = this.visibleItems.indexOf(node);
                              if (i == -1 && node && node.parent) {
                                i = this.visibleItems.indexOf(node.parent);
                              }
                              var items = this.visibleItems;
                              var top = 0, height = 0;
                              for (var index = 0; index < i; index++) {
                                height = this.getItemHeight(items[index], index);
                                top += height;
                              }
                              height = this.getItemHeight(items[i], i);
                              return {
                                top,
                                height
                              };
                            };
                            this.findIndexAtOffset = function(offset, clip) {
                              var items = this.visibleItems;
                              var top = 0, index = 0, l = items.length;
                              while (index < l) {
                                var height = this.getItemHeight(items[index], index);
                                top += height;
                                index++;
                                if (top >= offset) {
                                  index--;
                                  top -= height;
                                  break;
                                }
                              }
                              if (clip)
                                index = Math.min(Math.max(0, index), items.length - 1);
                              return index;
                            };
                            this.findItemAtOffset = function(offset, clip) {
                              var index = this.findIndexAtOffset(offset, clip);
                              return this.visibleItems[index];
                            };
                            this.getItemHeight = function(node, index) {
                              return node.height || this.rowHeight;
                            };
                            this.getRange = function(top, bottom) {
                              var items = this.visibleItems;
                              var startH = 0, index = 0, l = items.length;
                              while (index < l) {
                                var height = this.getItemHeight(items[index], index);
                                startH += height;
                                index++;
                                if (startH >= top) {
                                  index--;
                                  startH -= height;
                                  break;
                                }
                              }
                              index = Math.min(Math.max(0, index), items.length - 1);
                              var start = index;
                              var end = this.findIndexAtOffset(bottom, true) + 1;
                              var range = this.visibleItems.slice(start, end);
                              range.count = start;
                              range.size = startH;
                              return range;
                            };
                            this.getTotalHeight = function() {
                              if (!this.$cachedTotalHeight) {
                                var items = this.visibleItems;
                                var height = 0;
                                for (var index = 0; index < items.length; index++) {
                                  height += this.getItemHeight(items[index], index);
                                }
                                this.$cachedTotalHeight = height;
                              }
                              return this.$cachedTotalHeight;
                            };
                          };
                          module3.exports = DataProvider;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    365: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var dom = __webpack_require__2(435);
                          var lang = __webpack_require__2(955);
                          var escapeHTML = lang.escapeHTML;
                          var EventEmitter = __webpack_require__2(366).b;
                          var Cells = function(parentEl) {
                            this.element = dom.createElement("div");
                            this.element.className = "ace_tree_layer ace_tree_cell-layer";
                            parentEl.appendChild(this.element);
                          };
                          (function() {
                            oop.implement(this, EventEmitter);
                            this.config = {}, this.setDataProvider = function(provider) {
                              this.provider = provider;
                              if (provider)
                                this.update = provider.renderRow ? this.$customUpdate : this.$treeModeUpdate;
                            };
                            this.update = function(config) {
                            };
                            this.measureSizes = function() {
                              var domNode = this.element.firstChild;
                              if (domNode) {
                                this.provider.rowHeight = domNode.offsetHeight;
                                this.provider.rowHeightInner = domNode.clientHeight;
                              }
                            };
                            this.$treeModeUpdate = function(config) {
                              this.config = config;
                              var provider = this.provider;
                              var row, html = [], view = config.view, datarow;
                              var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                              var hsize = "auto;", vsize = provider.rowHeightInner || provider.rowHeight;
                              for (row = firstRow; row < lastRow; row++) {
                                datarow = view[row - firstRow];
                                if (provider.getItemHeight)
                                  vsize = provider.getItemHeight(datarow, row);
                                this.$renderRow(html, datarow, vsize, hsize, row);
                              }
                              if (firstRow <= 0 && lastRow <= 0) {
                                this.renderPlaceHolder(provider, html, config);
                              }
                              this.element.innerHTML = html.join("");
                              if (!vsize) {
                                this.measureSizes();
                              }
                            };
                            this.columnNode = function(datarow, column) {
                              return "<span class='tree-column " + (column.className || "") + "' style='" + (datarow.fullWidth ? "" : "width:" + column.$width + ";") + "'>";
                            };
                            this.getRowClass = function(datarow, row) {
                              var provider = this.provider;
                              return "tree-row " + (provider.isSelected(datarow) ? "selected " : "") + (provider.getClassName(datarow) || "") + (row & 1 ? " odd" : " even");
                            };
                            this.$renderRow = function(html, datarow, vsize, hsize, row) {
                              var provider = this.provider;
                              var columns = provider.columns;
                              var indent = provider.$indentSize;
                              html.push("<div style='height:" + vsize + "px;" + (columns ? "padding-right:" + columns.$fixedWidth : "") + "' class='" + this.getRowClass(datarow, row) + "'>");
                              if (!columns || columns[0].type == "tree") {
                                if (columns) {
                                  html.push(this.columnNode(datarow, columns[0], row));
                                }
                                var depth = provider.getRowIndent(datarow);
                                html.push((depth ? "<span style='width:" + depth * indent + "px' class='tree-indent'></span>" : "") + "<span class='toggler " + (provider.hasChildren(datarow) ? provider.isOpen(datarow) ? "open" : "closed" : "empty") + "'></span>" + (provider.getCheckboxHTML ? provider.getCheckboxHTML(datarow) : "") + provider.getIconHTML(datarow) + (provider.getContentHTML ? provider.getContentHTML(datarow) : "<span class='caption' style='width: " + hsize + "px;height: " + vsize + "px'>" + provider.getCaptionHTML(datarow) + "</span>"));
                              }
                              if (columns) {
                                for (var col = columns[0].type == "tree" ? 1 : 0; col < columns.length; col++) {
                                  var column = columns[col];
                                  var rowStr = column.getHTML ? column.getHTML(datarow) : escapeHTML(column.getText(datarow) + "");
                                  html.push("</span>" + this.columnNode(datarow, column, row) + rowStr);
                                }
                                html.push("</span>");
                              }
                              html.push("</div>");
                            };
                            this.$customUpdate = function(config) {
                              this.config = config;
                              var provider = this.provider;
                              var html = [];
                              var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                              for (var row = firstRow; row < lastRow; row++) {
                                provider.renderRow(row, html, config);
                              }
                              if (firstRow <= 0 && lastRow <= 0) {
                                this.renderPlaceHolder(provider, html, config);
                              }
                              this.element.innerHTML = html.join("");
                            };
                            this.updateClasses = function(config) {
                              if (this.update == this.$customUpdate && !this.provider.updateNode)
                                return this.update(config);
                              this.config = config;
                              var provider = this.provider;
                              var row, view = config.view, datarow;
                              var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                              var children = this.element.children;
                              if (children.length != lastRow - firstRow)
                                return this.update(config);
                              for (row = firstRow; row < lastRow; row++) {
                                datarow = view[row - firstRow];
                                var el = children[row - firstRow];
                                el.className = this.getRowClass(datarow, row);
                                if (provider.redrawNode)
                                  provider.redrawNode(el, datarow);
                              }
                            };
                            this.scroll = function(config) {
                              return this.update(config);
                              this.element.insertAdjacentHTML("afterBegin", "<span>a</span><s>r</s>");
                              this.element.insertAdjacentHTML("beforeEnd", "<span>a</span><s>r</s>");
                            };
                            this.updateRows = function(config, firstRow, lastRow) {
                            };
                            this.destroy = function() {
                            };
                            this.getDomNodeAtIndex = function(i) {
                              return this.element.children[i - this.config.firstRow];
                            };
                            this.renderPlaceHolder = function(provider, html, config) {
                              if (provider.renderEmptyMessage) {
                                provider.renderEmptyMessage(html, config);
                              } else if (provider.getEmptyMessage) {
                                html.push("<div class='message empty'>", escapeHTML(provider.getEmptyMessage()), "</div>");
                              }
                            };
                          }).call(Cells.prototype);
                          exports3.Cells = Cells;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    86: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var dom = __webpack_require__2(435);
                          var lang = __webpack_require__2(955);
                          var EventEmitter = __webpack_require__2(366).b;
                          var RESIZER_WIDTH = 3;
                          function getColumnText(node) {
                            return node[this.value] || this.defaultValue || "";
                          }
                          function ColumnHeader(parentEl, renderer) {
                            this.element = dom.createElement("div");
                            parentEl.appendChild(this.element);
                            this.element.className = "tree-headings";
                            this.visible = false;
                          }
                          (function() {
                            this.minWidth = 25;
                            this.update = function() {
                              if (!this.provider || !this.visible)
                                return;
                              var columns = this.provider.columns;
                              var html = [];
                              for (var i = 0; i < columns.length; i++) {
                                var col = columns[i];
                                html.push("<span class='tree-column " + (col.className || "") + "' style='width:" + col.$width + ";height:'>" + col.caption + "</span><span class='tree-column-resizer' ></span>");
                              }
                              this.element.style.paddingRight = columns.$fixedWidth;
                              this.element.innerHTML = html.join("");
                            };
                            this.setDataProvider = function(provider) {
                              this.provider = provider;
                              if (!provider)
                                return;
                              var columns = this.provider.columns;
                              if (!columns) {
                                this.visible = false;
                                return;
                              }
                              this.visible = true;
                              var fixedWidth = 0;
                              columns.forEach(function(col, i) {
                                col.index = i;
                                if (col.value && !col.getText)
                                  col.getText = getColumnText;
                                var w = col.width;
                                if (typeof w == "string" && w.slice(-1) == "%") {
                                  col.flex = parseInt(w, 10) / 100;
                                  col.$width = col.width;
                                } else {
                                  col.width = parseInt(w, 10) || this.minWidth;
                                  fixedWidth += col.width;
                                  col.$width = col.width + "px";
                                }
                                col.pixelWidth = 0;
                              }, this);
                              columns.fixedWidth = fixedWidth;
                              columns.$fixedWidth = fixedWidth + "px";
                              columns.width = null;
                              provider.columns = columns;
                            };
                            this.updateWidth = function(width) {
                              if (!this.provider || !this.visible)
                                return;
                              var columns = this.provider.columns;
                              var fixedWidth = 0;
                              columns.width = width;
                              columns.forEach(function(col) {
                                if (!col.flex) {
                                  fixedWidth += col.width;
                                }
                              });
                              var flexWidth = width - fixedWidth;
                              columns.forEach(function(col) {
                                if (col.flex) {
                                  col.pixelWidth = flexWidth * col.flex;
                                  col.$width = col.flex * 100 + "%";
                                } else {
                                  col.pixelWidth = col.width;
                                  col.$width = col.width + "px";
                                }
                              });
                              columns.fixedWidth = fixedWidth;
                              columns.$fixedWidth = fixedWidth + "px";
                            };
                            this.changeColumnWidth = function(changedColumn, dw, total) {
                              this.updateWidth(total);
                              var columns = this.provider.columns;
                              var minWidth = this.minWidth;
                              if (!dw)
                                return;
                              var index = columns.indexOf(changedColumn);
                              var col, nextCol, prevCol;
                              for (var i = index + 1; i < columns.length; i++) {
                                col = columns[i];
                                if (Math.floor(col.pixelWidth) > minWidth || dw < 0) {
                                  if (col.flex) {
                                    nextCol = col;
                                    break;
                                  } else if (!nextCol) {
                                    nextCol = col;
                                  }
                                }
                              }
                              for (var i = index; i >= 0; i--) {
                                col = columns[i];
                                if (Math.floor(col.pixelWidth) > minWidth || dw > 0) {
                                  if (col.flex) {
                                    prevCol = col;
                                    break;
                                  } else if (!prevCol) {
                                    prevCol = col;
                                    if (col == changedColumn)
                                      break;
                                  }
                                }
                              }
                              if (!prevCol || !nextCol)
                                return;
                              if (nextCol.pixelWidth - dw < minWidth)
                                dw = nextCol.pixelWidth - minWidth;
                              if (prevCol.pixelWidth + dw < minWidth)
                                dw = minWidth - prevCol.pixelWidth;
                              nextCol.pixelWidth -= dw;
                              prevCol.pixelWidth += dw;
                              if (!nextCol.flex)
                                columns.fixedWidth -= dw;
                              if (!prevCol.flex)
                                columns.fixedWidth += dw;
                              var flexWidth = total - columns.fixedWidth;
                              columns.forEach(function(col2) {
                                if (col2.flex) {
                                  col2.flex = col2.pixelWidth / flexWidth;
                                } else {
                                  col2.width = col2.pixelWidth;
                                }
                              });
                              this.updateWidth(total);
                            };
                            this.findColumn = function(x) {
                              var columns = this.provider.columns;
                              if (this.element.offsetWidth != columns.width)
                                this.updateWidth(this.element.offsetWidth);
                              var w = 0;
                              for (var i = 0; i < columns.length; i++) {
                                var column = columns[i];
                                w += column.pixelWidth;
                                if (x < w + RESIZER_WIDTH) {
                                  return {
                                    index: i,
                                    column,
                                    overResizer: x > w - RESIZER_WIDTH
                                  };
                                }
                              }
                            };
                          }).call(ColumnHeader.prototype);
                          exports3.ColumnHeader = ColumnHeader;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    611: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var dom = __webpack_require__2(435);
                          var Selection = function(parentEl, renderer) {
                            this.element = dom.createElement("div");
                            this.element.className = "ace_tree_layer ace_tree_selection-layer";
                            parentEl.appendChild(this.element);
                            this.renderer = renderer;
                            this.markerEl = null;
                            this.arrowEl = null;
                          };
                          (function() {
                            this.setDataProvider = function(provider) {
                              this.provider = provider;
                            };
                            this.update = function(config) {
                              if (!this.provider.markedFolder || this.provider.markedFolderType) {
                                this.markerEl && this.clearFolderMarker();
                              } else {
                                this.showFolderMarker(config);
                              }
                              if (!this.provider.markedFolder || !this.provider.markedFolderType) {
                                this.arrowEl && this.clearInsertionMarker();
                              } else {
                                this.showInsertionMarker(config);
                              }
                            };
                            this.showFolderMarker = function(config) {
                              this.config = config;
                              var provider = this.provider;
                              var node = provider.markedFolder;
                              var start = provider.getIndexForNode(node);
                              var items = provider.visibleItems;
                              var end = start + 1;
                              var depth = node.$depth;
                              while (items[end] && items[end].$depth > depth) {
                                end++;
                              }
                              end--;
                              if (start > config.lastRow || end < config.firstRow || start === end) {
                                return this.clearFolderMarker();
                              }
                              start++;
                              end++;
                              var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                              var left = (depth + 1) * provider.$indentSize;
                              var bottom = Math.min(end - config.firstRow, config.lastRow - config.firstRow + 2) * provider.rowHeight;
                              if (!this.markerEl) {
                                this.markerEl = dom.createElement("div");
                                this.markerEl.className = "dragHighlight";
                                this.element.appendChild(this.markerEl);
                              }
                              this.markerEl.style.top = top + "px";
                              this.markerEl.style.left = left + "px";
                              this.markerEl.style.right = "7px";
                              this.markerEl.style.height = bottom - top + "px";
                            };
                            this.showInsertionMarker = function(config) {
                              this.config = config;
                              var provider = this.provider;
                              var node = provider.markedFolder;
                              var type = this.provider.markedFolderType;
                              var start = provider.getIndexForNode(node);
                              var depth = node.$depth;
                              if (start > config.lastRow || start < config.firstRow) {
                                return this.clearInsertionMarker();
                              }
                              if (type == 1)
                                start++;
                              var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                              var left = (depth + 1) * provider.$indentSize;
                              if (!this.arrowEl) {
                                this.arrowEl = dom.createElement("div");
                                this.arrowEl.className = "dragArrow";
                                this.element.appendChild(this.arrowEl);
                              }
                              this.arrowEl.style.top = top + "px";
                              this.arrowEl.style.left = left + "px";
                              this.arrowEl.style.right = "7px";
                            };
                            this.clearFolderMarker = function() {
                              if (this.markerEl) {
                                this.markerEl.parentNode.removeChild(this.markerEl);
                                this.markerEl = null;
                              }
                            };
                            this.clearInsertionMarker = function() {
                              if (this.arrowEl) {
                                this.arrowEl.parentNode.removeChild(this.arrowEl);
                                this.arrowEl = null;
                              }
                            };
                            this.clear = function() {
                              this.clearFolderMarker();
                              this.clearInsertMarker();
                            };
                            this.destroy = function() {
                            };
                          }).call(Selection.prototype);
                          exports3.Selection = Selection;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    127: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var dom = __webpack_require__2(435);
                          var DRAG_OFFSET = 5;
                          function DefaultHandlers(mouseHandler) {
                            mouseHandler.$clickSelection = null;
                            var editor = mouseHandler.editor;
                            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                            editor.setDefaultHandler("mouseleave", this.onMouseLeave.bind(mouseHandler));
                            editor.setDefaultHandler("mousemove", this.onMouseMove.bind(mouseHandler));
                            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                            editor.setDefaultHandler("mouseup", this.onMouseUp.bind(mouseHandler));
                            editor.setDefaultHandler("click", this.onClick.bind(mouseHandler));
                            var exports4 = [
                              "dragMoveSelection",
                              "dragWait",
                              "dragWaitEnd",
                              "getRegion",
                              "updateHoverState"
                            ];
                            exports4.forEach(function(x) {
                              mouseHandler[x] = this[x];
                            }, this);
                          }
                          (function() {
                            function isTogglerClick(target) {
                              return dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                            }
                            this.onMouseMove = function(e) {
                              var editor = this.editor;
                              var node = e.getNode();
                              var title, provider = editor.provider;
                              if (!node) {
                                title = "";
                              } else if (provider.columns) {
                                var pos = e.getDocumentPosition();
                                var columnData = editor.renderer.$headingLayer.findColumn(pos.x);
                                title = columnData ? columnData.column.getText(node) : "";
                              } else {
                                title = provider.getTooltipText ? provider.getTooltipText(node) : provider.getText(node);
                              }
                              if (!editor.tooltip && editor.container.title != title)
                                editor.container.title = title;
                              this.updateHoverState(node);
                            };
                            this.onMouseLeave = function() {
                              this.updateHoverState(null);
                            };
                            this.updateHoverState = function(node) {
                              var provider = this.editor.provider;
                              if (node !== this.node && provider) {
                                if (this.node)
                                  provider.setClass(this.node, "hover", false);
                                this.node = node;
                                if (this.node)
                                  provider.setClass(this.node, "hover", true);
                              }
                            };
                            this.onMouseDown = function(ev) {
                              var editor = this.editor;
                              var provider = editor.provider;
                              ev.detail = 1;
                              this.mousedownEvent = ev;
                              this.delayedSelect = false;
                              this.isMousePressed = true;
                              var button = ev.getButton();
                              var selectedNodes = editor.selection.getSelectedNodes();
                              var isMultiSelect = selectedNodes.length > 1;
                              if (button !== 0 && isMultiSelect) {
                                return;
                              }
                              var node = ev.getNode();
                              this.$clickNode = node;
                              if (!node)
                                return;
                              var inSelection = provider.isSelected(node);
                              var target = ev.domEvent.target;
                              this.region = null;
                              if (isTogglerClick(target) || node.clickAction == "toggle") {
                                this.region = "toggler";
                                var toggleChildren = ev.getShiftKey();
                                var deep = ev.getAccelKey();
                                if (button === 0) {
                                  if (toggleChildren) {
                                    if (deep) {
                                      node = node.parent;
                                    }
                                    provider.close(node, true);
                                    provider.open(node);
                                  } else {
                                    provider.toggleNode(node, deep);
                                  }
                                }
                                this.$clickNode = null;
                              } else if (dom.hasCssClass(target, "checkbox")) {
                                var nodes = inSelection && editor.selection.getSelectedNodes();
                                provider._signal("toggleCheckbox", {
                                  target: node,
                                  selectedNodes: nodes
                                });
                                node.isChecked = !node.isChecked;
                                if (nodes) {
                                  nodes.forEach(function(n) {
                                    n.isChecked = node.isChecked;
                                  });
                                }
                                provider._signal(node.isChecked ? "check" : "uncheck", nodes || [
                                  node
                                ]);
                                provider._signal("change");
                              } else if (dom.hasCssClass(target, "icon-ok")) {
                                if (ev.getShiftKey()) {
                                  editor.selection.expandSelection(node, null, true);
                                } else {
                                  editor.selection.toggleSelect(node);
                                }
                              } else if (ev.getAccelKey()) {
                                if (inSelection && isMultiSelect)
                                  this.delayedSelect = "toggle";
                                else if (!inSelection || isMultiSelect)
                                  editor.selection.toggleSelect(node);
                              } else if (ev.getShiftKey()) {
                                editor.selection.expandSelection(node);
                              } else if (inSelection && isMultiSelect) {
                                if (!editor.isFocused())
                                  this.$clickNode = null;
                                else
                                  this.delayedSelect = true;
                              } else {
                                editor.selection.setSelection(node);
                              }
                              if (this.$clickNode)
                                editor.$mouseHandler.captureMouse(ev, "dragWait");
                              return ev.preventDefault();
                            };
                            this.onMouseUp = function(ev) {
                              if (this.isMousePressed == 2)
                                return;
                              this.isMousePressed = false;
                              var pos = ev.getDocumentPosition();
                              var node = this.editor.provider.findItemAtOffset(pos.y);
                              if (node && this.$clickNode && this.$clickNode == node) {
                                ev.button = ev.getButton();
                                ev.target = ev.domEvent.target;
                                ev.detail = this.mousedownEvent.detail;
                                this.onMouseEvent("click", ev);
                              }
                              this.$clickNode = this.mouseEvent = null;
                            };
                            this.onClick = function(ev) {
                              if (this.mousedownEvent.detail === 2) {
                                this.editor._emit("afterChoose");
                              }
                            };
                            this.onDoubleClick = function(ev) {
                              var provider = this.editor.provider;
                              if (provider.toggleNode && !isTogglerClick(ev.domEvent.target)) {
                                var node = ev.getNode();
                                if (node)
                                  provider.toggleNode(node);
                              }
                              if (this.mousedownEvent)
                                this.mousedownEvent.detail = 2;
                            };
                            this.dragMoveSelection = function() {
                              var editor = this.editor;
                              var ev = this.mouseEvent;
                              ev.$pos = ev.node = null;
                              var node = ev.getNode(true);
                              if (node != editor.selection.getCursor() && node) {
                                if (ev.getShiftKey()) {
                                  editor.selection.expandSelection(node, null, true);
                                } else {
                                  editor.selection.selectNode(node);
                                }
                                editor.renderer.scrollCaretIntoView();
                              }
                            };
                            this.dragWait = function() {
                              var ev = this.mousedownEvent;
                              if (Math.abs(this.x - ev.x) + Math.abs(this.y - ev.y) > DRAG_OFFSET) {
                                this.delayedSelect = false;
                                this.editor._emit("startDrag", ev);
                                if (this.state == "dragWait" && ev.getButton() === 0)
                                  this.setState("dragMoveSelection");
                              }
                            };
                            this.dragWaitEnd = function() {
                              if (this.delayedSelect) {
                                var selection = this.editor.selection;
                                if (this.$clickNode) {
                                  if (this.delayedSelect == "toggle")
                                    selection.toggleSelect(this.$clickNode);
                                  else
                                    selection.setSelection(this.$clickNode);
                                }
                                this.delayedSelect = false;
                              }
                            };
                            this.onMouseWheel = function(ev) {
                              if (ev.getShiftKey() || ev.getAccelKey())
                                return;
                              var t = ev.domEvent.timeStamp;
                              var dt = t - (this.$lastScrollTime || 0);
                              var editor = this.editor;
                              var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                              if (isScrolable || dt < 200) {
                                this.$lastScrollTime = t;
                                editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                return ev.stop();
                              }
                            };
                          }).call(DefaultHandlers.prototype);
                          exports3.DefaultHandlers = DefaultHandlers;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    513: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var event = __webpack_require__2(631);
                          var useragent = __webpack_require__2(943);
                          var DefaultHandlers = __webpack_require__2(127).DefaultHandlers;
                          var MouseEvent = __webpack_require__2(118).MouseEvent;
                          var config = __webpack_require__2(614);
                          var dom = __webpack_require__2(435);
                          function initDragHandlers(mouseHandler) {
                            var tree = mouseHandler.editor;
                            var UNFOLD_TIMEOUT = 500;
                            var WIDGET_UNFOLD_TIMEOUT = 500;
                            var AUTOSCROLL_DELAY = 300;
                            var MIN_DRAG_T = 500;
                            var dragInfo, x, y, dx, dy;
                            var scrollerRect;
                            mouseHandler.drag = function() {
                              var ev = this.mouseEvent;
                              if (!dragInfo || !ev)
                                return;
                              var node = ev.getNode();
                              dx = ev.x - x;
                              dy = ev.y - y;
                              x = ev.x;
                              y = ev.y;
                              var isInTree = isInRect(x, y, scrollerRect);
                              if (!isInTree) {
                                node = null;
                              }
                              if (dragInfo.isInTree != isInTree && dragInfo.selectedNodes) {
                                dragInfo.isInTree = isInTree;
                                ev.dragInfo = dragInfo;
                                tree._signal(isInTree ? "dragIn" : "dragOut", ev);
                              }
                              if (!isInTree) {
                                ev.dragInfo = dragInfo;
                                tree._signal("dragMoveOutside", ev);
                              }
                              if (dragInfo.el) {
                                dragInfo.el.style.top = ev.y - dragInfo.offsetY + "px";
                                dragInfo.el.style.left = ev.x - dragInfo.offsetX + "px";
                              }
                              var hoverNode = node;
                              if (hoverNode) {
                                var xOffset = x - scrollerRect.left;
                                var depth = Math.max(0, Math.floor(xOffset / tree.provider.$indentSize));
                                var depthDiff = hoverNode.$depth - depth;
                                while (depthDiff > 0 && hoverNode.parent) {
                                  depthDiff--;
                                  hoverNode = hoverNode.parent;
                                }
                                if (!hoverNode.isFolder && dragInfo.mode != "sort") {
                                  hoverNode = hoverNode.parent;
                                }
                              }
                              if (dragInfo.hoverNode !== hoverNode) {
                                if (dragInfo.hoverNode) {
                                  tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                                  tree._signal("folderDragLeave", dragInfo);
                                }
                                if (hoverNode && dragInfo.selectedNodes && dragInfo.selectedNodes.indexOf(hoverNode) != -1) {
                                  hoverNode = null;
                                }
                                dragInfo.hoverNode = hoverNode;
                                if (dragInfo.hoverNode) {
                                  tree._signal("folderDragEnter", dragInfo);
                                  if (dragInfo.mode !== "sort")
                                    tree.provider.setClass(dragInfo.hoverNode, "dropTarget", true);
                                }
                                highlightFolder(tree, dragInfo.hoverNode, dragInfo.insertPos);
                              }
                              var now = Date.now();
                              var target = ev.domEvent.target;
                              var isFoldWidget = target && dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                              var distance = Math.abs(dx) + Math.abs(dy);
                              var pos = ev.y - scrollerRect.top;
                              var rowHeight = tree.provider.rowHeight;
                              var renderer = tree.renderer;
                              var autoScrollMargin = 1.5 * rowHeight;
                              var scroll = pos - autoScrollMargin;
                              if (scroll > 0) {
                                scroll += -renderer.$size.scrollerHeight + 2 * autoScrollMargin;
                                if (scroll < 0)
                                  scroll = 0;
                              }
                              if (!scroll || !isInTree)
                                dragInfo.autoScroll = false;
                              if (distance <= 2) {
                                if (!dragInfo.stopTime)
                                  dragInfo.stopTime = now;
                              } else {
                                if (!isFoldWidget)
                                  dragInfo.stopTime = void 0;
                              }
                              var dt = now - dragInfo.stopTime;
                              if (scroll && isInTree) {
                                if (dt > AUTOSCROLL_DELAY || dragInfo.autoScroll) {
                                  tree.renderer.scrollBy(0, scroll / 2);
                                  dragInfo.autoScroll = true;
                                }
                              } else if (node && dragInfo.mode === "move") {
                                if (node.parent === tree.provider.root || node.isRoot || node.parent && node.parent.isRoot)
                                  isFoldWidget = false;
                                if (isFoldWidget && dt > WIDGET_UNFOLD_TIMEOUT && dt < 2 * WIDGET_UNFOLD_TIMEOUT) {
                                  tree.provider.toggleNode(node);
                                  dragInfo.stopTime = Infinity;
                                } else if (!isFoldWidget && dt > UNFOLD_TIMEOUT && dt < 2 * UNFOLD_TIMEOUT) {
                                  tree.provider.open(node);
                                  dragInfo.stopTime = Infinity;
                                }
                              }
                            };
                            mouseHandler.dragEnd = function(e, cancel) {
                              if (dragInfo) {
                                window.removeEventListener("mousedown", keyHandler, true);
                                window.removeEventListener("keydown", keyHandler, true);
                                window.removeEventListener("keyup", keyHandler, true);
                                if (dragInfo.el && dragInfo.el.parentNode)
                                  dragInfo.el.parentNode.removeChild(dragInfo.el);
                                if (dragInfo.hoverNode) {
                                  tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                                  tree._signal("folderDragLeave", dragInfo);
                                }
                                highlightFolder(tree, null);
                                if (tree.isFocused())
                                  tree.renderer.visualizeFocus();
                                tree.renderer.setStyle("dragOver", false);
                                dragInfo.target = dragInfo.hoverNode;
                                if (!cancel && dragInfo.selectedNodes && Date.now() - dragInfo.startT > MIN_DRAG_T)
                                  tree._emit("drop", dragInfo);
                                if (!dragInfo.isInTree) {
                                  if (cancel)
                                    dragInfo.selectedNodes = null;
                                  tree._signal("dropOutside", {
                                    dragInfo
                                  });
                                }
                                dragInfo = null;
                              }
                            };
                            mouseHandler.dragStart = function() {
                              if (dragInfo)
                                this.dragEnd(null, true);
                              mouseHandler.setState("drag");
                              tree.renderer.visualizeBlur();
                              tree.renderer.setStyle("dragOver", true);
                              scrollerRect = tree.renderer.scroller.getBoundingClientRect();
                              dragInfo = {};
                            };
                            tree.on("startDrag", function(ev) {
                              if (!tree.getOption("enableDragDrop"))
                                return;
                              var node = ev.getNode();
                              if (!node || ev.getButton())
                                return;
                              mouseHandler.dragStart();
                              window.addEventListener("mousedown", keyHandler, true);
                              window.addEventListener("keydown", keyHandler, true);
                              window.addEventListener("keyup", keyHandler, true);
                              var selectedNodes = tree.selection.getSelectedNodes();
                              var el = constructDragNode(node);
                              dragInfo = {
                                el,
                                node,
                                selectedNodes,
                                offsetX: 10,
                                offsetY: 10,
                                target: node,
                                startT: Date.now(),
                                isInTree: true,
                                mode: "move"
                              };
                              ev.dragInfo = dragInfo;
                              tree._signal("dragStarted", ev);
                              if (mouseHandler.state == "drag")
                                mouseHandler.drag();
                            });
                            function constructDragNode(node) {
                              var i = tree.provider.getIndexForNode(node);
                              var domNode = tree.renderer.$cellLayer.getDomNodeAtIndex(i);
                              if (!domNode)
                                return;
                              var offset = domNode.offsetHeight;
                              var selectedNodes = tree.selection.getSelectedNodes();
                              var el = document.createElement("div");
                              el.className = tree.container.className + " dragImage";
                              var ch = el.appendChild(domNode.cloneNode(true));
                              ch.removeChild(ch.firstChild);
                              ch.style.paddingRight = "5px";
                              ch.style.opacity = "0.8";
                              el.style.position = "absolute";
                              el.style.zIndex = "1000000";
                              el.style.pointerEvents = "none";
                              el.style.overflow = "visible";
                              if (selectedNodes.length > 1) {
                                ch.style.color = "transparent";
                                ch = el.appendChild(domNode.cloneNode(true));
                                ch.removeChild(ch.firstChild);
                                ch.style.paddingRight = "5px";
                                ch.style.top = -offset + 2 + "px";
                                ch.style.left = "2px";
                                ch.style.position = "relative";
                                ch.style.opacity = "0.8";
                              }
                              document.body.appendChild(el);
                              return el;
                            }
                            function keyHandler(e) {
                              if (dragInfo) {
                                if (e.keyCode === 27 || e.type == "mousedown") {
                                  mouseHandler.dragEnd(null, true);
                                  event.stopEvent(e);
                                } else if (dragInfo && e.keyCode == 17 || e.keyCode == 18) {
                                  dragInfo.isCopy = e.type == "keydown";
                                  dom.setCssClass(dragInfo.el, "copy", dragInfo.isCopy);
                                }
                              }
                            }
                          }
                          function highlightFolder(tree, node, type) {
                            tree.provider.markedFolder = node;
                            tree.provider.markedFolderType = type;
                            tree.renderer.$loop.schedule(tree.renderer.CHANGE_MARKER);
                          }
                          function isInRect(x, y, rect) {
                            if (x < rect.right && x > rect.left && y > rect.top && y < rect.bottom)
                              return true;
                          }
                          module3.exports = initDragHandlers;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    543: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var event = __webpack_require__2(631);
                          function HeadingHandler(mouseHandler) {
                            var editor = mouseHandler.editor;
                            var headingLayer = editor.renderer.$headingLayer;
                            event.addListener(headingLayer.element, "mousedown", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseDown"));
                            event.addListener(headingLayer.element, "mousemove", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseMove"));
                            var overResizer, dragStartPos, columnData;
                            editor.setDefaultHandler("headerMouseMove", function(e) {
                              if (dragStartPos || !editor.provider || !editor.provider.columns)
                                return;
                              var pos = e.getDocumentPosition();
                              var width = editor.renderer.$size.scrollerWidth;
                              if (width != editor.provider.columns.width)
                                headingLayer.updateWidth(width);
                              columnData = headingLayer.findColumn(pos.x);
                              overResizer = columnData && columnData.overResizer;
                              headingLayer.element.style.cursor = overResizer ? "ew-resize" : "default";
                            });
                            editor.setDefaultHandler("headerMouseDown", function(e) {
                              if (overResizer) {
                                var pos = e.getDocumentPosition();
                                dragStartPos = {
                                  x: pos.x
                                };
                                mouseHandler.setState("headerResize");
                                mouseHandler.captureMouse(e);
                                mouseHandler.mouseEvent = e;
                              }
                              e.stop();
                            });
                            mouseHandler.headerResize = function() {
                              if (this.mouseEvent && dragStartPos) {
                                var pos = this.mouseEvent.getDocumentPosition();
                                var dx = pos.x;
                                var columns = editor.renderer.provider.columns;
                                for (var i = 0; i < columns.length; i++) {
                                  var col = columns[i];
                                  dx -= col.pixelWidth;
                                  if (col === columnData.column)
                                    break;
                                }
                                var total = editor.renderer.$size.scrollerWidth;
                                headingLayer.changeColumnWidth(columnData.column, dx, total);
                                var renderer = editor.renderer;
                                renderer.updateFull();
                              }
                            };
                            mouseHandler.headerResizeEnd = function() {
                              dragStartPos = null;
                              headingLayer.element.style.cursor = "";
                              overResizer = false;
                            };
                          }
                          exports3.HeadingHandler = HeadingHandler;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    118: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var event = __webpack_require__2(631);
                          var useragent = __webpack_require__2(943);
                          var MouseEvent = exports3.MouseEvent = function(domEvent, editor) {
                            this.domEvent = domEvent;
                            this.editor = editor;
                            this.x = this.clientX = domEvent.clientX;
                            this.y = this.clientY = domEvent.clientY;
                            this.$pos = null;
                            this.$inSelection = null;
                            this.propagationStopped = false;
                            this.defaultPrevented = false;
                          };
                          (function() {
                            this.stopPropagation = function() {
                              event.stopPropagation(this.domEvent);
                              this.propagationStopped = true;
                            };
                            this.preventDefault = function() {
                              event.preventDefault(this.domEvent);
                              this.defaultPrevented = true;
                            };
                            this.stop = function() {
                              this.stopPropagation();
                              this.preventDefault();
                            };
                            this.getDocumentPosition = function() {
                              if (this.$pos)
                                return this.$pos;
                              this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                              return this.$pos;
                            };
                            this.inSelection = function() {
                              if (this.$inSelection !== null)
                                return this.$inSelection;
                              var node = this.getNode();
                              this.$inSelection = !!(node && node.isSelected);
                              return this.$inSelection;
                            };
                            this.node = null;
                            this.getNode = function(clip) {
                              if (this.node)
                                return this.node;
                              var pos = this.getDocumentPosition(clip);
                              if (!pos || !this.editor.provider)
                                return;
                              return this.node = this.editor.provider.findItemAtOffset(pos.y, clip);
                            };
                            this.getButton = function() {
                              return event.getButton(this.domEvent);
                            };
                            this.getShiftKey = function() {
                              return this.domEvent.shiftKey;
                            };
                            this.getAccelKey = useragent.isMac ? function() {
                              return this.domEvent.metaKey;
                            } : function() {
                              return this.domEvent.ctrlKey;
                            };
                          }).call(MouseEvent.prototype);
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    202: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var event = __webpack_require__2(631);
                          var useragent = __webpack_require__2(943);
                          var DefaultHandlers = __webpack_require__2(127).DefaultHandlers;
                          var initDragHandlers = __webpack_require__2(513);
                          var HeadingHandler = __webpack_require__2(543).HeadingHandler;
                          var MouseEvent = __webpack_require__2(118).MouseEvent;
                          var config = __webpack_require__2(614);
                          var MouseHandler = function(editor) {
                            this.editor = editor;
                            new DefaultHandlers(this);
                            new HeadingHandler(this);
                            initDragHandlers(this);
                            var mouseTarget = editor.renderer.getMouseEventTarget();
                            event.addListener(mouseTarget, "mousedown", function(e) {
                              editor.focus(true);
                              return event.preventDefault(e);
                            });
                            event.addListener(mouseTarget, "mousemove", this.onMouseEvent.bind(this, "mousemove"));
                            event.addListener(mouseTarget, "mouseup", this.onMouseEvent.bind(this, "mouseup"));
                            event.addMultiMouseDownListener(mouseTarget, [
                              300,
                              300,
                              250
                            ], this, "onMouseEvent");
                            event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [
                              300,
                              300,
                              250
                            ], this, "onMouseEvent");
                            event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [
                              300,
                              300,
                              250
                            ], this, "onMouseEvent");
                            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                            event.addListener(mouseTarget, "mouseout", this.onMouseEvent.bind(this, "mouseleave"));
                          };
                          (function() {
                            this.onMouseEvent = function(name, e) {
                              this.editor._emit(name, new MouseEvent(e, this.editor));
                            };
                            this.onMouseWheel = function(name, e) {
                              var mouseEvent = new MouseEvent(e, this.editor);
                              mouseEvent.speed = this.$scrollSpeed * 2;
                              mouseEvent.wheelX = e.wheelX;
                              mouseEvent.wheelY = e.wheelY;
                              this.editor._emit(name, mouseEvent);
                            };
                            this.setState = function(state) {
                              this.state = state;
                            };
                            this.captureMouse = function(ev, state) {
                              if (state)
                                this.setState(state);
                              this.x = ev.x;
                              this.y = ev.y;
                              this.isMousePressed = 2;
                              var renderer = this.editor.renderer;
                              if (renderer.$keepTextAreaAtCursor)
                                renderer.$keepTextAreaAtCursor = null;
                              var self2 = this;
                              var onMouseMove = function(e) {
                                self2.x = e.clientX;
                                self2.y = e.clientY;
                                self2.mouseEvent = new MouseEvent(e, self2.editor);
                                self2.$mouseMoved = true;
                              };
                              var onCaptureEnd = function(e) {
                                clearInterval(timerId);
                                onCaptureInterval();
                                self2[self2.state + "End"] && self2[self2.state + "End"](e);
                                self2.$clickSelection = null;
                                if (renderer.$keepTextAreaAtCursor == null) {
                                  renderer.$keepTextAreaAtCursor = true;
                                  renderer.$moveTextAreaToCursor();
                                }
                                self2.isMousePressed = false;
                                e && self2.onMouseEvent("mouseup", e);
                                self2.$onCaptureMouseMove = self2.releaseMouse = null;
                              };
                              var onCaptureInterval = function() {
                                self2[self2.state] && self2[self2.state]();
                                self2.$mouseMoved = false;
                              };
                              if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                                return setTimeout(function() {
                                  onCaptureEnd(ev.domEvent);
                                });
                              }
                              self2.$onCaptureMouseMove = onMouseMove;
                              self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                              var timerId = setInterval(onCaptureInterval, 20);
                            };
                            this.releaseMouse = null;
                          }).call(MouseHandler.prototype);
                          config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                            scrollSpeed: {
                              initialValue: 2
                            },
                            dragDelay: {
                              initialValue: 150
                            },
                            focusTimeout: {
                              initialValue: 0
                            },
                            enableDragDrop: {
                              initialValue: false
                            }
                          });
                          exports3.MouseHandler = MouseHandler;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    277: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var quickSearch = function(tree, str) {
                            var node = tree.selection.getCursor();
                            var siblings = tree.provider.getChildren(node.parent);
                            if (!siblings || siblings.length == 1) {
                              return;
                            }
                            var index = siblings.indexOf(node);
                            var newNode;
                            for (var i = index + 1; i < siblings.length; i++) {
                              node = siblings[i];
                              var label = node.label || node.name || "";
                              if (label[0] == str) {
                                newNode = node;
                                break;
                              }
                            }
                            if (!newNode) {
                              for (var i = 0; i < index; i++) {
                                node = siblings[i];
                                var label = node.label || node.name || "";
                                if (label[0] == str) {
                                  newNode = node;
                                  break;
                                }
                              }
                            }
                            if (newNode) {
                              tree.selection.selectNode(newNode);
                              tree.renderer.scrollCaretIntoView(newNode, 0.5);
                            }
                          };
                          module3.exports = quickSearch;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    541: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var EventEmitter = __webpack_require__2(366).b;
                          var scrollable = {};
                          (function() {
                            oop.implement(this, EventEmitter);
                            this.$scrollTop = 0;
                            this.getScrollTop = function() {
                              return this.$scrollTop;
                            };
                            this.setScrollTop = function(scrollTop) {
                              scrollTop = Math.round(scrollTop);
                              if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                                return;
                              this.$scrollTop = scrollTop;
                              this._signal("changeScrollTop", scrollTop);
                            };
                            this.$scrollLeft = 0;
                            this.getScrollLeft = function() {
                              return this.$scrollLeft;
                            };
                            this.setScrollLeft = function(scrollLeft) {
                              scrollLeft = Math.round(scrollLeft);
                              if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                                return;
                              this.$scrollLeft = scrollLeft;
                              this._signal("changeScrollLeft", scrollLeft);
                            };
                          }).call(scrollable);
                          module3.exports = scrollable;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    592: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var EventEmitter = __webpack_require__2(366).b;
                          var Selection = function(provider) {
                            this.provider = provider;
                            if (this.provider && !this.provider.selectedItems)
                              this.provider.selectedItems = [];
                            this.provider.on("remove", this.unselectRemoved = this.unselectRemoved.bind(this));
                          };
                          (function() {
                            oop.implement(this, EventEmitter);
                            this.$wrapAround = false;
                            this.getRange = function() {
                            };
                            this.selectAll = function() {
                              var sel = this.provider.selectedItems;
                              this.expandSelection(sel[0], sel[sel.length - 1]);
                              this._signal("change");
                            };
                            this.moveSelection = function(dir, select, add) {
                              var provider = this.provider;
                              var cursor = this.getCursor();
                              var anchor = this.getAnchor();
                              var i = provider.getIndexForNode(cursor);
                              if (!add) {
                                this.clear(true);
                              } else if (add && !select) {
                                this.unselectNode(cursor);
                              }
                              var min = provider.getMinIndex();
                              var max = provider.getMaxIndex();
                              var wrapped = false;
                              var newI = i;
                              do {
                                newI += dir;
                                if (newI < min) {
                                  newI = this.$wrapAround ? max : min;
                                  wrapped = true;
                                } else if (newI > max) {
                                  newI = this.$wrapAround ? min : max;
                                  wrapped = true;
                                }
                                var newNode = provider.getNodeAtIndex(newI);
                              } while (!wrapped && newNode && !provider.isSelectable(newNode));
                              if (!newNode || !provider.isSelectable(newNode))
                                newNode = cursor;
                              if (select) {
                                this.expandSelection(newNode, anchor, add);
                              } else {
                                this.selectNode(newNode, add);
                              }
                            };
                            this.getCursor = function() {
                              var sel = this.provider.selectedItems;
                              return sel.cursor || sel[sel.length - 1];
                            };
                            this.getAnchor = function() {
                              var sel = this.provider.selectedItems;
                              return sel.anchor || sel.cursor || sel[0];
                            };
                            this.getSelectedNodes = function() {
                              var sel = this.provider.selectedItems;
                              return sel.slice();
                            };
                            this.getVisibleSelectedNodes = function() {
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              return sel.filter(function(node) {
                                return provider.isVisible(node);
                              });
                            };
                            this.isEmpty = function() {
                              var sel = this.provider.selectedItems;
                              return sel.length === 0;
                            };
                            this.isMultiRow = function() {
                              var sel = this.provider.selectedItems;
                              return sel.length > 1;
                            };
                            this.toggleSelect = function(node) {
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              var i = sel.indexOf(node);
                              if (i != -1)
                                sel.splice(i, 1);
                              provider.setSelected(node, !provider.isSelected(node));
                              if (provider.isSelected(node)) {
                                sel.push(node);
                                sel.anchor = sel.cursor = node;
                              } else
                                sel.anchor = sel.cursor = sel[sel.length - 1];
                              this._signal("change");
                            };
                            this.selectNode = function(node, add, silent) {
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              if (!provider.isSelectable(node))
                                return;
                              if (!add)
                                this.clear(true);
                              if (node) {
                                var i = sel.indexOf(node);
                                if (i != -1)
                                  sel.splice(i, 1);
                                provider.setSelected(node, true);
                                if (provider.isSelected(node))
                                  sel.push(node);
                              }
                              sel.anchor = sel.cursor = node;
                              this._signal("change");
                            };
                            this.add = function(node) {
                              this.selectNode(node, true);
                            };
                            this.remove = function(node) {
                              if (this.provider.isSelected(node))
                                this.toggleSelect(node);
                            };
                            this.clear = this.clearSelection = function(silent) {
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              sel.forEach(function(node) {
                                provider.setSelected(node, false);
                              });
                              sel.splice(0, sel.length);
                              sel.anchor = sel.cursor;
                              silent || this._signal("change");
                            };
                            this.unselectNode = function(node, silent) {
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              var i = sel.indexOf(node);
                              if (i != -1) {
                                sel.splice(i, 1);
                                provider.setSelected(node, false);
                                if (sel.anchor == node)
                                  sel.anchor = sel[i - 1] || sel[i];
                                if (sel.cursor == node)
                                  sel.cursor = sel[i] || sel[i - 1];
                                silent || this._signal("change");
                              }
                            };
                            this.setSelection = function(nodes) {
                              if (Array.isArray(nodes)) {
                                this.clear(true);
                                nodes.forEach(function(node) {
                                  this.selectNode(node, true, true);
                                }, this);
                              } else
                                this.selectNode(nodes, false, true);
                            };
                            this.expandSelection = function(cursor, anchor, additive) {
                              anchor = anchor || this.getAnchor();
                              if (!additive)
                                this.clear(true);
                              var provider = this.provider;
                              var sel = provider.selectedItems;
                              var end = provider.getIndexForNode(cursor);
                              var start = provider.getIndexForNode(anchor || cursor);
                              if (end > start) {
                                for (var i = start; i <= end; i++) {
                                  var node = provider.getNodeAtIndex(i);
                                  var index = sel.indexOf(node);
                                  if (index != -1)
                                    sel.splice(index, 1);
                                  if (provider.isSelectable(node))
                                    provider.setSelected(node, true);
                                  sel.push(node);
                                }
                              } else {
                                for (var i = start; i >= end; i--) {
                                  var node = provider.getNodeAtIndex(i);
                                  var index = sel.indexOf(node);
                                  if (index != -1)
                                    sel.splice(index, 1);
                                  if (provider.isSelectable(node))
                                    provider.setSelected(node, true);
                                  sel.push(node);
                                }
                              }
                              sel.cursor = cursor;
                              sel.anchor = anchor;
                              this._signal("change");
                            };
                            this.unselectRemoved = function(toRemove) {
                              var sel = this.getSelectedNodes();
                              var provider = this.provider;
                              var changed, cursor = this.getCursor();
                              sel.forEach(function(n) {
                                if (provider.isAncestor(toRemove, n)) {
                                  changed = true;
                                  this.unselectNode(n, true);
                                }
                              }, this);
                              if (changed && !provider.isSelected(cursor)) {
                                var parent = toRemove.parent;
                                var ch = [];
                                if (parent && provider.isOpen(parent)) {
                                  ch = provider.getChildren(parent);
                                  var i = ch.indexOf(toRemove);
                                }
                                if (i == -1) {
                                  i = toRemove.index;
                                  var node = ch[i] || ch[i - 1] || parent;
                                } else {
                                  node = ch[i + 1] || ch[i - 1] || parent;
                                }
                                if (node == provider.root)
                                  node = ch[0] || node;
                                if (node)
                                  this.selectNode(node, true);
                                this._signal("change");
                              }
                            };
                          }).call(Selection.prototype);
                          exports3.Selection = Selection;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    336: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var Renderer = __webpack_require__2(743).VirtualRenderer;
                          exports3.config = __webpack_require__2(614);
                          var oop = __webpack_require__2(645);
                          var lang = __webpack_require__2(955);
                          var useragent = __webpack_require__2(943);
                          var TextInput = __webpack_require__2(984).k;
                          var MouseHandler = __webpack_require__2(202).MouseHandler;
                          var KeyBinding = __webpack_require__2(957).$;
                          var Selection = __webpack_require__2(592).Selection;
                          var EventEmitter = __webpack_require__2(366).b;
                          var CommandManager = __webpack_require__2(379).F;
                          var defaultCommands = __webpack_require__2(677).commands;
                          var config = __webpack_require__2(614);
                          var quickSearch = __webpack_require__2(277);
                          var Tree = function(element, cellWidth, cellHeight) {
                            this.$toDestroy = [];
                            this.cellWidth = cellWidth || 80;
                            this.cellHeight = cellHeight || 24;
                            this.renderer = new Renderer(element, this.cellWidth, this.cellHeight);
                            this.container = this.renderer.container;
                            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                            this.textInput = new TextInput(this.container, this);
                            this.keyBinding = new KeyBinding(this);
                            this.$mouseHandler = new MouseHandler(this);
                            this.$blockScrolling = 0;
                            var _self = this;
                            this.renderer.on("edit", function(e) {
                              _self._emit("edit", e);
                            });
                            this.commands.on("exec", function() {
                              this.selectionChanged = false;
                            }.bind(this));
                            this.commands.on("afterExec", function() {
                              if (this.selectionChanged) {
                                this.selectionChanged = false;
                                this.renderer.scrollCaretIntoView();
                                this._signal("userSelect");
                              }
                            }.bind(this));
                            this.on("changeSelection", function() {
                              if (this.$mouseHandler.isMousePressed)
                                this._signal("userSelect");
                            }.bind(this));
                            config.resetOptions(this);
                            config._emit("Tree", this);
                          };
                          (function() {
                            oop.implement(this, EventEmitter);
                            this.setDataProvider = function(provider) {
                              if (this.provider) {
                                var oldProvider = this.provider;
                                this.selection.off("changeCaret", this.$onCaretChange);
                                this.selection.off("change", this.$onSelectionChange);
                                oldProvider.off("changeClass", this.$onChangeClass);
                                oldProvider.off("expand", this.$redraw);
                                oldProvider.off("collapse", this.$redraw);
                                oldProvider.off("change", this.$redraw);
                                oldProvider.off("changeScrollTop", this.$onScrollTopChange);
                                oldProvider.off("changeScrollLeft", this.$onScrollLeftChange);
                              }
                              this.provider = provider;
                              this.model = provider;
                              if (provider) {
                                this.renderer.setDataProvider(provider);
                                if (!this.$redraw)
                                  this.$redraw = this.redraw.bind(this);
                                this.provider.on("expand", this.$redraw);
                                this.provider.on("collapse", this.$redraw);
                                this.provider.on("change", this.$redraw);
                                if (!this.provider.selection) {
                                  this.provider.selection = new Selection(this.provider);
                                }
                                this.selection = this.provider.selection;
                                this.$onCaretChange = this.onCaretChange.bind(this);
                                this.selection.on("changeCaret", this.$onCaretChange);
                                this.$onChangeClass = this.$onChangeClass.bind(this);
                                this.provider.on("changeClass", this.$onChangeClass);
                                this.$onSelectionChange = this.onSelectionChange.bind(this);
                                this.selection.on("change", this.$onSelectionChange);
                                this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                                this.provider.on("changeScrollTop", this.$onScrollTopChange);
                                this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                                this.provider.on("changeScrollLeft", this.$onScrollLeftChange);
                                this.$blockScrolling += 1;
                                this.onCaretChange();
                                this.$blockScrolling -= 1;
                                this.onScrollTopChange();
                                this.onScrollLeftChange();
                                this.onSelectionChange();
                                this.renderer.updateFull();
                              }
                              this._emit("changeDataProvider", {
                                provider,
                                oldProvider
                              });
                            };
                            this.redraw = function() {
                              this.renderer.updateFull();
                            };
                            this.getLength = function() {
                              return 0;
                            };
                            this.getLine = function(row) {
                              return {
                                length: 0
                                // this.renderer.$horHeadingLayer.length - 1
                              };
                            };
                            this.getDataProvider = function() {
                              return this.provider;
                            };
                            this.getSelection = function() {
                              return this.selection;
                            };
                            this.resize = function(force) {
                              this.renderer.onResize(force);
                            };
                            this.focus = function(once) {
                              var _self = this;
                              once || setTimeout(function() {
                                _self.textInput.focus();
                              });
                              this.textInput.focus();
                            };
                            this.isFocused = function() {
                              return this.textInput.isFocused();
                            };
                            this.blur = function() {
                              this.textInput.blur();
                            };
                            this.onFocus = function() {
                              if (this.$isFocused)
                                return;
                              this.$isFocused = true;
                              this.renderer.visualizeFocus();
                              this._emit("focus");
                            };
                            this.onBlur = function() {
                              if (!this.$isFocused)
                                return;
                              this.$isFocused = false;
                              this.renderer.visualizeBlur();
                              this._emit("blur");
                            };
                            this.onScrollTopChange = function() {
                              this.renderer.scrollToY(this.provider.getScrollTop());
                            };
                            this.onScrollLeftChange = function() {
                              this.renderer.scrollToX(this.renderer.getScrollLeft());
                            };
                            this.$onChangeClass = function() {
                              this.renderer.updateCaret();
                            };
                            this.onCaretChange = function() {
                              this.$onChangeClass();
                              if (!this.$blockScrolling)
                                this.selectionChanged = true;
                              this._emit("changeSelection");
                            };
                            this.onSelectionChange = function(e) {
                              this.onCaretChange();
                            };
                            this.execCommand = function(command, args) {
                              this.commands.exec(command, this, args);
                            };
                            this.onTextInput = function(text) {
                              this.keyBinding.onTextInput(text);
                            };
                            this.onCommandKey = function(e, hashId, keyCode) {
                              this.keyBinding.onCommandKey(e, hashId, keyCode);
                            };
                            this.insertSting = function(str) {
                              if (this.startFilter)
                                return this.startFilter(str);
                              quickSearch(this, str);
                            };
                            this.setTheme = function(theme) {
                              this.renderer.setTheme(theme);
                            };
                            this.$getSelectedRows = function() {
                              var range = this.getSelectionRange().collapseRows();
                              return {
                                first: range.start.row,
                                last: range.end.row
                              };
                            };
                            this.getVisibleNodes = function(tolerance) {
                              return this.renderer.getVisibleNodes(tolerance);
                            };
                            this.isNodeVisible = function(node, tolerance) {
                              return this.renderer.isNodeVisible(node, tolerance);
                            };
                            this.$moveByPage = function(dir, select) {
                              var renderer = this.renderer;
                              var config2 = this.renderer.layerConfig;
                              config2.lineHeight = this.provider.rowHeight;
                              var rows = dir * Math.floor(config2.height / config2.lineHeight);
                              this.$blockScrolling++;
                              this.selection.moveSelection(rows, select);
                              this.$blockScrolling--;
                              var scrollTop = renderer.scrollTop;
                              renderer.scrollBy(0, rows * config2.lineHeight);
                              if (select != null)
                                renderer.scrollCaretIntoView(null, 0.5);
                              renderer.animateScrolling(scrollTop);
                            };
                            this.selectPageDown = function() {
                              this.$moveByPage(1, true);
                            };
                            this.selectPageUp = function() {
                              this.$moveByPage(-1, true);
                            };
                            this.gotoPageDown = function() {
                              this.$moveByPage(1, false);
                            };
                            this.gotoPageUp = function() {
                              this.$moveByPage(-1, false);
                            };
                            this.scrollPageDown = function() {
                              this.$moveByPage(1);
                            };
                            this.scrollPageUp = function() {
                              this.$moveByPage(-1);
                            };
                            this.scrollToRow = function(row, center, animate, callback) {
                              this.renderer.scrollToRow(row, center, animate, callback);
                            };
                            this.centerSelection = function() {
                              var range = this.getSelectionRange();
                              var pos = {
                                row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                                column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                              };
                              this.renderer.alignCaret(pos, 0.5);
                            };
                            this.getCursorPosition = function() {
                              return this.selection.getCursor();
                            };
                            this.getCursorPositionScreen = function() {
                              return this.session.documentToScreenPosition(this.getCursorPosition());
                            };
                            this.getSelectionRange = function() {
                              return this.selection.getRange();
                            };
                            this.selectAll = function() {
                              this.$blockScrolling += 1;
                              this.selection.selectAll();
                              this.$blockScrolling -= 1;
                            };
                            this.clearSelection = function() {
                              this.selection.clearSelection();
                            };
                            this.moveCaretTo = function(row, column) {
                              this.selection.moveCaretTo(row, column);
                            };
                            this.moveCaretToPosition = function(pos) {
                              this.selection.moveCaretToPosition(pos);
                            };
                            this.gotoRow = function(rowNumber, column, animate) {
                              this.selection.clearSelection();
                              if (column === void 0)
                                column = this.selection.getCursor().column;
                              this.$blockScrolling += 1;
                              this.moveCaretTo(rowNumber - 1, column || 0);
                              this.$blockScrolling -= 1;
                              if (!this.isRowFullyVisible(rowNumber - 1))
                                this.scrollToRow(rowNumber - 1, true, animate);
                            };
                            this.navigateTo = function(row, column) {
                              this.clearSelection();
                              this.moveCaretTo(row, column);
                            };
                            this.navigateUp = function() {
                              var node = this.provider.navigate("up");
                              node && this.selection.setSelection(node);
                              this.$scrollIntoView();
                            };
                            this.navigateDown = function() {
                              var node = this.provider.navigate("down");
                              node && this.selection.setSelection(node);
                            };
                            this.navigateLevelUp = function(toggleNode) {
                              var node = this.selection.getCursor();
                              if (!node) {
                              } else if (toggleNode && this.provider.isOpen(node)) {
                                this.provider.close(node);
                              } else {
                                this.selection.setSelection(node.parent);
                              }
                            };
                            this.navigateLevelDown = function() {
                              var node = this.selection.getCursor();
                              var hasChildren = this.provider.hasChildren(node);
                              if (!hasChildren || this.provider.isOpen(node))
                                return this.selection.moveSelection(1);
                              this.provider.open(node);
                            };
                            this.navigateStart = function() {
                              var node = this.getFirstNode();
                              this.selection.setSelection(node);
                            };
                            this.navigateEnd = function() {
                              var node = this.getLastNode();
                              this.selection.setSelection(node);
                            };
                            this.getFirstNode = function() {
                              var index = this.provider.getMinIndex();
                              return this.provider.getNodeAtIndex(index);
                            };
                            this.getLastNode = function() {
                              var index = this.provider.getMaxIndex();
                              return this.provider.getNodeAtIndex(index);
                            };
                            this.$scrollIntoView = function(node) {
                              this.renderer.scrollCaretIntoView();
                            };
                            this.select = function(node) {
                              this.selection.setSelection(node);
                            };
                            this.getCopyText = function(node) {
                              return "";
                            };
                            this.onPaste = function(node) {
                              return "";
                            };
                            this.reveal = function(node, animate) {
                              var provider = this.provider;
                              var parent = node.parent;
                              while (parent) {
                                if (!provider.isOpen(parent))
                                  provider.expand(parent);
                                parent = parent.parent;
                              }
                              this.select(node);
                              var scrollTop = this.renderer.scrollTop;
                              this.renderer.scrollCaretIntoView(node, 0.5);
                              if (animate !== false)
                                this.renderer.animateScrolling(scrollTop);
                            };
                            this.undo = function() {
                              this.$blockScrolling++;
                              this.session.getUndoManager().undo();
                              this.$blockScrolling--;
                              this.renderer.scrollCaretIntoView(null, 0.5);
                            };
                            this.redo = function() {
                              this.$blockScrolling++;
                              this.session.getUndoManager().redo();
                              this.$blockScrolling--;
                              this.renderer.scrollCaretIntoView(null, 0.5);
                            };
                            this.getReadOnly = function() {
                              return this.getOption("readOnly");
                            };
                            this.destroy = function() {
                              this.renderer.destroy();
                              this._emit("destroy", this);
                            };
                            this.setHorHeadingVisible = function(value) {
                              this.renderer.setHorHeadingVisible(value);
                            };
                            this.setVerHeadingVisible = function(value) {
                              this.renderer.setVerHeadingVisible(value);
                            };
                            this.enable = function() {
                              this.$disabled = false;
                              this.container.style.pointerEvents = "";
                              this.container.style.opacity = "";
                            };
                            this.disable = function() {
                              this.$disabled = true;
                              this.container.style.pointerEvents = "none";
                              this.container.style.opacity = "0.9";
                              if (this.isFocused())
                                this.blur();
                            };
                          }).call(Tree.prototype);
                          config.defineOptions(Tree.prototype, "Tree", {
                            toggle: {
                              set: function(toggle) {
                              },
                              initialValue: false
                            },
                            readOnly: {
                              set: function(readOnly) {
                                this.textInput.setReadOnly(readOnly);
                              },
                              initialValue: false
                            },
                            animatedScroll: "renderer",
                            maxLines: "renderer",
                            minLines: "renderer",
                            scrollSpeed: "$mouseHandler",
                            enableDragDrop: "$mouseHandler"
                          });
                          module3.exports = Tree;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    743: (
                      /***/
                      (module22, exports2, __webpack_require__2) => {
                        var __WEBPACK_AMD_DEFINE_RESULT__;
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                          "use strict";
                          var oop = __webpack_require__2(645);
                          var dom = __webpack_require__2(435);
                          var config = __webpack_require__2(614);
                          var CellLayer = __webpack_require__2(365).Cells;
                          var MarkerLayer = __webpack_require__2(611).Selection;
                          var HeaderLayer = __webpack_require__2(86).ColumnHeader;
                          var ScrollBarH = __webpack_require__2(745).zy;
                          var ScrollBarV = __webpack_require__2(745).lc;
                          var RenderLoop = __webpack_require__2(481).x;
                          var EventEmitter = __webpack_require__2(366).b;
                          var pivotCss = __webpack_require__2(268);
                          dom.importCssString(pivotCss, "ace_tree");
                          var defaultTheme = __webpack_require__2(768);
                          var VirtualRenderer = function(container, cellWidth, cellHeight) {
                            var _self = this;
                            this.container = container || dom.createElement("div");
                            dom.addCssClass(this.container, "ace_tree");
                            dom.addCssClass(this.container, "ace_tree");
                            this.scroller = dom.createElement("div");
                            this.scroller.className = "ace_tree_scroller";
                            this.container.appendChild(this.scroller);
                            this.cells = dom.createElement("div");
                            this.cells.className = "ace_tree_cells";
                            this.scroller.appendChild(this.cells);
                            this.$headingLayer = new HeaderLayer(this.container, this);
                            this.$markerLayer = new MarkerLayer(this.cells, this);
                            this.$cellLayer = new CellLayer(this.cells);
                            this.canvas = this.$cellLayer.element;
                            this.$horizScroll = false;
                            this.scrollBarV = new ScrollBarV(this.container, this);
                            this.scrollBarV.setVisible(true);
                            this.scrollBarV.addEventListener("scroll", function(e) {
                              if (!_self.$inScrollAnimation)
                                _self.setScrollTop(e.data - _self.scrollMargin.top);
                            });
                            this.scrollBarH = new ScrollBarH(this.container, this);
                            this.scrollBarH.addEventListener("scroll", function(e) {
                              if (!_self.$inScrollAnimation)
                                _self.setScrollLeft(e.data);
                            });
                            this.scrollTop = 0;
                            this.scrollLeft = 0;
                            this.caretPos = {
                              row: 0,
                              column: 0
                            };
                            this.$size = {
                              width: 0,
                              height: 0,
                              scrollerHeight: 0,
                              scrollerWidth: 0,
                              headingHeight: 0
                            };
                            this.layerConfig = {
                              width: 1,
                              padding: 0,
                              firstRow: 0,
                              firstRowScreen: 0,
                              lastRow: 0,
                              lineHeight: 1,
                              characterWidth: 1,
                              minHeight: 1,
                              maxHeight: 1,
                              offset: 0,
                              height: 1
                            };
                            this.scrollMargin = {
                              left: 0,
                              right: 0,
                              top: 0,
                              bottom: 0,
                              v: 0,
                              h: 0
                            };
                            this.$scrollIntoView = null;
                            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                            this.$loop.schedule(this.CHANGE_FULL);
                            this.setTheme(defaultTheme);
                            this.$windowFocus = this.$windowFocus.bind(this);
                            window.addEventListener("focus", this.$windowFocus);
                          };
                          (function() {
                            this.CHANGE_SCROLL = 1;
                            this.CHANGE_COLUMN = 2;
                            this.CHANGE_ROW = 4;
                            this.CHANGE_CELLS = 8;
                            this.CHANGE_SIZE = 16;
                            this.CHANGE_CLASS = 32;
                            this.CHANGE_MARKER = 64;
                            this.CHANGE_FULL = 128;
                            this.CHANGE_H_SCROLL = 1024;
                            oop.implement(this, EventEmitter);
                            this.setDataProvider = function(provider) {
                              this.provider = provider;
                              this.model = provider;
                              if (this.scrollMargin.top && provider && provider.getScrollTop() <= 0)
                                provider.setScrollTop(-this.scrollMargin.top);
                              this.scroller.className = "ace_tree_scroller";
                              this.$cellLayer.setDataProvider(provider);
                              this.$markerLayer.setDataProvider(provider);
                              this.$headingLayer.setDataProvider(provider);
                              this.$size.headingHeight = provider && provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                              this.$loop.schedule(this.CHANGE_FULL);
                            };
                            this.updateRows = function(firstRow, lastRow) {
                              if (lastRow === void 0)
                                lastRow = Infinity;
                              if (!this.$changedLines) {
                                this.$changedLines = {
                                  firstRow,
                                  lastRow
                                };
                              } else {
                                if (this.$changedLines.firstRow > firstRow)
                                  this.$changedLines.firstRow = firstRow;
                                if (this.$changedLines.lastRow < lastRow)
                                  this.$changedLines.lastRow = lastRow;
                              }
                              if (this.$changedLines.firstRow > this.layerConfig.lastRow || this.$changedLines.lastRow < this.layerConfig.firstRow)
                                return;
                              this.$loop.schedule(this.CHANGE_ROW);
                            };
                            this.updateCaret = function() {
                              this.$loop.schedule(this.CHANGE_CLASS);
                            };
                            this.updateCells = function() {
                              this.$loop.schedule(this.CHANGE_CELLS);
                            };
                            this.updateFull = function(force) {
                              if (force)
                                this.$renderChanges(this.CHANGE_FULL, true);
                              else
                                this.$loop.schedule(this.CHANGE_FULL);
                            };
                            this.updateHorizontalHeadings = function() {
                              this.$loop.schedule(this.CHANGE_COLUMN);
                            };
                            this.updateVerticalHeadings = function() {
                              this.$loop.schedule(this.CHANGE_ROW);
                            };
                            this.$changes = 0;
                            this.onResize = function(force, width, height) {
                              if (this.resizing > 2)
                                return;
                              else if (this.resizing > 0)
                                this.resizing++;
                              else
                                this.resizing = force ? 1 : 0;
                              var el = this.container;
                              if (!height)
                                height = el.clientHeight || el.scrollHeight;
                              if (!width)
                                width = el.clientWidth || el.scrollWidth;
                              var changes = this.$updateCachedSize(force, width, height);
                              if (!this.$size.scrollerHeight || !width && !height)
                                return this.resizing = 0;
                              if (force)
                                this.$renderChanges(changes, true);
                              else
                                this.$loop.schedule(changes | this.$changes);
                              if (this.resizing)
                                this.resizing = 0;
                            };
                            this.$windowFocus = function() {
                              this.onResize();
                            };
                            this.$updateCachedSize = function(force, width, height) {
                              var changes = 0;
                              var size = this.$size;
                              var provider = this.provider;
                              if (provider) {
                                var headingHeight = provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                                if (headingHeight != size.headingHeight) {
                                  size.headingHeight = headingHeight;
                                  changes |= this.CHANGE_SIZE;
                                }
                              }
                              if (height && (force || size.height != height)) {
                                size.height = height;
                                changes |= this.CHANGE_SIZE;
                                size.scrollerHeight = size.height;
                                if (this.$horizScroll)
                                  size.scrollerHeight -= this.scrollBarH.getHeight();
                                size.scrollerHeight -= size.headingHeight;
                                this.$headingLayer.element.style.height = this.scroller.style.top = this.scrollBarV.element.style.top = size.headingHeight + "px";
                                this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                                if (provider && provider.setScrollTop) {
                                  changes |= this.CHANGE_SCROLL;
                                }
                                if (this.$scrollIntoView) {
                                  if (this.$scrollIntoView.model == this.model) {
                                    this.scrollCaretIntoView(this.$scrollIntoView.caret, this.$scrollIntoView.offset);
                                    this.$scrollIntoView = null;
                                  }
                                }
                              }
                              if (width && (force || size.width != width)) {
                                changes |= this.CHANGE_SIZE;
                                size.width = width;
                                this.scrollBarH.element.style.left = this.scroller.style.left = "0px";
                                size.scrollerWidth = Math.max(0, width - this.scrollBarV.getWidth());
                                this.$headingLayer.element.style.right = this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                                this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
                                this.$headingLayer.updateWidth(size.scrollerWidth);
                                if (provider && provider.columns)
                                  changes |= this.CHANGE_FULL;
                              }
                              if (changes)
                                this._signal("resize");
                              return changes;
                            };
                            this.setVerHeadingVisible = function(value) {
                              this.$treeLayer.visible = value;
                              if (this.layerConfig.vRange && this.layerConfig.hRange) {
                                this.$renderChanges(this.CHANGE_FULL, true);
                                this.onResize(true);
                              }
                            };
                            this.getContainerElement = function() {
                              return this.container;
                            };
                            this.getMouseEventTarget = function() {
                              return this.scroller;
                            };
                            this.getVisibleNodes = function(tolerance) {
                              var nodes = this.layerConfig.vRange;
                              var first = 0;
                              var last = nodes.length - 1;
                              while (this.isNodeVisible(nodes[first], tolerance) && first < last)
                                first++;
                              while (!this.isNodeVisible(nodes[last], tolerance) && last > first)
                                last--;
                              return nodes.slice(first, last + 1);
                            };
                            this.isNodeVisible = function(node, tolerance) {
                              var layerConfig = this.layerConfig;
                              if (!layerConfig.vRange)
                                return;
                              var provider = this.provider;
                              var i = layerConfig.vRange.indexOf(node);
                              if (i == -1)
                                return false;
                              var nodePos = provider.getNodePosition(node);
                              var top = nodePos.top;
                              var height = nodePos.height;
                              if (tolerance === void 0)
                                tolerance = 1 / 3;
                              if (this.scrollTop > top + tolerance * height)
                                return false;
                              if (this.scrollTop + this.$size.scrollerHeight <= top + (1 - tolerance) * height)
                                return false;
                              return true;
                            };
                            this.$updateScrollBar = function() {
                              this.$updateScrollBarH();
                              this.$updateScrollBarV();
                            };
                            this.setScrollMargin = function(top, bottom, left, right) {
                              var sm = this.scrollMargin;
                              sm.top = top | 0;
                              sm.bottom = bottom | 0;
                              sm.right = right | 0;
                              sm.left = left | 0;
                              sm.v = sm.top + sm.bottom;
                              sm.h = sm.left + sm.right;
                              if (sm.top && this.scrollTop <= 0 && this.provider)
                                this.provider.setScrollTop(-sm.top);
                              this.updateFull();
                            };
                            this.$updateScrollBarV = function() {
                              this.scrollBarV.setInnerHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
                              this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                            };
                            this.$updateScrollBarH = function() {
                              this.scrollBarH.setInnerWidth(this.layerConfig.maxWidth + this.scrollMargin.h);
                              this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                            };
                            this.$frozen = false;
                            this.freeze = function() {
                              this.$frozen = true;
                            };
                            this.unfreeze = function() {
                              this.$frozen = false;
                            };
                            this.$renderChanges = function(changes, force) {
                              if (this.$changes) {
                                changes |= this.$changes;
                                this.$changes = 0;
                              }
                              if (!this.provider || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                                this.$changes |= changes;
                                return;
                              }
                              if (!this.$size.width) {
                                this.$changes |= changes;
                                return this.onResize(true);
                              }
                              this._signal("beforeRender");
                              var config2 = this.layerConfig;
                              if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL || changes & this.CHANGE_COLUMN || changes & this.CHANGE_ROW || changes & this.CHANGE_CELLS) {
                                changes |= this.$computeLayerConfig();
                                config2 = this.layerConfig;
                                this.$updateScrollBar();
                                this.cells.style.marginTop = -config2.vOffset + "px";
                                this.cells.style.marginLeft = -config2.hOffset + "px";
                                this.cells.style.width = config2.width + "px";
                                this.cells.style.height = config2.height + config2.rowHeight + "px";
                              }
                              if (changes & this.CHANGE_FULL) {
                                this.$headingLayer.update(this.layerConfig);
                                this.$cellLayer.update(this.layerConfig);
                                this.$markerLayer.update(this.layerConfig);
                                this._signal("afterRender");
                                return;
                              }
                              if (changes & this.CHANGE_SCROLL) {
                                if (changes & this.CHANGE_ROW || changes & this.CHANGE_COLUMN || changes & this.CHANGE_CELLS) {
                                  this.$headingLayer.update(this.layerConfig);
                                  this.$cellLayer.update(this.layerConfig);
                                } else {
                                  this.$headingLayer.update(this.layerConfig);
                                  this.$cellLayer.scroll(this.layerConfig);
                                }
                                this.$markerLayer.update(this.layerConfig);
                                this.$updateScrollBar();
                                this._signal("afterRender");
                                return;
                              }
                              if (changes & this.CHANGE_CLASS)
                                this.$cellLayer.updateClasses(this.layerConfig);
                              if (changes & this.CHANGE_MARKER || changes & this.CHANGE_CELLS)
                                this.$markerLayer.update(this.layerConfig);
                              if (changes & this.CHANGE_COLUMN)
                                this.$horHeadingLayer.update(this.layerConfig);
                              if (changes & this.CHANGE_CELLS)
                                this.$cellLayer.update(this.layerConfig);
                              if (changes & this.CHANGE_SIZE)
                                this.$updateScrollBar();
                              this._signal("afterRender");
                              if (this.$scrollIntoView)
                                this.$scrollIntoView = null;
                            };
                            this.$autosize = function() {
                              var headingHeight = this.$size.headingHeight;
                              var height = this.provider.getTotalHeight() + headingHeight;
                              var maxHeight = this.getMaxHeight ? this.getMaxHeight() : this.$maxLines * this.provider.rowHeight + headingHeight;
                              var desiredHeight = Math.max((this.$minLines || 1) * this.provider.rowHeight + headingHeight, Math.min(maxHeight, height)) + this.scrollMargin.v;
                              var vScroll = height > maxHeight;
                              if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                                if (vScroll != this.$vScroll) {
                                  this.$vScroll = vScroll;
                                  this.scrollBarV.setVisible(vScroll);
                                }
                                var w = this.container.clientWidth;
                                this.container.style.height = desiredHeight + "px";
                                this.$updateCachedSize(true, w, desiredHeight);
                                this.desiredHeight = desiredHeight;
                                this._signal("autoresize");
                              }
                            };
                            this.$computeLayerConfig = function() {
                              if (this.$maxLines)
                                this.$autosize();
                              var provider = this.provider;
                              var vertical = this.$treeLayer;
                              var horizontal = this.$horHeadingLayer;
                              var minHeight = this.$size.scrollerHeight;
                              var maxHeight = provider.getTotalHeight();
                              var minWidth = this.$size.scrollerWidth;
                              var maxWidth = 0;
                              var hideScrollbars = this.$size.height <= 2 * 10;
                              var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || this.$size.scrollerWidth - maxWidth < 0);
                              var hScrollChanged = this.$horizScroll !== horizScroll;
                              if (hScrollChanged) {
                                this.$horizScroll = horizScroll;
                                this.scrollBarH.setVisible(horizScroll);
                              }
                              var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || this.$size.scrollerHeight - maxHeight < 0);
                              var vScrollChanged = this.$vScroll !== vScroll;
                              if (vScrollChanged) {
                                this.$vScroll = vScroll;
                                this.scrollBarV.setVisible(vScroll);
                              }
                              this.provider.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight + this.scrollMargin.bottom)));
                              this.provider.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, maxWidth - this.$size.scrollerWidth + this.scrollMargin.right)));
                              if (this.provider.getScrollTop() != this.scrollTop)
                                this.scrollTop = this.provider.getScrollTop();
                              var top = Math.max(this.scrollTop, 0);
                              var vRange = provider.getRange(top, top + this.$size.height);
                              var hRange = {
                                size: 0
                              };
                              var vOffset = this.scrollTop - vRange.size;
                              var hOffset = this.scrollLeft - hRange.size;
                              var rowCount = vRange.length;
                              var firstRow = vRange.count;
                              var lastRow = firstRow + rowCount - 1;
                              var colCount = hRange.length;
                              var firstCol = hRange.count;
                              var lastCol = firstCol + colCount - 1;
                              if (this.layerConfig)
                                this.layerConfig.discard = true;
                              var changes = 0;
                              if (hScrollChanged || vScrollChanged) {
                                changes = this.$updateCachedSize(true, this.$size.width, this.$size.height);
                                this._signal("scrollbarVisibilityChanged");
                              }
                              this.layerConfig = {
                                vRange,
                                hRange,
                                width: minWidth,
                                height: minHeight,
                                firstRow,
                                lastRow,
                                firstCol,
                                lastCol,
                                minHeight,
                                maxHeight,
                                minWidth,
                                maxWidth,
                                vOffset,
                                hOffset,
                                rowHeight: provider.rowHeight
                              };
                              var config2 = this.layerConfig, renderer = this;
                              if (vRange) {
                                config2.view = provider.getDataRange({
                                  start: vRange.count,
                                  length: vRange.length
                                }, {
                                  start: hRange.count,
                                  length: hRange.length
                                }, function(err, view, update) {
                                  if (err)
                                    return false;
                                  config2.view = view;
                                  if (update)
                                    renderer.$loop.schedule(renderer.CHANGE_CELLS);
                                });
                              }
                              return changes;
                            };
                            this.$updateRows = function() {
                              var firstRow = this.$changedLines.firstRow;
                              var lastRow = this.$changedLines.lastRow;
                              this.$changedLines = null;
                              var layerConfig = this.layerConfig;
                              if (firstRow > layerConfig.lastRow + 1) {
                                return;
                              }
                              if (lastRow < layerConfig.firstRow) {
                                return;
                              }
                              if (lastRow === Infinity) {
                                this.$cellLayer.update(layerConfig);
                                return;
                              }
                              this.$cellLayer.updateRows(layerConfig, firstRow, lastRow);
                              return true;
                            };
                            this.scrollSelectionIntoView = function(anchor, lead, offset) {
                              this.scrollCaretIntoView(anchor, offset);
                              this.scrollCaretIntoView(lead, offset);
                            };
                            this.scrollCaretIntoView = function(caret, offset) {
                              this.$scrollIntoView = {
                                caret,
                                offset,
                                scrollTop: this.scrollTop,
                                model: this.model,
                                height: this.$size.scrollerHeight
                              };
                              if (this.$size.scrollerHeight === 0)
                                return;
                              var provider = this.provider;
                              var node = caret || provider.selection.getCursor();
                              if (!node)
                                return;
                              var nodePos = provider.getNodePosition(node);
                              var top = nodePos.top;
                              var height = nodePos.height;
                              var left = 0;
                              var width = 0;
                              if (this.scrollTop > top) {
                                if (offset)
                                  top -= offset * this.$size.scrollerHeight;
                                if (top === 0)
                                  top = -this.scrollMargin.top;
                                this.provider.setScrollTop(top);
                              } else if (this.scrollTop + this.$size.scrollerHeight < top + height) {
                                if (offset)
                                  top += offset * this.$size.scrollerHeight;
                                this.provider.setScrollTop(top + height - this.$size.scrollerHeight);
                              }
                              var scrollLeft = this.scrollLeft;
                              if (scrollLeft > left) {
                                if (left < 0)
                                  left = 0;
                                this.provider.setScrollLeft(left);
                              } else if (scrollLeft + this.$size.scrollerWidth < left + width) {
                                this.provider.setScrollLeft(Math.round(left + width - this.$size.scrollerWidth));
                              }
                              this.$scrollIntoView.scrollTop = this.scrollTop;
                            };
                            this.getScrollTop = function() {
                              return this.scrollTop;
                            };
                            this.getScrollLeft = function() {
                              return this.scrollLeft;
                            };
                            this.setScrollTop = function(scrollTop) {
                              scrollTop = Math.round(scrollTop);
                              if (this.scrollTop === scrollTop || isNaN(scrollTop))
                                return;
                              this.scrollToY(scrollTop);
                            };
                            this.setScrollLeft = function(scrollLeft) {
                              scrollLeft = Math.round(scrollLeft);
                              if (this.scrollLeft === scrollLeft || isNaN(scrollLeft))
                                return;
                              this.scrollToX(scrollLeft);
                            };
                            this.getScrollTopRow = function() {
                              return this.layerConfig.firstRow;
                            };
                            this.getScrollBottomRow = function() {
                              return this.layerConfig.lastRow;
                            };
                            this.alignCaret = function(cursor, alignment) {
                              if (typeof cursor == "number")
                                cursor = {
                                  row: cursor,
                                  column: 0
                                };
                              var node = this.provider.findNodeByIndex(cursor.row);
                              var pos = this.provider.findSizeAtIndex(cursor.row);
                              var h = this.$size.scrollerHeight;
                              var offset = pos - (h - node.size) * (alignment || 0);
                              this.setScrollTop(offset);
                              return offset;
                            };
                            this.STEPS = 8;
                            this.$calcSteps = function(fromValue, toValue) {
                              var i = 0;
                              var l = this.STEPS;
                              var steps = [];
                              var func = function(t, x_min, dx) {
                                return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                              };
                              for (i = 0; i < l; ++i)
                                steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                              return steps;
                            };
                            this.scrollToRow = function(row, center, animate, callback) {
                              var node = this.provider.findNodeByIndex(row);
                              var offset = this.provider.findSizeAtIndex(row);
                              if (center)
                                offset -= (this.$size.scrollerHeight - node.size) / 2;
                              var initialScroll = this.scrollTop;
                              this.setScrollTop(offset);
                              if (animate !== false)
                                this.animateScrolling(initialScroll, callback);
                            };
                            this.animateScrolling = function(fromValue, callback) {
                              var toValue = this.scrollTop;
                              if (!this.$animatedScroll)
                                return;
                              var _self = this;
                              if (fromValue == toValue)
                                return;
                              if (this.$scrollAnimation) {
                                var oldSteps = this.$scrollAnimation.steps;
                                if (oldSteps.length) {
                                  fromValue = oldSteps[0];
                                  if (fromValue == toValue)
                                    return;
                                }
                              }
                              var steps = _self.$calcSteps(fromValue, toValue);
                              this.$scrollAnimation = {
                                from: fromValue,
                                to: toValue,
                                steps
                              };
                              clearInterval(this.$timer);
                              _self.provider.setScrollTop(steps.shift());
                              _self.provider.$scrollTop = toValue;
                              this.$timer = setInterval(function() {
                                if (steps.length) {
                                  _self.provider.setScrollTop(steps.shift());
                                  _self.provider.$scrollTop = toValue;
                                } else if (toValue != null) {
                                  _self.provider.$scrollTop = -1;
                                  _self.provider.setScrollTop(toValue);
                                  toValue = null;
                                } else {
                                  _self.$timer = clearInterval(_self.$timer);
                                  _self.$scrollAnimation = null;
                                  callback && callback();
                                }
                              }, 10);
                            };
                            this.scrollToY = function(scrollTop) {
                              if (this.scrollTop !== scrollTop) {
                                this.$loop.schedule(this.CHANGE_SCROLL);
                                this.scrollTop = scrollTop;
                              }
                            };
                            this.scrollToX = function(scrollLeft) {
                              if (scrollLeft < 0)
                                scrollLeft = 0;
                              if (this.scrollLeft !== scrollLeft) {
                                this.$loop.schedule(this.CHANGE_SCROLL);
                                this.scrollLeft = scrollLeft;
                              }
                            };
                            this.scrollBy = function(deltaX, deltaY) {
                              deltaY && this.provider.setScrollTop(this.provider.getScrollTop() + deltaY);
                              deltaX && this.provider.setScrollLeft(this.provider.getScrollLeft() + deltaX);
                            };
                            this.isScrollableBy = function(deltaX, deltaY) {
                              if (deltaY < 0 && this.getScrollTop() >= 1 - this.scrollMargin.top)
                                return true;
                              if (deltaY > 0 && this.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
                                return true;
                              if (deltaX < 0 && this.getScrollLeft() >= 1)
                                return true;
                              if (deltaX > 0 && this.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.maxWidth < -1)
                                return true;
                            };
                            this.screenToTextCoordinates = function(x, y) {
                              var canvasPos = this.scroller.getBoundingClientRect();
                              y -= canvasPos.top;
                              x -= canvasPos.left;
                              return {
                                x: x + this.scrollLeft,
                                y: y + this.scrollTop
                              };
                            };
                            this.textToScreenCoordinates = function(row, column) {
                              throw new Error();
                            };
                            this.findNodeAt = function(x, y, coords) {
                            };
                            this.$moveTextAreaToCursor = function() {
                            };
                            this.visualizeFocus = function() {
                              dom.addCssClass(this.container, "ace_tree_focus");
                            };
                            this.visualizeBlur = function() {
                              dom.removeCssClass(this.container, "ace_tree_focus");
                            };
                            this.setTheme = function(theme, cb) {
                              var _self = this;
                              this.$themeValue = theme;
                              _self._dispatchEvent("themeChange", {
                                theme
                              });
                              if (!theme || typeof theme == "string") {
                                var moduleName = theme || "ace/theme/textmate";
                                config.loadModule([
                                  "theme",
                                  moduleName
                                ], afterLoad);
                              } else {
                                afterLoad(theme);
                              }
                              function afterLoad(module4) {
                                if (_self.$themeValue != theme)
                                  return cb && cb();
                                if (!module4.cssClass)
                                  return;
                                dom.importCssString(module4.cssText, module4.cssClass, _self.container.ownerDocument);
                                if (_self.theme)
                                  dom.removeCssClass(_self.container, _self.theme.cssClass);
                                _self.$theme = module4.cssClass;
                                _self.theme = module4;
                                dom.addCssClass(_self.container, module4.cssClass);
                                dom.setCssClass(_self.container, "ace_dark", module4.isDark);
                                var padding = module4.padding || 4;
                                if (_self.$padding && padding != _self.$padding)
                                  _self.setPadding(padding);
                                if (_self.$size) {
                                  _self.$size.width = 0;
                                  _self.onResize();
                                }
                                _self._dispatchEvent("themeLoaded", {
                                  theme: module4
                                });
                                cb && cb();
                              }
                            };
                            this.getTheme = function() {
                              return this.$themeValue;
                            };
                            this.setStyle = function setStyle(style, include) {
                              dom.setCssClass(this.container, style, include !== false);
                            };
                            this.unsetStyle = function unsetStyle(style) {
                              dom.removeCssClass(this.container, style);
                            };
                            this.destroy = function() {
                              window.removeEventListener("focus", this.$windowFocus);
                              this.$cellLayer.destroy();
                            };
                          }).call(VirtualRenderer.prototype);
                          config.defineOptions(VirtualRenderer.prototype, "renderer", {
                            animatedScroll: {
                              initialValue: true
                            },
                            showInvisibles: {
                              set: function(value) {
                                if (this.$cellLayer.setShowInvisibles(value))
                                  this.$loop.schedule(this.CHANGE_TEXT);
                              },
                              initialValue: false
                            },
                            showPrintMargin: {
                              set: function() {
                                this.$updatePrintMargin();
                              },
                              initialValue: true
                            },
                            printMarginColumn: {
                              set: function() {
                                this.$updatePrintMargin();
                              },
                              initialValue: 80
                            },
                            printMargin: {
                              set: function(val) {
                                if (typeof val == "number")
                                  this.$printMarginColumn = val;
                                this.$showPrintMargin = !!val;
                                this.$updatePrintMargin();
                              },
                              get: function() {
                                return this.$showPrintMargin && this.$printMarginColumn;
                              }
                            },
                            displayIndentGuides: {
                              set: function(show) {
                                if (this.$cellLayer.setDisplayIndentGuides(show))
                                  this.$loop.schedule(this.CHANGE_TEXT);
                              },
                              initialValue: true
                            },
                            hScrollBarAlwaysVisible: {
                              set: function(alwaysVisible) {
                                this.$hScrollBarAlwaysVisible = alwaysVisible;
                                if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                                  this.$loop.schedule(this.CHANGE_SCROLL);
                              },
                              initialValue: false
                            },
                            vScrollBarAlwaysVisible: {
                              set: function(val) {
                                if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                                  this.$loop.schedule(this.CHANGE_SCROLL);
                              },
                              initialValue: false
                            },
                            fontSize: {
                              set: function(size) {
                                if (typeof size == "number")
                                  size = size + "px";
                                this.container.style.fontSize = size;
                                this.updateFontSize();
                              },
                              initialValue: 12
                            },
                            fontFamily: {
                              set: function(name) {
                                this.container.style.fontFamily = name;
                                this.updateFontSize();
                              }
                            },
                            maxLines: {
                              set: function(val) {
                                this.updateFull();
                              }
                            },
                            minLines: {
                              set: function(val) {
                                this.updateFull();
                              }
                            },
                            scrollPastEnd: {
                              set: function(val) {
                                val = +val || 0;
                                if (this.$scrollPastEnd == val)
                                  return;
                                this.$scrollPastEnd = val;
                                this.$loop.schedule(this.CHANGE_SCROLL);
                              },
                              initialValue: 0,
                              handlesSet: true
                            }
                          });
                          exports3.VirtualRenderer = VirtualRenderer;
                        }.call(exports2, __webpack_require__2, exports2, module22), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module22.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                      }
                    ),
                    /***/
                    28: (
                      /***/
                      (module22) => {
                        module22.exports = ".ace_tree-light.ace_tree{\n    font: 12px Arial;\n}\n\n.ace_tree_selection_range{\n    background : rgba(0, 110, 255, 0.2);\n    border : 1px solid rgba(0,0,0,0.1);\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-light .toggler {\n    overflow: visible;\n    width: 10px;\n    height: 10px;\n}\n\n.ace_tree-light .tree-row .caption {\n    padding : 4px 5px;\n}\n.ace_tree-light .tree-row > .caption {\n    overflow: visible;\n    display: inline-block;\n}\n.ace_tree-light .tree-row {\n    border: 1px solid transparent;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n.ace_tree-light .tree-row:hover,\n.ace_tree-light .tree-row.hover{\n    background: rgba(0, 0, 0, 0.03);\n}\n.ace_tree-light .tree-row.selected {\n    background: rgba(0, 0, 0, 0.04);\n}\n\n.ace_tree_focus.ace_tree-light .tree-row.selected {\n    background: -webkit-gradient(linear, left top, left bottom, from(#2890E5), color-stop(1, #1F82D2));\n    background: -moz-linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    background: linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    color: #f8f8f8;\n}\n\n\n/* datagrid */\n\n.ace_tree-light .tree-row>.tree-column {\n    border: 1px solid rgb(204, 204, 204);\n    border-width: 0 1px 1px 0;\n    padding: 4px 5px;\n}\n\n.ace_tree-light .tree-row.selected>.tree-column {\n    background: transparent;\n}\n.ace_tree-light .tree-headings {\n    background: rgb(253, 253, 253);\n}\n.ace_tree-light .tree-headings>.tree-column {\n    background: transparent;\n    padding: 5px 3px;\n}\n\n.ace_tree-light .tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 1px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -1px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
                      }
                    ),
                    /***/
                    268: (
                      /***/
                      (module22) => {
                        module22.exports = ".ace_tree{\n    overflow : hidden;\n    font : 12px Tahoma, Arial;\n    cursor: default;\n    position: relative;\n    white-space: pre;\n}\n\n.ace_tree textarea{\n    position : absolute;\n    z-index : 0;\n}\n\n.ace_tree_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n         -o-user-select: none;\n            user-select: none;\n}\n\n.ace_tree_content {\n    position: absolute;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n.ace_scrollbar {\n    position: absolute;\n    overflow-x: hidden;\n    overflow-y: auto;\n    right: 0;\n    bottom: 0;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    position: absolute;\n    overflow-x: auto;\n    overflow-y: hidden;\n    right: 0;\n    left: 0;\n    bottom: 0;\n}\n\n.ace_tree_horheading {\n    position : absolute;\n}\n\n.ace_tree_verheading{\n    bottom : 0;\n    position : absolute;\n}\n\n.ace_tree_heading {\n    z-index: 10;\n    position: relative;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree .tree-indent {\n    display : inline-block;\n}\n\n.ace_tree_selection_range{\n    position : absolute;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-editor {\n    position : absolute;\n    z-index : 10000;\n    background : white;\n    padding : 3px 4px 3px 4px;\n    -moz-box-sizing : border-box;\n         box-sizing : border-box;\n    border : 1px dotted green;\n    left: 0;\n    right: 0\n}\n\n\n\n.ace_tree .toggler {\n    width: 10px;\n    height: 10px;\n    background-repeat: no-repeat;\n    background-position: 0px 0px;\n    background-repeat: no-repeat;\n    cursor: pointer;\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_tree .toggler.empty {\n    pointer-events: none;\n}\n\n.ace_tree .toggler.open {\n    background-position: -10px 0px;\n}\n\n.ace_tree .toggler.empty {\n    background-position: 50px 0px;\n    cursor: default;\n}\n\n.ace_tree_cells, .ace_tree_cell-layer {\n    width: 100%;\n}\n.ace_tree_selection-layer {\n    width: 100%;\n    height: 110%;\n}\n.ace_tree_cells .message.empty {\n    text-align: center;\n    opacity: 0.9;\n    cursor : default;\n}\n\n/* datagrid */\n\n.ace_tree .tree-row>.tree-column {\n    display: inline-block;\n    overflow: hidden;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n\n.tree-headings {\n    white-space: nowrap;\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    left: 0;\n    right: 0;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.tree-headings>.tree-column {\n    display: inline-block;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 2px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -2px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
                      }
                    )
                    /******/
                  };
                  var __webpack_module_cache__2 = {};
                  function __nested_webpack_require_262623__(moduleId) {
                    var cachedModule = __webpack_module_cache__2[moduleId];
                    if (cachedModule !== void 0) {
                      return cachedModule.exports;
                    }
                    var module22 = __webpack_module_cache__2[moduleId] = {
                      /******/
                      // no module.id needed
                      /******/
                      // no module.loaded needed
                      /******/
                      exports: {}
                      /******/
                    };
                    __webpack_modules__2[moduleId](module22, module22.exports, __nested_webpack_require_262623__);
                    return module22.exports;
                  }
                  (() => {
                    __nested_webpack_require_262623__.n = (module22) => {
                      var getter = module22 && module22.__esModule ? (
                        /******/
                        () => module22["default"]
                      ) : (
                        /******/
                        () => module22
                      );
                      __nested_webpack_require_262623__.d(getter, { a: getter });
                      return getter;
                    };
                  })();
                  (() => {
                    __nested_webpack_require_262623__.d = (exports2, definition) => {
                      for (var key in definition) {
                        if (__nested_webpack_require_262623__.o(definition, key) && !__nested_webpack_require_262623__.o(exports2, key)) {
                          Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                        }
                      }
                    };
                  })();
                  (() => {
                    __nested_webpack_require_262623__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
                  })();
                  (() => {
                    __nested_webpack_require_262623__.r = (exports2) => {
                      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                        Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                      }
                      Object.defineProperty(exports2, "__esModule", { value: true });
                    };
                  })();
                  var __nested_webpack_exports__ = {};
                  (() => {
                    "use strict";
                    __nested_webpack_require_262623__.r(__nested_webpack_exports__);
                    __nested_webpack_require_262623__.d(__nested_webpack_exports__, {
                      /* harmony export */
                      DataProvider: () => (
                        /* reexport module object */
                        _src_data_provider__WEBPACK_IMPORTED_MODULE_1__
                      ),
                      /* harmony export */
                      Tree: () => (
                        /* reexport module object */
                        _src_tree__WEBPACK_IMPORTED_MODULE_0__
                      )
                      /* harmony export */
                    });
                    var _src_tree__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_262623__(336);
                    var _src_tree__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_tree__WEBPACK_IMPORTED_MODULE_0__);
                    var _src_data_provider__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_262623__(950);
                    var _src_data_provider__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_data_provider__WEBPACK_IMPORTED_MODULE_1__);
                  })();
                  return __nested_webpack_exports__;
                })()
              );
            });
          }
        ),
        /***/
        46: (
          /***/
          (module2) => {
            "use strict";
            var R = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args);
            };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === "function") {
              ReflectOwnKeys = R.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn)
                console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module2.exports = EventEmitter;
            module2.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
              }
              this._maxListeners = n;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args = [];
              for (var i = 1; i < arguments.length; i++)
                args.push(arguments[i]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args.length > 0)
                  er = args[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  ReflectApply(listeners[i], this, args);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit(
                    "newListener",
                    type,
                    listener.listener ? listener.listener : listener
                  );
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                  existing.warned = true;
                  var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w.name = "MaxListenersExceededWarning";
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  ProcessEmitWarning(w);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = { fired: false, wrapFn: void 0, target, type, listener };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once2(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position, i, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                  if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                  }
                }
                if (position < 0)
                  return this;
                if (position === 0)
                  list.shift();
                else {
                  spliceOne(list, position);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === "removeListener")
                    continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
              var copy = new Array(n);
              for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
              return copy;
            }
            function spliceOne(list, index) {
              for (; index + 1 < list.length; index++)
                list[index] = list[index + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }
            function once(emitter, name) {
              return new Promise(function(resolve, reject) {
                function errorListener(err) {
                  emitter.removeListener(name, resolver);
                  reject(err);
                }
                function resolver() {
                  if (typeof emitter.removeListener === "function") {
                    emitter.removeListener("error", errorListener);
                  }
                  resolve([].slice.call(arguments));
                }
                ;
                eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                if (name !== "error") {
                  addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                }
              });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
              if (typeof emitter.on === "function") {
                eventTargetAgnosticAddListener(emitter, "error", handler, flags);
              }
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
              if (typeof emitter.on === "function") {
                if (flags.once) {
                  emitter.once(name, listener);
                } else {
                  emitter.on(name, listener);
                }
              } else if (typeof emitter.addEventListener === "function") {
                emitter.addEventListener(name, function wrapListener(arg) {
                  if (flags.once) {
                    emitter.removeEventListener(name, wrapListener);
                  }
                  listener(arg);
                });
              } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
              }
            }
          }
        ),
        /***/
        591: (
          /***/
          (module2) => {
            "use strict";
            var stylesInDOM = [];
            function getIndexByIdentifier(identifier) {
              var result = -1;
              for (var i = 0; i < stylesInDOM.length; i++) {
                if (stylesInDOM[i].identifier === identifier) {
                  result = i;
                  break;
                }
              }
              return result;
            }
            function modulesToDom(list, options) {
              var idCountMap = {};
              var identifiers = [];
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                var id = options.base ? item[0] + options.base : item[0];
                var count = idCountMap[id] || 0;
                var identifier = "".concat(id, " ").concat(count);
                idCountMap[id] = count + 1;
                var indexByIdentifier = getIndexByIdentifier(identifier);
                var obj = {
                  css: item[1],
                  media: item[2],
                  sourceMap: item[3],
                  supports: item[4],
                  layer: item[5]
                };
                if (indexByIdentifier !== -1) {
                  stylesInDOM[indexByIdentifier].references++;
                  stylesInDOM[indexByIdentifier].updater(obj);
                } else {
                  var updater = addElementStyle(obj, options);
                  options.byIndex = i;
                  stylesInDOM.splice(i, 0, {
                    identifier,
                    updater,
                    references: 1
                  });
                }
                identifiers.push(identifier);
              }
              return identifiers;
            }
            function addElementStyle(obj, options) {
              var api = options.domAPI(options);
              api.update(obj);
              var updater = function updater2(newObj) {
                if (newObj) {
                  if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
                    return;
                  }
                  api.update(obj = newObj);
                } else {
                  api.remove();
                }
              };
              return updater;
            }
            module2.exports = function(list, options) {
              options = options || {};
              list = list || [];
              var lastIdentifiers = modulesToDom(list, options);
              return function update(newList) {
                newList = newList || [];
                for (var i = 0; i < lastIdentifiers.length; i++) {
                  var identifier = lastIdentifiers[i];
                  var index = getIndexByIdentifier(identifier);
                  stylesInDOM[index].references--;
                }
                var newLastIdentifiers = modulesToDom(newList, options);
                for (var _i = 0; _i < lastIdentifiers.length; _i++) {
                  var _identifier = lastIdentifiers[_i];
                  var _index = getIndexByIdentifier(_identifier);
                  if (stylesInDOM[_index].references === 0) {
                    stylesInDOM[_index].updater();
                    stylesInDOM.splice(_index, 1);
                  }
                }
                lastIdentifiers = newLastIdentifiers;
              };
            };
          }
        ),
        /***/
        128: (
          /***/
          (module2) => {
            "use strict";
            var memo = {};
            function getTarget(target) {
              if (typeof memo[target] === "undefined") {
                var styleTarget = document.querySelector(target);
                if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                  try {
                    styleTarget = styleTarget.contentDocument.head;
                  } catch (e) {
                    styleTarget = null;
                  }
                }
                memo[target] = styleTarget;
              }
              return memo[target];
            }
            function insertBySelector(insert, style) {
              var target = getTarget(insert);
              if (!target) {
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              }
              target.appendChild(style);
            }
            module2.exports = insertBySelector;
          }
        ),
        /***/
        51: (
          /***/
          (module2) => {
            "use strict";
            function insertStyleElement(options) {
              var element = document.createElement("style");
              options.setAttributes(element, options.attributes);
              options.insert(element, options.options);
              return element;
            }
            module2.exports = insertStyleElement;
          }
        ),
        /***/
        855: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            function setAttributesWithoutAttributes(styleElement) {
              var nonce =  true ? __webpack_require__2.nc : 0;
              if (nonce) {
                styleElement.setAttribute("nonce", nonce);
              }
            }
            module2.exports = setAttributesWithoutAttributes;
          }
        ),
        /***/
        740: (
          /***/
          (module2) => {
            "use strict";
            function apply(styleElement, options, obj) {
              var css = "";
              if (obj.supports) {
                css += "@supports (".concat(obj.supports, ") {");
              }
              if (obj.media) {
                css += "@media ".concat(obj.media, " {");
              }
              var needLayer = typeof obj.layer !== "undefined";
              if (needLayer) {
                css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
              }
              css += obj.css;
              if (needLayer) {
                css += "}";
              }
              if (obj.media) {
                css += "}";
              }
              if (obj.supports) {
                css += "}";
              }
              var sourceMap = obj.sourceMap;
              if (sourceMap && typeof btoa !== "undefined") {
                css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
              }
              options.styleTagTransform(css, styleElement, options.options);
            }
            function removeStyleElement(styleElement) {
              if (styleElement.parentNode === null) {
                return false;
              }
              styleElement.parentNode.removeChild(styleElement);
            }
            function domAPI(options) {
              if (typeof document === "undefined") {
                return {
                  update: function update() {
                  },
                  remove: function remove() {
                  }
                };
              }
              var styleElement = options.insertStyleElement(options);
              return {
                update: function update(obj) {
                  apply(styleElement, options, obj);
                },
                remove: function remove() {
                  removeStyleElement(styleElement);
                }
              };
            }
            module2.exports = domAPI;
          }
        ),
        /***/
        656: (
          /***/
          (module2) => {
            "use strict";
            function styleTagTransform(css, styleElement) {
              if (styleElement.styleSheet) {
                styleElement.styleSheet.cssText = css;
              } else {
                while (styleElement.firstChild) {
                  styleElement.removeChild(styleElement.firstChild);
                }
                styleElement.appendChild(document.createTextNode(css));
              }
            }
            module2.exports = styleTagTransform;
          }
        ),
        /***/
        937: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAItlI+py+2fgAMSVUGvoZjHrFkeE0LmiabqagZO4CKxAM8GTONJrSv1ywoKh4oCADs=";
          }
        ),
        /***/
        592: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAACICAYAAADuxmtPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBQkU4MzRBNDE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBQkU4MzRBNTE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkFCRTgzNEEyMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFCRTgzNEEzMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+JumAiwAACF9JREFUeNrsmX9sU9cVx6/t599J6JrUSZyfjg2OnR+khB91qdRQ0a4pVA3QlgilaemP/TFtfyG1f7VSxRqgQ9M2RZUYYh2MpghNKlJAqVKphbUNtEAggRjHTuwk2IlJ45g48e8fb+cY+8XGdvADNHVdrnQU5/l+z73vnnM+795nDk3TBFthUZES/jSCFYHxSfoWBLODXbplt5vxAhUTP9Xe3r772c2bnywuLlZQFCVMpw6FQv6pqSlzb2/vedB8Ck6+o+BD1Wttbbtfb29vlUDj8XhkiSaUSqUauVxeweFyceApLmie2LJliy4vL08CIxMOh7OkYR/s+0Jz85Og3UAFg8HHKioqqvBLNg00CtSiA0oIjbBsqEFtdBHZjp7Yog64sCAP5OB/fAYCgSAMzc/n81lFArMSNGGuTCZz2Ww2y70S6G6zWq2WwsJCF7e5uXnk9OnTfRBTD65FNoZ9UYNa3r/Pnbt9+PBhemx83A+5Lc7Nzc2DeuClGxVuNTAxMWH6rKurx2g0ftnZ2dnHiZWz/I8HD9aePHmyDKotF0ZIW1F4z1Ct8607d1r37NlzDS5Nxh1gewRMBibFyGZYuwiYG+wW2BwTxhgT8uFPAwugzD1coLzz9tut+fn5EizMTIkFtysEmGgqKyuTgbJjxw5daWmpRCwWR8OUKfb4HfbBvtu3bYsChYtQ0Gq1VWxTGDSLQIF0Zg0U1KD2/svwYVXjL2EGCJQYHO4fKFCiFrYjj4+PLwLl1KlTfYFAwJMtjbAvahigHDp0iB4bG/MXxYACKcvLMO2AxWIxHT16tGdoaOiXAhSscSIrLHxq//79R0wm0w2/3++LRCJ0OsPvoI++o6PjCGqis4cPVR/BBY/H4wbq0tkY9t0HA4JWeQco27frYIEkMArJxrDvtpaWxR1KWVlZVcJiZtVAswgUeI4I0TObhhpmh8JWnFLO/+8OECiQYQ8GlJuw28A8YGMTN28uAqW7u7vP6/V6ss1E7Isa1GI5r2hra3tOqVQ246a7pKSkCp7OgkxAgb2R+cyZM31ms/nL48eP9y4D5SEAhVQqFLsMBoMeFo6+l/3j7HH6nc9+F/0Mmhuo5SYCZSk7N/Qt+fOlT4g3h5DWY2+wA4rRaiJ7v/uYqDR1ZNBwmfx9R2d6oDidTjLnc5HK4ookBx+eO0CK5OXkqk1PPtr8HtHKNIyGG3eA1m3qIa1f7CZfXOlmrr3f8wdC5YqIfsZE2hUvkeeVm5nvksrZ5pwk/xw8QTZqmkjH9wdJmBMm8/4FYgtOE/OCjazJXUV+r/tNSukzMyheUUQOvfJX0m+6QGoVa0i3uZd8cvEwmfbfJnlBiny8ZS+JhJKLKuUW5MI7TkasNwgH6qlW0UicM5PkLy0HCD9EpVRl1EEcKPGLpUI5+dvL4GRyiFwd6yd7n/+AFPFlKWLYI2QGSrmohHRu+xP57YY3yAZZ45JA4b351lu5kN/59fX1aogtP97hUf4jpLZAm1bs8/k8n5840aNSqb5ZBkoiUA4cOGIaGbkB4fHRGRp+B330Hfv2JQMFL8DKuuksG/bFARmgIKYyYSzR4kDBz4g/Bijl5eX3PPJ8PXiWAcorn75GQLMIFDzmLbXFGbLoU4CCmpQjj91uJ8NjxhQHcaBcA6B8AEB5vKwhuZzjKRoHyokL/2KuvXvq/SSgtNRsZb5LygOTbSQroKQ9saA3lVx5T6CIheKkoko58qgLVmYEyqPiX6U/MyFQEA5xr9rHqlOAsipflVLSEIHMR566Qi0DlOdWPrPkkScKlNHR0fzGxkY1xJYpInleMVlXuiatGAjowVNLRWXlN8yRxwJHHvCY3ZHn2LEe/fKRZ3mHsrxDWd6hLO9QMr+Ura6u3rimoUEAa8CDqaZ9O4dlbLPZVlzu71eA5nvmpeyqlSs3Nj39NIWxnZyaCtMZnvUcaCKxmLdp0yY+/LMRX8pSMNp6iEBk1uFwZ3NmDgYCYfgTUCoUAojEOgoQJRPw+X62J3gY2IdaCoT8OxuwAOujP2gFVGxx7vsFws/EARRH+IEcwALe/wzgUR70er00lDLNMgL4sj5ESaVSx5zLJc7JyWEVx4WFBQFoZ7hqtXrQefu2yOf1YpbR2Rj2RQ1qsZwFT+h0TZM22yqJROIWCYVBSHk6ww8UHJ/fL4CHq1heUmK6cP782TgPJLt27VL/ePGi1u12F8D9UWm3dHDPOO3169bpu7q6huGSJxEoiDFxLDKZXrZj5xCYF4N3N1DKHuhn4/8KUKanpwukOTkRAEqENVAcDseKUbO5GtfBr1b3A1BoBAo3ASgZ2+zsrHRkdLTu1Vd3ctauXe8dNhrrYvulZKBACCU4GoTKEx95fn5eCiOvbmnZDmnPd8AmRCISifxgQdQy5QwO+HAmrANnPJVSeRE7QcJIzBbL6q1bXxTAw2r2hx/OS6zWieDaxkb93NwchpNHxTbPBKa4uqnpmTwej0t/9VVvA0Tjus1qrf918wtiHoj7+y8Jx8bMIRBfn5mZWYgvNDdWGCKYgcR+y+7iC0Sz1ZoaLizQehDnwPPWOThwVTQyYqTr6+pQ7IK+4TiEqNjP4PNajebalf7LNcFAkC4vrwjKi+XBUDBMhg0GvslkDDc0NAzMOBxz4VCITgEKzCAETuya6urIwMCVGlhdqrS0LARnCmp42EBg5GsQZmfoLnESUGBaUSdQomRg8KoWOlND+uuc2pqaQVj5mbupFQcKD7JJhSXNo6gQdoLmhp2HxzBsKIAM1UNopz1ebzgMm+1Ec83PY724eDqdjsCZSSWEZIoe8WG7BIXvUVZV/QQjO8FBOBIOk0QDqHAgIaRarfbHjECB6XFwi//zB8p/BBgAHNqa8EdleScAAAAASUVORK5CYII=";
          }
        ),
        /***/
        952: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANCAYAAAB7AEQGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNEM5MTlGOTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNEM5MTlGQTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM0QzkxOUY3MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM0QzkxOUY4MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+52cTFgAAAQdJREFUeNpi+v//PwMyZuQUUEEXY2JAAkxcghMV5OVug2hkcWQTJgRFxPy/c+fOf3efwP9Afg9MDqagx9bZ4/+lS5f+Hzhw4P/Fixf/Wzu6gRS2g+WBDHNDfb0T82dNYXj18iXEDUxMDIJCQgwxSRkMN27e0oObBMRfgfg/Ev4ANwlsJ8TRXECKnQEVfPn37f1vsCKggnZOTo4KNjY2FBVfv35j+PPnDxvIKkNdY8v/V69e+//w4UM4Pn/+wn9VHSOQtZpwkzTV1Srys1IYWJiZGX79+sXQO3kmw937D5qA1tWjhJOhuc3/qdOm/Tcws8YMJ2SFojJKIAUTkMUZsMSdEroYQIABAD4w1u/PTSI1AAAAAElFTkSuQmCC";
          }
        ),
        /***/
        560: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAIjlI+py+0PDZhs2mWpyqDqCIbiSJbmEqRMyqJs4LbxSdf2UgAAOw==";
          }
        ),
        /***/
        784: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/gif;base64,R0lGODlhBAAeAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAEAB4AAAIXhA4maeyr1Jm02mvDDFpw/YVe12HmaRUAOw==";
          }
        ),
        /***/
        553: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAAqCAYAAAAXk8MDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjQyQUZBRjU3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjQyQUZBRjY3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2NDJBRkFGMzdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2NDJBRkFGNDdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv8NHYkAAASLSURBVHja3FhLbyNFEP7aHj+z3k1k5yGUxYmEtICSFRJrIXHYUyBCAo6cOEX5BZz4I9y4J3vgEIG0h0U5RQpIK22AA4l4HJIgsrE3b4f4MdN0tdPj2cnMZCZMj1eU1B67uz1dX9dX1V3FOOcgmZqa4pZlQQljzP6u5jjHqM85xz3Xa4yE1uh0Omi1Wi/1m6aJdDp9bZ9Xv/qdSqWQyWSwt7cnFzfo4/XqXV6e3UflXhuFIVKMtEMkoencBk8gr87pCjzbz4DPPvoCDx98gvKdCuKUF0d1PP7+W1RGK7xRbzBjenqaj71Tx1StjXwOyGYj4/IF45a/fwc+//RL1N78AC+eH+D5X/uxgjMMAx8+/BhGJo2JiQlukElfe7uF27eAYh5IG32FfU1kc9ADpEe/GvvzEHir+h7q9Tp0CNGd3v3g/vv4qvU1DPKN0h0gLyyWE82msuIZcynrBZpf8x81zUyhdd654sOxg7zoSj+UdiJAwhfBxNNSyvK+4szHWld05N4W7QeTDLrdLnSLWsNQypCilhkyciAABHNZEg5rQr/VXvLBHl1oV8XTuqqk7Uf29kcInS56irMmWXC0mATGewBvJF5+6YNhIOCIkhYPCBIxiMV7h3iitLQuaWn7HPP3KWdw4dzHz3ytlrDl5FXqv9IypPCkaWlbzlQ7G4GKLGTUvPxNm5g8La1eM60QoFjEyDlIWirLmWbIcy5MtPQZGwg40+pbL+qFuXd+BQNVF+uebycITvoA9/C3EH7nqSf3n2dhANHy4kxkBKVwlvM8CvzSIBfgtLi/nreaKGSLWkGdXzTlM0Xg6n9k0WkLenb7FvRrloPCgfMUDR3ziiL7+G33R2k9ne3ZLz8gl8vB2N7eZpN3J7mR2cf4vQ6Ktx0WivF2QlIcBtZ/fgRLbOIbk++K/PFWrBZr/nOKn359iu++eYLDw0PGlA9Uq1W7huKujzh/O31G1VKuq7k451JC2W63Zb6lQ6iWQsD6KY8QKthQi3tRWiybzcrCDRVwiC7UvC7U7qJSUBHKb/Od/dJylUqFLy4uYn5+HqOjo7GCo7R/dXUVy8vLGBsbk3UOVQUjsOq7U6hf9ak5zuqZc9w9dnJygqOjI+zs7DA2Pj7OFxYWMDc3JzvjzpQJzPDwMNbW1rCysoJyuay3xCBof3BwgOPjYxhExVqtpr1oMzs7i6WlJapK2TTSdeaNjIxIgLL6RdbSfbjSGtZlJh43MOf7FO3tgJJk0UYXMK/AYySd+rsVC77ehdfLa64nOL+diCVhddDyOuWj6uBmha/ldFhTvTPsu6Pq4J5veJ0z2soMCdKf1hqoz4XdhCD93If8KxNQwvraTfyf/pMoLZNeK3bLBUVaXRE4UVr6vS8p+it2JOpz/wvLvQpHAVlPgjs7O8PQ0JDWxZrNZmDYjlMoGSCWpChL3tjY0F602dzcRD6fT8RilJfSRhqNRoOJ/EfyZWZmBqVSKdbFTk9PsbW1hfX1de2JKmUeAo9su7u7/QIRAbxJ/SRsClMoFGSuFaYmEnXcfWOhih59/1eAAQAVvW4V+Ky7cAAAAABJRU5ErkJggg==";
          }
        ),
        /***/
        147: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==";
          }
        ),
        /***/
        444: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__444__;
          }
        ),
        /***/
        910: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__910__;
          }
        ),
        /***/
        254: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__254__;
          }
        ),
        /***/
        685: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__685__;
          }
        ),
        /***/
        292: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__292__;
          }
        ),
        /***/
        736: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__736__;
          }
        ),
        /***/
        517: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__517__;
          }
        ),
        /***/
        540: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__540__;
          }
        ),
        /***/
        863: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__863__;
          }
        ),
        /***/
        387: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__387__;
          }
        ),
        /***/
        493: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__493__;
          }
        ),
        /***/
        748: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__748__;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __nested_webpack_require_440138__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          id: moduleId,
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __nested_webpack_require_440138__);
        return module2.exports;
      }
      __nested_webpack_require_440138__.m = __webpack_modules__;
      (() => {
        __nested_webpack_require_440138__.n = (module2) => {
          var getter = module2 && module2.__esModule ? (
            /******/
            () => module2["default"]
          ) : (
            /******/
            () => module2
          );
          __nested_webpack_require_440138__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __nested_webpack_require_440138__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__nested_webpack_require_440138__.o(definition, key) && !__nested_webpack_require_440138__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __nested_webpack_require_440138__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __nested_webpack_require_440138__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      (() => {
        __nested_webpack_require_440138__.b = document.baseURI || self.location.href;
        var installedChunks = {
          /******/
          57: 0
          /******/
        };
      })();
      (() => {
        __nested_webpack_require_440138__.nc = void 0;
      })();
      var __nested_webpack_exports__ = {};
      (() => {
        "use strict";
        __nested_webpack_require_440138__.r(__nested_webpack_exports__);
        __nested_webpack_require_440138__.d(__nested_webpack_exports__, {
          Accordion: () => (
            /* reexport */
            Accordion
          ),
          AceEditor: () => (
            /* reexport */
            AceEditor
          ),
          AceLayout: () => (
            /* reexport */
            AceLayout
          ),
          AceTreeWrapper: () => (
            /* reexport */
            AceTreeWrapper
          ),
          Box: () => (
            /* reexport */
            Box
          ),
          Button: () => (
            /* reexport */
            Button
          ),
          CommandManager: () => (
            /* reexport */
            CommandManager
          ),
          Dropdown: () => (
            /* reexport */
            Dropdown
          ),
          EditorType: () => (
            /* reexport */
            EditorType
          ),
          FileSystemWeb: () => (
            /* reexport */
            FileSystemWeb
          ),
          ListBox: () => (
            /* reexport */
            ListBox
          ),
          Menu: () => (
            /* reexport */
            Menu
          ),
          MenuBar: () => (
            /* reexport */
            MenuBar
          ),
          MenuItems: () => (
            /* reexport */
            MenuItems
          ),
          MenuManager: () => (
            /* reexport */
            MenuManager
          ),
          MenuPopup: () => (
            /* reexport */
            MenuPopup
          ),
          MenuSearchBox: () => (
            /* reexport */
            MenuSearchBox
          ),
          MenuToolbar: () => (
            /* reexport */
            MenuToolbar
          ),
          Pane: () => (
            /* reexport */
            Pane
          ),
          Panel: () => (
            /* reexport */
            Panel
          ),
          PanelBar: () => (
            /* reexport */
            PanelBar
          ),
          PanelManager: () => (
            /* reexport */
            PanelManager
          ),
          PreviewEditor: () => (
            /* reexport */
            PreviewEditor
          ),
          SettingsSearchBox: () => (
            /* reexport */
            SettingsSearchBox
          ),
          SizeUnit: () => (
            /* reexport */
            SizeUnit
          ),
          Switcher: () => (
            /* reexport */
            Switcher
          ),
          Tab: () => (
            /* reexport */
            Tab
          ),
          TabManager: () => (
            /* reexport */
            TabManager
          ),
          Toolbar: () => (
            /* reexport */
            Toolbar
          ),
          dom: () => (
            /* reexport */
            dom
          )
        });
        var accordion_namespaceObject = {};
        __nested_webpack_require_440138__.r(accordion_namespaceObject);
        __nested_webpack_require_440138__.d(accordion_namespaceObject, {
          "default": () => styles_accordion
        });
        var tab_namespaceObject = {};
        __nested_webpack_require_440138__.r(tab_namespaceObject);
        __nested_webpack_require_440138__.d(tab_namespaceObject, {
          "default": () => styles_tab
        });
        var menu_namespaceObject = {};
        __nested_webpack_require_440138__.r(menu_namespaceObject);
        __nested_webpack_require_440138__.d(menu_namespaceObject, {
          "default": () => styles_menu
        });
        var button_namespaceObject = {};
        __nested_webpack_require_440138__.r(button_namespaceObject);
        __nested_webpack_require_440138__.d(button_namespaceObject, {
          "default": () => assets_styles_button
        });
        var dropdown_namespaceObject = {};
        __nested_webpack_require_440138__.r(dropdown_namespaceObject);
        __nested_webpack_require_440138__.d(dropdown_namespaceObject, {
          "default": () => styles_dropdown
        });
        var switcher_namespaceObject = {};
        __nested_webpack_require_440138__.r(switcher_namespaceObject);
        __nested_webpack_require_440138__.d(switcher_namespaceObject, {
          "default": () => styles_switcher
        });
        var panel_namespaceObject = {};
        __nested_webpack_require_440138__.r(panel_namespaceObject);
        __nested_webpack_require_440138__.d(panel_namespaceObject, {
          "default": () => styles_panel
        });
        var layout_namespaceObject = {};
        __nested_webpack_require_440138__.r(layout_namespaceObject);
        __nested_webpack_require_440138__.d(layout_namespaceObject, {
          "default": () => styles_layout
        });
        var ace_tree_namespaceObject = {};
        __nested_webpack_require_440138__.r(ace_tree_namespaceObject);
        __nested_webpack_require_440138__.d(ace_tree_namespaceObject, {
          "default": () => styles_ace_tree
        });
        var hash_handler_ = __nested_webpack_require_440138__(736);
        ;
        const commandManager_event = __nested_webpack_require_440138__(517);
        const keyUtil = __nested_webpack_require_440138__(863);
        class CommandManager {
          static registerCommands(commands, context) {
            let menuKb = new hash_handler_.HashHandler(commands);
            let _this = context;
            commandManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
              let keyString = keyUtil.keyCodeToString(keyCode);
              let command = menuKb.findKeyCommand(hashId, keyString);
              if (command && command.exec) {
                commandManager_event.stopEvent(e);
                command.exec(_this);
              }
            });
          }
        }
        var useragent_ = __nested_webpack_require_440138__(493);
        ;
        var XHTML_NS = "http://www.w3.org/1999/xhtml";
        var dom;
        ((dom2) => {
          dom2.buildDom = function(arr, parent, refs) {
            if (typeof arr == "string" && arr) {
              var txt = document.createTextNode(arr);
              if (parent)
                parent.appendChild(txt);
              return txt;
            }
            if (!Array.isArray(arr)) {
              if (arr && arr.appendChild && parent)
                parent.appendChild(arr);
              return arr;
            }
            if (typeof arr[0] != "string" || !arr[0]) {
              var els = [];
              for (var i = 0; i < arr.length; i++) {
                var ch = (0, dom2.buildDom)(arr[i], parent, refs);
                ch && els.push(ch);
              }
              return els;
            }
            var el = document.createElement(arr[0]);
            var options2 = arr[1];
            var childIndex = 1;
            if (options2 && typeof options2 == "object" && !Array.isArray(options2))
              childIndex = 2;
            for (var i = childIndex; i < arr.length; i++)
              (0, dom2.buildDom)(arr[i], el, refs);
            if (childIndex == 2) {
              Object.keys(options2).forEach(function(n) {
                var val = options2[n];
                if (n === "class") {
                  el.className = Array.isArray(val) ? val.join(" ") : val;
                } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                  el[n] = val;
                } else if (n === "ref") {
                  if (refs)
                    refs[val] = el;
                } else if (n === "style") {
                  if (typeof val == "string")
                    el.style.cssText = val;
                } else if (val != null) {
                  el.setAttribute(n, val);
                }
              });
            }
            if (parent)
              parent.appendChild(el);
            return el;
          };
          dom2.getDocumentHead = function(doc) {
            if (!doc)
              doc = document;
            return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
          };
          dom2.createElement = function(tag, ns) {
            return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
          };
          dom2.removeChildren = function(element) {
            element.innerHTML = "";
          };
          dom2.createTextNode = function(textContent, element) {
            var doc = element ? element.ownerDocument : document;
            return doc.createTextNode(textContent);
          };
          dom2.createFragment = function(element) {
            var doc = element ? element.ownerDocument : document;
            return doc.createDocumentFragment();
          };
          dom2.hasCssClass = function(el, name) {
            var classes = (el.className + "").split(/\s+/g);
            return classes.indexOf(name) !== -1;
          };
          dom2.addCssClass = function(el, name) {
            if (!(0, dom2.hasCssClass)(el, name)) {
              el.className += " " + name;
            }
          };
          dom2.removeCssClass = function(el, name) {
            var classes = el.className.split(/\s+/g);
            while (true) {
              var index = classes.indexOf(name);
              if (index == -1) {
                break;
              }
              classes.splice(index, 1);
            }
            el.className = classes.join(" ");
          };
          dom2.toggleCssClass = function(el, name) {
            var classes = el.className.split(/\s+/g), add = true;
            while (true) {
              var index = classes.indexOf(name);
              if (index == -1) {
                break;
              }
              add = false;
              classes.splice(index, 1);
            }
            if (add)
              classes.push(name);
            el.className = classes.join(" ");
            return add;
          };
          dom2.setCssClass = function(node, className, include) {
            if (include) {
              (0, dom2.addCssClass)(node, className);
            } else {
              (0, dom2.removeCssClass)(node, className);
            }
          };
          dom2.hasCssString = function(id, doc) {
            var index = 0, sheets;
            doc = doc || document;
            if (sheets = doc.querySelectorAll("style")) {
              while (index < sheets.length) {
                if (sheets[index++].id === id) {
                  return true;
                }
              }
            }
          };
          dom2.removeElementById = function(id, doc) {
            doc = doc || document;
            if (doc.getElementById(id)) {
              doc.getElementById(id).remove();
            }
          };
          var strictCSP;
          var cssCache = [];
          dom2.useStrictCSP = function(value) {
            strictCSP = value;
            if (value == false)
              insertPendingStyles();
            else if (!cssCache)
              cssCache = [];
          };
          function insertPendingStyles() {
            var cache = cssCache;
            cssCache = null;
            cache && cache.forEach(function(item) {
              importCssString(item[0], item[1]);
            });
          }
          function importCssString(cssText, id, target) {
            if (typeof document == "undefined")
              return;
            if (cssCache) {
              if (target) {
                insertPendingStyles();
              } else if (target === false) {
                return cssCache.push([cssText, id]);
              }
            }
            if (strictCSP)
              return;
            var container = target;
            if (!target || !target.getRootNode) {
              container = document;
            } else {
              container = target.getRootNode();
              if (!container || container == target)
                container = document;
            }
            var doc = container.ownerDocument || container;
            if (id && (0, dom2.hasCssString)(id, container))
              return null;
            if (id)
              cssText += "\n/*# sourceURL=ace/css/" + id + " */";
            var style = (0, dom2.createElement)("style");
            style.appendChild(doc.createTextNode(cssText));
            if (id)
              style.id = id;
            if (container == doc)
              container = (0, dom2.getDocumentHead)(doc);
            container.insertBefore(style, container.firstChild);
          }
          dom2.importCssString = importCssString;
          dom2.importCssStylsheet = function(uri, doc) {
            (0, dom2.buildDom)(["link", { rel: "stylesheet", href: uri }], (0, dom2.getDocumentHead)(doc));
          };
          dom2.scrollbarWidth = function(document2) {
            var inner = (0, dom2.createElement)("ace_inner");
            inner.style.width = "100%";
            inner.style.minWidth = "0px";
            inner.style.height = "200px";
            inner.style.display = "block";
            var outer = (0, dom2.createElement)("ace_outer");
            var style = outer.style;
            style.position = "absolute";
            style.left = "-10000px";
            style.overflow = "hidden";
            style.width = "200px";
            style.minWidth = "0px";
            style.height = "150px";
            style.display = "block";
            outer.appendChild(inner);
            var body = document2.documentElement;
            body.appendChild(outer);
            var noScrollbar = inner.offsetWidth;
            style.overflow = "scroll";
            var withScrollbar = inner.offsetWidth;
            if (noScrollbar == withScrollbar) {
              withScrollbar = outer.clientWidth;
            }
            body.removeChild(outer);
            return noScrollbar - withScrollbar;
          };
          dom2.computedStyle = function(element, style) {
            return window.getComputedStyle(element, "") || {};
          };
          dom2.setStyle = function(styles, property, value) {
            if (styles[property] !== value) {
              styles[property] = value;
            }
          };
          dom2.HAS_CSS_ANIMATION = false;
          dom2.HAS_CSS_TRANSFORMS = false;
          dom2.HI_DPI = useragent_.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
          if (useragent_.isChromeOS)
            dom2.HI_DPI = false;
          if (typeof document !== "undefined") {
            var div = document.createElement("div");
            if (dom2.HI_DPI && div.style.transform !== void 0)
              dom2.HAS_CSS_TRANSFORMS = true;
            if (!useragent_.isEdge && typeof div.style.animationName !== "undefined")
              dom2.HAS_CSS_ANIMATION = true;
            div = null;
          }
          if (dom2.HAS_CSS_TRANSFORMS) {
            dom2.translate = function(element, tx, ty) {
              element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
            };
          } else {
            dom2.translate = function(element, tx, ty) {
              element.style.top = Math.round(ty) + "px";
              element.style.left = Math.round(tx) + "px";
            };
          }
        })(dom || (dom = {}));
        ;
        var SizeUnit = /* @__PURE__ */ ((SizeUnit2) => {
          SizeUnit2[SizeUnit2["px"] = 0] = "px";
          SizeUnit2[SizeUnit2["percent"] = 1] = "percent";
          return SizeUnit2;
        })(SizeUnit || {});
        var EditorType = /* @__PURE__ */ ((EditorType2) => {
          EditorType2["ace"] = "ace";
          EditorType2["preview"] = "preview";
          return EditorType2;
        })(EditorType || {});
        ;
        var Utils;
        ((Utils2) => {
          Utils2.findHost = function(el, constructor) {
            while (el) {
              if (el.$host && (!constructor || el.$host.constructor === constructor))
                return el.$host;
              el = el.parentElement;
            }
          };
          Utils2.findNode = function(node, className) {
            while (node && node.classList) {
              if (node.classList.contains(className))
                return node;
              node = node.parentNode;
            }
            return null;
          };
          Utils2.findHostTarget = function(target) {
            while (target) {
              if (target.$host)
                return target;
              target = target.parentElement;
            }
            return null;
          };
          Utils2.setBox = function(el, x, y, w, h) {
            if (w) {
              w = Math.max(w, 0);
            }
            if (h) {
              h = Math.max(h, 0);
            }
            let s = el.style;
            s.left = x + "px";
            s.top = y + "px";
            s.width = w + "px";
            s.height = h + "px";
          };
          function getEdge(style, dir) {
            return parseInt(style["padding" + dir], 10) + parseInt(style["margin" + dir], 10) + parseInt(style["border" + dir], 10);
          }
          Utils2.getEdge = getEdge;
          function getElementEdges(element) {
            let style = getComputedStyle(element);
            return {
              "top": getEdge(style, "Top"),
              "bottom": getEdge(style, "Bottom"),
              "left": getEdge(style, "Left"),
              "right": getEdge(style, "Right")
            };
          }
          Utils2.getElementEdges = getElementEdges;
        })(Utils || (Utils = {}));
        var event_ = __nested_webpack_require_440138__(517);
        var events = __nested_webpack_require_440138__(46);
        ;
        const SPLITTER_SIZE = 1;
        const BOX_MIN_SIZE = 40;
        class Box extends events.EventEmitter {
          constructor(options2) {
            var _a, _b, _c, _d;
            super();
            this.$editorAdded = (editor) => {
              this.emit("editorAdded", editor);
            };
            if (options2.splitter !== false) {
            }
            this.vertical = options2.vertical || false;
            this.color = (_a = options2.color) != null ? _a : "";
            this.isMain = options2.isMain || false;
            this[0] = options2[0];
            this[1] = options2[1];
            if (this[0])
              this[0].parent = this;
            if (this[1])
              this[1].parent = this;
            this.ratio = options2.ratio;
            this.toolBars = options2.toolBars || {};
            this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
            this.size = options2.size;
            this.sizeUnit = (_b = options2.sizeUnit) != null ? _b : SizeUnit.px;
            this.minSize = options2.minSize || BOX_MIN_SIZE;
            this.minVerticalSize = options2.minVerticalSize || this.minSize;
            this.minHorizontalSize = options2.minHorizontalSize || this.minSize;
            this.classNames = (_c = options2.classNames) != null ? _c : "";
            this.hidden = (_d = options2.hidden) != null ? _d : false;
            this.fixedSize = options2.fixedSize;
          }
          //TODO
          static enableAnimation() {
            document.documentElement.classList.add("animateBoxes");
          }
          static disableAnimation() {
            document.documentElement.classList.remove("animateBoxes");
          }
          static setGlobalCursor(value) {
            if (value)
              document.documentElement.classList.add("inheritCursor");
            else
              document.documentElement.classList.remove("inheritCursor");
            document.documentElement.style.cursor = value;
          }
          toJSON() {
            return {
              0: this[0] && this[0].toJSON(),
              1: this[1] && this[1].toJSON(),
              ratio: this.ratio,
              type: this.vertical ? "vbox" : "hbox",
              fixedSize: this.fixedSize || null,
              hidden: this.hidden,
              color: this.color,
              size: this.size
            };
          }
          onMouseDown(e) {
            let button = e.button;
            if (button !== 0)
              return;
            let box = this;
            let rect = this.element.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;
            document.body.classList.add("dragging");
            let onMouseMove = function(e2) {
              x = e2.clientX - rect.left - box.padding.left;
              y = e2.clientY - rect.top - box.padding.top;
              let height = rect.height - box.padding.top - box.padding.bottom;
              let width = rect.width - box.padding.left - box.padding.right;
              if (box.fixedChild) {
                if (box.vertical) {
                  box.fixedChild.fixedSize = box.fixedChild === box[1] ? height - y : y;
                } else {
                  box.fixedChild.fixedSize = box.fixedChild === box[1] ? width - x : x;
                }
                box.fixedChild.fixedSize = Math.max(box.fixedChild.fixedSize, box.fixedChild.minSize);
                box.ratio = void 0;
              } else {
                if (box.vertical) {
                  box.ratio = y / height;
                } else {
                  box.ratio = x / width;
                }
                box.ratio = Math.max(box.minRatio, Math.min(box.ratio, box.maxRatio));
              }
              box.resize();
            };
            let onResizeEnd = function(e2) {
              Box.setGlobalCursor("");
              document.body.classList.remove("dragging");
            };
            Box.setGlobalCursor(`${box.vertical ? "ns" : "ew"}-resize`);
            event_.capture(window, onMouseMove, onResizeEnd);
            return e.preventDefault();
          }
          resize() {
            if (!this.box)
              return;
            this.setBox(...this.box);
          }
          calculateMinMaxRatio() {
            if (!this.box || !this[0] && !this[1])
              return;
            let propertyName = this.vertical ? "minVerticalSize" : "minHorizontalSize";
            let size = this.vertical ? this.box[3] - this.padding.top - this.padding.bottom : this.box[2] - this.padding.left - this.padding.right;
            this.minRatio = this[0] ? this[0][propertyName] / size : 0;
            this.maxRatio = this[1] ? (size - this[1][propertyName]) / size : 1;
          }
          render() {
            var _a;
            if ((_a = this.element) == null ? void 0 : _a.$host)
              return this.element;
            this.renderElement();
            this.splitter = dom.buildDom(["div", {
              class: `splitter splitter${this.vertical ? "-v" : "-h"}`
            }, ["div"]]);
            this.splitter.onmousedown = this.onMouseDown.bind(this);
            this.element.appendChild(this.splitter);
            this.element.$host = this;
            this.element.style.backgroundColor = this.color;
            this.element.style.position = "absolute";
            this.renderToolBarList();
            this.renderChildren();
            if (!this.ratio)
              this.calculateRatio();
            return this.element;
          }
          renderElement() {
            var _a;
            (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", {
              class: "box" + this.classNames
            }]);
          }
          renderToolBarList() {
            for (let position in this.toolBars) {
              this.addToolBar(position, this.toolBars[position]);
            }
          }
          addToolBar(position, bar) {
            var _a, _b;
            if (position == "left" || position == "right")
              bar.direction = "vertical";
            (_b = (_a = this.toolBars[position]) == null ? void 0 : _a.element) == null ? void 0 : _b.remove();
            bar.position = position;
            this.padding[position] = bar.size;
            this.element.appendChild(bar.render());
            this.toolBars[position] = bar;
          }
          removeToolBar(position) {
            delete this.toolBars[position];
            this.padding[position] = 0;
          }
          renderChildren() {
            this.renderChild(this[0]);
            this.renderChild(this[1]);
            this.calculateMinSize();
          }
          renderChild(child) {
            if (!child)
              return;
            if (!this.element)
              this.render();
            child.on("editorAdded", this.$editorAdded);
            this.element.appendChild(child.render());
          }
          calculateMinSize(forceChildrenSize = false) {
            let childrenMinVerticalSize = 0;
            let childrenMinHorizontalSize = 0;
            let calculateChildBoxMinSize = (childBox) => {
              if (this.vertical) {
                childrenMinVerticalSize += childBox.minVerticalSize;
                childrenMinHorizontalSize = Math.max(childBox.minHorizontalSize, childrenMinHorizontalSize);
              } else {
                childrenMinVerticalSize = Math.max(childBox.minVerticalSize, childrenMinVerticalSize);
                childrenMinHorizontalSize += childBox.minHorizontalSize;
              }
            };
            if (this[0])
              calculateChildBoxMinSize(this[0]);
            if (this[1])
              calculateChildBoxMinSize(this[1]);
            if (forceChildrenSize) {
              this.minVerticalSize = childrenMinVerticalSize;
              this.minHorizontalSize = childrenMinHorizontalSize;
            } else {
              this.minVerticalSize = Math.max(this.minVerticalSize, childrenMinVerticalSize);
              this.minHorizontalSize = Math.max(this.minHorizontalSize, childrenMinHorizontalSize);
            }
            this.minSize = this.vertical ? this.minVerticalSize : this.minHorizontalSize;
            this.calculateMinMaxRatio();
          }
          calculateRatio() {
            if (this[0]) {
              this.calculateChildRatio(this[0]);
            }
            if (this.ratio || this.fixedChild) {
              return;
            }
            if (this[1]) {
              this.calculateChildRatio(this[1]);
            }
            if (!this.ratio && !this.fixedChild) {
              this.ratio = 0.5;
            }
          }
          calculateChildRatio(childBox, isSecond = false) {
            if (!childBox.size) {
              return;
            }
            let size = childBox.size;
            switch (this.sizeUnit) {
              case SizeUnit.px:
                childBox.fixedSize = size;
                this.fixedChild = childBox;
                break;
              case SizeUnit.percent:
                if (isSecond) {
                  size = 100 - size;
                }
                this.ratio = Math.min(size / 100, 1);
                break;
            }
          }
          renderButtons(buttonList) {
            let buttons = buttonList.map((button) => {
              return dom.buildDom(["div", {
                class: "button " + button.class,
                title: button.title,
                onclick: button.onclick
              }, button.content]);
            });
            this.setButtons(buttons);
          }
          /**
           * Sets buttons of this box top-right tabBar
           */
          setButtons(buttons) {
            this.buttons = buttons;
            if (this.topRightPane)
              this.topRightPane.removeButtons();
            this.topRightPane = this.getTopRightPane();
            if (this.topRightPane)
              this.topRightPane.setButtons(buttons);
          }
          addButton(button) {
            this.topRightPane = this.getTopRightPane();
            if (this.topRightPane)
              this.topRightPane.addButton(button);
          }
          /**
           * Finds the most top-right Pane
           */
          getTopRightPane() {
            let childBox = this.vertical ? this[0] || this[1] : this[1] || this[0];
            if (!childBox)
              return;
            return childBox.getTopRightPane();
          }
          setBox(x, y, w, h) {
            this.box = [x, y, w, h];
            if (this.isMaximized) {
              x = 0;
              y = 0;
              w = window.innerWidth;
              h = window.innerHeight;
            }
            Utils.setBox(this.element, x, y, w, h);
            this.calculateMinMaxRatio();
            this.$updateChildSize(x, y, w, h);
          }
          $updateChildSize(x, y, w, h) {
            var _a;
            let splitterSize = SPLITTER_SIZE;
            if (!this[0] || this[0].hidden || !this[1] || this[1].hidden) {
              this.splitter.style.display = "none";
              splitterSize = 0;
            } else {
              this.splitter.style.display = "";
            }
            this.updateToolBarSize(w, h);
            w -= this.padding.left + this.padding.right;
            h -= this.padding.top + this.padding.bottom;
            x = this.padding.left;
            y = this.padding.top;
            if (this.fixedChild) {
              let size = this.fixedChild.fixedSize;
              if (this.fixedChild === this[1]) {
                size = this.vertical ? h - size : w - size;
              }
              this.ratio = this.vertical ? size / h : size / w;
            }
            this.ratio = Math.max(this.minRatio, Math.min((_a = this.ratio) != null ? _a : this.maxRatio, this.maxRatio));
            let ratio = this.ratio;
            if (!this[0] || this[0].hidden) {
              ratio = 0;
            } else if (!this[1] || this[1].hidden) {
              ratio = 1;
            }
            if (this.vertical) {
              let splitY = h * ratio - splitterSize;
              if (this.splitter)
                Utils.setBox(this.splitter, x, y + splitY, w, splitterSize);
              if (this[0])
                this[0].setBox(x, y, w, splitY);
              if (this[1])
                this[1].setBox(x, y + splitY + splitterSize, w, h - splitY - splitterSize);
            } else {
              let splitX = w * ratio - splitterSize;
              if (this.splitter)
                Utils.setBox(this.splitter, x + splitX, y, splitterSize, h);
              if (this[0])
                this[0].setBox(x, y, splitX, h);
              if (this[1])
                this[1].setBox(x + splitX + splitterSize, y, w - splitX - splitterSize, h);
            }
          }
          updateToolBarSize(width, height) {
            let bar, x, y, w, h;
            for (let type in this.toolBars) {
              x = 0;
              y = 0;
              w = width;
              h = height;
              bar = this.toolBars[type];
              switch (type) {
                case "top":
                case "bottom":
                  h = bar.size;
                  if (type === "bottom")
                    y = height - bar.size;
                  break;
                case "left":
                case "right":
                  w = bar.size;
                  y = this.padding.top;
                  h -= this.padding.top + this.padding.bottom;
                  if (type === "right")
                    x = width - bar.size;
                  break;
                default:
                  continue;
              }
              bar.setBox(x, y, w, h);
            }
          }
          restore(disableAnimation = false) {
            let node = this.element;
            function rmClass(ch, cls) {
              for (let i = 0; i < ch.length; i++) {
                if (ch[i].classList)
                  ch[i].classList.remove(cls);
              }
            }
            let finishRestore = () => {
              classes.forEach(function(className) {
                rmClass(document.querySelectorAll("." + className), className);
              });
              this.setBox(...this.box);
            };
            let classes = [
              "fullScreenSibling",
              "fullScreenNode",
              "fullScreenParent"
            ];
            this.isMaximized = false;
            if (disableAnimation) {
              finishRestore();
            } else {
              Box.enableAnimation();
              node.addEventListener("transitionend", function handler(l) {
                Box.disableAnimation();
                node.removeEventListener("transitionend", handler);
                finishRestore();
              });
            }
            let parentRect = node.parentNode.getBoundingClientRect();
            let top = parentRect.top + this.box[1];
            let left = parentRect.left + this.box[0];
            Utils.setBox(node, left, top, this.box[2], this.box[3]);
          }
          maximize(disableAnimation = false) {
            let node = this.element;
            function addClasses() {
              node.classList.add("fullScreenNode");
              let parent = node.parentNode;
              while (parent && parent !== document.body) {
                if (parent.classList)
                  parent.classList.add("fullScreenParent");
                let childNodes = parent.childNodes;
                for (let i = 0; i < childNodes.length; i++) {
                  let childNode = childNodes[i];
                  if (childNode != node && childNode.classList && !childNode.classList.contains("fullScreenParent"))
                    childNode.classList.add("fullScreenSibling");
                }
                parent = parent.parentNode;
              }
            }
            let rect = node.getBoundingClientRect();
            Utils.setBox(node, rect.left, rect.top, rect.width, rect.height);
            addClasses();
            this.isMaximized = true;
            node.getBoundingClientRect();
            if (!disableAnimation) {
              Box.enableAnimation();
              node.addEventListener("transitionend", function handler() {
                node.removeEventListener("transitionend", handler);
                Box.disableAnimation();
              });
            }
            this.setBox(...this.box);
          }
          toggleMaximize() {
            if (this.isMaximized)
              this.restore();
            else
              this.maximize();
          }
          remove() {
            this.removeAllChildren();
            if (this.element)
              this.element.remove();
            if (this.parent) {
              if (this.parent[0] == this)
                this.parent[0] = void 0;
              if (this.parent[1] == this)
                this.parent[1] = void 0;
              this.parent.recalculateAllMinSizes();
              this.parent = void 0;
            }
          }
          removeAllChildren() {
            this.removeChild(this[0]);
            this.removeChild(this[1]);
            this[0] = void 0;
            this[1] = void 0;
          }
          removeChild(child) {
            if (!child)
              return;
            child.off("editorAdded", this.$editorAdded);
            child.remove();
            child.element.remove();
          }
          toggleShowHide() {
            var _a;
            Box.enableAnimation();
            this.hidden = !this.hidden;
            (_a = this.parent) == null ? void 0 : _a.resize();
            let node = this.element;
            let self2 = this;
            node.addEventListener("transitionend", function handler() {
              var _a2;
              node.removeEventListener("transitionend", handler);
              Box.disableAnimation();
              (_a2 = self2.parent) == null ? void 0 : _a2.resize();
            });
          }
          hide() {
            var _a;
            Box.enableAnimation();
            this.hidden = true;
            (_a = this.parent) == null ? void 0 : _a.resize();
            let node = this.element;
            let self2 = this;
            node.addEventListener("transitionend", function handler() {
              var _a2;
              node.removeEventListener("transitionend", handler);
              Box.disableAnimation();
              (_a2 = self2.parent) == null ? void 0 : _a2.resize();
            });
          }
          show() {
            var _a;
            Box.enableAnimation();
            this.hidden = false;
            (_a = this.parent) == null ? void 0 : _a.resize();
            let node = this.element;
            let self2 = this;
            node.addEventListener("transitionend", function handler() {
              var _a2;
              node.removeEventListener("transitionend", handler);
              Box.disableAnimation();
              (_a2 = self2.parent) == null ? void 0 : _a2.resize();
            });
          }
          /**
           *
           * @param {Number} previousBoxIndex
           * @param {Box} box
           * @returns {Box}
           */
          addChildBox(previousBoxIndex, box) {
            let previousBox, index;
            if (previousBoxIndex instanceof Box) {
              previousBox = previousBoxIndex;
              index = this[0] == previousBox ? 0 : 1;
            } else {
              index = previousBoxIndex;
              previousBox = this[index];
            }
            if (previousBox && previousBox === box)
              return previousBox;
            let previousParent = box.parent;
            if (previousParent && previousParent !== this) {
              let previousIndex = previousParent[0] === box ? 0 : 1;
              previousParent[previousIndex] = null;
              previousParent.ratio = 1;
              if (previousParent.fixedChild && previousParent.fixedChild === box) {
                previousParent.fixedChild = null;
              }
              previousParent.resize();
            }
            this[index] = box;
            box.parent = this;
            this.renderChild(box);
            if (previousBox && previousBox.isMaximized) {
              previousBox.restore(true);
              box.maximize(true);
            }
            if (previousBox && previousBox.parent === this) {
              if (this.fixedChild && this.fixedChild == previousBox) {
                box.fixedSize = previousBox.fixedSize;
                if (!box.size)
                  box.size = previousBox.size;
                previousBox.fixedSize = previousBox.size = null;
                this.fixedChild = box;
              }
              previousBox.remove();
            }
            if (!this.fixedChild)
              this.calculateChildRatio(box);
            this.recalculateAllMinSizes();
            this.resize();
            return box;
          }
          recalculateAllMinSizes() {
            let node = this;
            while (node) {
              node.calculateMinSize(true);
              node = node.parent;
            }
          }
        }
        ;
        let accordion_handler_event = __nested_webpack_require_440138__(517);
        var AccordionHandler;
        ((AccordionHandler2) => {
          AccordionHandler2.toggleBarMouseDown = function(e, accordionConstructor) {
            let toggleBlock = Utils.findNode(e.target, "toggle-block");
            if (!toggleBlock)
              return;
            let accordionBox, accordionBoxRect, toggleBlockDragging, toggleBlockRect;
            let startIndex, changeIndex, previousIndex;
            let toggleBar, section, splitter;
            let startX = e.clientX, startY = e.clientY;
            let isDragging = false;
            let posX, posY, prevY, prevX;
            let prevBlock, topMaxY, nextBlock, bottomMaxY;
            function distance(dx, dy) {
              return dx * dx + dy * dy;
            }
            function calculateNearbyBlocksData() {
              if (!accordionBox)
                return;
              prevBlock = accordionBox.toggleBlockList[changeIndex - 1] || null;
              nextBlock = accordionBox.toggleBlockList[changeIndex + 1] || null;
              topMaxY = prevBlock && parseInt(prevBlock.style.top, 10) + parseInt(prevBlock.style.height, 10) / 2 + accordionBoxRect.top;
              bottomMaxY = nextBlock && parseInt(nextBlock.style.top, 10) + parseInt(nextBlock.style.height, 10) / 2 + accordionBoxRect.top;
            }
            function startDragging() {
              if (isDragging)
                return;
              accordionBox = Utils.findHost(toggleBlock, accordionConstructor);
              if (!accordionBox)
                return;
              accordionBoxRect = accordionBox.element.getBoundingClientRect();
              startIndex = changeIndex = previousIndex = toggleBlock.$index;
              toggleBlockRect = toggleBlock.getBoundingClientRect();
              toggleBlockDragging = toggleBlock.cloneNode(true);
              toggleBlockDragging.$hostAccordionBox = accordionBox;
              toggleBlockDragging.$hostIndex = startIndex;
              toggleBlockDragging.classList.add("toggleBlockDragging");
              Utils.setBox(toggleBlockDragging, toggleBlockRect.left, toggleBlockRect.top, toggleBlockRect.width, toggleBlockRect.height);
              posX = startX - toggleBlockRect.left;
              posY = startY - toggleBlockRect.top;
              document.body.appendChild(toggleBlockDragging);
              toggleBlock.style.opacity = 0;
              calculateNearbyBlocksData();
              isDragging = true;
            }
            function recalculateIndexes(arr) {
              for (let i = 0; i < arr.length; i++) {
                arr[i].$index = i;
              }
            }
            function accordionDataChanged() {
              if (!accordionBox)
                return;
              recalculateIndexes(accordionBox.sections);
              recalculateIndexes(accordionBox.toggleBarList);
              recalculateIndexes(accordionBox.toggleBlockList);
              recalculateIndexes(accordionBox.splitterList);
              accordionBox.resize();
            }
            function addToAccordionBox(index) {
              if (!accordionBox)
                return;
              accordionBox.sections.splice(index, 0, section);
              accordionBox.toggleBarList.splice(index, 0, toggleBar);
              accordionBox.toggleBlockList.splice(index, 0, toggleBlock);
              calculateNearbyBlocksData();
              if (nextBlock) {
                accordionBox.element.insertBefore(splitter, nextBlock);
                accordionBox.element.insertBefore(toggleBlock, splitter);
                accordionBox.splitterList.splice(index - 1, 0, splitter);
              } else {
                accordionBox.element.appendChild(splitter);
                accordionBox.element.appendChild(toggleBlock);
                accordionBox.splitterList.push(splitter);
              }
              toggleBlock.$parent = accordionBox;
              splitter.$parent = accordionBox;
              accordionBox.calculateSectionsSizesPercents();
              accordionBox.recalculateChildrenSizes();
              accordionDataChanged();
            }
            function removeFromAccordionBox() {
              if (!accordionBox)
                return;
              section = accordionBox.sections.splice(previousIndex, 1)[0];
              toggleBar = accordionBox.toggleBarList.splice(previousIndex, 1)[0];
              toggleBlock = accordionBox.toggleBlockList.splice(previousIndex, 1)[0];
              let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex - 1;
              splitter = accordionBox.splitterList.splice(splitterIndex, 1)[0];
              toggleBlockDragging.style.height = accordionBox.toggleBarHeight + "px";
              toggleBlock.remove();
              splitter.remove();
              accordionBox.calculateSectionsSizesPercents();
              accordionBox.recalculateChildrenSizes();
              accordionDataChanged();
              accordionBox = void 0;
              toggleBlock.$parent = null;
              splitter.$parent = null;
            }
            function finishDragging() {
              if (!accordionBox) {
                accordionBox = toggleBlockDragging.$hostAccordionBox;
                addToAccordionBox(toggleBlockDragging.$hostIndex);
              }
              toggleBlockDragging.remove();
              toggleBlock.style.opacity = 1;
              isDragging = false;
            }
            let onMouseMove = function(e2) {
              if (e2.type !== "mousemove")
                return;
              if (!isDragging) {
                if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
                  return;
                startDragging();
              }
              let left = e2.clientX - posX;
              let top = e2.clientY - posY;
              if (accordionBox) {
                if (left < accordionBoxRect.left - accordionBoxRect.width || left > accordionBoxRect.left + accordionBoxRect.width) {
                  removeFromAccordionBox();
                }
              }
              if (!accordionBox) {
                accordionBox = Utils.findHost(e2.target, accordionConstructor);
                if (accordionBox) {
                  accordionBoxRect = accordionBox.element.getBoundingClientRect();
                  nextBlock = Utils.findNode(e2.target, "toggle-block");
                  if (nextBlock) {
                    startIndex = nextBlock.$index;
                  } else {
                    startIndex = accordionBox.toggleBlockList.length;
                  }
                  previousIndex = changeIndex = startIndex;
                  addToAccordionBox(previousIndex);
                  toggleBlockDragging.style.height = toggleBlock.style.height;
                }
              }
              if (accordionBox) {
                left = accordionBoxRect.left;
                if (e2.clientY < prevY && topMaxY && top < topMaxY) {
                  changeIndex--;
                } else if (e2.clientY > prevY && bottomMaxY && top + toggleBlockRect.height > bottomMaxY) {
                  changeIndex++;
                }
                if (changeIndex !== previousIndex) {
                  accordionBox.element.insertBefore(toggleBlock, accordionBox.toggleBlockList[changeIndex]);
                  let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex + 1;
                  accordionBox.element.insertBefore(accordionBox.toggleBlockList[changeIndex], accordionBox.splitterList[splitterIndex]);
                  accordionBox.sections.splice(changeIndex, 0, accordionBox.sections.splice(previousIndex, 1)[0]);
                  accordionBox.toggleBarList.splice(changeIndex, 0, accordionBox.toggleBarList.splice(previousIndex, 1)[0]);
                  accordionBox.toggleBlockList.splice(changeIndex, 0, accordionBox.toggleBlockList.splice(previousIndex, 1)[0]);
                  calculateNearbyBlocksData();
                  accordionDataChanged();
                  previousIndex = changeIndex;
                }
              }
              toggleBlockDragging.style.left = left + "px";
              toggleBlockDragging.style.top = top + "px";
              prevX = e2.clientX;
              prevY = e2.clientY;
            };
            let onMouseUp = function(e2) {
              if (!isDragging)
                return;
              finishDragging();
            };
            accordion_handler_event.capture(window, onMouseMove, onMouseUp);
            return e.preventDefault();
          };
          AccordionHandler2.toggleBarOnClick = function(e) {
            let toggleBlock = Utils.findNode(e.target, "toggle-block");
            if (!toggleBlock)
              return;
            let accordionBox = toggleBlock.$parent;
            let index = toggleBlock.$index;
            let isOpened = accordionBox.isOpenedBlock(toggleBlock);
            if (!isOpened) {
              toggleBlock.classList.add("toggle-opened");
              index = void 0;
            } else {
              toggleBlock.classList.remove("toggle-opened");
            }
            accordionBox.recalculateChildrenSizes(index);
            Box.enableAnimation();
            let node = accordionBox.element;
            node.addEventListener("transitionend", function handler() {
              node.removeEventListener("transitionend", handler);
              Box.disableAnimation();
            });
            accordionBox.resize();
          };
          AccordionHandler2.splitterMouseDown = function(e) {
            let button = e.button;
            if (button !== 0)
              return;
            let splitter = Utils.findNode(e.target, "splitter");
            if (!splitter)
              return;
            let accordionBox = splitter.$parent;
            let x = e.clientX;
            let y = e.clientY;
            let splitterIndex = splitter.$index + 1;
            let prevX = x;
            let prevY = y;
            if (!accordionBox.hasNextOpenedBlocks(splitterIndex) || !accordionBox.hasPrevOpenedBlocks(splitterIndex))
              return;
            accordionBox.keepState();
            let onMouseMove = function(e2) {
              x = e2.clientX;
              y = e2.clientY;
              let changedSize = 0;
              if (prevY > y) {
                changedSize = accordionBox.recalculatePreviousSectionsSize(splitterIndex, y);
                if (changedSize === 0)
                  return;
                accordionBox.expandNextSections(splitterIndex, changedSize);
              } else if (prevY < y) {
                changedSize = accordionBox.recalculateNextSectionsSize(splitterIndex, y);
                if (changedSize === 0)
                  return;
                accordionBox.expandPreviousSections(splitterIndex, changedSize);
              } else {
                return;
              }
              prevY = y;
              accordionBox.resize();
            };
            let onResizeEnd = function(e2) {
              accordionBox.dischargeState();
              Box.setGlobalCursor("");
              accordionBox.calculateSectionsSizesPercents();
            };
            Box.setGlobalCursor(`${accordionBox.vertical ? "ns" : "ew"}-resize`);
            accordion_handler_event.capture(window, onMouseMove, onResizeEnd);
            return e.preventDefault();
          };
        })(AccordionHandler || (AccordionHandler = {}));
        var injectStylesIntoStyleTag = __nested_webpack_require_440138__(591);
        var injectStylesIntoStyleTag_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(injectStylesIntoStyleTag);
        var styleDomAPI = __nested_webpack_require_440138__(740);
        var styleDomAPI_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(styleDomAPI);
        var insertBySelector = __nested_webpack_require_440138__(128);
        var insertBySelector_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(insertBySelector);
        var setAttributesWithoutAttributes = __nested_webpack_require_440138__(855);
        var setAttributesWithoutAttributes_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(setAttributesWithoutAttributes);
        var insertStyleElement = __nested_webpack_require_440138__(51);
        var insertStyleElement_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(insertStyleElement);
        var styleTagTransform = __nested_webpack_require_440138__(656);
        var styleTagTransform_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(styleTagTransform);
        var accordion = __nested_webpack_require_440138__(286);
        ;
        var options = {};
        options.styleTagTransform = styleTagTransform_default();
        options.setAttributes = setAttributesWithoutAttributes_default();
        options.insert = insertBySelector_default().bind(null, "head");
        options.domAPI = styleDomAPI_default();
        options.insertStyleElement = insertStyleElement_default();
        var update = injectStylesIntoStyleTag_default()(accordion.A, options);
        const styles_accordion = accordion.A && accordion.A.locals ? accordion.A.locals : void 0;
        ;
        dom.importCssString(accordion_namespaceObject, "accordion.css");
        const accordion_BOX_MIN_SIZE = 80;
        class Accordion extends Box {
          constructor(options2) {
            var _a;
            super(options2);
            this.toggleBarList = [];
            this.splitterList = [];
            this.toggleBlockList = [];
            this.boxMinSize = 30;
            this.toggleBarHeight = 20;
            this.splitterSize = 1;
            this.vertical = options2.vertical || false;
            this.color = (_a = options2.color) != null ? _a : "";
            this.sections = options2.sections;
            this.minSize = options2.minSize || accordion_BOX_MIN_SIZE;
            this.minVerticalSize = options2.minVerticalSize || this.minSize;
            this.minHorizontalSize = options2.minHorizontalSize || this.minSize;
            this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
            this.size = options2.size;
          }
          hasNextOpenedBlocks(index) {
            for (let i = index; i < this.toggleBlockList.length; i++) {
              if (this.isOpenedByIndex(i))
                return true;
            }
            return false;
          }
          hasPrevOpenedBlocks(index) {
            for (let i = index - 1; i >= 0; i--) {
              if (this.isOpenedByIndex(i))
                return true;
            }
            return false;
          }
          isOpenedByIndex(index) {
            return this.isOpenedBlock(this.toggleBlockList[index]);
          }
          isOpenedBlock(toggleBlock) {
            return toggleBlock.classList.contains("toggle-opened");
          }
          keepState() {
            this.nextChangedIndexes = [];
            this.prevChangedIndexes = [];
            for (let i = 0; i < this.toggleBlockList.length; i++) {
              if (this.isOpenedByIndex(i)) {
                let section = this.sections[i];
                section.previousSize = section.currentSize;
              }
            }
          }
          dischargeState() {
            this.nextChangedIndexes = void 0;
            this.prevChangedIndexes = void 0;
            for (let i = 0; i < this.toggleBlockList.length; i++) {
              if (this.isOpenedByIndex(i))
                this.sections[i].previousSize = void 0;
            }
          }
          recalculatePreviousSectionsSize(index, top, maxChangeSize) {
            let changedSize = 0;
            for (let i = index - 1; i >= 0; i--) {
              if (this.isOpenedByIndex(i)) {
                let section = this.sections[i];
                let rect = section.box.element.getBoundingClientRect();
                let done = false;
                let prevSize = rect.height;
                let currentSize = Math.max(top - rect.top, this.boxMinSize);
                top -= rect.height;
                if (currentSize < prevSize) {
                  if (currentSize > this.boxMinSize)
                    done = true;
                  if (!this.prevChangedIndexes.includes(i))
                    this.prevChangedIndexes.unshift(i);
                  section.currentSize = currentSize;
                  changedSize += prevSize - currentSize;
                  if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
                    break;
                }
              }
              top -= this.toggleBarHeight;
            }
            return changedSize;
          }
          recalculateNextSectionsSize(index, top, maxChangeSize) {
            let changedSize = 0;
            for (let i = index; i < this.toggleBlockList.length; i++) {
              if (this.isOpenedByIndex(i)) {
                let section = this.sections[i];
                let rect = section.box.element.getBoundingClientRect();
                let done = false;
                let prevSize = rect.height;
                let currentSize = Math.max(rect.bottom - top - this.toggleBarHeight, this.boxMinSize);
                top += rect.height;
                if (currentSize < prevSize) {
                  if (currentSize > this.boxMinSize)
                    done = true;
                  if (!this.nextChangedIndexes.includes(i))
                    this.nextChangedIndexes.unshift(i);
                  section.currentSize = currentSize;
                  changedSize += prevSize - currentSize;
                  if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
                    break;
                }
              }
              top += this.toggleBarHeight;
              top += this.splitterSize;
            }
            return changedSize;
          }
          restoreChangedSizes(size, changedIndexes) {
            if (!changedIndexes)
              return size;
            while (changedIndexes.length && size > 0) {
              let index = changedIndexes[0];
              let section = this.sections[index];
              let currSize = section.currentSize;
              section.currentSize = Math.min(section.previousSize, currSize + size);
              size -= section.currentSize - currSize;
              if (section.currentSize >= section.previousSize)
                changedIndexes.shift();
            }
            return size;
          }
          expandPreviousSections(index, size) {
            size = this.restoreChangedSizes(size, this.prevChangedIndexes);
            if (size <= 0)
              return;
            let openedSectionsList = [];
            for (let i = index - 1; i >= 0; i--) {
              if (this.isOpenedByIndex(i))
                openedSectionsList.push(this.sections[i]);
            }
            this.applySizeToOpenedSections(size, openedSectionsList);
          }
          expandNextSections(index, size) {
            size = this.restoreChangedSizes(size, this.nextChangedIndexes);
            if (size <= 0)
              return;
            let openedSectionsList = [];
            for (let i = index; i < this.toggleBlockList.length; i++) {
              if (this.isOpenedByIndex(i)) {
                openedSectionsList.push(this.sections[i]);
              }
            }
            this.applySizeToOpenedSections(size, openedSectionsList);
          }
          applySizeToOpenedSections(size, openedSections) {
            let count = openedSections.length;
            if (!count)
              return;
            let remainder = size % count;
            let addSize = (size - remainder) / count;
            for (let i = 0; i < count; i++) {
              openedSections[i].currentSize += addSize;
            }
            openedSections[0].currentSize += remainder;
          }
          resize() {
            this.$updateChildSize(...this.rect);
          }
          render() {
            var _a, _b;
            if (this.element)
              return this.element;
            this.element = dom.buildDom(["div", {
              class: "box accordion",
              $host: this
            }]);
            let section;
            let splitter;
            let toggleBlock;
            let toggleBar;
            for (let i = 0; i < this.sections.length; i++) {
              section = this.sections[i];
              if (i > 0) {
                splitter = dom.buildDom(["div", {
                  class: `splitter accordion-splitter splitter${this.vertical ? "-v" : "-h"}`,
                  $index: i - 1,
                  $parent: this,
                  onmousedown: function(e) {
                    AccordionHandler.splitterMouseDown(e);
                  }
                }, ["div"]]);
                this.element.appendChild(splitter);
                this.splitterList.push(splitter);
              }
              toggleBlock = dom.buildDom(["div", {
                class: `toggle-block`,
                $index: i,
                $parent: this
              }]);
              toggleBar = dom.buildDom(["div", {
                class: `toggle-bar toggle-bar${this.vertical ? "-v" : "-h"}`,
                onmousedown: function(e) {
                  AccordionHandler.toggleBarMouseDown(e, Accordion);
                },
                onclick: function(e) {
                  AccordionHandler.toggleBarOnClick(e);
                }
              }, ["div", { class: "title" }, section.title]]);
              section.currentSize = section.savedSize = parseInt((_b = (_a = section.box.size) == null ? void 0 : _a.toString()) != null ? _b : "", 10);
              toggleBlock.appendChild(toggleBar);
              this.toggleBarList.push(toggleBar);
              toggleBlock.appendChild(section.box.render());
              this.element.appendChild(toggleBlock);
              this.toggleBlockList.push(toggleBlock);
            }
            this.element.style.backgroundColor = this.color;
            this.element.style.position = "absolute";
            this.calculateSectionsSizesPercents();
            return this.element;
          }
          calculateSectionsSizesPercents() {
            let totalSize = 0;
            let actualSizes = [];
            for (let i = 0; i < this.sections.length; i++) {
              let section = this.sections[i];
              actualSizes.push(this.isOpenedByIndex(i) ? section.currentSize : section.savedSize);
              totalSize += actualSizes[i];
            }
            let minPercent = Math.floor(this.boxMinSize / totalSize * 100);
            let maxPercent = 100 - minPercent * (this.sections.length - 1);
            let totalPercent = 0;
            for (let i = 0; i < this.sections.length; i++) {
              let section = this.sections[i];
              section.sizePercent = Math.floor(actualSizes[i] / totalSize * 100);
              section.sizePercent = Math.min(Math.max(section.sizePercent, minPercent), maxPercent);
              totalPercent += section.sizePercent;
            }
            if (totalPercent !== 100)
              this.sections[this.sections.length - 1].sizePercent += 100 - totalPercent;
          }
          setBox(x, y, w, h) {
            this.rect = [x, y, w, h];
            Utils.setBox(this.element, x, y, w, h);
            this.recalculateChildrenSizes();
            this.$updateChildSize(x, y, w, h);
          }
          recalculateChildrenSizes(index) {
            let height = this.rect[3];
            height -= this.toggleBarHeight * this.toggleBarList.length;
            height -= this.splitterSize * this.splitterList.length;
            let totalSize = 0;
            let openedIndexes = [];
            for (let i = 0; i < this.sections.length; i++) {
              let section = this.sections[i];
              section.currentSize = Math.max(Math.floor(height * section.sizePercent / 100), this.boxMinSize);
              if (this.isOpenedByIndex(i)) {
                totalSize += section.currentSize;
                openedIndexes.push(i);
              } else {
                section.savedSize = section.currentSize;
                section.currentSize = 0;
              }
            }
            let spareSize = height - totalSize;
            if (!spareSize)
              return;
            if (index !== void 0) {
              let prevOpenedIndexes = [];
              while (openedIndexes.length && openedIndexes[0] < index) {
                prevOpenedIndexes.push(openedIndexes.shift());
              }
              if (!openedIndexes.length)
                openedIndexes = prevOpenedIndexes;
            }
            let prevSize, changedSize, openedBoxesCount, remainder, addSize;
            while (openedIndexes.length && spareSize) {
              let changedIndexes = [];
              openedBoxesCount = openedIndexes.length;
              remainder = spareSize % openedBoxesCount;
              addSize = (spareSize - remainder) / openedBoxesCount;
              for (let i = 0; i < openedIndexes.length; i++) {
                let section = this.sections[openedIndexes[i]];
                prevSize = section.currentSize;
                if (openedBoxesCount === 1)
                  addSize += remainder;
                section.currentSize += addSize;
                section.currentSize = Math.max(section.currentSize, this.boxMinSize);
                changedSize = section.currentSize - prevSize;
                spareSize -= changedSize;
                openedBoxesCount--;
                if (changedSize < 0)
                  changedIndexes.push(openedIndexes[i]);
              }
              openedIndexes = changedIndexes;
            }
          }
          $updateChildSize(x, y, w, h) {
            x = 0;
            y = 0;
            for (let i = 0; i < this.toggleBlockList.length; i++) {
              let toggleBlock = this.toggleBlockList[i];
              let section = this.sections[i];
              let boxSize = section.currentSize;
              h = this.toggleBarHeight + boxSize;
              Utils.setBox(toggleBlock, x, y, w, h);
              y += this.toggleBarHeight;
              section.box.setBox(0, this.toggleBarHeight, w, boxSize);
              y += boxSize;
              if (this.splitterList[i]) {
                Utils.setBox(this.splitterList[i], x, y, w, this.splitterSize);
                y += this.splitterSize;
              }
            }
          }
          remove() {
            if (this.element)
              this.element.remove();
            if (this.parent) {
              if (this.vertical === this.parent.vertical)
                this.parent.minSize -= this.minSize;
              if (this.parent[0] == this)
                this.parent[0] = void 0;
              if (this.parent[1] == this)
                this.parent[1] = void 0;
            }
          }
          toJSON() {
            let sections = [];
            let section;
            for (let i = 0; i < this.sections.length; i++) {
              section = this.sections[i];
              sections.push({
                title: section.title,
                boxData: section.box.toJSON()
              });
            }
            return {
              type: "accordion",
              vertical: this.vertical,
              size: this.size,
              sections
            };
          }
        }
        var popup_ = __nested_webpack_require_440138__(910);
        ;
        class ListBox extends Box {
          render() {
            if (this.element)
              return this.element;
            this.element = super.render();
            let popup = new popup_.AcePopup();
            popup.renderer.setStyle("ace_listBox");
            popup.container.style.display = "block";
            popup.container.style.position = "absolute";
            popup.container.style.zIndex = "0";
            popup.container.style.boxShadow = "none";
            popup.renderer.setScrollMargin(2, 2, 0, 0);
            popup.autoSelect = false;
            popup.renderer["$maxLines"] = null;
            popup.setRow(-1);
            popup.on("click", (e) => {
              e.stop();
              let data = popup.getData(popup.getRow());
            });
            popup.on("dblclick", (e) => {
              e.stop();
              let data = popup.getData(popup.getRow());
            });
            popup.on("tripleclick", (e) => {
              e.stop();
            });
            popup.on("quadclick", (e) => {
              e.stop();
            });
            this.element.appendChild(popup.container);
            this.popup = popup;
            delete popup.focus;
            return this.element;
          }
          $updateChildSize(x, y, w, h) {
            Utils.setBox(this.popup.container, x, y, w, h);
            this.popup.resize(true);
          }
        }
        var esm_resolver_ = __nested_webpack_require_440138__(444);
        var esm_resolver_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(esm_resolver_);
        var editor_ = __nested_webpack_require_440138__(254);
        var virtual_renderer_ = __nested_webpack_require_440138__(748);
        var language_tools_ = __nested_webpack_require_440138__(685);
        ;
        const modeList = __nested_webpack_require_440138__(292);
        class AceEditor {
          resize() {
            this.editor.resize();
          }
          focus() {
            this.editor.focus();
          }
          destroy() {
            this.editor.setSession(esm_resolver_default().createEditSession("", this.getMode()));
            this.editor.destroy();
            this.container.remove();
          }
          constructor() {
            this.editor = new editor_.Editor(new virtual_renderer_.VirtualRenderer(null));
            this.container = this.editor.container;
            this.container.style.position = "absolute";
            this.editor.setOptions({
              customScrollbar: false,
              newLineMode: "unix",
              enableLiveAutocompletion: true,
              enableBasicAutocompletion: true,
              showPrintMargin: false
            });
          }
          setSession(tab2, value) {
            this.tab = tab2;
            this.initTabSession(value);
            this.editor.setSession(this.tab.session);
          }
          initTabSession(value) {
            var _a, _b;
            if (this.tab.session && value == null)
              return;
            (_b = (_a = this.tab).session) != null ? _b : _a.session = esm_resolver_default().createEditSession(value != null ? value : "", this.getMode());
            if (value == null) {
              this.restoreSessionFromJson(this.tab);
            } else {
              this.tab.session.setValue(value);
            }
          }
          getMode() {
            if (this.tab.path !== void 0) {
              return modeList.getModeForPath(this.tab.path).mode;
            }
            return null;
          }
          static getSessionState(tab2) {
            let session = tab2.session;
            let undoManager = session.getUndoManager();
            return JSON.stringify({
              selection: session.selection.toJSON(),
              //@ts-ignore
              undoManager: undoManager.toJSON(),
              value: session.getValue(),
              scroll: [
                session.getScrollLeft(),
                session.getScrollTop()
              ]
            });
          }
          sessionToJSON(tab2) {
            return AceEditor.getSessionState(tab2);
          }
          restoreSessionFromJson(tab2) {
            if (!tab2.session || !tab2.sessionValue)
              return;
            let session = tab2.session;
            let json = JSON.parse(tab2.sessionValue);
            try {
              if (typeof json.value == "string" && json.value != session.getValue())
                session.doc.setValue(json.value);
              if (json.selection)
                session.selection.fromJSON(json.selection);
              if (json.scroll) {
                session.setScrollLeft(json.scroll[0]);
                session.setScrollTop(json.scroll[1]);
              }
              tab2.sessionValue = void 0;
            } catch (e) {
              console.error(e);
            }
          }
        }
        ;
        class PreviewEditor {
          resize() {
          }
          focus() {
          }
          destroy() {
            this.container.remove();
          }
          constructor() {
            this.container = document.createElement("iframe");
            this.container.style.position = "absolute";
          }
          setSession(tab2, value) {
            this.tab = tab2;
            value != null ? value : value = tab2.session;
            tab2.session = value;
            this.container.setAttribute("srcdoc", value);
          }
          restoreSessionFromJson(tab2) {
            var _a;
            tab2.session = (_a = tab2.sessionValue) != null ? _a : "";
            tab2.sessionValue = void 0;
          }
          sessionToJSON(tab2) {
            return tab2.session;
          }
        }
        ;
        let tabbar_handler_event = __nested_webpack_require_440138__(517);
        var TabbarHandler;
        ((TabbarHandler2) => {
          TabbarHandler2.tabbarMouseDown = function(e, tabConstructor, tabBarConstructor, showSplit = false) {
            let divSplit, splitPosition, pane;
            function hideSplitPosition() {
              if (!divSplit)
                return;
              divSplit.remove();
              divSplit = splitPosition = pane = null;
            }
            function showSplitPosition(e2) {
              let el = e2.target;
              if (tabBar) {
                hideSplitPosition();
                return;
              }
              pane = Utils.findHost(el);
              if (!pane || !pane.acceptsTab || !pane.acceptsTab(tab2)) {
                hideSplitPosition();
                return;
              }
              if (pane.tabBar.tabList.length === 0) {
                hideSplitPosition();
                return;
              }
              let dark = false;
              if (!divSplit) {
                divSplit = document.createElement("div");
                document.body.appendChild(divSplit);
              }
              divSplit.className = "split-area" + (dark ? " dark" : "");
              let rect = pane.element.getBoundingClientRect();
              let bHeight = pane.tabBar.element.clientHeight - 1;
              rect = {
                left: rect.left,
                top: rect.top + bHeight,
                width: rect.width,
                height: rect.height - bHeight
              };
              let left = (e2.clientX - rect.left) / rect.width;
              let right = 1 - left;
              let top = (e2.clientY - rect.top) / rect.height;
              let bottom = 1 - top;
              let min = Math.min(left, top, right, bottom);
              if (min == left) {
                splitPosition = [true, false];
                Utils.setBox(divSplit, rect.left, rect.top, rect.width / 2, rect.height);
              } else if (min == right) {
                splitPosition = [false, false];
                Utils.setBox(divSplit, rect.left + rect.width / 2, rect.top, rect.width / 2, rect.height);
              } else if (min == top) {
                splitPosition = [true, true];
                Utils.setBox(divSplit, rect.left, rect.top, rect.width, rect.height / 2);
              } else if (min == bottom) {
                splitPosition = [false, true];
                Utils.setBox(divSplit, rect.left, rect.top + rect.height / 2, rect.width, rect.height / 2);
              }
            }
            if (e.target.classList.contains("tabCloseButton")) {
              return;
            }
            let tab2 = Utils.findHost(e.target, tabConstructor);
            if (!tab2)
              return;
            let tabBar = Utils.findHost(e.target, tabBarConstructor);
            if (!tabBar)
              return;
            let isVertical = tabBar.isVertical();
            tabBar.tabMouseDown(tab2, e.shiftKey, e.ctrlKey);
            if (e.shiftKey || e.ctrlKey)
              return;
            let isDragging = false;
            let posX, posY, prevX, prevY;
            let startX = e.clientX, startY = e.clientY;
            let parentRect, tabElement, index, selectedTabs, hostTabBar, hostIndex;
            let prevTab, leftMaxX, topMaxY, nextTab, rightMaxX, bottomMaxY;
            let tabDragElementSize = 0;
            let tabDragElementLeft = 0;
            let tabDragElementTop = 0;
            let calculateNearbyTabsData = function() {
              if (isVertical) {
                topMaxY = prevTab && parseInt(prevTab.style.top, 10) + parseInt(prevTab.style.height, 10) / 2 + parentRect.top;
                bottomMaxY = nextTab && parseInt(nextTab.style.top, 10) + parseInt(nextTab.style.height, 10) / 2 + parentRect.top;
              } else {
                if (prevTab) {
                  let prevSibling = prevTab.previousSibling;
                  leftMaxX = prevSibling ? parseInt(prevSibling.style.left, 10) + parseInt(prevSibling.style.width, 10) + parentRect.left : parentRect.left;
                }
                rightMaxX = nextTab && parseInt(nextTab.style.left, 10) + parseInt(nextTab.style.width, 10) / 2 + parentRect.left;
              }
            };
            let startDragging = function() {
              if (isDragging || !tabBar)
                return;
              tabElement = dom.buildDom(["div", {
                class: "tabDragging"
              }]);
              let activeIndex = index = tabBar.tabList.indexOf(tab2);
              tabBar.tabContainer.insertBefore(tabElement, tab2.element);
              tabDragElementLeft = parseInt(tab2.element.style.left, 10);
              tabDragElementTop = parseInt(tab2.element.style.top, 10);
              selectedTabs = [];
              let selectedTab, selectedTabElement;
              for (let i = 0; i < tabBar.selectedTabs.length; i++) {
                selectedTab = tabBar.selectedTabs[i];
                selectedTab.currentIndex = tabBar.tabList.indexOf(selectedTab);
                if (selectedTab.currentIndex < activeIndex) {
                  index--;
                  if (isVertical) {
                    tabDragElementTop -= parseInt(selectedTab.element.style.top, 10);
                  } else {
                    tabDragElementLeft -= parseInt(selectedTab.element.style.width, 10);
                  }
                }
                selectedTabs.push(selectedTab);
              }
              selectedTabs.sort(function(tab1, tab22) {
                return tab1.currentIndex - tab22.currentIndex;
              });
              for (let i = 0; i < selectedTabs.length; i++) {
                selectedTab = selectedTabs[i];
                selectedTabElement = selectedTab.element;
                tabElement.appendChild(selectedTabElement);
                selectedTabElement.style.pointerEvents = "none";
                if (isVertical) {
                  selectedTabElement.style.top = tabDragElementSize + "px";
                  tabDragElementSize += parseInt(selectedTabElement.style.height, 10);
                } else {
                  selectedTabElement.style.left = tabDragElementSize + "px";
                  tabDragElementSize += parseInt(selectedTabElement.style.width, 10);
                }
                tabBar.removeTab(selectedTab);
              }
              prevTab = tabElement.previousSibling;
              nextTab = tabElement.nextSibling;
              parentRect = tabBar.element.getBoundingClientRect();
              if (isVertical) {
                tabDragElementTop += parentRect.top;
                posY = startY - tabDragElementTop;
                posX = startX - parentRect.left;
              } else {
                tabDragElementLeft += parentRect.left;
                posX = startX - tabDragElementLeft;
                posY = startY - parentRect.top;
              }
              prevX = e.clientX;
              prevY = e.clientY;
              hostTabBar = tabBar;
              hostIndex = index;
              calculateNearbyTabsData();
              isDragging = true;
              document.body.appendChild(tabElement);
              if (isVertical) {
                Utils.setBox(tabElement, tabDragElementTop, parentRect.left, parentRect.width, tabDragElementSize);
              } else {
                Utils.setBox(tabElement, tabDragElementLeft, parentRect.top, tabDragElementSize, parentRect.height);
              }
              tabBar.startTabDragging(tabElement, index);
            };
            let finishDragging = function() {
              if (pane && pane.split && splitPosition) {
                let newPane = pane.split(...splitPosition);
                tabBar = newPane.tabBar;
              } else if (!tabBar) {
                tabBar = hostTabBar;
              }
              tabBar.removeSelections();
              tabElement.remove();
              let selectedTab;
              for (let i = 0; i < selectedTabs.length; i++) {
                selectedTab = selectedTabs[i];
                selectedTab.element.style.pointerEvents = "";
                if (selectedTab === tab2) {
                  selectedTab.active = true;
                }
                tabBar.addTab(selectedTab, index++);
                tabBar.addSelection(selectedTab);
              }
              if (tabBar !== hostTabBar) {
                hostTabBar.removeSelections();
                hostTabBar.activatePrevious(hostIndex);
              }
              tabBar.finishTabDragging();
              isDragging = false;
              hideSplitPosition();
            };
            function distance(dx, dy) {
              return dx * dx + dy * dy;
            }
            let onMouseMove = function(e2) {
              if (e2.type !== "mousemove")
                return;
              if (!isDragging) {
                if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
                  return;
                startDragging();
              }
              function removeTabFromBar() {
                tabBar.finishTabDragging();
                tabBar = void 0;
              }
              if (tabBar) {
                tabBar.startTabDragging(tabElement, index);
                if (!isVertical && (e2.clientX < parentRect.left || e2.clientX > parentRect.left + parentRect.width) || isVertical && (e2.clientY < parentRect.top || e2.clientY > parentRect.top + parentRect.height)) {
                  removeTabFromBar();
                }
              } else {
                tabBar = Utils.findHost(e2.target, tabBarConstructor);
                if (tabBar) {
                  isVertical = tabBar.isVertical();
                  let nextTabHost = Utils.findHost(e2.target, tabConstructor);
                  if (nextTabHost) {
                    index = tabBar.tabList.indexOf(nextTabHost);
                    nextTab = nextTabHost.element;
                    prevTab = nextTab.previousSibling;
                  } else {
                    index = tabBar.tabList.length;
                    nextTab = null;
                    prevTab = tabBar.tabContainer.childNodes[index - 1];
                  }
                  tabBar.startTabDragging(tabElement, index);
                  parentRect = tabBar.element.getBoundingClientRect();
                  calculateNearbyTabsData();
                }
              }
              if (showSplit)
                showSplitPosition(e2);
              let left = e2.clientX - posX;
              let top = e2.clientY - posY;
              let x = left;
              let y = top;
              if (tabBar) {
                if (isVertical && (x < parentRect.left - parentRect.width || x > parentRect.left + parentRect.width) || !isVertical && (y < parentRect.top - parentRect.height || y > parentRect.top + parentRect.height)) {
                  removeTabFromBar();
                } else {
                  if (isVertical) {
                    x = parentRect.left;
                  } else {
                    y = parentRect.top;
                  }
                  if (isVertical && e2.clientY < prevY && topMaxY && top < topMaxY || !isVertical && e2.clientX < prevX && leftMaxX && left < leftMaxX) {
                    if (isVertical) {
                      prevTab.style.top = parseInt(prevTab.style.top, 10) + tabDragElementSize + "px";
                    } else {
                      prevTab.style.left = parseInt(prevTab.style.left, 10) + tabDragElementSize + "px";
                    }
                    index--;
                    [prevTab, nextTab] = [prevTab.previousSibling, prevTab];
                    calculateNearbyTabsData();
                  } else if (isVertical && e2.clientY > prevY && bottomMaxY && top + tabDragElementSize > bottomMaxY || !isVertical && e2.clientX > prevX && rightMaxX && left + tabDragElementSize > rightMaxX) {
                    if (isVertical) {
                      nextTab.style.top = parseInt(nextTab.style.top, 10) - tabDragElementSize + "px";
                    } else {
                      nextTab.style.left = parseInt(nextTab.style.left, 10) - tabDragElementSize + "px";
                    }
                    index++;
                    [prevTab, nextTab] = [nextTab, nextTab.nextSibling];
                    calculateNearbyTabsData();
                  }
                }
              }
              prevX = e2.clientX;
              prevY = e2.clientY;
              tabElement.style.left = x + "px";
              tabElement.style.top = y + "px";
            };
            let onMouseUp = function(e2) {
              if (!isDragging) {
                if (tabBar.selectedTabs.length > 1) {
                  tabBar.removeSelections();
                  tabBar.addSelection(tab2);
                }
              } else {
                finishDragging();
              }
            };
            tabbar_handler_event.capture(window, onMouseMove, onMouseUp);
            return e.preventDefault();
          };
        })(TabbarHandler || (TabbarHandler = {}));
        window.addEventListener("mousedown", function() {
          document.body.classList.add("disableIframe");
        }, true);
        window.addEventListener("mouseup", function() {
          document.body.classList.remove("disableIframe");
        }, true);
        var tab = __nested_webpack_require_440138__(129);
        ;
        var tab_options = {};
        tab_options.styleTagTransform = styleTagTransform_default();
        tab_options.setAttributes = setAttributesWithoutAttributes_default();
        tab_options.insert = insertBySelector_default().bind(null, "head");
        tab_options.domAPI = styleDomAPI_default();
        tab_options.insertStyleElement = insertStyleElement_default();
        var tab_update = injectStylesIntoStyleTag_default()(tab.A, tab_options);
        const styles_tab = tab.A && tab.A.locals ? tab.A.locals : void 0;
        ;
        class TabPanel {
          constructor(options2) {
            var _a;
            this.active = (_a = options2.active) != null ? _a : false;
            this.title = options2.title;
          }
          activate() {
            this.active = true;
            this.element.classList.add("active");
          }
          deactivate() {
            this.active = false;
            this.element.classList.remove("active");
          }
        }
        ;
        dom.importCssString(tab_namespaceObject, "tab.css");
        class Tab extends TabPanel {
          constructor(options2) {
            var _a, _b, _c;
            super(options2);
            this.contextMenu = "tabs";
            this.tabIcon = (_a = options2.icon) != null ? _a : "";
            this.path = options2.path;
            this.preview = (_b = options2.preview) != null ? _b : false;
            this.editorType = (_c = options2.editorType) != null ? _c : EditorType.ace;
          }
          toJSON() {
            return {
              title: this.title,
              icon: this.tabIcon || void 0,
              active: this.active || void 0,
              path: this.path,
              preview: this.preview || void 0,
              editorType: this.editorType
            };
          }
          activate(content) {
            super.activate();
            this.activatePane();
            let tabManager = TabManager.getInstance();
            tabManager.loadFile(this, content);
            tabManager.activePane.resize();
          }
          activatePane() {
            var _a;
            TabManager.getInstance().activePane = (_a = this.parent) == null ? void 0 : _a.parent;
          }
          remove() {
            var _a;
            (_a = this.parent) == null ? void 0 : _a.closeTab(this);
          }
          set caption(value) {
            this.$caption = value;
          }
          get caption() {
            return this.$caption;
          }
          render() {
            this.element = dom.buildDom([
              "div",
              {
                class: "tab" + (this.active ? " active" : ""),
                title: this.path
              },
              ["span", { class: "tabIcon" }, this.tabIcon],
              ["span", { class: "tabTitle", ref: "$title" }, this.title],
              ["span", { class: "tabCloseButton" }]
            ], void 0, this);
            if (this.preview)
              this.element.style.fontStyle = "italic";
            this.element.$host = this;
            return this.element;
          }
          setTitle(title) {
            this.title = title;
            this.element.getElementsByClassName("tabTitle")[0].innerHTML = title;
          }
          get isActive() {
            var _a;
            return ((_a = this.parent) == null ? void 0 : _a.activeTab) == this;
          }
          get editor() {
            var _a;
            return (_a = this.parent) == null ? void 0 : _a.parent.getEditor(this.editorType);
          }
        }
        ;
        function getCurrentPaneTabs(element) {
          var _a, _b, _c, _d;
          if (element instanceof Tab) {
            return {
              tabs: [...(_b = (_a = element.parent) == null ? void 0 : _a.tabList) != null ? _b : []],
              activeTab: element
            };
          } else {
            return {
              tabs: [...(_d = (_c = element.activePane) == null ? void 0 : _c.tabBar.tabList) != null ? _d : []],
              activeTab: element.activeTab
            };
          }
        }
        function goToTab(el, tabNum) {
          let currentPaneTabs = getCurrentPaneTabs(el);
          let tabs = currentPaneTabs.tabs;
          let activeTab = currentPaneTabs.activeTab;
          let index = tabNum != null ? tabNum : tabs.indexOf(activeTab);
          TabManager.getInstance().navigateToTab(index, activeTab, tabs);
        }
        let tabCommands = [
          {
            name: "clonetab",
            mac: "",
            win: "",
            desc: "Create a new tab with a view on the same file"
          },
          {
            name: "Close Tab",
            mac: "Option-W",
            win: "Alt-W",
            desc: "close the tab that is currently active",
            position: 300,
            exec: (el) => {
              if (el instanceof Tab) {
                el.remove();
              } else {
                el.activeTab.remove();
              }
            }
          },
          {
            name: "Close All Tabs",
            mac: "Option-Shift-W",
            win: "Alt-Shift-W",
            desc: "Close all opened tabs",
            position: 310,
            exec: () => {
              let tabs = TabManager.getInstance().tabs;
              for (let i in tabs) {
                tabs[i].remove();
              }
            }
          },
          {
            name: "Close other tabs",
            mac: "Option-Ctrl-W",
            win: "Ctrl-Alt-W",
            desc: "close all opened tabs, except the tab that is currently active",
            position: 320,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              for (let tab2 of tabs) {
                if (tab2 != activeTab)
                  tab2.remove();
              }
            }
          },
          {
            name: "Go to tab right",
            mac: "Command-}",
            win: "Ctrl-}",
            //TODO: used by ace
            desc: "navigate to the next tab, right to the tab that is currently active",
            position: 330,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
            }
          },
          {
            name: "Go to tab left",
            mac: "Command-{",
            win: "Ctrl-{",
            //TODO: used by ace
            desc: "navigate to the next tab, left to the tab that is currently active",
            position: 340,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
            }
          },
          {
            name: "movetabright",
            mac: "Command-Option-Shift-Right",
            win: "Ctrl-Meta-Right",
            desc: "move the tab that is currently active to the right. Will create a split tab to the right if it's the right most tab."
          },
          {
            name: "movetableft",
            mac: "Command-Option-Shift-Left",
            win: "Ctrl-Meta-Left",
            desc: "move the tab that is currently active to the left. Will create a split tab to the left if it's the left most tab."
          },
          {
            name: "movetabup",
            mac: "Command-Option-Shift-Up",
            win: "Ctrl-Meta-Up",
            desc: "move the tab that is currently active to the up. Will create a split tab to the top if it's the top most tab."
          },
          {
            name: "movetabdown",
            mac: "Command-Option-Shift-Down",
            win: "Ctrl-Meta-Down",
            desc: "move the tab that is currently active to the down. Will create a split tab to the bottom if it's the bottom most tab."
          },
          {
            name: "Go to first tab",
            mac: "Command-1",
            win: "Ctrl-1",
            desc: "navigate to the first tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 0);
            }
          },
          {
            name: "Go to second tab",
            mac: "Command-2",
            win: "Ctrl-2",
            desc: "navigate to the second tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 1);
            }
          },
          {
            name: "Go to third tab",
            mac: "Command-3",
            win: "Ctrl-3",
            desc: "navigate to the third tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 2);
            }
          },
          {
            name: "tab4",
            mac: "Command-4",
            win: "Ctrl-4",
            desc: "navigate to the fourth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 3);
            }
          },
          {
            name: "tab5",
            mac: "Command-5",
            win: "Ctrl-5",
            desc: "navigate to the fifth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 4);
            }
          },
          {
            name: "tab6",
            mac: "Command-6",
            win: "Ctrl-6",
            desc: "navigate to the sixth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 5);
            }
          },
          {
            name: "tab7",
            mac: "Command-7",
            win: "Ctrl-7",
            desc: "navigate to the seventh tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 6);
            }
          },
          {
            name: "tab8",
            mac: "Command-8",
            win: "Ctrl-8",
            desc: "navigate to the eighth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 7);
            }
          },
          {
            name: "tab9",
            mac: "Command-9",
            win: "Ctrl-9",
            desc: "navigate to the ninth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 8);
            }
          },
          {
            name: "tab0",
            mac: "Command-0",
            win: "Ctrl-0",
            desc: "navigate to the tenth tab",
            position: 340,
            exec: (el) => {
              goToTab(el, 9);
            }
          },
          {
            name: "Reveal tab",
            mac: "Command-Shift-L",
            win: "Ctrl-Shift-L",
            //TODO: used by ace
            desc: "reveal current tab in the file tree",
            position: 340,
            exec: (el) => {
            }
          },
          {
            name: "Go to next tab",
            mac: "Option-Tab",
            win: "Ctrl-Tab|Alt-`",
            desc: "navigate to the next tab in the stack of accessed tabs",
            position: 340,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              if (index < tabs.length - 1) {
                TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
              } else {
                TabManager.getInstance().navigateToTab(0, activeTab, tabs);
              }
            }
          },
          {
            name: "Go to previous tab",
            mac: "Option-Shift-Tab",
            win: "Ctrl-Shift-Tab|Alt-Shift-`",
            desc: "navigate to the previous tab in the stack of accessed tabs",
            position: 340,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              if (index > 0) {
                TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
              } else {
                TabManager.getInstance().navigateToTab(tabs.length - 1, activeTab, tabs);
              }
            }
          },
          {
            name: "nextpane",
            mac: "Option-ESC",
            win: "Ctrl-`",
            desc: "navigate to the next tab in the stack of panes"
          },
          {
            name: "previouspane",
            mac: "Option-Shift-ESC",
            win: "Ctrl-Shift-`",
            desc: "navigate to the previous tab in the stack of panes"
          },
          {
            name: "gotopaneright",
            mac: "Ctrl-Meta-Right",
            win: "Ctrl-Meta-Right",
            desc: "navigate to the pane on the right"
          },
          {
            name: "gotopaneleft",
            mac: "Ctrl-Meta-Left",
            win: "Ctrl-Meta-Left",
            desc: "navigate to the pane on the left"
          },
          {
            name: "gotopaneup",
            mac: "Ctrl-Meta-Up",
            win: "Ctrl-Meta-Up",
            desc: "navigate to the pane on the top"
          },
          {
            name: "gotopanedown",
            mac: "Ctrl-Meta-Down",
            win: "Ctrl-Meta-Down",
            desc: "navigate to the pane on the bottom"
          },
          {
            name: "reopenLastTab",
            mac: "Option-Shift-T",
            win: "Alt-Shift-T",
            /*exec: function () {
                return menuClosedItems.length;
            },*/
            desc: "reopen last closed tab"
          },
          {
            name: "Close all to the right",
            mac: "",
            win: "",
            desc: "close all tabs to the right of the focussed tab",
            position: 340,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              if (index < tabs.length - 1) {
                for (let i = index + 1; i < tabs.length; i++) {
                  tabs[i].remove();
                }
              }
            }
          },
          {
            name: "Close all to the left",
            mac: "",
            win: "",
            desc: "close all tabs to the left of the focussed tab",
            position: 340,
            exec: (el) => {
              let currentPaneTabs = getCurrentPaneTabs(el);
              let tabs = currentPaneTabs.tabs;
              let activeTab = currentPaneTabs.activeTab;
              let index = tabs.indexOf(activeTab);
              if (index > 0) {
                for (let i = 0; i < index; i++) {
                  tabs[i].remove();
                }
              }
            }
          },
          {
            name: "Close pane",
            mac: "Command-Ctrl-W",
            win: "Ctrl-W",
            desc: "close this pane",
            position: 340,
            exec: (el) => {
              var _a, _b;
              let tabs;
              if (el instanceof Tab) {
                tabs = [...(_b = (_a = el.parent) == null ? void 0 : _a.tabList) != null ? _b : []];
              } else {
                tabs = [...el.activePane.tabBar.tabList];
              }
              for (let tab2 of tabs) {
                tab2.remove();
              }
            }
          },
          {
            name: "nosplit",
            mac: "",
            win: "",
            desc: "no split"
          },
          {
            name: "hsplit",
            mac: "",
            win: "",
            desc: "split the current pane in two columns and move the active tab to it"
          },
          {
            name: "vsplit",
            mac: "",
            win: "",
            desc: "split the current pane in two rows and move the active tab to it"
          },
          {
            name: "twovsplit",
            mac: "",
            win: "",
            desc: "create a two pane row layout"
          },
          {
            name: "twohsplit",
            mac: "",
            win: "",
            desc: "create a two pane column layout"
          },
          {
            name: "foursplit",
            mac: "",
            win: "",
            desc: "create a four pane layout"
          },
          {
            name: "threeleft",
            mac: "",
            win: "",
            desc: "create a three pane layout with the stack on the left side"
          },
          {
            name: "threeright",
            mac: "",
            win: "",
            desc: "create a three pane layout with the stack on the right side"
          }
        ];
        var event_emitter_ = __nested_webpack_require_440138__(540);
        var menu = __nested_webpack_require_440138__(807);
        ;
        var menu_options = {};
        menu_options.styleTagTransform = styleTagTransform_default();
        menu_options.setAttributes = setAttributesWithoutAttributes_default();
        menu_options.insert = insertBySelector_default().bind(null, "head");
        menu_options.domAPI = styleDomAPI_default();
        menu_options.insertStyleElement = insertStyleElement_default();
        var menu_update = injectStylesIntoStyleTag_default()(menu.A, menu_options);
        const styles_menu = menu.A && menu.A.locals ? menu.A.locals : void 0;
        ;
        dom.importCssString(menu_namespaceObject, "menu.css");
        class Menu {
          getLastOpenPopup() {
            return !this.menuPopup ? this : this.menuPopup.getLastOpenPopup();
          }
          getLastSelectedMenu() {
            return !this.menuPopup || !this.menuPopup.selectedMenu ? this.selectedMenu : this.menuPopup.getLastSelectedMenu();
          }
          closeLastMenu() {
            if (this.menuPopup && this.menuPopup.menuPopup) {
              this.menuPopup.closeLastMenu();
            } else {
              this.closeMenu();
            }
          }
          selectMenu(menu2) {
            menu2.buttonElement.classList.add(this.selectedClass);
            this.selectedMenu = menu2;
          }
          unselectMenu() {
            if (!this.selectedMenu)
              return;
            this.selectedMenu.buttonElement.classList.remove(this.selectedClass);
            this.selectedMenu = void 0;
          }
          openMenu(direction) {
            if (!direction && this.constructor.name === "MenuPopup")
              direction = "right";
            if (this.menuPopup)
              return this.menuPopup;
            this.menuPopup = new MenuPopup();
            this.menuPopup.direction = direction != null ? direction : "";
            this.menuPopup.isSubMenu = this.constructor.name === "MenuPopup";
            this.menuPopup.menuManager = this.menuManager;
            this.menuPopup.menu = this.selectedMenu;
            this.menuPopup.parentMenu = this;
            this.menuPopup.open();
            if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen) {
              if (!this.menuPopup.isSubMenu) {
                this.menuManager.searchBox.setParentPopup(this.menuPopup);
              } else {
                this.menuManager.searchBox.addSymbol("/");
              }
            }
            return this.menuPopup;
          }
          closeMenu() {
            if (!this.menuPopup) {
              return;
            }
            if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen && this.menuPopup.isSubMenu && this.menuManager.searchBox.value.substring(this.menuManager.searchBox.value.length - 1) === "/") {
              this.menuManager.searchBox.removeSymbol();
            }
            this.menuPopup.close();
            this.menuPopup = void 0;
          }
          moveOnTarget(target) {
            let host = target ? target.$host : null;
            if (!host) {
              return;
            }
            if (this.selectedMenu) {
              if (host.path === this.selectedMenu.path) {
                return;
              } else {
                this.unselectMenu();
              }
            }
            if (this.menuPopup) {
              this.closeMenu();
            }
            host.buttonElement = host.$buttonElement || target;
            this.selectMenu(host);
          }
          openMenuByPath(path) {
            var _a;
            if (typeof path === "string")
              path = path.split("/");
            let menu2 = this.getMenuByPath(path.shift());
            if (!menu2)
              return;
            if (!menu2.$host)
              menu2.$host = menu2;
            this.moveOnTarget(menu2);
            if (!menu2.$host.map)
              return;
            this.openMenu();
            if (path.length)
              (_a = this.menuPopup) == null ? void 0 : _a.openMenuByPath(path);
          }
        }
        class MenuBar extends Menu {
          constructor() {
            super(...arguments);
            this.selectedClass = "menuButtonDown";
            this.onMouseMove = (e) => {
              let target = this.menuManager.getTarget(e.target);
              this.moveOnTarget(target);
            };
          }
          build(parent) {
            this.element = parent;
            let items = this.menus.map || {};
            Object.keys(items).filter(Boolean).map((key) => items[key]).sort(function(item1, item2) {
              return item1.position - item2.position;
            }).map((item) => {
              item.$buttonElement = dom.buildDom(["div", {
                class: "menuButton" + (item.className ? " " + item.className : ""),
                $host: item,
                onmousedown: (e) => this.onMouseDown(e)
              }, item.label + ""], this.element);
            });
            let rect = this.element.getBoundingClientRect();
            this.bottom = rect.bottom;
          }
          activateMenu() {
            this.element.addEventListener("mousemove", this.onMouseMove);
          }
          inactivateMenu() {
            this.unselectMenu();
            this.closeMenu();
            this.element.removeEventListener("mousemove", this.onMouseMove);
          }
          /*** event handlers ***/
          onMouseDown(e) {
            e.preventDefault();
            let activate = true;
            if (this.menuManager.isActive) {
              this.menuManager.inactivateMenu();
            } else {
              let target = e.target;
              target.$host.buttonElement = target.$host.$buttonElement;
              this.selectMenu(target.$host);
              this.openMenu();
              this.menuManager.activeMenu = this;
              this.menuManager.activateMenu();
            }
          }
          moveOnTarget(target) {
            var _a;
            super.moveOnTarget(target);
            if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
              this.openMenu();
          }
          getMenuByPath(path) {
            return this.menuManager.find(path);
          }
        }
        class MenuPopup extends Menu {
          constructor() {
            super(...arguments);
            this.selectedClass = "hover";
            this.isSubMenu = false;
            this.onMouseMove = (e) => {
              var _a;
              if (e.target === this.element)
                return;
              if (this.menuPopup && this.isDirectedToSubMenu(e))
                return;
              let target = this.menuManager.getTarget(e.target);
              if (target === this.element)
                return;
              this.moveOnTarget(target);
              if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
                this.openMenu();
            };
            this.onMouseUp = (e) => {
              if (e.target === this.element)
                return;
              let target = this.menuManager.getTarget(e.target);
              if (!target || target === this.element)
                return;
              let host = target.$host;
              if (host && host.buttonElement) {
                e.preventDefault();
                if (host.exec)
                  host.exec(this.menuManager.currentHost);
              }
              if (!host.map)
                this.menuManager.inactivateMenu();
            };
          }
          inactivateMenu() {
            this.close();
          }
          activateMenu() {
          }
          open() {
            this.build();
            this.render();
          }
          build() {
            if (this.element) {
              return;
            }
            if (this.menu.element) {
              this.element = this.menu.element;
              return;
            }
            let result = [];
            if (this.menu.map) {
              let items = Object.values(this.menu.map).sort(function(item1, item2) {
                return item1.position - item2.position;
              });
              let afterDivider = true;
              result = items.map((item) => {
                if (item.label[0] === "~") {
                  if (afterDivider)
                    return;
                  afterDivider = true;
                  return [
                    "div",
                    {
                      class: "menu_divider",
                      $host: item
                    }
                  ];
                }
                afterDivider = false;
                let classList = ["menu_item"];
                if (item.checked)
                  classList.push(item.type === "check" ? "checked" : "selected");
                if (item.map)
                  classList.push("submenu");
                if (item.disabled)
                  classList.push("disabled");
                return [
                  "div",
                  {
                    class: classList.join(" "),
                    $host: item
                  },
                  ["u", " "],
                  ["a", item.label + ""],
                  [
                    "span",
                    {
                      class: "shortcut"
                    },
                    item.hotKey
                  ]
                ];
              }).filter(Boolean);
              if (afterDivider)
                result.pop();
            }
            this.menu.element = dom.buildDom(
              [
                "blockquote",
                {
                  class: "menu",
                  style: "display:block",
                  $host: this.menu,
                  onmousemove: this.onMouseMove,
                  onmouseup: this.onMouseUp
                },
                result
              ],
              document.body
            );
            this.element = this.menu.element;
          }
          render() {
            if (!this.element)
              return;
            if (this.element.style.maxWidth)
              this.element.style.maxWidth = window.innerWidth + "px";
            if (this.element.style.maxHeight)
              this.element.style.maxHeight = window.innerHeight + "px";
            let elRect = this.element.getBoundingClientRect();
            let edge = Utils.getElementEdges(this.element);
            let parentRect, top, left;
            if (this.menu && this.menu.buttonElement)
              parentRect = this.menu.buttonElement.getBoundingClientRect();
            if (parentRect) {
              if (this.isSubMenu) {
                top = parentRect.top - edge.top;
                left = parentRect.right;
              } else {
                top = parentRect.bottom;
                left = parentRect.left;
              }
            } else {
              top = this.position.y;
              left = this.position.x;
            }
            let targetH = Math.min(elRect.height, window.innerHeight);
            let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
            if (availableH < targetH && (!parentRect || this.isSubMenu)) {
              let tmpTop = parentRect ? window.innerHeight : top;
              top = tmpTop - targetH - edge.top;
              top = Math.max(top, this.menuManager.menuBar.bottom);
              availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
            }
            this.element.style.maxHeight = availableH - 10 + "px";
            elRect = this.element.getBoundingClientRect();
            let availableW = window.innerWidth - left - edge.left - edge.right - 2;
            if (availableW < elRect.width) {
              if (parentRect) {
                let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
                if (tmpLeft > availableW) {
                  this.direction = "left";
                  left = tmpLeft - elRect.width + edge.left;
                  left = Math.max(left, 0);
                  availableW = tmpLeft + edge.left + edge.right;
                }
                if (availableW < elRect.width) {
                  this.element.style.maxWidth = availableW + "px";
                  this.element.style.overflowX = "auto";
                }
              } else {
                left = window.innerWidth - elRect.width - edge.left - edge.right;
              }
            }
            this.element.style.top = top + "px";
            this.element.style.left = left + "px";
            this.element.style.position = "absolute";
            this.element.style.zIndex = String(195055);
            this.element.style.overflowY = "auto";
          }
          close() {
            if (this.menuPopup) {
              this.closeMenu();
            }
            if (this.element) {
              this.element.remove();
              delete this.element;
            }
            if (this.menu.element) {
              delete this.menu.element;
            }
          }
          scrollIfNeeded() {
            if (!this.selectedMenu)
              return;
            let menu2 = this.element;
            let item = this.selectedMenu.buttonElement;
            let menuRect = menu2.getBoundingClientRect();
            let itemRect = item.getBoundingClientRect();
            if (itemRect.top < menuRect.top) {
              item.scrollIntoView(true);
            } else if (itemRect.bottom > menuRect.bottom) {
              item.scrollIntoView(false);
            }
          }
          moveOnTarget(target) {
            super.moveOnTarget(target);
          }
          isDirectedToSubMenu(e) {
            let currPos = { x: e.clientX, y: e.clientY };
            let prevPos = this.menuManager.prevPos;
            let rect = this.menuPopup.element.getBoundingClientRect();
            let rectYTop = rect.top;
            let rectYBottom = rect.bottom;
            if (currPos.y < rectYTop || currPos.y > rectYBottom) {
              return false;
            }
            let rectX = this.menuPopup.direction === "left" ? rect.right : rect.left;
            let prevDiffX = Math.abs(rectX - prevPos.x);
            let currDiffX = Math.abs(rectX - currPos.x);
            if (prevDiffX < currDiffX) {
              return false;
            }
            let directedToBottom = currPos.y > prevPos.y;
            let prevDiffY = directedToBottom ? rectYBottom - prevPos.y : prevPos.y - rectYTop;
            let tng = prevDiffY / prevDiffX;
            let maxYDiff = tng * currDiffX;
            return directedToBottom && rectYBottom - maxYDiff >= currPos.y || !directedToBottom && rectYTop + maxYDiff <= currPos.y;
          }
          renderRecursive() {
            this.render();
            if (this.menuPopup) {
              this.menuPopup.renderRecursive();
            }
          }
          getMenuByPath(path) {
            let childNode;
            let childNodes = this.element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
              childNode = childNodes[i];
              if (childNode.$host && childNode.$host.id === path) {
                if (childNode.classList.contains("menu_item") && !childNode.classList.contains("disabled")) {
                  return childNode;
                }
              }
            }
            return null;
          }
        }
        class MenuSearchBox {
          constructor() {
            this.isOpen = false;
            this.hideFiltered = false;
            this.value = "";
            this.currValue = "";
          }
          open() {
            if (!this.element) {
              this.build();
            }
            this.isOpen = true;
            document.body.appendChild(this.element);
            this.calcElementPosition();
          }
          close() {
            this.isOpen = false;
            if (this.parentPopup && this.parentPopup.element) {
              if (this.parentPopup.prevMaxHeight) {
                this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
              }
            }
            if (this.value.length) {
              this.value = "";
              this.currValue = "";
              this.update();
            }
            this.parentPopup = void 0;
            this.element.remove();
          }
          setParentPopup(parentPopup) {
            var _a;
            if (this.parentPopup && this.parentPopup.element) {
              if (this.parentPopup.prevMaxHeight) {
                this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
              }
            }
            this.parentPopup = parentPopup;
            this.currPopupMenu = parentPopup;
            if (this.isOpen) {
              this.calcElementPosition();
              let currPopupMenu = parentPopup;
              let valueArr = this.value.split("/");
              while (currPopupMenu) {
                this.currPopupMenu = currPopupMenu;
                this.currValue = (_a = valueArr.shift()) != null ? _a : "";
                this.isChanged = true;
                this.update();
                this.isOpen = false;
                currPopupMenu = this.currPopupMenu.selectedMenu && this.currPopupMenu.selectedMenu.map ? this.currPopupMenu.openMenu() : null;
                this.isOpen = true;
              }
            }
          }
          calcElementPosition() {
            if (!this.parentPopup)
              return;
            this.parentPopup.prevMaxHeight = null;
            let parentRect = this.parentPopup.element.getBoundingClientRect();
            let top = parentRect.top - 20;
            if (top < this.menuManager.menuBar.bottom) {
              top = parentRect.bottom;
              if (parentRect.bottom + 20 > window.innerHeight) {
                this.parentPopup.prevMaxHeight = this.parentPopup.element.style.maxHeight;
                this.parentPopup.element.style.maxHeight = parseInt(this.parentPopup.element.style.maxHeight, 10) - 20 + "px";
                top -= 20;
              }
            }
            this.element.style.top = top + "px";
            this.element.style.right = window.innerWidth - parentRect.right + "px";
          }
          addSymbol(symbol) {
            var _a;
            if (symbol === "/" && this.value.substring(this.value.length - 1) === "/") {
              return;
            }
            this.value += symbol;
            if (symbol === "/") {
              if (((_a = this.currPopupMenu) == null ? void 0 : _a.selectedMenu) && this.currPopupMenu.selectedMenu.map) {
                this.currPopupMenu = this.currPopupMenu.openMenu();
                this.currValue = "";
              }
              this.isChanged = false;
            } else {
              this.currValue += symbol;
              this.isChanged = true;
            }
            this.update();
          }
          removeSymbol() {
            var _a, _b;
            if (!this.isOpen) {
              return;
            }
            let removed = this.value.substring(this.value.length - 1);
            this.value = this.value.substring(0, this.value.length - 1);
            if (removed === "/") {
              this.currValue = (_a = this.value.split("/").pop()) != null ? _a : "";
              this.currPopupMenu = ((_b = this.currPopupMenu) == null ? void 0 : _b.parentMenu) instanceof MenuPopup ? this.currPopupMenu.parentMenu : void 0;
              this.isChanged = false;
            } else {
              this.currValue = this.currValue.substring(0, this.currValue.length - 1);
              this.isChanged = true;
            }
            this.update();
            if (!this.value.length) {
              this.close();
            }
          }
          update() {
            this.searchField.textContent = this.value;
            if (this.currPopupMenu && this.currPopupMenu.element && this.isChanged) {
              this.setPopupMenuHighlights();
              if (this.hideFiltered) {
                this.calcElementPosition();
              }
            }
          }
          switchShowHideFiltered() {
            this.hideFiltered = !this.hideFiltered;
            this.update();
            if (!this.hideFiltered) {
              this.calcElementPosition();
            }
          }
          showHideMenuNode(menu2, show) {
            var _a;
            show = show || false;
            if (!show && menu2.classList.contains("hover") && ((_a = this.currPopupMenu) == null ? void 0 : _a.menuPopup)) {
              show = true;
            }
            menu2.isFiltered = !show;
            show = show || !this.hideFiltered;
            menu2.style.display = show ? "block" : "none";
          }
          setPopupMenuHighlights() {
            var _a;
            if (!((_a = this.currPopupMenu) == null ? void 0 : _a.element))
              return;
            let childNode;
            let width = 0;
            this.selectMenu = null;
            this.secondarySelectMenu = null;
            if (this.hideFiltered) {
              let rect = this.currPopupMenu.element.getBoundingClientRect();
              let edges = Utils.getElementEdges(this.currPopupMenu.element);
              width = rect.width - edges.left - edges.right;
            }
            let afterDivider = true;
            let noResult = true;
            for (let i = 0; i < this.currPopupMenu.element.childNodes.length; i++) {
              childNode = this.currPopupMenu.element.childNodes[i];
              if (childNode.classList.contains("menu_item")) {
                this.setHighlights(childNode);
                afterDivider = afterDivider && childNode.isFiltered;
                if (noResult && !childNode.isFiltered) {
                  noResult = false;
                }
              } else if (childNode.classList.contains("menu_divider")) {
                this.showHideMenuNode(childNode, !afterDivider);
                afterDivider = true;
              }
            }
            if (this.hideFiltered) {
              this.currPopupMenu.element.style.width = Math.ceil(width) + "px";
              let noResultEl = this.currPopupMenu.element.querySelector(".menu_no_result");
              if (noResult && !noResultEl) {
                dom.buildDom(["div", { class: "menu_no_result" }, "No matching result"], this.currPopupMenu.element);
              } else if (!noResult && noResultEl) {
                noResultEl.remove();
              }
            }
            this.selectMenu = this.selectMenu || this.secondarySelectMenu;
            if (this.selectMenu) {
              this.currPopupMenu.moveOnTarget(this.selectMenu);
              this.currPopupMenu.scrollIfNeeded();
            }
            if (this.hideFiltered) {
              this.currPopupMenu.renderRecursive();
            }
            if (this.suggestionPopup) {
              this.suggestionPopup.close();
            }
            if (noResult) {
              this.currValue = this.value;
              let suggestionList = {};
              let addToSuggestionList = (menus) => {
                Object.keys(menus).forEach((name) => {
                  let item = menus[name];
                  if (item.label && item.label[0] === "~") {
                    return;
                  }
                  if (!item.path) {
                    console.log(item);
                    return;
                  }
                  let path = item.path;
                  let tokens = this.getTokens(path);
                  if (tokens) {
                    suggestionList[path] = {
                      label: path,
                      tokens
                    };
                  }
                  if (item.map) {
                    addToSuggestionList(item.map);
                  }
                });
              };
              addToSuggestionList(this.menuManager.menus.map);
              this.suggestionPopup = new MenuPopup();
              this.suggestionPopup.direction = "right";
              this.suggestionPopup.isSubMenu = true;
              this.suggestionPopup.menuManager = this.menuManager;
              this.suggestionPopup.menu = {
                buttonElement: this.element,
                map: suggestionList
              };
              this.suggestionPopup.parentMenu = this;
              this.suggestionPopup.open();
              for (let i = 0; i < this.suggestionPopup.element.childNodes.length; i++) {
                let childNode2 = this.suggestionPopup.element.childNodes[i];
                let menuTitle = childNode2.querySelector("a");
                let innerHtml = "";
                for (let t = 0; t < childNode2.$host.tokens.length; t++) {
                  innerHtml += "<span class='menu-" + childNode2.$host.tokens[t].type + "'>" + childNode2.$host.tokens[t].value + "</span>";
                }
                menuTitle.innerHTML = innerHtml;
              }
            }
          }
          setHighlights(menu2) {
            let text = menu2.$host.label;
            let menuTitle = menu2.querySelector("a");
            if (!this.currValue || !this.currValue.length) {
              menuTitle.innerHTML = text;
              this.showHideMenuNode(menu2, true);
              return;
            }
            let tokens = this.getTokens(text);
            let innerHtml = "";
            let show = true;
            if (tokens) {
              if (menu2.classList.contains("disabled")) {
                innerHtml = text;
              } else {
                this.secondarySelectMenu = this.secondarySelectMenu || menu2;
                if (!this.selectMenu && tokens[0].type === "completion-highlight") {
                  this.selectMenu = menu2;
                }
                for (let i = 0; i < tokens.length; i++) {
                  innerHtml += "<span class='menu-" + tokens[i].type + "'>" + tokens[i].value + "</span>";
                }
              }
            } else {
              innerHtml = text;
              show = false;
            }
            this.showHideMenuNode(menu2, show);
            menuTitle.innerHTML = innerHtml;
          }
          getTokens(string) {
            let tokens = [];
            let caption = string.toLowerCase();
            let lower = this.currValue.toLowerCase();
            let upper = this.currValue.toUpperCase();
            function addToken(value, className) {
              value && tokens.push({
                type: className || "",
                value
              });
            }
            let lastIndex = -1;
            let matchMask = 0;
            let index, distance;
            let fullMatchIndex = caption.indexOf(lower);
            if (fullMatchIndex === -1) {
              for (let j = 0; j < this.currValue.length; j++) {
                let i1 = caption.indexOf(lower[j], lastIndex + 1);
                let i2 = caption.indexOf(upper[j], lastIndex + 1);
                index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                if (index < 0)
                  return;
                distance = index - lastIndex - 1;
                if (distance > 0) {
                  matchMask = matchMask | 1 << j;
                }
                lastIndex = index;
              }
            }
            let filterText = lower;
            lower = caption.toLowerCase();
            lastIndex = 0;
            let lastI = 0;
            for (let i = 0; i <= filterText.length; i++) {
              if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
                let sub = filterText.slice(lastI, i);
                lastI = i;
                index = lower.indexOf(sub, lastIndex);
                if (index === -1)
                  continue;
                addToken(string.slice(lastIndex, index), "");
                lastIndex = index + sub.length;
                addToken(string.slice(index, lastIndex), "completion-highlight");
              }
            }
            addToken(string.slice(lastIndex, string.length), "");
            return tokens;
          }
          build() {
            var _a, _b, _c, _d;
            this.element = dom.buildDom([
              "div",
              { class: "menu_searchbox" },
              ["span", { class: "search_field" }],
              ["span", { class: "searchbtn_filter" }],
              ["span", { class: "searchbtn_close" }]
            ]);
            this.element.$host = this;
            this.searchField = this.element.querySelector(".search_field");
            let _this = this;
            (_b = (_a = this.element) == null ? void 0 : _a.querySelector(".searchbtn_close")) == null ? void 0 : _b.addEventListener("mousedown", function(e) {
              _this.close();
            });
            (_d = (_c = this.element) == null ? void 0 : _c.querySelector(".searchbtn_filter")) == null ? void 0 : _d.addEventListener("mousedown", function(e) {
              _this.switchShowHideFiltered();
            });
          }
        }
        ;
        const menuManager_event = __nested_webpack_require_440138__(517);
        const menuManager_keyUtil = __nested_webpack_require_440138__(863);
        function getPrevSibling(node, conditionFn, parentElement) {
          parentElement = node ? node.parentElement : parentElement;
          let wrapped = false;
          do {
            node = node && node.previousSibling;
            if (!node && !wrapped) {
              node = parentElement == null ? void 0 : parentElement.lastChild;
              wrapped = true;
            }
            if (!node)
              return;
          } while (!conditionFn(node));
          return node;
        }
        function getNextSibling(node, conditionFn, parentElement) {
          parentElement = node ? node.parentElement : parentElement;
          let wrapped = false;
          do {
            node = node && node.nextSibling;
            if (!node && !wrapped) {
              node = parentElement == null ? void 0 : parentElement.firstChild;
              wrapped = true;
            }
            if (!node)
              return;
          } while (!conditionFn(node));
          return node;
        }
        class MenuManager {
          constructor() {
            this.menus = new MenuItems();
            this.onMouseDown = (e) => {
              let target = this.getTarget(e.target, (target2) => target2.$host instanceof MenuItems);
              if (!target)
                this.inactivateMenu();
            };
            this.onMouseMove = (e) => {
              let lastPos = { x: e.clientX, y: e.clientY };
              if (this.lastPos && this.lastPos.x === lastPos.x && this.lastPos.y === lastPos.y) {
                return;
              }
              this.prevPos = this.lastPos;
              this.lastPos = lastPos;
            };
            this.onWindowResize = (e) => {
              if (!this.activeMenu) {
                return;
              }
              let menuPopup = this.activeMenu instanceof MenuPopup ? this.activeMenu : this.activeMenu.menuPopup;
              if (menuPopup) {
                menuPopup.renderRecursive();
              }
            };
            this.onContextMenuOpen = (e) => {
              e.preventDefault();
              let target = this.getTarget(e.target, (target2) => target2.$host.contextMenu);
              if (!target) {
                return;
              }
              let pos = { x: e.clientX + 2, y: e.clientY + 2 };
              this.openMenuByPath("/context/" + target.$host.contextMenu, pos);
              this.currentHost = target.$host;
            };
            this.add = this.addByPath;
          }
          static getInstance() {
            if (!MenuManager._instance) {
              MenuManager._instance = new MenuManager();
            }
            return MenuManager._instance;
          }
          find(path, item) {
            if (typeof path === "string")
              path = path.split("/");
            item = item || this.menus;
            path.forEach(function(part) {
              if (!item || !item.map)
                return;
              item = item.map[part];
            });
            return item;
          }
          addByPath(path, options2 = {}) {
            var _a, _b, _c, _d, _e;
            if (typeof path == "string")
              path = path.split("/");
            let item = this.menus;
            path.forEach(function(part) {
              var _a2, _b2, _c2;
              (_a2 = item.map) != null ? _a2 : item.map = {};
              (_c2 = (_b2 = item.map)[part]) != null ? _c2 : _b2[part] = new MenuItems();
              item = item.map[part];
            });
            item.path = path.join("/");
            let name = path.pop();
            item.id = name;
            item.label = options2.label || name;
            item.position = (_a = options2.position) != null ? _a : 0;
            item.hotKey = options2.hotKey;
            item.type = (_b = options2.type) != null ? _b : "";
            item.checked = (_c = options2.checked) != null ? _c : false;
            item.disabled = (_d = options2.disabled) != null ? _d : false;
            item.className = (_e = options2.className) != null ? _e : "";
            item.exec = options2.exec;
          }
          getTarget(target, callback) {
            while (target) {
              if (target.$host && (!callback || callback(target)))
                return target;
              target = target.parentElement;
            }
            return;
          }
          bindKeys() {
            function isMenuBarItem(node) {
              return node.classList.contains("menuButton");
            }
            function isMenuPopupActiveItem(node) {
              return node.classList.contains("menu_item") && !node.classList.contains("disabled") && !node.isFiltered;
            }
            function menuKeyDown(menuManager) {
              var _a;
              let menuPopup = (_a = menuManager.activeMenu) == null ? void 0 : _a.getLastOpenPopup();
              if (!menuPopup)
                return;
              let menu2 = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
              let nextMenu = getNextSibling(menu2, isMenuPopupActiveItem, menuPopup.element);
              menuPopup.moveOnTarget(nextMenu);
              menuPopup.scrollIfNeeded();
            }
            let menuKb = new hash_handler_.HashHandler([
              {
                bindKey: "Esc",
                name: "Esc",
                exec: function(menuManager) {
                  if (menuManager.searchBox && menuManager.searchBox.isOpen) {
                    menuManager.searchBox.close();
                    return;
                  }
                  let activeMenu = menuManager.activeMenu;
                  if (!activeMenu.menuPopup && activeMenu !== menuManager.menuBar) {
                    activeMenu.close();
                    menuManager.inactivateMenu();
                  } else {
                    activeMenu.closeLastMenu();
                    if (!activeMenu.menuPopup && activeMenu === menuManager.menuBar) {
                      menuManager.inactivateMenu();
                    }
                  }
                }
              },
              {
                bindKey: "Left",
                name: "Left",
                exec: function(menuManager) {
                  let activeMenu = menuManager.activeMenu;
                  activeMenu.closeLastMenu();
                  if (!activeMenu.menuPopup) {
                    if (activeMenu === menuManager.menuBar) {
                      let prevMenu = getPrevSibling(activeMenu.selectedMenu.buttonElement, isMenuBarItem);
                      if (prevMenu) {
                        activeMenu.moveOnTarget(prevMenu);
                      }
                    } else if (!activeMenu.element) {
                      menuManager.inactivateMenu();
                    }
                  }
                }
              },
              {
                bindKey: "Right",
                name: "Right",
                exec: function(menuManager) {
                  function moveToNextOnBar() {
                    if (menuManager.activeMenu !== menuManager.menuBar) {
                      return;
                    }
                    let nextMenu = getNextSibling(menuManager.menuBar.selectedMenu.buttonElement, isMenuBarItem);
                    if (nextMenu) {
                      menuManager.menuBar.moveOnTarget(nextMenu);
                    }
                  }
                  let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                  let menu2 = menuManager.activeMenu.getLastSelectedMenu();
                  if (!menu2) {
                    return;
                  }
                  let moveToNext = !menu2.map || menuManager.activeMenu === menuManager.menuBar && !menuManager.activeMenu.menuPopup.selectedMenu;
                  if (!moveToNext && (!menuPopup.selectedMenu && (menuManager.activeMenu.menuPopup !== menuPopup || menuManager.activeMenu !== menuPopup) || menuPopup.selectedMenu === menu2)) {
                    let isNewOpened = false;
                    if (menuPopup.selectedMenu === menu2) {
                      menuPopup.openMenu();
                      isNewOpened = true;
                    }
                    menuKeyDown(menuManager);
                    if (!isNewOpened && !menuPopup.selectedMenu) {
                      moveToNext = true;
                    }
                  }
                  if (moveToNext) {
                    moveToNextOnBar();
                  }
                }
              },
              {
                bindKey: "Enter",
                name: "Enter",
                exec: function(menuManager) {
                  let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                  let menu2 = menuManager.activeMenu.getLastSelectedMenu();
                  if (menu2 && menu2.map && menuPopup.selectedMenu === menu2) {
                    menuPopup.openMenu();
                  }
                }
              },
              {
                bindKey: "Up",
                name: "Up",
                exec: function(menuManager) {
                  let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                  let menu2 = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
                  let prevMenu = getPrevSibling(menu2, isMenuPopupActiveItem, menuPopup.element);
                  menuPopup.moveOnTarget(prevMenu);
                  menuPopup.scrollIfNeeded();
                }
              },
              {
                bindKey: "Backspace",
                name: "Backspace",
                exec: function(menuManager) {
                  menuManager.searchBox.removeSymbol();
                }
              },
              {
                bindKey: "Down",
                name: "Down",
                exec: menuKeyDown
              }
            ]);
            let _this = this;
            menuManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
              if (!_this.isActive) {
                return;
              }
              menuManager_event.stopEvent(e);
              let keyString = menuManager_keyUtil.keyCodeToString(keyCode);
              let command = menuKb.findKeyCommand(hashId, keyString);
              if (command && command.exec) {
                command.exec(_this);
              } else if (e.key.length === 1) {
                MenuManager.getInstance().addSymbolToSearchBox(e.key);
              }
            });
          }
          build() {
            window.addEventListener("contextmenu", this.onContextMenuOpen);
          }
          buildMenuBar(parent) {
            this.menuBar = new MenuBar();
            this.menuBar.menus = this.menus;
            this.menuBar.menuManager = this;
            this.menuBar.build(parent);
          }
          openMenuByPath(path, position) {
            if (typeof path === "string")
              path = path.split("/");
            if (path[0] && path[0].length) {
              this.activeMenu = this.menuBar;
            } else {
              this.activeMenu = new MenuPopup();
              this.activeMenu.menuManager = this;
              this.activeMenu.position = position;
              this.activeMenu.menu = this.find(path);
              this.activeMenu.open();
            }
            this.activateMenu();
            this.activeMenu.openMenuByPath(path);
          }
          activateMenu() {
            var _a;
            this.isActive = true;
            window.addEventListener("mousedown", this.onMouseDown);
            window.addEventListener("mousemove", this.onMouseMove);
            window.addEventListener("resize", this.onWindowResize);
            if ((_a = this.activeMenu) == null ? void 0 : _a.activateMenu)
              this.activeMenu.activateMenu();
          }
          inactivateMenu() {
            var _a;
            this.isActive = false;
            window.removeEventListener("mousedown", this.onMouseDown);
            window.removeEventListener("mousemove", this.onMouseMove);
            window.removeEventListener("resize", this.onWindowResize);
            if ((_a = this.activeMenu) == null ? void 0 : _a.inactivateMenu)
              this.activeMenu.inactivateMenu();
            this.activeMenu = void 0;
            if (this.searchBox)
              this.searchBox.close();
            this.currentHost = null;
          }
          addSymbolToSearchBox(symbol) {
            if (!this.searchBox || !this.searchBox.isOpen) {
              this.openSearchBox();
            }
            this.searchBox.addSymbol(symbol);
          }
          openSearchBox() {
            var _a;
            if (!this.searchBox) {
              this.searchBox = new MenuSearchBox();
              this.searchBox.menuManager = this;
            }
            this.searchBox.setParentPopup((_a = this.activeMenu) == null ? void 0 : _a.getLastOpenPopup());
            this.searchBox.open();
          }
        }
        class MenuItems {
        }
        ;
        const oop = __nested_webpack_require_440138__(387);
        const useragent = __nested_webpack_require_440138__(493);
        let newTabCounter = 1;
        class TabManager {
          constructor(options2) {
            this.$setBoxState = (box, state) => {
              if (!box)
                return;
              box.removeAllChildren();
              this.setBoxData(box, state);
              if (!box[0] && box.isMain)
                this.setChildBoxData(box, [{ type: "pane" }], 0);
            };
            this.containers = options2.containers;
            this.tabs = {};
            this.fileSystem = options2.fileSystem;
            this.commandsInit();
            this.initFileSystem();
          }
          static getInstance(options2) {
            if (!TabManager._instance)
              TabManager._instance = new TabManager(options2);
            return TabManager._instance;
          }
          initFileSystem() {
            var _a;
            (_a = this.fileSystem) == null ? void 0 : _a.on("openFile", (treeNode, fileContent) => {
              this.open({
                path: treeNode.path,
                title: treeNode.path.split("/").pop()
              }, void 0, fileContent);
            });
          }
          commandsInit() {
            MenuManager.getInstance().addByPath("/context/tabs");
            let commandsKeys = [];
            for (let command of tabCommands) {
              if (command.exec !== void 0) {
                MenuManager.getInstance().addByPath("/context/tabs/" + command.name, {
                  position: command.position,
                  hotKey: useragent.isMac ? command.mac : command.win,
                  exec: command.exec
                });
                commandsKeys.push({
                  bindKey: {
                    win: command.win,
                    mac: command.mac
                  },
                  exec: command.exec
                });
              }
            }
            CommandManager.registerCommands(commandsKeys, this);
          }
          toJSON() {
            let containers = Object.keys(this.containers);
            return Object.fromEntries(containers.map((container) => {
              var _a;
              return [container, (_a = this.containers[container]) == null ? void 0 : _a.toJSON()];
            }));
          }
          setChildBoxData(box, boxData, index) {
            if (!boxData[index])
              return;
            let boxType = boxData[index].type;
            if (!box[index])
              box.addChildBox(index, boxType === "pane" ? new Pane() : new Box({ vertical: boxType === "vbox" }));
            this.setBoxData(box[index], boxData[index]);
          }
          setBoxData(box, boxData) {
            if (!boxData)
              return;
            if (boxData.fixedSize)
              box.fixedSize = boxData.fixedSize;
            if (box instanceof Pane) {
              if (boxData.tabBar) {
                box.tabBar.scrollLeft = boxData.tabBar.scrollLeft;
                if (boxData.tabBar.tabList) {
                  box.tabBar.freeze = true;
                  boxData.tabBar.tabList.forEach((tabData) => {
                    let tab2 = box.tabBar.addTab(new Tab(tabData));
                    this.tabs[tab2.path] = tab2;
                    if (tab2.preview)
                      this.previewTab = tab2;
                  });
                  box.tabBar.freeze = false;
                  box.tabBar.configure();
                }
              }
            } else {
              box.hidden = boxData.hidden;
              box.ratio = boxData.ratio;
              this.setChildBoxData(box, boxData, 0);
              this.setChildBoxData(box, boxData, 1);
              box.buttons && box.setButtons(box.buttons);
            }
          }
          setState(state) {
            this.activePane = void 0;
            this.tabs = {};
            this.previewTab = void 0;
            for (let container in this.containers) {
              this.setContainerState(container, state[container]);
            }
          }
          setContainerState(container, state) {
            this.$setBoxState(this.containers[container], state);
          }
          clear() {
          }
          getPanes() {
          }
          getTabs() {
            return this.tabs;
          }
          get activeTab() {
            var _a;
            return (_a = this.activePane) == null ? void 0 : _a.tabBar.activeTab;
          }
          open(tabOptions, container, fileContent) {
            var _a;
            let tab2 = this.tabs[tabOptions.path];
            tabOptions.active = (_a = tabOptions.active) != null ? _a : true;
            if (!tab2 || !tab2.parent) {
              let pane;
              if (container) {
                pane = this.getContainerPane(container);
              } else {
                pane = this.activePane && this.activePane.tabBar.tabList.length > 0 ? this.activePane : this.getContainerPane("main");
              }
              if (this.previewTab)
                this.previewTab.remove();
              tab2 = pane.tabBar.addTab(new Tab(tabOptions), void 0, fileContent);
              if (tabOptions.preview)
                this.previewTab = tab2;
              tab2.parent.scrollTabIntoView(tab2);
              this.tabs[tab2.path] = tab2;
            }
            if (!tabOptions.preview) {
              if (this.previewTab == tab2) {
                this.clearPreviewStatus(tab2);
              } else if (this.previewTab) {
                this.previewTab.remove();
              }
            }
            tab2.parent.removeSelections();
            tab2.parent.activateTab(tab2, fileContent);
            return tab2;
          }
          getContainerPane(container) {
            return this.containers[container].element.querySelector(".tabPanel").$host;
          }
          clearPreviewStatus(tab2) {
            tab2.preview = false;
            tab2.element.style.fontStyle = "";
            if (this.previewTab == tab2)
              this.previewTab = void 0;
          }
          get newTabPath() {
            return `untitled_${newTabCounter}`;
          }
          addNewTab(pane, options2) {
            while (this.tabs.hasOwnProperty(this.newTabPath)) {
              newTabCounter++;
            }
            options2 != null ? options2 : options2 = { title: `Untitled ${newTabCounter}`, path: this.newTabPath };
            options2.active = true;
            let newTab = pane.tabBar.addTab(new Tab(options2));
            this.tabs[this.newTabPath] = newTab;
            return newTab;
          }
          removeTab(tab2) {
            delete this.tabs[tab2.path];
          }
          //TODO: move to separate class
          loadFile(tab2, fileContent) {
            let editor = tab2.parent.parent.getOrCreateEditor(tab2.editorType);
            editor.setSession(tab2, fileContent);
          }
          navigateToTab(index, tab2, tabs) {
            var _a;
            let tabsList = tabs || Object.values(this.tabs);
            let activeTab = tab2 || this.activeTab;
            if (index >= 0 && tabsList.length > index)
              (_a = activeTab == null ? void 0 : activeTab.parent) == null ? void 0 : _a.activateTab(tabsList[index], void 0, true);
          }
          saveTo(storage) {
            for (let [path, tab2] of Object.entries(this.tabs)) {
              storage["@file@" + path] = tab2.session ? tab2.editor.sessionToJSON(tab2) : tab2.sessionValue;
            }
          }
          restoreFrom(storage) {
            for (let [path, tab2] of Object.entries(this.tabs)) {
              tab2.sessionValue = storage["@file@" + path];
              if (tab2.session)
                tab2.editor.restoreSessionFromJson(tab2);
            }
          }
          getTab(path) {
            return this.tabs[path];
          }
        }
        oop.implement(TabManager.prototype, event_emitter_.EventEmitter);
        ;
        class Toolbar {
          setBox(x, y, w, h) {
            Utils.setBox(this.element, x, y, w, h);
          }
          constructor(options2) {
            this.direction = (options2 == null ? void 0 : options2.direction) || "horizontal";
            this.size = (options2 == null ? void 0 : options2.size) || 27;
            this.position = options2 == null ? void 0 : options2.position;
          }
        }
        ;
        class TabPanelBar extends Toolbar {
          constructor(options2) {
            var _a, _b;
            super(options2);
            this.selectedTabs = [];
            this.tabList = [];
            this.scrollLeft = 0;
            this.animationSteps = 0;
            this.MIN_TAB_SIZE = 120;
            this.MAX_TAB_SIZE = 150;
            this.activeTabHistory = [];
            this.onMouseWheel = (e) => {
              let d = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
              if (Math.abs(d) > 50) {
                this.animateScroll(d);
              } else {
                this.stopScrollAnimation();
                this.setScrollPosition((this.scrollLeft || 0) + d);
              }
            };
            this.initTabList = (_b = (_a = options2.tabList) != null ? _a : options2.panelList) != null ? _b : [];
          }
          isVertical() {
            return this.direction === "vertical";
          }
          getDraggingElementSize() {
            if (!this.tabDraggingElement)
              return 0;
            let draggingElementSize = this.isVertical() ? this.tabDraggingElement.style.height : this.tabDraggingElement.style.width;
            return parseInt(draggingElementSize, 10);
          }
          tabMouseDown(tab2, expand = false, toggle = false) {
            if (expand) {
              this.expandSelection(tab2, toggle);
            } else {
              this.anchorTab = null;
              if (toggle) {
                this.toggleSelection(tab2);
              } else {
                this.activateTab(tab2, void 0, this.selectedTabs.indexOf(tab2) < 0);
              }
            }
          }
          expandSelection(tab2, toggle = false) {
            if (!this.anchorTab)
              this.anchorTab = this.activeTab;
            let prevSelectedTabs = this.selectedTabs;
            this.selectedTabs = [];
            let start = this.tabList.indexOf(this.anchorTab);
            let end = this.tabList.indexOf(tab2);
            if (end < start) {
              [start, end] = [end, start];
            }
            for (let i = start; i <= end; i++) {
              this.addSelection(this.tabList[i]);
            }
            prevSelectedTabs.forEach((selectedTab) => {
              if (this.selectedTabs.indexOf(selectedTab) < 0) {
                if (!toggle) {
                  this.deselectTab(selectedTab);
                } else {
                  this.addSelection(selectedTab);
                }
              }
            });
            this.activateTab(tab2);
          }
          toggleSelection(tab2) {
            let index = this.selectedTabs.indexOf(tab2);
            if (index < 0) {
              this.activateTab(tab2);
            } else if (tab2 !== this.activeTab) {
              this.removeSelection(tab2);
            }
          }
          addSelection(tab2) {
            if (this.selectedTabs.indexOf(tab2) < 0) {
              this.selectTab(tab2);
              this.selectedTabs.push(tab2);
            }
          }
          selectTab(tab2) {
            tab2.element.classList.add("selected");
          }
          deselectTab(tab2) {
            tab2.element.classList.remove("selected");
          }
          removeSelection(tab2) {
            if (this.selectedTabs.indexOf(tab2) < 0)
              return;
            this.deselectTab(tab2);
            this.selectedTabs.splice(this.selectedTabs.indexOf(tab2), 1);
          }
          removeSelections() {
            this.selectedTabs.forEach((selectedTab) => {
              this.deselectTab(selectedTab);
            });
            this.selectedTabs = [];
          }
          scrollTabIntoView(tab2) {
            let index = this.tabList.indexOf(tab2);
            this.setScrollPosition((index + 1) * this.tabWidth);
          }
          activateTab(tab2, content, removeSelections = false) {
            removeSelections && this.removeSelections();
            this.activeTabClicked = false;
            this.addSelection(tab2);
            if (this.activeTab) {
              if (this.activeTab === tab2) {
                this.activeTabClicked = true;
                return;
              }
              if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
                this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
              this.activeTabHistory.push(this.activeTab);
              this.activeTab.deactivate();
            }
            tab2.activate();
            this.activeTab = tab2;
            this.configure();
          }
          removeTab(tab2) {
            if (tab2 === this.activeTab)
              this.activeTab = void 0;
            let index = this.tabList.indexOf(tab2);
            if (index >= 0)
              this.tabList.splice(index, 1);
            tab2.parent = void 0;
          }
          activatePrevious(index) {
            if (this.tabList.length) {
              let tab2 = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
              this.activateTab(tab2);
            }
          }
          addTab(tab2, index, content) {
            if (!tab2.element)
              tab2.render();
            tab2.parent = this;
            if (index === void 0 || index === null || index >= this.tabList.length) {
              this.tabContainer.appendChild(tab2.element);
              this.tabList.push(tab2);
            } else {
              this.tabContainer.insertBefore(tab2.element, this.tabContainer.childNodes[index]);
              this.tabList.splice(index, 0, tab2);
            }
            if (tab2.active)
              this.activateTab(tab2, content, true);
            this.configure();
            return tab2;
          }
          setScrollPosition(scrollLeft) {
            this.scrollLeft = scrollLeft;
            this.configure();
          }
          animateScroll(v) {
            this.vX = v / 80;
            this.animationSteps += 15;
            if (this.animationSteps > 15) {
              this.vX *= 1.2 * this.animationSteps / 10;
              this.animationSteps = 15 + Math.ceil((this.animationSteps - 15) * 0.75);
            }
            if (this.animationTimer)
              return;
            this.animationTimer = setInterval(() => {
              if (this.animationSteps-- <= 0) {
                return this.stopScrollAnimation();
              }
              let vX = this.vX;
              if (Math.abs(this.vX) < 0.01)
                vX = 0;
              vX = 0.9 * vX;
              let oldScrollLeft = this.scrollLeft;
              this.setScrollPosition(this.scrollLeft + 10 * vX);
              if (oldScrollLeft == this.scrollLeft)
                this.animationSteps = 0;
              this.vX = vX;
            }, 10);
          }
          stopScrollAnimation() {
            clearInterval(this.animationTimer);
            this.animationTimer = null;
            this.animationScrollLeft = null;
            this.vX = 0;
          }
          transform(el, dx, dy) {
            el.style.left = Math.round(dx) + "px";
            el.dx = dx;
            el.dy = dy;
          }
          startTabDragging(element, index) {
            if (this.isDragging)
              return;
            this.tabDraggingElement = element;
            this.draggingElementIndex = index;
            this.configure();
            this.isDragging = true;
          }
          finishTabDragging() {
            this.draggingElementIndex = void 0;
            this.tabDraggingElement = void 0;
            if (this.activeTabHistory.length) {
              let removedHistoryTabs = [];
              for (let i = 0; i < this.activeTabHistory.length; i++) {
                if (this.tabList.indexOf(this.activeTabHistory[i]) < 0) {
                  removedHistoryTabs.push(this.activeTabHistory[i]);
                }
              }
              removedHistoryTabs.forEach((tab2) => {
                let index = this.activeTabHistory.indexOf(tab2);
                if (index >= 0) {
                  this.activeTabHistory.splice(index, 1);
                }
              });
            }
            this.configure();
            this.isDragging = false;
          }
          toJSON() {
            return {
              tabList: this.tabList.map((tab2) => tab2.toJSON()),
              scrollLeft: this.scrollLeft
            };
          }
        }
        ;
        class TabBar extends TabPanelBar {
          constructor() {
            super(...arguments);
            this.inverted = true;
            this.buttonsWidth = 0;
            this.buttons = [];
            this.onTabMouseUp = (e) => {
              if (e.button == 1) {
                let tab2 = Utils.findHost(e.target, Tab);
                if (tab2)
                  tab2.remove();
              }
            };
            this.onTabMouseDown = (e) => {
              if (e.button == 0)
                TabbarHandler.tabbarMouseDown(e, Tab, TabBar, true);
            };
            this.onTabPlusClick = (e) => {
              this.removeSelections();
              TabManager.getInstance().addNewTab(this.parent);
            };
            this.onTabClick = (e) => {
              let target = e.target;
              let tab2 = Utils.findHost(target, Tab);
              if (tab2) {
                if (e.button == 0 && target.classList.contains("tabCloseButton")) {
                  this.closeTab(tab2);
                } else if (e.button == 0 && tab2.isActive && tab2.editor) {
                  tab2.editor.focus();
                } else if (e.button == 1) {
                  tab2.remove();
                }
              }
            };
          }
          setBox(x, y, w, h) {
            super.setBox(x, y, w, h);
            this.width = w;
            this.configure();
          }
          renderElement() {
            this.element = dom.buildDom([
              "div",
              {
                class: "tabbar " + this.direction,
                onwheel: this.onMouseWheel,
                $host: this
              },
              ["span", { class: "tabMenuButton" }],
              [
                "div",
                {
                  class: "tabScroller"
                },
                ["div", {
                  class: "tabContainer",
                  ref: "tabContainer",
                  onclick: this.onTabClick,
                  onmouseup: this.onTabMouseUp,
                  onmousedown: this.onTabMouseDown
                }]
              ],
              ["span", {
                class: "tabPlusButton",
                ref: "tabPlusButton",
                onclick: this.onTabPlusClick
              }, "+"],
              ["span", {
                class: "sizer"
              }],
              ["span", {
                class: "buttons",
                ref: "additionalButtons"
              }]
            ], void 0, this);
            if (this.initTabList && this.initTabList.length) {
              for (let i = 0; i < this.initTabList.length; i++) {
                this.addTab(this.initTabList[i]);
              }
            }
          }
          render() {
            if (!this.element)
              this.renderElement();
            return this.element;
          }
          computeConfig() {
            let draggingElementSize = this.getDraggingElementSize();
            this.plusButtonWidth = this.tabPlusButton.getBoundingClientRect().width;
            this.containerWidth = this.width - this.plusButtonWidth - this.buttonsWidth;
            let tabsCount = this.tabList.length;
            if (tabsCount * this.MAX_TAB_SIZE + draggingElementSize < this.containerWidth) {
              this.tabWidth = this.MAX_TAB_SIZE;
              this.containerWidth = tabsCount * this.tabWidth + draggingElementSize;
            } else if (tabsCount * this.MIN_TAB_SIZE + draggingElementSize < this.containerWidth) {
              this.tabWidth = (this.containerWidth - draggingElementSize) / tabsCount;
            } else {
              this.tabWidth = this.MIN_TAB_SIZE;
            }
            let tabsWidth = this.tabWidth * tabsCount + draggingElementSize;
            this.scrollLeft = Math.min(Math.max(this.scrollLeft, 0), tabsWidth - this.containerWidth);
          }
          configure() {
            if (!this.width || this.freeze)
              return;
            let shadowWidth = 4;
            this.computeConfig();
            this.tabContainer.style.width = this.containerWidth + "px";
            let draggingElementSize = this.getDraggingElementSize();
            if (this.inverted) {
              let zIndex = this.tabList.length;
              let min = shadowWidth - this.tabWidth;
              let max = this.containerWidth;
              let maxPos = (max - this.tabWidth) / 2;
              let i = 0;
              for (; i < this.tabList.length; i++) {
                let tab2 = this.tabList[i];
                let el = tab2.element;
                let pos = this.tabWidth * i - this.scrollLeft;
                if (this.tabDraggingElement && i >= this.draggingElementIndex) {
                  pos += draggingElementSize;
                }
                if (tab2 === this.activeTab) {
                  let activeMin = Math.max(min + this.tabWidth * 0.25, -this.tabWidth * 0.75);
                  if (pos < activeMin)
                    min = activeMin;
                }
                if (pos < min) {
                  pos = min;
                  min += shadowWidth;
                  el.classList.add("scrolledLeft");
                } else if (pos > maxPos) {
                  break;
                } else {
                  el.classList.remove("scrolledLeft");
                }
                el.style.width = this.tabWidth + "px";
                el.style.zIndex = String(zIndex);
                zIndex--;
                this.transform(el, pos, 0);
              }
              let lastRendered = i;
              zIndex = this.tabList.length;
              for (let i2 = this.tabList.length - 1; i2 >= lastRendered; i2--) {
                let tab2 = this.tabList[i2];
                let el = tab2.element;
                let pos = this.tabWidth * i2 - this.scrollLeft;
                if (this.tabDraggingElement && i2 >= this.draggingElementIndex) {
                  pos += draggingElementSize;
                }
                if (tab2 === this.activeTab) {
                  let activeMax = Math.min(max - this.tabWidth * 0.25, this.containerWidth - this.tabWidth * 0.25);
                  if (pos > activeMax)
                    max = activeMax;
                }
                if (pos > max) {
                  pos = max;
                  max -= shadowWidth;
                  el.classList.add("scrolledLeft");
                } else {
                  el.classList.remove("scrolledLeft");
                }
                el.style.width = this.tabWidth + "px";
                el.style.zIndex = String(zIndex);
                zIndex--;
                this.transform(el, pos, 0);
              }
            } else {
            }
          }
          addButton(button) {
            this.buttons.push(button);
            this.setButtons(this.buttons);
          }
          setButtons(buttons) {
            this.additionalButtons.innerHTML = "";
            this.buttons = buttons;
            buttons.forEach((button) => this.additionalButtons.appendChild(button));
            let rect = this.additionalButtons.getBoundingClientRect();
            this.buttonsWidth = rect.width;
            this.configure();
          }
          removeButtons() {
            if (!this.buttons.length)
              return;
            this.buttons = [];
            this.additionalButtons.innerHTML = "";
            this.buttonsWidth = 0;
            this.configure();
          }
          clear() {
            this.removeButtons();
            this.tabList = [];
          }
          remove() {
          }
          closeTab(tab2) {
            let index = this.tabList.indexOf(tab2);
            let isActiveTab = this.activeTab === tab2;
            let isAnchorTab = this.anchorTab === tab2;
            this.removeTab(tab2);
            this.removeSelection(tab2);
            if (isActiveTab) {
              this.activeTab = void 0;
              this.activatePrevious(index);
            }
            if (isAnchorTab)
              this.anchorTab = null;
            if (tab2.element)
              tab2.element.remove();
            TabManager.getInstance().removeTab(tab2);
            this.configure();
          }
          activateTab(tab2, content, removeSelections = false) {
            removeSelections && this.removeSelections();
            this.activeTabClicked = false;
            this.addSelection(tab2);
            if (this.activeTab) {
              if (this.activeTab === tab2) {
                this.activeTabClicked = true;
                tab2.activatePane();
                return;
              }
              if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
                this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
              this.activeTabHistory.push(this.activeTab);
              this.activeTab.deactivate();
            }
            tab2.activate(content);
            this.activeTab = tab2;
            this.configure();
          }
          activatePrevious(index) {
            if (this.tabList.length) {
              let tab2 = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
              this.activateTab(tab2);
            } else if (this.parent) {
              this.parent.remove();
            }
          }
        }
        ;
        class Pane extends Box {
          constructor(options2 = {}) {
            var _a;
            let tabBar = new TabBar({
              tabList: options2.tabList
            });
            options2.toolBars = (_a = options2.toolBars) != null ? _a : {};
            options2.toolBars.top = tabBar;
            super(options2);
            tabBar.parent = this;
            this.tabBar = tabBar;
          }
          toJSON() {
            return {
              type: "pane",
              tabBar: this.tabBar.toJSON()
            };
          }
          render() {
            super.render();
            this.element.classList.add("tabPanel");
            this.tabEditorBoxElement = dom.buildDom(["div", {
              class: `tab-editor`
            }]);
            this.element.appendChild(this.tabEditorBoxElement);
            return this.element;
          }
          acceptsTab(tab2) {
            return true;
          }
          split(far, vertical) {
            let newPane = new Pane({});
            let root = this.parent;
            let wrapper = new Box({
              [far ? 1 : 0]: this,
              [far ? 0 : 1]: newPane,
              vertical,
              ratio: 0.5
            });
            root.addChildBox(this, wrapper);
            if (this.isButtonHost) {
              let buttons = this.tabBar.buttons;
              this.removeButtons();
              wrapper.setButtons(buttons);
            }
            return newPane;
          }
          setButtons(buttons) {
            this.isButtonHost = true;
            if (buttons) {
              this.tabBar.setButtons(buttons);
            } else {
              this.tabBar.removeButtons();
            }
          }
          addButton(button) {
            this.isButtonHost = true;
            this.tabBar.addButton(button);
          }
          $updateChildSize(x, y, w, h) {
            this.updateToolBarSize(w, h);
            w -= this.padding.left + this.padding.right;
            h -= this.padding.top + this.padding.bottom;
            x = this.padding.left;
            y = this.padding.top;
            if (this.editor) {
              Utils.setBox(this.editor.container, x, y, w, h);
              this.editor.resize();
            }
          }
          removeButtons() {
            this.tabBar.removeButtons();
            this.isButtonHost = false;
          }
          remove() {
            let wrapper = this.parent;
            let root = wrapper.parent;
            let paneIndex = wrapper[0] == this ? 1 : 0;
            let pane = wrapper[paneIndex] || null;
            let rootIndex = root[0] == wrapper ? 0 : 1;
            if (pane) {
              pane.parent = root;
              root[rootIndex] = pane;
              root.element.appendChild(pane.element);
              if (root.fixedChild && root.fixedChild == wrapper) {
                pane.fixedSize = wrapper.fixedSize;
                pane.size = wrapper.size;
                root.fixedChild = pane;
              }
              wrapper.element.remove();
            } else {
              if (wrapper.isMain) {
                root = wrapper;
              } else {
                wrapper.element.remove();
              }
              root.ratio = 1;
            }
            root.recalculateAllMinSizes();
            root.resize();
            if (this.isButtonHost)
              root.setButtons(this.tabBar.buttons);
            this.clearEditors();
            this.tabBar.clear();
          }
          getTopRightPane() {
            return this;
          }
          createEditor() {
            let editor = this.createEditorByType();
            this.emit("editorAdded", editor);
            return editor;
          }
          createEditorByType() {
            switch (this.currentEditorType) {
              case EditorType.preview:
                return new PreviewEditor();
              case EditorType.ace:
              default:
                return new AceEditor();
            }
          }
          initEditor(editorType = EditorType.ace) {
            var _a, _b, _c;
            if (this.currentEditorType == editorType)
              return;
            this.hidePreviousEditor();
            (_a = this.editors) != null ? _a : this.editors = {};
            this.currentEditorType = editorType;
            (_c = (_b = this.editors)[editorType]) != null ? _c : _b[editorType] = this.createEditor();
            this.editor = this.editors[editorType];
            this.element.appendChild(this.editor.container);
          }
          hidePreviousEditor() {
            if (!this.editor)
              return;
            this.element.removeChild(this.editor.container);
          }
          getEditor(editorType = EditorType.ace) {
            return this.editors[editorType];
          }
          getOrCreateEditor(editorType = EditorType.ace) {
            this.initEditor(editorType);
            return this.editor;
          }
          clearEditors() {
            for (let i in this.editors) {
              this.editors[i].destroy();
            }
            this.editors = {};
            this.currentEditorType = void 0;
            this.editor = void 0;
          }
        }
        var styles_button = __nested_webpack_require_440138__(382);
        ;
        var button_options = {};
        button_options.styleTagTransform = styleTagTransform_default();
        button_options.setAttributes = setAttributesWithoutAttributes_default();
        button_options.insert = insertBySelector_default().bind(null, "head");
        button_options.domAPI = styleDomAPI_default();
        button_options.insertStyleElement = insertStyleElement_default();
        var button_update = injectStylesIntoStyleTag_default()(styles_button.A, button_options);
        const assets_styles_button = styles_button.A && styles_button.A.locals ? styles_button.A.locals : void 0;
        ;
        var __defProp = Object.defineProperty;
        var __getOwnPropSymbols = Object.getOwnPropertySymbols;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __propIsEnum = Object.prototype.propertyIsEnumerable;
        var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
        var __spreadValues = (a, b) => {
          for (var prop in b || (b = {}))
            if (__hasOwnProp.call(b, prop))
              __defNormalProp(a, prop, b[prop]);
          if (__getOwnPropSymbols)
            for (var prop of __getOwnPropSymbols(b)) {
              if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
            }
          return a;
        };
        var __objRest = (source, exclude) => {
          var target = {};
          for (var prop in source)
            if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
              target[prop] = source[prop];
          if (source != null && __getOwnPropSymbols)
            for (var prop of __getOwnPropSymbols(source)) {
              if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
                target[prop] = source[prop];
            }
          return target;
        };
        dom.importCssString(button_namespaceObject, "button.css");
        class Button {
          constructor(options2) {
            let _a = options2, {
              disabled,
              value,
              className,
              onClick
            } = _a, other = __objRest(_a, [
              "disabled",
              "value",
              "className",
              "onClick"
            ]);
            this.disabled = disabled;
            this.value = value;
            this.className = className || "blackbutton";
            this.onClick = onClick;
            this.options = other;
          }
          remove() {
          }
          render() {
            var _a;
            this.renderElement();
            this.element.$host = this;
            this.element.onclick = (_a = this.onClick) != null ? _a : null;
            this.disabled && this.element.classList.add("Disabled");
            this.onClick && this.element.addEventListener("click", this.onClick);
            this.element.addEventListener("mousedown", (e) => this.addClass(e, "Down"));
            this.element.addEventListener("mouseup", (e) => this.removeClass(e, "Down"));
            this.element.addEventListener("mouseover", (e) => this.addClass(e, "Over"));
            this.element.addEventListener("mouseout", (e) => this.removeClass(e, "Over"));
            this.element.addEventListener("focus", (e) => this.addClass(e, "Focus"));
            this.element.addEventListener("unfocus", (e) => this.removeClass(e, "Focus"));
            return this.element;
          }
          addClass(e, className) {
            e.preventDefault();
            this.element.classList.add(className);
          }
          removeClass(e, className) {
            this.element.classList.remove(className);
          }
          renderElement() {
            var _a;
            (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", __spreadValues({}, this.options), this.value]);
            this.element.classList.add(this.className);
          }
          toJSON() {
          }
        }
        var dropdown = __nested_webpack_require_440138__(593);
        ;
        var dropdown_options = {};
        dropdown_options.styleTagTransform = styleTagTransform_default();
        dropdown_options.setAttributes = setAttributesWithoutAttributes_default();
        dropdown_options.insert = insertBySelector_default().bind(null, "head");
        dropdown_options.domAPI = styleDomAPI_default();
        dropdown_options.insertStyleElement = insertStyleElement_default();
        var dropdown_update = injectStylesIntoStyleTag_default()(dropdown.A, dropdown_options);
        const styles_dropdown = dropdown.A && dropdown.A.locals ? dropdown.A.locals : void 0;
        ;
        var dropdown_defProp = Object.defineProperty;
        var dropdown_getOwnPropSymbols = Object.getOwnPropertySymbols;
        var dropdown_hasOwnProp = Object.prototype.hasOwnProperty;
        var dropdown_propIsEnum = Object.prototype.propertyIsEnumerable;
        var dropdown_defNormalProp = (obj, key, value) => key in obj ? dropdown_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
        var dropdown_spreadValues = (a, b) => {
          for (var prop in b || (b = {}))
            if (dropdown_hasOwnProp.call(b, prop))
              dropdown_defNormalProp(a, prop, b[prop]);
          if (dropdown_getOwnPropSymbols)
            for (var prop of dropdown_getOwnPropSymbols(b)) {
              if (dropdown_propIsEnum.call(b, prop))
                dropdown_defNormalProp(a, prop, b[prop]);
            }
          return a;
        };
        var dropdown_objRest = (source, exclude) => {
          var target = {};
          for (var prop in source)
            if (dropdown_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
              target[prop] = source[prop];
          if (source != null && dropdown_getOwnPropSymbols)
            for (var prop of dropdown_getOwnPropSymbols(source)) {
              if (exclude.indexOf(prop) < 0 && dropdown_propIsEnum.call(source, prop))
                target[prop] = source[prop];
            }
          return target;
        };
        dom.importCssString(dropdown_namespaceObject, "dropdown.css");
        dom.importCssString(menu_namespaceObject, "menu.css");
        const DEFAULT_WIDTH = 200;
        class Dropdown {
          constructor(options2) {
            this.onMouseDown = (e) => {
              e.preventDefault();
              let node = Utils.findNode(e.target, this.className);
              if (node && node == this.element)
                return;
              node = Utils.findNode(e.target, this.popup.element.className);
              if (node && node == this.popup.element)
                return;
              this.closePopup();
            };
            this.onMouseWheel = (e) => {
              this.closePopup();
            };
            let _a = options2, { disabled, items, value, className, width } = _a, other = dropdown_objRest(_a, ["disabled", "items", "value", "className", "width"]);
            this.disabled = disabled != null ? disabled : false;
            this.items = items;
            this.value = value != null ? value : items[0].value;
            this.className = className || "black_dropdown";
            this.width = width != null ? width : DEFAULT_WIDTH;
            this.options = other;
          }
          render() {
            this.element = dom.buildDom(["div", dropdown_spreadValues({
              class: this.className + (this.disabled ? this.className + "Disabled" : ""),
              style: "width: " + this.width + "px",
              onmousedown: (e) => {
                e.preventDefault();
                this.element.className = this.className + " " + this.className + "Down";
                this.togglePopup();
              },
              onmouseup: (e) => {
                this.element.className = this.className;
              },
              onmouseover: (e) => {
                this.element.className = this.className + " " + this.className + "Over";
              },
              onfocus: (e) => {
                this.element.className = this.className + " " + this.className + "Focus";
              },
              onunfocus: (e) => {
                this.element.className = this.className;
              },
              onmouseout: (e) => {
                this.element.className = this.className;
              }
            }, this.options), [
              ["div", {
                class: "lbl",
                ref: "lbl"
              }],
              ["div", {
                class: "button"
              }]
            ]], void 0, this);
            this.element.$host = this;
            this.updateLabel();
            return this.element;
          }
          togglePopup() {
            if (this.isPopupOpen) {
              this.closePopup();
            } else {
              this.openPopup();
            }
          }
          openPopup() {
            if (this.isPopupOpen)
              return;
            this.popup = new Popup();
            this.popup.items = this.items;
            this.popup.selectedItem = this.value;
            this.popup.parent = this;
            this.popup.selectCallback = (host) => {
              this.select(host.value);
              this.closePopup();
            };
            this.popup.open();
            window.addEventListener("mousedown", this.onMouseDown);
            window.addEventListener("wheel", this.onMouseWheel);
            this.isPopupOpen = true;
          }
          closePopup() {
            if (!this.isPopupOpen)
              return;
            this.popup.close();
            this.isPopupOpen = false;
            window.removeEventListener("mousedown", this.onMouseDown);
            window.removeEventListener("wheel", this.onMouseWheel);
          }
          select(value) {
            this.setValue(value);
          }
          setValue(value) {
            if (this.value !== value) {
              this.value = value;
              this.updateLabel();
            }
          }
          updateLabel() {
            let items = this.items;
            for (let i = 0; i < items.length; i++) {
              let x = items[i];
              let itemValue = x.value;
              if (this.value === itemValue) {
                this.lbl.innerHTML = x.caption;
                return;
              }
            }
          }
          toJSON() {
          }
        }
        class Popup {
          open() {
            this.build();
            this.render();
          }
          build() {
            if (this.element) {
              return;
            }
            let result = [];
            if (this.items) {
              let items = Object.values(this.items).sort(function(item1, item2) {
                return item1.position - item2.position;
              });
              let afterDivider = true;
              result = items.map((item) => {
                if (item.caption[0] === "~") {
                  if (afterDivider)
                    return;
                  afterDivider = true;
                  return [
                    "div",
                    {
                      class: "menu_divider",
                      $host: item
                    }
                  ];
                }
                afterDivider = false;
                let classList = ["menu_item"];
                if (item.checked)
                  classList.push(item.type === "check" ? "checked" : "selected");
                if (item.map)
                  classList.push("submenu");
                if (item.disabled)
                  classList.push("disabled");
                if (item.value === this.selectedItem)
                  classList.push("selected");
                return [
                  "div",
                  {
                    class: classList.join(" "),
                    $host: item
                  },
                  ["u", " "],
                  ["a", item.caption + ""],
                  [
                    "span",
                    {
                      class: "shortcut"
                    },
                    item.hotKey
                  ]
                ];
              }).filter(Boolean);
              if (afterDivider)
                result.pop();
            }
            this.element = dom.buildDom(
              [
                "blockquote",
                {
                  class: "menu",
                  style: "display:block",
                  $host: this.parent,
                  onmousemove: this.onMouseMove.bind(this),
                  onclick: this.onClick.bind(this)
                },
                result
              ],
              document.body
            );
          }
          render() {
            if (this.element.style.maxWidth) {
              this.element.style.maxWidth = window.innerWidth + "px";
            }
            if (this.element.style.maxHeight) {
              this.element.style.maxHeight = window.innerHeight + "px";
            }
            let elRect = this.element.getBoundingClientRect();
            let edge = Utils.getElementEdges(this.element);
            let parentRect, top, left;
            if (this.parent && this.parent.element) {
              parentRect = this.parent.element.getBoundingClientRect();
            }
            if (parentRect) {
              if (this.isSubMenu) {
                top = parentRect.top - edge.top;
                left = parentRect.right;
              } else {
                top = parentRect.bottom;
                left = parentRect.left;
              }
            } else {
              top = this.position.y;
              left = this.position.x;
            }
            let targetH = Math.min(elRect.height, window.innerHeight);
            let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
            if (availableH < targetH && (!parentRect || this.isSubMenu)) {
              let tmpTop = parentRect ? window.innerHeight : top;
              top = tmpTop - targetH - edge.top;
              availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
            }
            this.element.style.maxHeight = availableH - 10 + "px";
            elRect = this.element.getBoundingClientRect();
            let availableW = window.innerWidth - left - edge.left - edge.right - 2;
            if (availableW < elRect.width) {
              if (parentRect) {
                let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
                if (tmpLeft > availableW) {
                  this.direction = "left";
                  left = tmpLeft - elRect.width + edge.left;
                  left = Math.max(left, 0);
                  availableW = tmpLeft + edge.left + edge.right;
                }
                if (availableW < elRect.width) {
                  this.element.style.maxWidth = availableW + "px";
                  this.element.style.overflowX = "auto";
                }
              } else {
                left = window.innerWidth - elRect.width - edge.left - edge.right;
              }
            }
            this.element.style.top = top + "px";
            this.element.style.left = left + "px";
            this.element.style.position = "absolute";
            this.element.style.zIndex = 195055;
            this.element.style.overflowY = "auto";
          }
          close() {
            if (this.element) {
              this.element.remove();
              delete this.element;
            }
          }
          scrollIfNeeded() {
            if (!this.selectedMenu) {
              return;
            }
            let menu2 = this.element;
            let item = this.selectedMenu.buttonElement;
            let menuRect = menu2.getBoundingClientRect();
            let itemRect = item.getBoundingClientRect();
            if (itemRect.top < menuRect.top) {
              item.scrollIntoView(true);
            } else if (itemRect.bottom > menuRect.bottom) {
              item.scrollIntoView(false);
            }
          }
          //handle events
          onMouseMove(e) {
            if (e.target === this.element) {
              return;
            }
            let target = Utils.findHostTarget(e.target);
            if (target === this.element) {
              return;
            }
            if (target == this.activeItem) {
              return;
            }
            if (this.activeItem) {
              this.activeItem.classList.remove("hover");
            }
            this.activeItem = target;
            this.activeItem.classList.add("hover");
          }
          onClick(e) {
            if (e.target === this.element)
              return;
            let target = Utils.findHostTarget(e.target);
            if (target === this.element)
              return;
            let host = target.$host;
            this.selectCallback && this.selectCallback(host);
          }
        }
        ;
        class SettingsSearchBox {
          constructor(prefsParentNode) {
            this.hideFiltered = false;
            this.value = "";
            this.currValue = "";
            this.searchResultsCount = 0;
            this.prefsParentNode = prefsParentNode;
          }
          filter() {
            let childNode;
            let noResult = true;
            this.searchResultsCount = 0;
            for (let i = 0; i < this.prefsParentNode.childNodes.length; i++) {
              childNode = this.prefsParentNode.childNodes[i];
              this.updateVisibility(childNode);
              if (noResult && !childNode.isFiltered) {
                noResult = false;
              }
            }
            if (this.currValue != "") {
              this.searchResults.innerHTML = " " + this.searchResultsCount + " Preferences Found";
            } else {
              this.searchResults.innerHTML = "";
            }
          }
          showHide(item, show) {
            show = show || false;
            item.isFiltered = !show;
            item.style.display = show ? "block" : "none";
          }
          updateVisibility(item) {
            let text = item.innerText;
            let tokens = this.getTokens(text);
            let show = true;
            if (!tokens) {
              show = false;
            } else {
              this.searchResultsCount++;
            }
            this.showHide(item, show);
          }
          getTokens(string) {
            let tokens = [];
            let caption = string.toLowerCase();
            let lower = this.currValue.toLowerCase();
            let upper = this.currValue.toUpperCase();
            function addToken(value, className) {
              value && tokens.push({
                type: className || "",
                value
              });
            }
            let lastIndex = -1;
            let matchMask = 0;
            let index, distance;
            let fullMatchIndex = caption.indexOf(lower);
            if (fullMatchIndex === -1) {
              for (let j = 0; j < this.currValue.length; j++) {
                let i1 = caption.indexOf(lower[j], lastIndex + 1);
                let i2 = caption.indexOf(upper[j], lastIndex + 1);
                index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                if (index < 0)
                  return null;
                distance = index - lastIndex - 1;
                if (distance > 0) {
                  matchMask = matchMask | 1 << j;
                }
                lastIndex = index;
              }
            }
            let filterText = lower;
            lower = caption.toLowerCase();
            lastIndex = 0;
            let lastI = 0;
            for (let i = 0; i <= filterText.length; i++) {
              if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
                let sub = filterText.slice(lastI, i);
                lastI = i;
                index = lower.indexOf(sub, lastIndex);
                if (index === -1)
                  continue;
                addToken(string.slice(lastIndex, index), "");
                lastIndex = index + sub.length;
                addToken(string.slice(index, lastIndex), "completion-highlight");
              }
            }
            addToken(string.slice(lastIndex, string.length), "");
            return tokens;
          }
          build() {
            this.element = dom.buildDom([
              "div",
              {},
              ["input", { class: "search_field tbsimple", placeholder: "Search preferences" }],
              ["span", { class: "search_results" }],
              ["span", { class: "searchbtn_close" }]
            ]);
            this.element.$host = this;
            this.searchField = this.element.querySelector(".search_field");
            this.searchResults = this.element.querySelector(".search_results");
            let _this = this;
            this.element.querySelector(".searchbtn_close").addEventListener("mousedown", function(e) {
              _this.clear();
            });
            this.searchField.addEventListener("input", function(e) {
              _this.currValue = e.target.value;
              _this.filter();
            });
          }
          clear() {
            if (this.currValue.length) {
              this.searchField.value = "";
              this.currValue = "";
              this.filter();
            }
          }
        }
        var switcher = __nested_webpack_require_440138__(915);
        ;
        var switcher_options = {};
        switcher_options.styleTagTransform = styleTagTransform_default();
        switcher_options.setAttributes = setAttributesWithoutAttributes_default();
        switcher_options.insert = insertBySelector_default().bind(null, "head");
        switcher_options.domAPI = styleDomAPI_default();
        switcher_options.insertStyleElement = insertStyleElement_default();
        var switcher_update = injectStylesIntoStyleTag_default()(switcher.A, switcher_options);
        const styles_switcher = switcher.A && switcher.A.locals ? switcher.A.locals : void 0;
        ;
        var switcher_defProp = Object.defineProperty;
        var switcher_getOwnPropSymbols = Object.getOwnPropertySymbols;
        var switcher_hasOwnProp = Object.prototype.hasOwnProperty;
        var switcher_propIsEnum = Object.prototype.propertyIsEnumerable;
        var switcher_defNormalProp = (obj, key, value) => key in obj ? switcher_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
        var switcher_spreadValues = (a, b) => {
          for (var prop in b || (b = {}))
            if (switcher_hasOwnProp.call(b, prop))
              switcher_defNormalProp(a, prop, b[prop]);
          if (switcher_getOwnPropSymbols)
            for (var prop of switcher_getOwnPropSymbols(b)) {
              if (switcher_propIsEnum.call(b, prop))
                switcher_defNormalProp(a, prop, b[prop]);
            }
          return a;
        };
        var switcher_objRest = (source, exclude) => {
          var target = {};
          for (var prop in source)
            if (switcher_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
              target[prop] = source[prop];
          if (source != null && switcher_getOwnPropSymbols)
            for (var prop of switcher_getOwnPropSymbols(source)) {
              if (exclude.indexOf(prop) < 0 && switcher_propIsEnum.call(source, prop))
                target[prop] = source[prop];
            }
          return target;
        };
        dom.importCssString(switcher_namespaceObject, "switcher.css");
        class Switcher {
          constructor(options2) {
            let _a = options2, { className, checked } = _a, other = switcher_objRest(_a, ["className", "checked"]);
            this.className = className || "cboffline";
            this.options = other;
            this.checked = checked || false;
          }
          render() {
            this.element = dom.buildDom(["div", switcher_spreadValues({
              class: this.className + (this.checked ? " " + this.className + "Checked" : ""),
              onmousedown: (e) => {
                e.preventDefault();
                this.checked = !this.checked;
                e.target.className = this.className + (this.checked ? " " + this.className + "Down" : "");
              },
              onclick: (e) => {
                e.preventDefault();
                e.target.className = this.className + (this.checked ? " " + this.className + "Checked" : "");
              }
            }, this.options), ""]);
            this.element.$host = this;
            return this.element;
          }
          toJSON() {
            return {};
          }
          remove() {
          }
        }
        ;
        class MenuToolbar extends Toolbar {
          render() {
            if (!this.element) {
              this.element = dom.buildDom(["div", {
                class: "menuToolBar"
              }, [
                "div",
                {
                  class: "menuBar",
                  ref: "menuBar"
                }
              ]], void 0, this);
              let menuManager = MenuManager.getInstance();
              menuManager.build();
              menuManager.buildMenuBar(this.menuBar);
              menuManager.bindKeys();
            }
            return this.element;
          }
          remove() {
          }
          toJSON() {
          }
        }
        ;
        class PanelBar extends TabPanelBar {
          setBox(x, y, w, h) {
            super.setBox(x, y, w, h);
            this.configure();
          }
          configure() {
            let tabElement;
            let tabSize = 30;
            let position = 0;
            for (let i = 0; i < this.tabList.length; i++) {
              tabElement = this.tabList[i].element;
              if (this.draggingElementIndex === i)
                position += this.getDraggingElementSize();
              if (this.isVertical()) {
                tabElement.style.left = "0px";
                tabElement.style.height = tabSize + "px";
                tabElement.style.top = position + "px";
              } else {
                tabElement.style.top = "0px";
                tabElement.style.width = tabSize + "px";
                tabElement.style.left = position + "px";
              }
              position += tabSize;
            }
          }
          render() {
            if (!this.element) {
              this.element = dom.buildDom(["div", {
                class: "panelbar " + this.direction + " " + this.position
              }, ["div", {
                class: "tabContainer",
                ref: "tabContainer",
                onmousedown: function(e) {
                  TabbarHandler.tabbarMouseDown(e, Panel, PanelBar);
                },
                onmouseup: (e) => {
                  if (this.activeTabClicked) {
                    let activeTab = this.activeTab;
                    this.removeSelection(activeTab);
                    activeTab.deactivate();
                    this.activeTab = void 0;
                    if (this.activeTabHistory.length && activeTab.autoHide) {
                      let previousTab = activeTab;
                      while (previousTab === activeTab && this.activeTabHistory.length) {
                        previousTab = this.activeTabHistory.pop();
                      }
                      if (previousTab !== activeTab)
                        this.activateTab(previousTab);
                    }
                  }
                }
              }]], void 0, this);
            }
            if (this.initTabList && this.initTabList.length) {
              for (let i = 0; i < this.initTabList.length; i++) {
                this.addTab(this.initTabList[i]);
              }
            }
            this.element.$host = this;
            return this.element;
          }
          addTabList(tabList, index) {
            index = index || this.tabList.length;
            let tab2;
            for (let i = 0; i < tabList.length; i++) {
              tab2 = new Panel(tabList[i]);
              this.addTab(tab2, index++);
            }
          }
          remove() {
          }
        }
        ;
        class PanelManager {
          constructor(options2) {
            this.layout = options2.layout;
            this.locations = options2.locations;
          }
          static getInstance(options2) {
            if (!PanelManager._instance)
              PanelManager._instance = new PanelManager(options2);
            return PanelManager._instance;
          }
          toJSON() {
            return {
              panelBars: this.panelBarsToJSON()
            };
          }
          panelBarsToJSON() {
            let panelBars = {};
            for (let [position, panelBar] of Object.entries(this.layout.toolBars)) {
              if (panelBar instanceof PanelBar)
                panelBars[position] = panelBar.toJSON();
            }
            return panelBars;
          }
          setState(state) {
            var _a;
            let panelBars = (_a = state.panelBars) != null ? _a : {};
            let panelBar, panelList, panel2;
            let panelBody, panelBodyData;
            for (let position of Object.keys(panelBars)) {
              panelList = [];
              let tabList = panelBars[position].tabList;
              for (let i = 0; i < tabList.length; i++) {
                panel2 = tabList[i];
                panelBodyData = panel2.panelBody;
                if (panelBodyData.type === "accordion") {
                  let accordionSections = [];
                  let sections = panelBodyData.sections;
                  for (let index = 0; index < sections.length; index++) {
                    accordionSections.push({
                      title: sections[index].title,
                      box: new Box(sections[index].boxData)
                    });
                  }
                  panelBody = new Accordion({
                    vertical: panelBodyData.vertical,
                    size: panelBodyData.size,
                    sections: accordionSections
                  });
                } else {
                  panelBody = new Box({
                    vertical: panelBodyData.type === "vbox",
                    color: panelBodyData.color,
                    size: panelBodyData.size,
                    hidden: panelBodyData.hidden,
                    fixedSize: panelBodyData.fixedSize
                  });
                }
                panelList.push({
                  active: panel2.active,
                  title: panel2.title,
                  autoHide: panel2.autoHide,
                  panelBody
                });
              }
              panelBar = new PanelBar({ panelList: {} });
              this.layout.addToolBar(position, panelBar);
              panelBar.addTabList(panelList);
            }
          }
          activatePanel(panel2) {
            let location = this.locations[panel2.parent.position];
            if (!location)
              return;
            let index = location.index;
            let parent = location.parent;
            panel2.panelBody.size = location.size;
            let newBox = parent.addChildBox(index, panel2.panelBody);
            if (newBox.fixedSize && !parent.fixedChild)
              parent.fixedChild = newBox;
            location.box = newBox;
            newBox.show();
          }
          deactivatePanel(panel2) {
            let location = this.locations[panel2.parent.position];
            location == null ? void 0 : location.box.hide();
          }
        }
        var panel = __nested_webpack_require_440138__(174);
        ;
        var panel_options = {};
        panel_options.styleTagTransform = styleTagTransform_default();
        panel_options.setAttributes = setAttributesWithoutAttributes_default();
        panel_options.insert = insertBySelector_default().bind(null, "head");
        panel_options.domAPI = styleDomAPI_default();
        panel_options.insertStyleElement = insertStyleElement_default();
        var panel_update = injectStylesIntoStyleTag_default()(panel.A, panel_options);
        const styles_panel = panel.A && panel.A.locals ? panel.A.locals : void 0;
        ;
        dom.importCssString(panel_namespaceObject, "panel.css");
        class Panel extends TabPanel {
          constructor(options2) {
            var _a;
            super(options2);
            this.location = options2.location;
            this.panelBody = options2.panelBody;
            this.autoHide = (_a = options2.autoHide) != null ? _a : false;
            this.title = options2.title;
          }
          activate() {
            super.activate();
            PanelManager.getInstance().activatePanel(this);
          }
          deactivate() {
            super.deactivate();
            PanelManager.getInstance().deactivatePanel(this);
          }
          render() {
            this.element = dom.buildDom(["div", {
              class: "panelButton" + (this.active ? " active" : "")
            }, ["span", {
              class: "panelTitle"
            }, this.title]]);
            this.element.$host = this;
            return this.element;
          }
          toJSON() {
            return {
              active: this.active,
              title: this.title,
              autoHide: this.autoHide,
              panelBody: this.panelBody.toJSON()
            };
          }
          remove() {
          }
        }
        var layout = __nested_webpack_require_440138__(0);
        ;
        var layout_options = {};
        layout_options.styleTagTransform = styleTagTransform_default();
        layout_options.setAttributes = setAttributesWithoutAttributes_default();
        layout_options.insert = insertBySelector_default().bind(null, "head");
        layout_options.domAPI = styleDomAPI_default();
        layout_options.insertStyleElement = insertStyleElement_default();
        var layout_update = injectStylesIntoStyleTag_default()(layout.A, layout_options);
        const styles_layout = layout.A && layout.A.locals ? layout.A.locals : void 0;
        ;
        class AceLayout {
          constructor(startBox, css) {
            dom.importCssString(css != null ? css : layout_namespaceObject, "layout.css");
            this.box = startBox;
          }
        }
        var ace_tree_lib = __nested_webpack_require_440138__(532);
        ;
        const getIconUrl = (path, isDir) => {
          return `https://raw.githubusercontent.com/vscode-icons/vscode-icons/master/icons/${getIconName(
            path,
            isDir
          )}.svg`;
        };
        function getIconName(path, isDir) {
          if (!path)
            return "default_file";
          if (isDir)
            return "default_folder";
          const filename = path.substring(path.lastIndexOf("/") + 1);
          const ext = filename.split(".").pop() || "";
          return getIconNameFromExtension(ext) || getIconNameFromFileName(filename) || "default_file";
        }
        function getIconNameFromExtension(ext) {
          switch (ext.toLowerCase()) {
            case "js":
              return "file_type_js";
            case "ts":
              return "file_type_typescript";
            case "html":
              return "file_type_html";
            case "css":
              return "file_type_css";
            case "less":
              return "file_type_less";
            case "sass":
              return "file_type_sass";
            case "scss":
              return "file_type_scss";
            case "json":
              return "file_type_json";
            case "py":
              return "file_type_python";
            case "rb":
              return "file_type_ruby";
            case "go":
              return "file_type_go";
            case "rust":
              return "file_type_rust";
            case "java":
              return "file_type_java";
            case "scala":
              return "file_type_scala";
            case "swift":
              return "file_type_swift";
            case "sh":
              return "file_type_shell";
            case "makefile":
              return "file_type_shell";
            case "bat":
              return "file_type_shell";
            case "bash":
              return "file_type_shell";
            case "cs":
              return "file_type_csharp";
            case "yml":
              return "file_type_yaml";
            case "yaml":
              return "file_type_yaml";
            case "xml":
              return "file_type_xml";
            case "md":
              return "file_type_markdown";
            case "sql":
              return "file_type_sql";
            case "jpg":
              return "file_type_image";
            case "svg":
              return "file_type_image";
            case "jpeg":
              return "file_type_image";
            case "png":
              return "file_type_image";
            case "gif":
              return "file_type_image";
            case "bmp":
              return "file_type_image";
            default:
              return null;
          }
        }
        function getIconNameFromFileName(filename) {
          switch (filename.toLowerCase()) {
            case "dockerfile":
              return "file_type_docker";
            case ".gitignore":
              return "file_type_git2";
            case ".gitattributes":
              return "file_type_git2";
            default:
              return null;
          }
        }
        var ace_tree = __nested_webpack_require_440138__(216);
        ;
        var ace_tree_options = {};
        ace_tree_options.styleTagTransform = styleTagTransform_default();
        ace_tree_options.setAttributes = setAttributesWithoutAttributes_default();
        ace_tree_options.insert = insertBySelector_default().bind(null, "head");
        ace_tree_options.domAPI = styleDomAPI_default();
        ace_tree_options.insertStyleElement = insertStyleElement_default();
        var ace_tree_update = injectStylesIntoStyleTag_default()(ace_tree.A, ace_tree_options);
        const styles_ace_tree = ace_tree.A && ace_tree.A.locals ? ace_tree.A.locals : void 0;
        ;
        const ace_tree_oop = __nested_webpack_require_440138__(387);
        dom.importCssString(ace_tree_namespaceObject, "ace-tree.css");
        function transform(node) {
          const path = node["path"] || "";
          const name = path.slice(path.lastIndexOf("/") + 1);
          let children = node["nodes"] || node["children"];
          if (children)
            children = children.map(transform);
          return {
            fsNode: node,
            name,
            children
          };
        }
        class AceTreeWrapper {
          render() {
            var _a;
            if (this.tree) {
              return this.element;
            }
            (_a = this.element) != null ? _a : this.element = dom.buildDom(["div"]);
            this.element.className = "ace-tree-wrapper";
            this.tree = new ace_tree_lib.Tree(this.element);
            this.model = new ace_tree_lib.DataProvider({});
            this.setupAceTree();
            return this.element;
          }
          remove() {
            this.element.remove();
          }
          toJSON() {
            return {};
          }
          setupAceTree() {
            this.tree.setDataProvider(this.model);
            this.provideIcons();
            if (typeof window !== "undefined") {
              window["fileTree"] = this.tree;
            }
          }
          updateTreeData(fileTree) {
            const model = this.model;
            const tree = this.tree;
            if (!model.root || model.root.fsNode != fileTree) {
              const treeNodes = transform(fileTree);
              if (treeNodes.children.length == 1) {
                treeNodes.children[0].isOpen = true;
              }
              model.setRoot(treeNodes);
              tree.on("afterChoose", () => {
                var _a;
                const fsNode = (_a = tree.selection.getCursor()) == null ? void 0 : _a.fsNode;
                if (fsNode && fsNode.kind != "directory") {
                  const event = new CustomEvent("item-click", {
                    detail: fsNode
                  });
                  this.element.dispatchEvent(event);
                }
              });
            }
            this.tree.resize();
          }
          provideIcons() {
            this.model.getIconHTML = function(node) {
              const treeNode = node.fsNode;
              const isDir = treeNode.kind === "directory";
              const size = 16;
              return `<span class="file-icon">
<svg width="${size}" height="${size}">
     <image xlink:href="${getIconUrl(
                treeNode.path,
                isDir
              )}" width="${size}" height="${size}"/>
</svg>
</span>`;
            };
          }
        }
        ace_tree_oop.implement(AceTreeWrapper.prototype, event_emitter_.EventEmitter);
        ;
        var __knownSymbol = (name, symbol) => {
          return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
        };
        var __async = (__this, __arguments, generator) => {
          return new Promise((resolve, reject) => {
            var fulfilled = (value) => {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            };
            var rejected = (value) => {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            };
            var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
            step((generator = generator.apply(__this, __arguments)).next());
          });
        };
        var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
        const MAX_SIZE = 8e6;
        class FileSystemEntry {
          constructor(fileSystemHandle, filePath = "") {
            this.fileSystemHandle = fileSystemHandle;
            this.filePath = filePath;
          }
          get path() {
            return [this.filePath, this.name].join("/");
          }
          get name() {
            return this.fileSystemHandle.name;
          }
          get leaf() {
            const { name, kind, path } = this;
            const leaf = { name, kind, path, self: this };
            if (kind == "directory")
              leaf["children"] = [];
            return leaf;
          }
        }
        class File extends FileSystemEntry {
          constructor(fileSystemHandle, filePath = "") {
            super(fileSystemHandle, filePath);
            this.fileSystemHandle = fileSystemHandle;
            this.filePath = filePath;
            this.kind = "file";
          }
          getFileData() {
            return __async(this, null, function* () {
              return yield this.fileSystemHandle.getFile();
            });
          }
          getFileText() {
            return __async(this, null, function* () {
              const fileData = yield this.getFileData();
              if (fileData.size > MAX_SIZE)
                throw new Error(
                  `File size to large: ${fileData.size}, max ${MAX_SIZE} supported`
                );
              return yield fileData.text();
            });
          }
        }
        class Directory extends FileSystemEntry {
          constructor(fileSystemHandle, filePath = "") {
            super(fileSystemHandle, filePath);
            this.fileSystemHandle = fileSystemHandle;
            this.filePath = filePath;
            this.childNodes = [];
            this.kind = "directory";
          }
          static openFilehandle(fileHandle) {
            return __async(this, null, function* () {
              if (!fileHandle)
                throw new Error("FileHandle undefined");
              return new Directory(fileHandle);
            });
          }
          getFileTee() {
            return __async(this, null, function* () {
              const root = this.leaf;
              const entries = [root];
              while (entries.length) {
                const entry = entries.pop();
                const dir = entry.self;
                for (const childNode of yield dir.children()) {
                  const child = childNode.leaf;
                  if (child.kind == "directory") {
                    entries.push(child);
                  }
                  entry.children.push(child);
                }
                delete entry.self;
              }
              return root;
            });
          }
          getFileByPath(pathname) {
            return __async(this, null, function* () {
              const entries = yield this.children();
              while (entries.length) {
                const entry = entries.pop();
                if (entry.path == pathname)
                  return entry;
                if (entry.kind == "directory")
                  entries.push(...yield entry.children());
              }
              throw new Error(`File not found in tree: ${pathname}`);
            });
          }
          getDirectoryHandle(name) {
            return __async(this, null, function* () {
              return this.fileSystemHandle.getDirectoryHandle(name);
            });
          }
          children() {
            return __async(this, null, function* () {
              if (!this.childNodes.length) {
                try {
                  for (var iter = __forAwait(this.fileSystemHandle.values()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                    const child = temp.value;
                    let childNode;
                    if (child.kind == "directory") {
                      const fileHandle = yield this.getDirectoryHandle(
                        child.name
                      );
                      childNode = new Directory(fileHandle, this.path);
                    } else {
                      const fileHandle = yield this.fileSystemHandle.getFileHandle(child.name);
                      childNode = new File(fileHandle, this.path);
                    }
                    this.childNodes.push(childNode);
                  }
                } catch (temp2) {
                  error = [temp2];
                } finally {
                  try {
                    more && (temp = iter.return) && (yield temp.call(iter));
                  } finally {
                    if (error)
                      throw error[0];
                  }
                }
              }
              return [...this.childNodes];
            });
          }
        }
        ;
        var file_system_web_async = (__this, __arguments, generator) => {
          return new Promise((resolve, reject) => {
            var fulfilled = (value) => {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            };
            var rejected = (value) => {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            };
            var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
            step((generator = generator.apply(__this, __arguments)).next());
          });
        };
        class FileSystemWeb extends events.EventEmitter {
          get dir() {
            if (!this.directory)
              throw new Error("Accessing directory before created");
            return this.directory;
          }
          open() {
            return file_system_web_async(this, null, function* () {
              const handle = yield window.showDirectoryPicker().catch((err) => console.error("showDirectoryPicker:", err.message));
              if (handle) {
                const { err, dir } = yield Directory.openFilehandle(handle).then((dir2) => ({ dir: dir2, err: null })).catch((err2) => ({ err: err2, dir: null }));
                this.directory = dir;
                return this.getFileTree();
              }
            });
          }
          getFileTree() {
            return file_system_web_async(this, null, function* () {
              if (this.directory) {
                const nodes = [yield this.dir.getFileTee()];
                return { nodes };
              }
            });
          }
          openFile(treeNode) {
            return file_system_web_async(this, null, function* () {
              const file = yield this.dir.getFileByPath(treeNode.path);
              const fileText = yield file.getFileText();
              this.emit("openFile", treeNode, fileText);
            });
          }
        }
        ;
      })();
      return __nested_webpack_exports__;
    })()
  );
});


/***/ }),

/***/ 70590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true)
    module.exports = factory(__webpack_require__(19631), __webpack_require__(29451), __webpack_require__(93050), __webpack_require__(74943), __webpack_require__(51826), __webpack_require__(10776), __webpack_require__(27258), __webpack_require__(21016), __webpack_require__(91772), __webpack_require__(61893), __webpack_require__(2645), __webpack_require__(87366));
  else { var i, a; }
})(self, (__WEBPACK_EXTERNAL_MODULE__517__, __WEBPACK_EXTERNAL_MODULE__863__, __WEBPACK_EXTERNAL_MODULE__736__, __WEBPACK_EXTERNAL_MODULE__493__, __WEBPACK_EXTERNAL_MODULE__910__, __WEBPACK_EXTERNAL_MODULE__444__, __WEBPACK_EXTERNAL_MODULE__254__, __WEBPACK_EXTERNAL_MODULE__748__, __WEBPACK_EXTERNAL_MODULE__292__, __WEBPACK_EXTERNAL_MODULE__685__, __WEBPACK_EXTERNAL_MODULE__387__, __WEBPACK_EXTERNAL_MODULE__540__) => {
  return (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        465: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            (function webpackUniversalModuleDefinition2(root, factory) {
              if (true)
                module2.exports = factory(__webpack_require__2(517), __webpack_require__2(863), __webpack_require__2(736), __webpack_require__2(493), __webpack_require__2(910), __webpack_require__2(444), __webpack_require__2(254), __webpack_require__2(748), __webpack_require__2(292), __webpack_require__2(685), __webpack_require__2(387), __webpack_require__2(540));
              else { var i, a; }
            })(self, (__WEBPACK_EXTERNAL_MODULE__517__2, __WEBPACK_EXTERNAL_MODULE__863__2, __WEBPACK_EXTERNAL_MODULE__736__2, __WEBPACK_EXTERNAL_MODULE__493__2, __WEBPACK_EXTERNAL_MODULE__910__2, __WEBPACK_EXTERNAL_MODULE__444__2, __WEBPACK_EXTERNAL_MODULE__254__2, __WEBPACK_EXTERNAL_MODULE__748__2, __WEBPACK_EXTERNAL_MODULE__292__2, __WEBPACK_EXTERNAL_MODULE__685__2, __WEBPACK_EXTERNAL_MODULE__387__2, __WEBPACK_EXTERNAL_MODULE__540__2) => {
              return (
                /******/
                (() => {
                  var __webpack_modules__2 = {
                    /***/
                    286: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.toggle-block {
    position: absolute;
    /*border: 1px solid black;*/
}


.toggle-bar {
    display:flex;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
    cursor: pointer;
}
.toggleBlockDragging {
    pointer-events: none;
    overflow-y: hidden;
}
.toggleBlockDragging  .title{
    pointer-events: none;
}

.toggle-bar .title {
    position: absolute;
    top: auto;
    left: auto;
    width: auto;
    height: auto;
}

.toggle-bar-h {
    width: 20px;
    height: 100%;
}

.toggle-bar-v {
    height: 20px;
    width: 100%;
}
.toggle-bar-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.toggle-bar-v div {
    margin-top: -2px;
    height: 5px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/accordion.css"], "names": [], "mappings": "AAAA;IACI,kBAAkB;IAClB,2BAA2B;AAC/B;;;AAGA;IACI,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,oBAAoB;IACpB,kBAAkB;AACtB;AACA;IACI,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,UAAU;IACV,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,WAAW;AACf;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf", "sourcesContent": [".toggle-block {\n    position: absolute;\n    /*border: 1px solid black;*/\n}\n\n\n.toggle-bar {\n    display:flex;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n    user-select: none;\n    cursor: pointer;\n}\n.toggleBlockDragging {\n    pointer-events: none;\n    overflow-y: hidden;\n}\n.toggleBlockDragging  .title{\n    pointer-events: none;\n}\n\n.toggle-bar .title {\n    position: absolute;\n    top: auto;\n    left: auto;\n    width: auto;\n    height: auto;\n}\n\n.toggle-bar-h {\n    width: 20px;\n    height: 100%;\n}\n\n.toggle-bar-v {\n    height: 20px;\n    width: 100%;\n}\n.toggle-bar-h div {\n    margin-left: -2px;\n    width: 5px;\n    height: 100%\n}\n.toggle-bar-v div {\n    margin-top: -2px;\n    height: 5px;\n}"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    216: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.ace-tree-wrapper {
    height: 100%;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/ace-tree.css"], "names": [], "mappings": "AAAA;IACI,YAAY;AAChB", "sourcesContent": [".ace-tree-wrapper {\n    height: 100%;\n}"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    382: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.blackbutton {
    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);
    border: 1px solid #042440;
    border-radius: 3px;
    color: #d0e3ce;
    text-shadow: 0;
    height: 27px;
    line-height: 27px;
    padding: 0 11px;
    text-align: center;
    cursor: default;
    font-weight: normal;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.blackbuttonDisabled {
    color: rgba(220, 235, 219, 0.5);
}
.blackbuttonFocus {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;
}
.blackbuttonOver {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;
}
.blackbuttonDown {
    box-shadow: 0 0 3px 2px #343434 inset;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/button.css"], "names": [], "mappings": "AAAA;IACI,gGAAgG;IAChG,wFAAwF;IACxF,yBAAyB;IACzB,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,YAAY;IACZ,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,eAAe;IACf,mBAAmB;IACnB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,+BAA+B;AACnC;AACA;IACI,oIAAoI;AACxI;AACA;IACI,sIAAsI;AAC1I;AACA;IACI,qCAAqC;AACzC", "sourcesContent": [".blackbutton {\n    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);\n    border: 1px solid #042440;\n    border-radius: 3px;\n    color: #d0e3ce;\n    text-shadow: 0;\n    height: 27px;\n    line-height: 27px;\n    padding: 0 11px;\n    text-align: center;\n    cursor: default;\n    font-weight: normal;\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\n}\n.blackbuttonDisabled {\n    color: rgba(220, 235, 219, 0.5);\n}\n.blackbuttonFocus {\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;\n}\n.blackbuttonOver {\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;\n}\n.blackbuttonDown {\n    box-shadow: 0 0 3px 2px #343434 inset;\n}"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    593: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__22(62);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
                        var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
                          /* asset import */
                          __webpack_require__22(952),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.black_dropdown {
    display: inline-block;
    position: relative;
    overflow: hidden;
    height: 21px;
    border-radius: 3px;
    border: 1px solid #1c1c1c;
    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);
    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);
    text-shadow: none;
    min-height: 19px !important;
    max-height: 19px !important;
}
.black_dropdown .lbl {
    position: relative;
    overflow: hidden;
    height: 17px;
    padding: 4px 0 0 6px;
    margin: 0 19px 0 0;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    color: #c0dabe;
    line-height: 13px;
    border-right: 1px solid #1c1c1c;
    cursor: default;
    white-space: nowrap;
}
.black_dropdown .button {
    width: 19px;
    border-left: 1px solid #4d4c4d;
    bottom: 0;
    position: absolute;
    top: 0;
    right: 0;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-size: 9px 13px;
    background-position: 4px 4px;
}
.black_dropdownOver {
    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);
}
.black_dropdownDown {
    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/dropdown.css"], "names": [], "mappings": "AAAA;IACI,qBAAqB;IACrB,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,kBAAkB;IAClB,yBAAyB;IACzB,mEAAmE;IACnE,iGAAiG;IACjG,iBAAiB;IACjB,2BAA2B;IAC3B,2BAA2B;AAC/B;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,oBAAoB;IACpB,kBAAkB;IAClB,yCAAyC;IACzC,eAAe;IACf,cAAc;IACd,iBAAiB;IACjB,+BAA+B;IAC/B,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,WAAW;IACX,8BAA8B;IAC9B,SAAS;IACT,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,4BAA4B;IAC5B,yDAAmE;IACnE,yBAAyB;IACzB,4BAA4B;AAChC;AACA;IACI,iEAAiE;AACrE;AACA;IACI,mEAAmE;AACvE", "sourcesContent": [".black_dropdown {\n    display: inline-block;\n    position: relative;\n    overflow: hidden;\n    height: 21px;\n    border-radius: 3px;\n    border: 1px solid #1c1c1c;\n    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);\n    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);\n    text-shadow: none;\n    min-height: 19px !important;\n    max-height: 19px !important;\n}\n.black_dropdown .lbl {\n    position: relative;\n    overflow: hidden;\n    height: 17px;\n    padding: 4px 0 0 6px;\n    margin: 0 19px 0 0;\n    font-family: Arial, Helvetica, sans-serif;\n    font-size: 12px;\n    color: #c0dabe;\n    line-height: 13px;\n    border-right: 1px solid #1c1c1c;\n    cursor: default;\n    white-space: nowrap;\n}\n.black_dropdown .button {\n    width: 19px;\n    border-left: 1px solid #4d4c4d;\n    bottom: 0;\n    position: absolute;\n    top: 0;\n    right: 0;\n    background-repeat: no-repeat;\n    background-image: url(../images/dropdown-dark-glossy/button@1x.png);\n    background-size: 9px 13px;\n    background-position: 4px 4px;\n}\n.black_dropdownOver {\n    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);\n}\n.black_dropdownDown {\n    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);\n}"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    0: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `body {
    font-family: Tahoma, sans-serif;
}

body.disableIframe iframe {pointer-events: none;}

.splitter {
    background: var(--splitter-color);
    z-index:10;
    position: absolute;
}

.splitter-h {
    width: 1px;
    cursor: ew-resize;
}

.splitter-v {
    height: 1px;
    cursor: ns-resize;
    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);
}
.splitter-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.splitter-v div {
    margin-top: -2px;
    height: 5px;
}
.splitter-h:hover {

}
.splitter-v:hover {

}
.splitter:hover {

}
.box {
    overflow: hidden;
}

.menuToolBar {
    display: flex;
    height: 30px;
    background: #787878;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}

.findbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}


.fullScreenParent {overflow: visible}
.fullScreenNode {
    position: fixed!important;
    z-index: 1!important;
}
.fullScreenSibling {
    z-index: 0!important;
}


body {
    overflow: hidden!important;
    width: 100%;
    height: 100%;
}

.consoleCloseBtn {
    background-repeat: no-repeat;
    background-size: 22px 66px;
    cursor: pointer;
    padding-right: 5px;
}

div.consoleCloseBtn:hover {
    color: #35cc95;
}

.buttons {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    z-index: 1000;
    padding: 0px;
    position: absolute;
    right: 3px;
    top: 0px;
    height: 24px;
}

.animateBoxes {
    transition-duration: 0.15s;
    transition-property: top, left, width, height, transform;
    transition-timing-function: cubic-bezier(.10, .10, .25, .90);
}


.animateBoxes * {
    transition-duration: inherit;
    transition-property: top, left, width, height, transform;
    transition-timing-function: inherit;
}


.tabPanel {
    background: whitesmoke;
}

.inheritCursor *{
    cursor: inherit;
}

.panelbar {
    background-color: var(--toolbar-background);
    position: absolute;
    box-sizing: border-box;
}
.panelbar.top, .tabbar {
    border-bottom: 1px solid var(--splitter-color);
    box-sizing: border-box;
}
.panelbar.bottom {
    border-top: 1px solid var(--splitter-color);
}

body {
    --toolbar-background: #f3f3f3;
    --splitter-color: #d0d0d0;
    --hover-background: #eaeaea;
}

.spacer {
    flex: 1
}
.panelbar {
    display: flex;
    align-items: center;
    padding: 4px;
}
.panelbar>* {
    margin: 0 4px
}
.panelbar> button {
    padding: 5px;
}
.panelbar> button, .panelbar> input  {
    border: none;
    color: #333
}
.panelbar> *:active,
.panelbar> *:focus {
    outline: 1px solid lightblue;
    outline-offset: 1px
}
.panelbar> button {
    background: transparent;
    color: #0da6ff;
}
.panelbar> button:hover  {
    background: var(--hover-background);
    color: black
}
.panelbar> button[disabled] {
    pointer-events: none;
    color: gray!important;
}

.ace_editor.ace_listBox {
    background: var(--toolbar-background)!important;
    font-family: inherit;
    border: none;
}


.ace_listBox .ace_ {
    margin-left: 1em;
}
.ace_listBox .ace_header {
    font-weight: bold;
    margin-left: 0;
}

iframe {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/layout.css"], "names": [], "mappings": "AAAA;IACI,+BAA+B;AACnC;;AAEA,2BAA2B,oBAAoB,CAAC;;AAEhD;IACI,iCAAiC;IACjC,UAAU;IACV,kBAAkB;AACtB;;AAEA;IACI,UAAU;IACV,iBAAiB;AACrB;;AAEA;IACI,WAAW;IACX,iBAAiB;IACjB,iDAAiD;AACrD;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;;AAGA,mBAAmB,iBAAiB;AACpC;IACI,yBAAyB;IACzB,oBAAoB;AACxB;AACA;IACI,oBAAoB;AACxB;;;AAGA;IACI,0BAA0B;IAC1B,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,4BAA4B;IAC5B,0BAA0B;IAC1B,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,yBAAyB;IACzB,aAAa;IACb,YAAY;IACZ,kBAAkB;IAClB,UAAU;IACV,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,wDAAwD;IACxD,4DAA4D;AAChE;;;AAGA;IACI,4BAA4B;IAC5B,wDAAwD;IACxD,mCAAmC;AACvC;;;AAGA;IACI,sBAAsB;AAC1B;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,2CAA2C;IAC3C,kBAAkB;IAClB,sBAAsB;AAC1B;AACA;IACI,8CAA8C;IAC9C,sBAAsB;AAC1B;AACA;IACI,2CAA2C;AAC/C;;AAEA;IACI,6BAA6B;IAC7B,yBAAyB;IACzB,2BAA2B;AAC/B;;AAEA;IACI;AACJ;AACA;IACI,aAAa;IACb,mBAAmB;IACnB,YAAY;AAChB;AACA;IACI;AACJ;AACA;IACI,YAAY;AAChB;AACA;IACI,YAAY;IACZ;AACJ;AACA;;IAEI,4BAA4B;IAC5B;AACJ;AACA;IACI,uBAAuB;IACvB,cAAc;AAClB;AACA;IACI,mCAAmC;IACnC;AACJ;AACA;IACI,oBAAoB;IACpB,qBAAqB;AACzB;;AAEA;IACI,+CAA+C;IAC/C,oBAAoB;IACpB,YAAY;AAChB;;;AAGA;IACI,gBAAgB;AACpB;AACA;IACI,iBAAiB;IACjB,cAAc;AAClB;;AAEA;IACI,SAAS;IACT,UAAU;IACV,SAAS;IACT,eAAe;IACf,aAAa;IACb,wBAAwB;AAC5B", "sourcesContent": ["body {\n    font-family: Tahoma, sans-serif;\n}\n\nbody.disableIframe iframe {pointer-events: none;}\n\n.splitter {\n    background: var(--splitter-color);\n    z-index:10;\n    position: absolute;\n}\n\n.splitter-h {\n    width: 1px;\n    cursor: ew-resize;\n}\n\n.splitter-v {\n    height: 1px;\n    cursor: ns-resize;\n    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);\n}\n.splitter-h div {\n    margin-left: -2px;\n    width: 5px;\n    height: 100%\n}\n.splitter-v div {\n    margin-top: -2px;\n    height: 5px;\n}\n.splitter-h:hover {\n\n}\n.splitter-v:hover {\n\n}\n.splitter:hover {\n\n}\n.box {\n    overflow: hidden;\n}\n\n.menuToolBar {\n    display: flex;\n    height: 30px;\n    background: #787878;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n\n.findbar {\n    display:flex;\n    height:30px;\n    background: #665a82;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n\n\n.fullScreenParent {overflow: visible}\n.fullScreenNode {\n    position: fixed!important;\n    z-index: 1!important;\n}\n.fullScreenSibling {\n    z-index: 0!important;\n}\n\n\nbody {\n    overflow: hidden!important;\n    width: 100%;\n    height: 100%;\n}\n\n.consoleCloseBtn {\n    background-repeat: no-repeat;\n    background-size: 22px 66px;\n    cursor: pointer;\n    padding-right: 5px;\n}\n\ndiv.consoleCloseBtn:hover {\n    color: #35cc95;\n}\n\n.buttons {\n    display: flex;\n    align-items: center;\n    justify-content: flex-end;\n    z-index: 1000;\n    padding: 0px;\n    position: absolute;\n    right: 3px;\n    top: 0px;\n    height: 24px;\n}\n\n.animateBoxes {\n    transition-duration: 0.15s;\n    transition-property: top, left, width, height, transform;\n    transition-timing-function: cubic-bezier(.10, .10, .25, .90);\n}\n\n\n.animateBoxes * {\n    transition-duration: inherit;\n    transition-property: top, left, width, height, transform;\n    transition-timing-function: inherit;\n}\n\n\n.tabPanel {\n    background: whitesmoke;\n}\n\n.inheritCursor *{\n    cursor: inherit;\n}\n\n.panelbar {\n    background-color: var(--toolbar-background);\n    position: absolute;\n    box-sizing: border-box;\n}\n.panelbar.top, .tabbar {\n    border-bottom: 1px solid var(--splitter-color);\n    box-sizing: border-box;\n}\n.panelbar.bottom {\n    border-top: 1px solid var(--splitter-color);\n}\n\nbody {\n    --toolbar-background: #f3f3f3;\n    --splitter-color: #d0d0d0;\n    --hover-background: #eaeaea;\n}\n\n.spacer {\n    flex: 1\n}\n.panelbar {\n    display: flex;\n    align-items: center;\n    padding: 4px;\n}\n.panelbar>* {\n    margin: 0 4px\n}\n.panelbar> button {\n    padding: 5px;\n}\n.panelbar> button, .panelbar> input  {\n    border: none;\n    color: #333\n}\n.panelbar> *:active,\n.panelbar> *:focus {\n    outline: 1px solid lightblue;\n    outline-offset: 1px\n}\n.panelbar> button {\n    background: transparent;\n    color: #0da6ff;\n}\n.panelbar> button:hover  {\n    background: var(--hover-background);\n    color: black\n}\n.panelbar> button[disabled] {\n    pointer-events: none;\n    color: gray!important;\n}\n\n.ace_editor.ace_listBox {\n    background: var(--toolbar-background)!important;\n    font-family: inherit;\n    border: none;\n}\n\n\n.ace_listBox .ace_ {\n    margin-left: 1em;\n}\n.ace_listBox .ace_header {\n    font-weight: bold;\n    margin-left: 0;\n}\n\niframe {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font-size: 100%;\n    font: inherit;\n    vertical-align: baseline;\n}"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    807: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__22(62);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
                        var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
                          /* asset import */
                          __webpack_require__22(784),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_URL_IMPORT_1___ = new URL(
                          /* asset import */
                          __webpack_require__22(560),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_URL_IMPORT_2___ = new URL(
                          /* asset import */
                          __webpack_require__22(937),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_URL_IMPORT_3___ = new URL(
                          /* asset import */
                          __webpack_require__22(147),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
                        var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
                        var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
                        var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.menuButton {
    height: 100%;
    box-sizing: border-box;
    overflow: visible;
    cursor: default;
    position: relative;
    display: inline-block;
    font-family: Tahoma, Arial;
    font-size: 12px;
    line-height: 14px;
    color: #cecece;
    padding: 4px 7px 0 7px;
    text-shadow: #292a2b 0px 1px 0px;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
}
.menuButtonOver, .menuButton:hover {
    background-color: #333333;
    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    color: #d4d4d4;
}
.menuButton.menuButtonDown {
    font-weight: normal;
    background-color: #494949;
    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    border: 0;
    border-width: 0;
    padding: 4px 7px 0 7px;
    z-index: 100000000;
}
.menuButtonDisabled.menuButton .label {
    color: #999999;
}
.menuButtonIcon {
    padding-left: 24px;
}
.menuButtonIcon .icon {
    display: block;
}
.menuButtonEmpty {
    padding-left: 7px;
}
.menuButtonEmpty .icon {
    left: 0;
    top: 0;
}
.menuButtonDisabled {
    color: gray;
}
.menuButton.btn {
    min-width: 12px;
    font-weight: bold;
    background-position: 2px 50%;
}


.menu {
    margin: -1px 0 0 0;
    padding: 3px 0 3px 0;
    z-index: 10000;
    position: absolute;
    overflow: visible;
    font-family: Tahoma, Arial;
    font-size: 11px;
    line-height: 14px;
    color: #f1f1f1;
    cursor: default;
    display: none;
    border: 1px solid #00040a;
    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);
    background-color: #494949;
    text-shadow: 0px 1px 0px #2c2c2c;
    border-radius: 0;
}
.menu > div.menu_item {
    padding: 3px 16px 5px 23px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}
.menu > div.menu_item.update {
    background-color: #748512;
    font-weight: bold;
    color: #f1f1f1;
    text-shadow: none;
}
.menu > div.menu_item.hover {
    background-color: #262626;
    color: #a0b42a;
}
.menu > div.menu_divider {
    overflow: visible;
    padding: 0;
    font-size: 1px;
    margin: 2px 3px;
    border-top: 1px solid #353535;
    border-bottom: 1px solid #565656;
    height: 0;
}
.menu > div.menu_item > .shortcut {
    right: 15px;
    margin-top: 0px;
    z-index: 10;
    text-align: right;
    padding-left: 15px;
    float: right;
}
.menu > div.submenu > .shortcut {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
    width: 4px;
    height: 7px;
    display: block;
    position: absolute;
    right: 8px;
    margin: 4px 0 0 0;
    z-index: 10;
}
.menu > div.submenu.hover > span {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
}
.menu > div.menu_item.disabled {
    color: #808080;
    text-shadow: none;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.menu > div.menu_item > u {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 3px;
    margin-top: -1px;
}
.menu > div.menu_item > a {
    float: left;
}
.menu > div.menu_item.selected > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.disabled > u {
    opacity: 0.2;
}
.menu > div.menu_item.checked.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}

.menu_searchbox {
    height: auto;
    width: auto;
    border: 1px solid #be1100;
    background-color: #653b13;
    color: white;
    position: absolute;
    font-family: Tahoma, Arial;
    font-size: 12px;
}

.menu-completion-highlight {
    color: #2d69c7;
}
.searchbtn_close {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_3___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}
.searchbtn_close:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.searchbtn_filter {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}

.searchbtn_filter:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.menu_no_result {
    padding: 3px 10px 5px 20px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/menu.css"], "names": [], "mappings": "AAAA;IACI,YAAY;IACZ,sBAAsB;IACtB,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;IACrB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,sBAAsB;IACtB,gCAAgC;IAChC,yBAAyB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,iBAAiB;AAC/F;AACA;IACI,yBAAyB;IACzB,+FAA+F;IAC/F,cAAc;AAClB;AACA;IACI,mBAAmB;IACnB,yBAAyB;IACzB,iGAAiG;IACjG,SAAS;IACT,eAAe;IACf,sBAAsB;IACtB,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,iBAAiB;AACrB;AACA;IACI,OAAO;IACP,MAAM;AACV;AACA;IACI,WAAW;AACf;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,4BAA4B;AAChC;;;AAGA;IACI,kBAAkB;IAClB,oBAAoB;IACpB,cAAc;IACd,kBAAkB;IAClB,iBAAiB;IACjB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,eAAe;IACf,aAAa;IACb,yBAAyB;IACzB,gDAAgD;IAChD,yBAAyB;IACzB,gCAAgC;IAChC,gBAAgB;AACpB;AACA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB;AACA;IACI,yBAAyB;IACzB,iBAAiB;IACjB,cAAc;IACd,iBAAiB;AACrB;AACA;IACI,yBAAyB;IACzB,cAAc;AAClB;AACA;IACI,iBAAiB;IACjB,UAAU;IACV,cAAc;IACd,eAAe;IACf,6BAA6B;IAC7B,gCAAgC;IAChC,SAAS;AACb;AACA;IACI,WAAW;IACX,eAAe;IACf,WAAW;IACX,iBAAiB;IACjB,kBAAkB;IAClB,YAAY;AAChB;AACA;IACI,yEAAoE;IACpE,UAAU;IACV,WAAW;IACX,cAAc;IACd,kBAAkB;IAClB,UAAU;IACV,iBAAiB;IACjB,WAAW;AACf;AACA;IACI,yEAAoE;AACxE;AACA;IACI,cAAc;IACd,iBAAiB;IACjB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,SAAS;IACT,gBAAgB;AACpB;AACA;IACI,WAAW;AACf;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,YAAY;AAChB;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,yBAAyB;IACzB,yBAAyB;IACzB,YAAY;IACZ,kBAAkB;IAClB,0BAA0B;IAC1B,eAAe;AACnB;;AAEA;IACI,cAAc;AAClB;AACA;IACI,mEAA+Q;IAC/Q,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;AACA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,mEAAsD;IACtD,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;;AAEA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB", "sourcesContent": ['.menuButton {\n    height: 100%;\n    box-sizing: border-box;\n    overflow: visible;\n    cursor: default;\n    position: relative;\n    display: inline-block;\n    font-family: Tahoma, Arial;\n    font-size: 12px;\n    line-height: 14px;\n    color: #cecece;\n    padding: 4px 7px 0 7px;\n    text-shadow: #292a2b 0px 1px 0px;\n    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;\n}\n.menuButtonOver, .menuButton:hover {\n    background-color: #333333;\n    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\n    color: #d4d4d4;\n}\n.menuButton.menuButtonDown {\n    font-weight: normal;\n    background-color: #494949;\n    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\n    border: 0;\n    border-width: 0;\n    padding: 4px 7px 0 7px;\n    z-index: 100000000;\n}\n.menuButtonDisabled.menuButton .label {\n    color: #999999;\n}\n.menuButtonIcon {\n    padding-left: 24px;\n}\n.menuButtonIcon .icon {\n    display: block;\n}\n.menuButtonEmpty {\n    padding-left: 7px;\n}\n.menuButtonEmpty .icon {\n    left: 0;\n    top: 0;\n}\n.menuButtonDisabled {\n    color: gray;\n}\n.menuButton.btn {\n    min-width: 12px;\n    font-weight: bold;\n    background-position: 2px 50%;\n}\n\n\n.menu {\n    margin: -1px 0 0 0;\n    padding: 3px 0 3px 0;\n    z-index: 10000;\n    position: absolute;\n    overflow: visible;\n    font-family: Tahoma, Arial;\n    font-size: 11px;\n    line-height: 14px;\n    color: #f1f1f1;\n    cursor: default;\n    display: none;\n    border: 1px solid #00040a;\n    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);\n    background-color: #494949;\n    text-shadow: 0px 1px 0px #2c2c2c;\n    border-radius: 0;\n}\n.menu > div.menu_item {\n    padding: 3px 16px 5px 23px;\n    white-space: nowrap;\n    cursor: default;\n    z-index: 1100000;\n    height: 13px;\n}\n.menu > div.menu_item.update {\n    background-color: #748512;\n    font-weight: bold;\n    color: #f1f1f1;\n    text-shadow: none;\n}\n.menu > div.menu_item.hover {\n    background-color: #262626;\n    color: #a0b42a;\n}\n.menu > div.menu_divider {\n    overflow: visible;\n    padding: 0;\n    font-size: 1px;\n    margin: 2px 3px;\n    border-top: 1px solid #353535;\n    border-bottom: 1px solid #565656;\n    height: 0;\n}\n.menu > div.menu_item > .shortcut {\n    right: 15px;\n    margin-top: 0px;\n    z-index: 10;\n    text-align: right;\n    padding-left: 15px;\n    float: right;\n}\n.menu > div.submenu > .shortcut {\n    background: url("../images/submenu_arrow.gif") no-repeat right -15px;\n    width: 4px;\n    height: 7px;\n    display: block;\n    position: absolute;\n    right: 8px;\n    margin: 4px 0 0 0;\n    z-index: 10;\n}\n.menu > div.submenu.hover > span {\n    background: url("../images/submenu_arrow.gif") no-repeat right -15px;\n}\n.menu > div.menu_item.disabled {\n    color: #808080;\n    text-shadow: none;\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\n}\n.menu > div.menu_item > u {\n    width: 16px;\n    height: 16px;\n    position: absolute;\n    left: 3px;\n    margin-top: -1px;\n}\n.menu > div.menu_item > a {\n    float: left;\n}\n.menu > div.menu_item.selected > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.selected:hover > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.checked > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.checked:hover > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.disabled > u {\n    opacity: 0.2;\n}\n.menu > div.menu_item.checked.disabled > u {\n    background: url("../images/check.gif") no-repeat 0 -16px;\n}\n.menu > div.menu_item.selected.disabled > u {\n    background: url("../images/radio.gif") no-repeat 0 -16px;\n}\n\n.menu_searchbox {\n    height: auto;\n    width: auto;\n    border: 1px solid #be1100;\n    background-color: #653b13;\n    color: white;\n    position: absolute;\n    font-family: Tahoma, Arial;\n    font-size: 12px;\n}\n\n.menu-completion-highlight {\n    color: #2d69c7;\n}\n.searchbtn_close {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\n    border-radius: 50%;\n    border: 0 none;\n    color: #656565;\n    cursor: pointer;\n    font: 16px/16px Arial;\n    padding: 0;\n    height: 14px;\n    width: 14px; \n    display: inline-block;\n}\n.searchbtn_close:hover {\n    background-color: #656565;\n    background-position: 50% 100%;\n    color: white;\n}\n\n.searchbtn_filter {\n    background: url("../images/check.gif") no-repeat 50% 0;\n    border-radius: 50%;\n    border: 0 none;\n    color: #656565;\n    cursor: pointer;\n    font: 16px/16px Arial;\n    padding: 0;\n    height: 14px;\n    width: 14px; \n    display: inline-block;\n}\n\n.searchbtn_filter:hover {\n    background-color: #656565;\n    background-position: 50% 100%;\n    color: white;\n}\n\n.menu_no_result {\n    padding: 3px 10px 5px 20px;\n    white-space: nowrap;\n    cursor: default;\n    z-index: 1100000;\n    height: 13px;\n}'], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    174: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.panelbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}
.panelbar.vertical {
}

.panelbar.vertical .panelButton {
}
.panelbar.vertical.right .panelButton {
}

.panelButton {
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    transition: 0.5s background-color;
    border-left: #b3b3b3 solid 1px;
    user-select: none;
    height: 30px;
    width: 30px;
    position: absolute;
}
.panelButton:hover {
    background: #e0e0e0;
    border-radius: 10px 10px 0 0;
}
.panelButton.selected {
    background-color: #e7e7e7;
}
.panelButton.active {
    background-color: whitesmoke!important;
    border-radius: 10px 10px 0 0;
}
.panelTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
`, "", { "version": 3, "sources": ["webpack://./assets/styles/panel.css"], "names": [], "mappings": "AAAA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;IACI,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,iCAAiC;IACjC,8BAA8B;IAC9B,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,4BAA4B;AAChC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,sCAAsC;IACtC,4BAA4B;AAChC;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB", "sourcesContent": [".panelbar {\n    display:flex;\n    height:30px;\n    background: #665a82;\n    background: #cecece;\n    color: #111;\n    align-items: stretch;\n    justify-content: stretch;\n    overflow: hidden;\n    position: absolute;\n}\n.panelbar.vertical {\n}\n\n.panelbar.vertical .panelButton {\n}\n.panelbar.vertical.right .panelButton {\n}\n\n.panelButton {\n    cursor: default;\n    display:flex;\n    align-items: center;\n    padding: 0 10px;\n    box-sizing: border-box;\n    transition: 0.5s background-color;\n    border-left: #b3b3b3 solid 1px;\n    user-select: none;\n    height: 30px;\n    width: 30px;\n    position: absolute;\n}\n.panelButton:hover {\n    background: #e0e0e0;\n    border-radius: 10px 10px 0 0;\n}\n.panelButton.selected {\n    background-color: #e7e7e7;\n}\n.panelButton.active {\n    background-color: whitesmoke!important;\n    border-radius: 10px 10px 0 0;\n}\n.panelTitle {\n    flex: 1;\n    padding: 0 2px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n"], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    915: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__22(62);
                        var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
                        var ___CSS_LOADER_URL_IMPORT_0___ = new URL(
                          /* asset import */
                          __webpack_require__22(553),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_URL_IMPORT_1___ = new URL(
                          /* asset import */
                          __webpack_require__22(592),
                          __webpack_require__22.b
                        );
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
                        var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.cboffline {
    width: 55px;
    height: 21px;
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat 0 -21px;
    display: inline-block;
}
.cbofflineDown {
    background-position: 0 0px;
}
.cbofflineChecked {
    background-position: 0 0px;
}

.checkbox {
    display: inline-block;
    width: 16px;
    height: 17px;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
    background-size: 16px 136px;
    background-position: 0 0;
}

.checkboxOver {
    background-position: 0 -17px;
}

.checkboxDown {
    background-position: 0 -34px;
}

.checkboxChecked {
    background-position: 0 -51px;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/switcher.css"], "names": [], "mappings": "AAAA;IACI,WAAW;IACX,YAAY;IACZ,qEAAuD;IACvD,qBAAqB;AACzB;AACA;IACI,0BAA0B;AAC9B;AACA;IACI,0BAA0B;AAC9B;;AAEA;IACI,qBAAqB;IACrB,WAAW;IACX,YAAY;IACZ,4BAA4B;IAC5B,yDAAwD;IACxD,2BAA2B;IAC3B,wBAAwB;AAC5B;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC", "sourcesContent": ['.cboffline {\n    width: 55px;\n    height: 21px;\n    background: url("../images/sync.png") no-repeat 0 -21px;\n    display: inline-block;\n}\n.cbofflineDown {\n    background-position: 0 0px;\n}\n.cbofflineChecked {\n    background-position: 0 0px;\n}\n\n.checkbox {\n    display: inline-block;\n    width: 16px;\n    height: 17px;\n    background-repeat: no-repeat;\n    background-image: url("../images/checkbox_black@1x.png");\n    background-size: 16px 136px;\n    background-position: 0 0;\n}\n\n.checkboxOver {\n    background-position: 0 -17px;\n}\n\n.checkboxDown {\n    background-position: 0 -34px;\n}\n\n.checkboxChecked {\n    background-position: 0 -51px;\n}'], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    129: (
                      /***/
                      (module22, __webpack_exports__2, __webpack_require__22) => {
                        "use strict";
                        __webpack_require__22.d(__webpack_exports__2, {
                          /* harmony export */
                          A: () => __WEBPACK_DEFAULT_EXPORT__
                          /* harmony export */
                        });
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__22(1);
                        var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__22(935);
                        var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__22.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
                        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
                        ___CSS_LOADER_EXPORT___.push([module22.id, `.tabContainer {
    align-items: stretch;
    height: 30px;
}

.tabPlusButton {
    --color: #ababab;
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 8px;
    color: transparent;
}
.tabPlusButton:after {
    content: "";
    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);
        position: absolute;
    width: 12px;
    height: 12px;
    top: 8px;
}
.tabPlusButton:hover:after {
    --color: #35cc95

}

.tabPlusButton:active {
    color: darkgreen
}

.tabScroller {
    overflow: hidden;
    position: relative;
}
.tab.changed>.tabCloseButton {
    background: #afafaf;
    border: transparent;
}

.tabbar {
    display:flex;
    background: var(--toolbar-background);
    color: #333;
    align-items: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
}
.tab {
    font-size: 12px;
    height: 100%;
    /*min-width: 100px;*/
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    background: var(--toolbar-background);
    border-left: transparent solid 1px;
    border-right: transparent solid 1px;
    user-select: none;
    position: absolute;
}

.tab.selected.active:after {
    content: "";
    border-bottom: 2px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}
.tab.focused.active:after {
    content: "";
    border-bottom: 3px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}

.tab.scrolledLeft {
    border-color: var(--splitter-color);
    box-shadow: 0px 0px 2px 0px #d0d0d0;
}
.tabIcon {
    display: none;
}

.tabLeftOverflow {

}
.tabRightOverflow {

}
.tabDragging {
    display: flex;
    box-sizing: border-box;
    transition: 0.5s background-color;
    user-select: none;
    z-index: 100000;
    pointer-events: none;
    position: absolute;
}

.tab:hover {
    background: var(--hover-background);
}
.tab.selected {
    background-color: #e7e7e7;
}
.tab.active {
    background-color: whitesmoke;
}
 .tabDragging > .tab.active {
    background-color: #e7e7e7;
}

.tabCloseButton {
    transform: rotate(45deg);
    width: 11px;
    height: 11px;
    display: inline-block;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0;
    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);
}


.tabCloseButton:hover {
    background-color: #ababab;
    border: 1px solid #ababab;
    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);

}

.tab.active .tabCloseButton,
.tab:hover .tabCloseButton,
.tabCloseButton.changed {
    opacity: 1
}

.tabIcon {
    color: yellow;
    padding: 0 4px 0 0;
}
.tab.active .tabIcon {
    color: orange
}
.tabTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}



.tabbar.vertical .tab {
    transform: rotate(180deg);
}


.split-area {
    position: absolute;
    background: rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0, 0, 0, 0.2);
    z-index: 100000;
    pointer-events: none;
    box-sizing: border-box;
    cursor: default;
}

.dark.split-area {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;
    outline: 1px solid black;
}

.tab-editor {
    position: absolute;
}`, "", { "version": 3, "sources": ["webpack://./assets/styles/tab.css"], "names": [], "mappings": "AAAA;IACI,oBAAoB;IACpB,YAAY;AAChB;;AAEA;IACI,gBAAgB;IAChB,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,YAAY;IACZ,kBAAkB;AACtB;AACA;IACI,WAAW;IACX;uGACmG;QAC/F,kBAAkB;IACtB,WAAW;IACX,YAAY;IACZ,QAAQ;AACZ;AACA;IACI;;AAEJ;;AAEA;IACI;AACJ;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,mBAAmB;AACvB;;AAEA;IACI,YAAY;IACZ,qCAAqC;IACrC,WAAW;IACX,oBAAoB;IACpB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,YAAY;IACZ,oBAAoB;IACpB,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,qCAAqC;IACrC,kCAAkC;IAClC,mCAAmC;IACnC,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;AACA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;IACnC,mCAAmC;AACvC;AACA;IACI,aAAa;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;IACI,aAAa;IACb,sBAAsB;IACtB,iCAAiC;IACjC,iBAAiB;IACjB,eAAe;IACf,oBAAoB;IACpB,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;AACvC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,4BAA4B;AAChC;CACC;IACG,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;IACxB,WAAW;IACX,YAAY;IACZ,qBAAqB;IACrB,mBAAmB;IACnB,eAAe;IACf,UAAU;IACV;6FACyF;AAC7F;;;AAGA;IACI,yBAAyB;IACzB,yBAAyB;IACzB;uFACmF;;AAEvF;;AAEA;;;IAGI;AACJ;;AAEA;IACI,aAAa;IACb,kBAAkB;AACtB;AACA;IACI;AACJ;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;;;AAIA;IACI,yBAAyB;AAC7B;;;AAGA;IACI,kBAAkB;IAClB,+BAA+B;IAC/B,oCAAoC;IACpC,eAAe;IACf,oBAAoB;IACpB,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,qCAAqC;IACrC,0CAA0C;IAC1C,qDAAqD;IACrD,wBAAwB;AAC5B;;AAEA;IACI,kBAAkB;AACtB", "sourcesContent": ['.tabContainer {\n    align-items: stretch;\n    height: 30px;\n}\n\n.tabPlusButton {\n    --color: #ababab;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    padding: 8px;\n    color: transparent;\n}\n.tabPlusButton:after {\n    content: "";\n    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);\n        position: absolute;\n    width: 12px;\n    height: 12px;\n    top: 8px;\n}\n.tabPlusButton:hover:after {\n    --color: #35cc95\n\n}\n\n.tabPlusButton:active {\n    color: darkgreen\n}\n\n.tabScroller {\n    overflow: hidden;\n    position: relative;\n}\n.tab.changed>.tabCloseButton {\n    background: #afafaf;\n    border: transparent;\n}\n\n.tabbar {\n    display:flex;\n    background: var(--toolbar-background);\n    color: #333;\n    align-items: stretch;\n    overflow: hidden;\n    position: absolute;\n    user-select: none;\n}\n.tab {\n    font-size: 12px;\n    height: 100%;\n    /*min-width: 100px;*/\n    cursor: default;\n    display:flex;\n    align-items: center;\n    padding: 0 10px;\n    box-sizing: border-box;\n    background: var(--toolbar-background);\n    border-left: transparent solid 1px;\n    border-right: transparent solid 1px;\n    user-select: none;\n    position: absolute;\n}\n\n.tab.selected.active:after {\n    content: "";\n    border-bottom: 2px solid rgb(127, 127, 191);\n    width: calc(100% - 22px);\n    bottom: 0;\n    position: absolute;\n}\n.tab.focused.active:after {\n    content: "";\n    border-bottom: 3px solid rgb(127, 127, 191);\n    width: calc(100% - 22px);\n    bottom: 0;\n    position: absolute;\n}\n\n.tab.scrolledLeft {\n    border-color: var(--splitter-color);\n    box-shadow: 0px 0px 2px 0px #d0d0d0;\n}\n.tabIcon {\n    display: none;\n}\n\n.tabLeftOverflow {\n\n}\n.tabRightOverflow {\n\n}\n.tabDragging {\n    display: flex;\n    box-sizing: border-box;\n    transition: 0.5s background-color;\n    user-select: none;\n    z-index: 100000;\n    pointer-events: none;\n    position: absolute;\n}\n\n.tab:hover {\n    background: var(--hover-background);\n}\n.tab.selected {\n    background-color: #e7e7e7;\n}\n.tab.active {\n    background-color: whitesmoke;\n}\n .tabDragging > .tab.active {\n    background-color: #e7e7e7;\n}\n\n.tabCloseButton {\n    transform: rotate(45deg);\n    width: 11px;\n    height: 11px;\n    display: inline-block;\n    border-radius: 10px;\n    cursor: pointer;\n    opacity: 0;\n    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);\n}\n\n\n.tabCloseButton:hover {\n    background-color: #ababab;\n    border: 1px solid #ababab;\n    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),\n        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);\n\n}\n\n.tab.active .tabCloseButton,\n.tab:hover .tabCloseButton,\n.tabCloseButton.changed {\n    opacity: 1\n}\n\n.tabIcon {\n    color: yellow;\n    padding: 0 4px 0 0;\n}\n.tab.active .tabIcon {\n    color: orange\n}\n.tabTitle {\n    flex: 1;\n    padding: 0 2px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n\n\n.tabbar.vertical .tab {\n    transform: rotate(180deg);\n}\n\n\n.split-area {\n    position: absolute;\n    background: rgba(0, 0, 0, 0.05);\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    z-index: 100000;\n    pointer-events: none;\n    box-sizing: border-box;\n    cursor: default;\n}\n\n.dark.split-area {\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid rgba(255, 255, 255, 0.3);\n    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;\n    outline: 1px solid black;\n}\n\n.tab-editor {\n    position: absolute;\n}'], "sourceRoot": "" }]);
                        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
                      }
                    ),
                    /***/
                    935: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = function(cssWithMappingToString) {
                          var list = [];
                          list.toString = function toString() {
                            return this.map(function(item) {
                              var content = "";
                              var needLayer = typeof item[5] !== "undefined";
                              if (item[4]) {
                                content += "@supports (".concat(item[4], ") {");
                              }
                              if (item[2]) {
                                content += "@media ".concat(item[2], " {");
                              }
                              if (needLayer) {
                                content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
                              }
                              content += cssWithMappingToString(item);
                              if (needLayer) {
                                content += "}";
                              }
                              if (item[2]) {
                                content += "}";
                              }
                              if (item[4]) {
                                content += "}";
                              }
                              return content;
                            }).join("");
                          };
                          list.i = function i(modules, media, dedupe, supports, layer) {
                            if (typeof modules === "string") {
                              modules = [[null, modules, void 0]];
                            }
                            var alreadyImportedModules = {};
                            if (dedupe) {
                              for (var k = 0; k < this.length; k++) {
                                var id = this[k][0];
                                if (id != null) {
                                  alreadyImportedModules[id] = true;
                                }
                              }
                            }
                            for (var _k = 0; _k < modules.length; _k++) {
                              var item = [].concat(modules[_k]);
                              if (dedupe && alreadyImportedModules[item[0]]) {
                                continue;
                              }
                              if (typeof layer !== "undefined") {
                                if (typeof item[5] === "undefined") {
                                  item[5] = layer;
                                } else {
                                  item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
                                  item[5] = layer;
                                }
                              }
                              if (media) {
                                if (!item[2]) {
                                  item[2] = media;
                                } else {
                                  item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
                                  item[2] = media;
                                }
                              }
                              if (supports) {
                                if (!item[4]) {
                                  item[4] = "".concat(supports);
                                } else {
                                  item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
                                  item[4] = supports;
                                }
                              }
                              list.push(item);
                            }
                          };
                          return list;
                        };
                      }
                    ),
                    /***/
                    62: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = function(url, options) {
                          if (!options) {
                            options = {};
                          }
                          if (!url) {
                            return url;
                          }
                          url = String(url.__esModule ? url.default : url);
                          if (/^['"].*['"]$/.test(url)) {
                            url = url.slice(1, -1);
                          }
                          if (options.hash) {
                            url += options.hash;
                          }
                          if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
                            return '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"');
                          }
                          return url;
                        };
                      }
                    ),
                    /***/
                    1: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = function(item) {
                          var content = item[1];
                          var cssMapping = item[3];
                          if (!cssMapping) {
                            return content;
                          }
                          if (typeof btoa === "function") {
                            var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
                            var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
                            var sourceMapping = "/*# ".concat(data, " */");
                            return [content].concat([sourceMapping]).join("\n");
                          }
                          return [content].join("\n");
                        };
                      }
                    ),
                    /***/
                    532: (
                      /***/
                      function(module22) {
                        (function webpackUniversalModuleDefinition2(root, factory) {
                          if (true)
                            module22.exports = factory();
                          else { var i, a; }
                        })(this, () => {
                          return (
                            /******/
                            (() => {
                              var __webpack_modules__22 = {
                                /***/
                                217: (
                                  /***/
                                  (module222) => {
                                    "use strict";
                                    var $cancelT;
                                    module222.exports = {
                                      lineMode: false,
                                      pasteCancelled: function() {
                                        if ($cancelT && $cancelT > Date.now() - 50)
                                          return true;
                                        return $cancelT = false;
                                      },
                                      cancel: function() {
                                        $cancelT = Date.now();
                                      }
                                    };
                                  }
                                ),
                                /***/
                                379: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var oop = __webpack_require__22(645);
                                    var MultiHashHandler = __webpack_require__22(50).O;
                                    var EventEmitter = __webpack_require__22(366).b;
                                    var CommandManager = function(platform, commands) {
                                      MultiHashHandler.call(this, commands, platform);
                                      this.byName = this.commands;
                                      this.setDefaultHandler("exec", function(e) {
                                        if (!e.args) {
                                          return e.command.exec(e.editor, {}, e.event, true);
                                        }
                                        return e.command.exec(e.editor, e.args, e.event, false);
                                      });
                                    };
                                    oop.inherits(CommandManager, MultiHashHandler);
                                    (function() {
                                      oop.implement(this, EventEmitter);
                                      this.exec = function(command, editor, args) {
                                        if (Array.isArray(command)) {
                                          for (var i = command.length; i--; ) {
                                            if (this.exec(command[i], editor, args))
                                              return true;
                                          }
                                          return false;
                                        }
                                        if (typeof command === "string")
                                          command = this.commands[command];
                                        if (!command)
                                          return false;
                                        if (editor && editor.$readOnly && !command.readOnly)
                                          return false;
                                        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
                                          return false;
                                        var e = { editor, command, args };
                                        e.returnValue = this._emit("exec", e);
                                        this._signal("afterExec", e);
                                        return e.returnValue === false ? false : true;
                                      };
                                      this.toggleRecording = function(editor) {
                                        if (this.$inReplay)
                                          return;
                                        editor && editor._emit("changeStatus");
                                        if (this.recording) {
                                          this.macro.pop();
                                          this.off("exec", this.$addCommandToMacro);
                                          if (!this.macro.length)
                                            this.macro = this.oldMacro;
                                          return this.recording = false;
                                        }
                                        if (!this.$addCommandToMacro) {
                                          this.$addCommandToMacro = function(e) {
                                            this.macro.push([e.command, e.args]);
                                          }.bind(this);
                                        }
                                        this.oldMacro = this.macro;
                                        this.macro = [];
                                        this.on("exec", this.$addCommandToMacro);
                                        return this.recording = true;
                                      };
                                      this.replay = function(editor) {
                                        if (this.$inReplay || !this.macro)
                                          return;
                                        if (this.recording)
                                          return this.toggleRecording(editor);
                                        try {
                                          this.$inReplay = true;
                                          this.macro.forEach(function(x) {
                                            if (typeof x == "string")
                                              this.exec(x, editor);
                                            else
                                              this.exec(x[0], editor, x[1]);
                                          }, this);
                                        } finally {
                                          this.$inReplay = false;
                                        }
                                      };
                                      this.trimMacro = function(m) {
                                        return m.map(function(x) {
                                          if (typeof x[0] != "string")
                                            x[0] = x[0].name;
                                          if (!x[1])
                                            x = x[0];
                                          return x;
                                        });
                                      };
                                    }).call(CommandManager.prototype);
                                    exports2.F = CommandManager;
                                  }
                                ),
                                /***/
                                50: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var __webpack_unused_export__;
                                    var keyUtil = __webpack_require__22(451);
                                    var useragent = __webpack_require__22(943);
                                    var KEY_MODS = keyUtil.KEY_MODS;
                                    function HashHandler(config, platform) {
                                      this.platform = platform || (useragent.isMac ? "mac" : "win");
                                      this.commands = {};
                                      this.commandKeyBinding = {};
                                      this.addCommands(config);
                                      this.$singleCommand = true;
                                    }
                                    function MultiHashHandler(config, platform) {
                                      HashHandler.call(this, config, platform);
                                      this.$singleCommand = false;
                                    }
                                    MultiHashHandler.prototype = HashHandler.prototype;
                                    (function() {
                                      this.addCommand = function(command) {
                                        if (this.commands[command.name])
                                          this.removeCommand(command);
                                        this.commands[command.name] = command;
                                        if (command.bindKey)
                                          this._buildKeyHash(command);
                                      };
                                      this.removeCommand = function(command, keepCommand) {
                                        var name = command && (typeof command === "string" ? command : command.name);
                                        command = this.commands[name];
                                        if (!keepCommand)
                                          delete this.commands[name];
                                        var ckb = this.commandKeyBinding;
                                        for (var keyId in ckb) {
                                          var cmdGroup = ckb[keyId];
                                          if (cmdGroup == command) {
                                            delete ckb[keyId];
                                          } else if (Array.isArray(cmdGroup)) {
                                            var i = cmdGroup.indexOf(command);
                                            if (i != -1) {
                                              cmdGroup.splice(i, 1);
                                              if (cmdGroup.length == 1)
                                                ckb[keyId] = cmdGroup[0];
                                            }
                                          }
                                        }
                                      };
                                      this.bindKey = function(key, command, position) {
                                        if (typeof key == "object" && key) {
                                          if (position == void 0)
                                            position = key.position;
                                          key = key[this.platform];
                                        }
                                        if (!key)
                                          return;
                                        if (typeof command == "function")
                                          return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
                                        key.split("|").forEach(function(keyPart) {
                                          var chain = "";
                                          if (keyPart.indexOf(" ") != -1) {
                                            var parts = keyPart.split(/\s+/);
                                            keyPart = parts.pop();
                                            parts.forEach(function(keyPart2) {
                                              var binding2 = this.parseKeys(keyPart2);
                                              var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                                              chain += (chain ? " " : "") + id2;
                                              this._addCommandToBinding(chain, "chainKeys");
                                            }, this);
                                            chain += " ";
                                          }
                                          var binding = this.parseKeys(keyPart);
                                          var id = KEY_MODS[binding.hashId] + binding.key;
                                          this._addCommandToBinding(chain + id, command, position);
                                        }, this);
                                      };
                                      function getPosition(command) {
                                        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
                                      }
                                      this._addCommandToBinding = function(keyId, command, position) {
                                        var ckb = this.commandKeyBinding, i;
                                        if (!command) {
                                          delete ckb[keyId];
                                        } else if (!ckb[keyId] || this.$singleCommand) {
                                          ckb[keyId] = command;
                                        } else {
                                          if (!Array.isArray(ckb[keyId])) {
                                            ckb[keyId] = [ckb[keyId]];
                                          } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                                            ckb[keyId].splice(i, 1);
                                          }
                                          if (typeof position != "number") {
                                            position = getPosition(command);
                                          }
                                          var commands = ckb[keyId];
                                          for (i = 0; i < commands.length; i++) {
                                            var other = commands[i];
                                            var otherPos = getPosition(other);
                                            if (otherPos > position)
                                              break;
                                          }
                                          commands.splice(i, 0, command);
                                        }
                                      };
                                      this.addCommands = function(commands) {
                                        commands && Object.keys(commands).forEach(function(name) {
                                          var command = commands[name];
                                          if (!command)
                                            return;
                                          if (typeof command === "string")
                                            return this.bindKey(command, name);
                                          if (typeof command === "function")
                                            command = { exec: command };
                                          if (typeof command !== "object")
                                            return;
                                          if (!command.name)
                                            command.name = name;
                                          this.addCommand(command);
                                        }, this);
                                      };
                                      this.removeCommands = function(commands) {
                                        Object.keys(commands).forEach(function(name) {
                                          this.removeCommand(commands[name]);
                                        }, this);
                                      };
                                      this.bindKeys = function(keyList) {
                                        Object.keys(keyList).forEach(function(key) {
                                          this.bindKey(key, keyList[key]);
                                        }, this);
                                      };
                                      this._buildKeyHash = function(command) {
                                        this.bindKey(command.bindKey, command);
                                      };
                                      this.parseKeys = function(keys) {
                                        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
                                          return x;
                                        });
                                        var key = parts.pop();
                                        var keyCode = keyUtil[key];
                                        if (keyUtil.FUNCTION_KEYS[keyCode])
                                          key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
                                        else if (!parts.length)
                                          return { key, hashId: -1 };
                                        else if (parts.length == 1 && parts[0] == "shift")
                                          return { key: key.toUpperCase(), hashId: -1 };
                                        var hashId = 0;
                                        for (var i = parts.length; i--; ) {
                                          var modifier = keyUtil.KEY_MODS[parts[i]];
                                          if (modifier == null) {
                                            if (typeof console != "undefined")
                                              console.error("invalid modifier " + parts[i] + " in " + keys);
                                            return false;
                                          }
                                          hashId |= modifier;
                                        }
                                        return { key, hashId };
                                      };
                                      this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                                        var key = KEY_MODS[hashId] + keyString;
                                        return this.commandKeyBinding[key];
                                      };
                                      this.handleKeyboard = function(data, hashId, keyString, keyCode) {
                                        if (keyCode < 0)
                                          return;
                                        var key = KEY_MODS[hashId] + keyString;
                                        var command = this.commandKeyBinding[key];
                                        if (data.$keyChain) {
                                          data.$keyChain += " " + key;
                                          command = this.commandKeyBinding[data.$keyChain] || command;
                                        }
                                        if (command) {
                                          if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                                            data.$keyChain = data.$keyChain || key;
                                            return { command: "null" };
                                          }
                                        }
                                        if (data.$keyChain) {
                                          if ((!hashId || hashId == 4) && keyString.length == 1)
                                            data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
                                          else if (hashId == -1 || keyCode > 0)
                                            data.$keyChain = "";
                                        }
                                        return { command };
                                      };
                                      this.getStatusText = function(editor, data) {
                                        return data.$keyChain || "";
                                      };
                                    }).call(HashHandler.prototype);
                                    __webpack_unused_export__ = HashHandler;
                                    exports2.O = MultiHashHandler;
                                  }
                                ),
                                /***/
                                957: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var keyUtil = __webpack_require__22(451);
                                    var event = __webpack_require__22(631);
                                    var KeyBinding = function(editor) {
                                      this.$editor = editor;
                                      this.$data = { editor };
                                      this.$handlers = [];
                                      this.setDefaultHandler(editor.commands);
                                    };
                                    (function() {
                                      this.setDefaultHandler = function(kb) {
                                        this.removeKeyboardHandler(this.$defaultHandler);
                                        this.$defaultHandler = kb;
                                        this.addKeyboardHandler(kb, 0);
                                      };
                                      this.setKeyboardHandler = function(kb) {
                                        var h = this.$handlers;
                                        if (h[h.length - 1] == kb)
                                          return;
                                        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                                          this.removeKeyboardHandler(h[h.length - 1]);
                                        this.addKeyboardHandler(kb, 1);
                                      };
                                      this.addKeyboardHandler = function(kb, pos) {
                                        if (!kb)
                                          return;
                                        if (typeof kb == "function" && !kb.handleKeyboard)
                                          kb.handleKeyboard = kb;
                                        var i = this.$handlers.indexOf(kb);
                                        if (i != -1)
                                          this.$handlers.splice(i, 1);
                                        if (pos == void 0)
                                          this.$handlers.push(kb);
                                        else
                                          this.$handlers.splice(pos, 0, kb);
                                        if (i == -1 && kb.attach)
                                          kb.attach(this.$editor);
                                      };
                                      this.removeKeyboardHandler = function(kb) {
                                        var i = this.$handlers.indexOf(kb);
                                        if (i == -1)
                                          return false;
                                        this.$handlers.splice(i, 1);
                                        kb.detach && kb.detach(this.$editor);
                                        return true;
                                      };
                                      this.getKeyboardHandler = function() {
                                        return this.$handlers[this.$handlers.length - 1];
                                      };
                                      this.getStatusText = function() {
                                        var data = this.$data;
                                        var editor = data.editor;
                                        return this.$handlers.map(function(h) {
                                          return h.getStatusText && h.getStatusText(editor, data) || "";
                                        }).filter(Boolean).join(" ");
                                      };
                                      this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
                                        var toExecute;
                                        var success = false;
                                        var commands = this.$editor.commands;
                                        for (var i = this.$handlers.length; i--; ) {
                                          toExecute = this.$handlers[i].handleKeyboard(
                                            this.$data,
                                            hashId,
                                            keyString,
                                            keyCode,
                                            e
                                          );
                                          if (!toExecute || !toExecute.command)
                                            continue;
                                          if (toExecute.command == "null") {
                                            success = true;
                                          } else {
                                            success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                                          }
                                          if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                                            event.stopEvent(e);
                                          }
                                          if (success)
                                            break;
                                        }
                                        if (!success && hashId == -1) {
                                          toExecute = { command: "insertstring" };
                                          success = commands.exec("insertstring", this.$editor, keyString);
                                        }
                                        if (success && this.$editor._signal)
                                          this.$editor._signal("keyboardActivity", toExecute);
                                        return success;
                                      };
                                      this.onCommandKey = function(e, hashId, keyCode) {
                                        var keyString = keyUtil.keyCodeToString(keyCode);
                                        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                                      };
                                      this.onTextInput = function(text) {
                                        return this.$callKeyboardHandlers(-1, text);
                                      };
                                    }).call(KeyBinding.prototype);
                                    exports2.$ = KeyBinding;
                                  }
                                ),
                                /***/
                                984: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var __webpack_unused_export__;
                                    var event = __webpack_require__22(631);
                                    var useragent = __webpack_require__22(943);
                                    var dom = __webpack_require__22(435);
                                    var lang = __webpack_require__22(955);
                                    var clipboard = __webpack_require__22(217);
                                    var BROKEN_SETDATA = useragent.isChrome < 18;
                                    var USE_IE_MIME_TYPE = useragent.isIE;
                                    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
                                    var MAX_LINE_LENGTH = 400;
                                    var KEYS = __webpack_require__22(451);
                                    var MODS = KEYS.KEY_MODS;
                                    var isIOS = useragent.isIOS;
                                    var valueResetRegex = isIOS ? /\s/ : /\n/;
                                    var isMobile = useragent.isMobile;
                                    var TextInput = function(parentNode, host) {
                                      var text = dom.createElement("textarea");
                                      text.className = "ace_text-input";
                                      text.setAttribute("wrap", "off");
                                      text.setAttribute("autocorrect", "off");
                                      text.setAttribute("autocapitalize", "off");
                                      text.setAttribute("spellcheck", false);
                                      text.style.opacity = "0";
                                      parentNode.insertBefore(text, parentNode.firstChild);
                                      var copied = false;
                                      var pasted = false;
                                      var inComposition = false;
                                      var sendingText = false;
                                      var tempStyle = "";
                                      if (!isMobile)
                                        text.style.fontSize = "1px";
                                      var commandMode = false;
                                      var ignoreFocusEvents = false;
                                      var lastValue = "";
                                      var lastSelectionStart = 0;
                                      var lastSelectionEnd = 0;
                                      var lastRestoreEnd = 0;
                                      try {
                                        var isFocused = document.activeElement === text;
                                      } catch (e) {
                                      }
                                      this.setAriaOptions = function(options) {
                                        if (options.activeDescendant) {
                                          text.setAttribute("aria-haspopup", "true");
                                          text.setAttribute("aria-autocomplete", "list");
                                          text.setAttribute("aria-activedescendant", options.activeDescendant);
                                        } else {
                                          text.setAttribute("aria-haspopup", "false");
                                          text.setAttribute("aria-autocomplete", "both");
                                          text.removeAttribute("aria-activedescendant");
                                        }
                                        if (options.role) {
                                          text.setAttribute("role", options.role);
                                        }
                                      };
                                      this.setAriaOptions({ role: "textbox" });
                                      event.addListener(text, "blur", function(e) {
                                        if (ignoreFocusEvents)
                                          return;
                                        host.onBlur(e);
                                        isFocused = false;
                                      }, host);
                                      event.addListener(text, "focus", function(e) {
                                        if (ignoreFocusEvents)
                                          return;
                                        isFocused = true;
                                        if (useragent.isEdge) {
                                          try {
                                            if (!document.hasFocus())
                                              return;
                                          } catch (e2) {
                                          }
                                        }
                                        host.onFocus(e);
                                        if (useragent.isEdge)
                                          setTimeout(resetSelection);
                                        else
                                          resetSelection();
                                      }, host);
                                      this.$focusScroll = false;
                                      this.focus = function() {
                                        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
                                          return text.focus({ preventScroll: true });
                                        var top = text.style.top;
                                        text.style.position = "fixed";
                                        text.style.top = "0px";
                                        try {
                                          var isTransformed = text.getBoundingClientRect().top != 0;
                                        } catch (e) {
                                          return;
                                        }
                                        var ancestors = [];
                                        if (isTransformed) {
                                          var t = text.parentElement;
                                          while (t && t.nodeType == 1) {
                                            ancestors.push(t);
                                            t.setAttribute("ace_nocontext", true);
                                            if (!t.parentElement && t.getRootNode)
                                              t = t.getRootNode().host;
                                            else
                                              t = t.parentElement;
                                          }
                                        }
                                        text.focus({ preventScroll: true });
                                        if (isTransformed) {
                                          ancestors.forEach(function(p) {
                                            p.removeAttribute("ace_nocontext");
                                          });
                                        }
                                        setTimeout(function() {
                                          text.style.position = "";
                                          if (text.style.top == "0px")
                                            text.style.top = top;
                                        }, 0);
                                      };
                                      this.blur = function() {
                                        text.blur();
                                      };
                                      this.isFocused = function() {
                                        return isFocused;
                                      };
                                      host.on("beforeEndOperation", function() {
                                        var curOp = host.curOp;
                                        var commandName = curOp && curOp.command && curOp.command.name;
                                        if (commandName == "insertstring")
                                          return;
                                        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
                                        if (inComposition && isUserAction) {
                                          lastValue = text.value = "";
                                          onCompositionEnd();
                                        }
                                        resetSelection();
                                      });
                                      var resetSelection = isIOS ? function(value) {
                                        if (!isFocused || copied && !value || sendingText)
                                          return;
                                        if (!value)
                                          value = "";
                                        var newValue = "\n ab" + value + "cde fg\n";
                                        if (newValue != text.value)
                                          text.value = lastValue = newValue;
                                        var selectionStart = 4;
                                        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
                                        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                                          text.setSelectionRange(selectionStart, selectionEnd);
                                        }
                                        lastSelectionStart = selectionStart;
                                        lastSelectionEnd = selectionEnd;
                                      } : function() {
                                        if (inComposition || sendingText)
                                          return;
                                        if (!isFocused && !afterContextMenu)
                                          return;
                                        inComposition = true;
                                        var selectionStart = 0;
                                        var selectionEnd = 0;
                                        var line = "";
                                        if (host.session) {
                                          var selection = host.selection;
                                          var range = selection.getRange();
                                          var row = selection.cursor.row;
                                          selectionStart = range.start.column;
                                          selectionEnd = range.end.column;
                                          line = host.session.getLine(row);
                                          if (range.start.row != row) {
                                            var prevLine = host.session.getLine(row - 1);
                                            selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                                            selectionEnd += prevLine.length + 1;
                                            line = prevLine + "\n" + line;
                                          } else if (range.end.row != row) {
                                            var nextLine = host.session.getLine(row + 1);
                                            selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
                                            selectionEnd += line.length + 1;
                                            line = line + "\n" + nextLine;
                                          } else if (isMobile && row > 0) {
                                            line = "\n" + line;
                                            selectionEnd += 1;
                                            selectionStart += 1;
                                          }
                                          if (line.length > MAX_LINE_LENGTH) {
                                            if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                                              line = line.slice(0, MAX_LINE_LENGTH);
                                            } else {
                                              line = "\n";
                                              if (selectionStart == selectionEnd) {
                                                selectionStart = selectionEnd = 0;
                                              } else {
                                                selectionStart = 0;
                                                selectionEnd = 1;
                                              }
                                            }
                                          }
                                        }
                                        var newValue = line + "\n\n";
                                        if (newValue != lastValue) {
                                          text.value = lastValue = newValue;
                                          lastSelectionStart = lastSelectionEnd = newValue.length;
                                        }
                                        if (afterContextMenu) {
                                          lastSelectionStart = text.selectionStart;
                                          lastSelectionEnd = text.selectionEnd;
                                        }
                                        if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
                                          try {
                                            text.setSelectionRange(selectionStart, selectionEnd);
                                            lastSelectionStart = selectionStart;
                                            lastSelectionEnd = selectionEnd;
                                          } catch (e) {
                                          }
                                        }
                                        inComposition = false;
                                      };
                                      this.resetSelection = resetSelection;
                                      if (isFocused)
                                        host.onFocus();
                                      var isAllSelected = function(text2) {
                                        return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
                                      };
                                      var onSelect = function(e) {
                                        if (inComposition)
                                          return;
                                        if (copied) {
                                          copied = false;
                                        } else if (isAllSelected(text)) {
                                          host.selectAll();
                                          resetSelection();
                                        } else if (isMobile && text.selectionStart != lastSelectionStart) {
                                          resetSelection();
                                        }
                                      };
                                      var inputHandler = null;
                                      this.setInputHandler = function(cb) {
                                        inputHandler = cb;
                                      };
                                      this.getInputHandler = function() {
                                        return inputHandler;
                                      };
                                      var afterContextMenu = false;
                                      var sendText = function(value, fromInput) {
                                        if (afterContextMenu)
                                          afterContextMenu = false;
                                        if (pasted) {
                                          resetSelection();
                                          if (value)
                                            host.onPaste(value);
                                          pasted = false;
                                          return "";
                                        } else {
                                          var selectionStart = text.selectionStart;
                                          var selectionEnd = text.selectionEnd;
                                          var extendLeft = lastSelectionStart;
                                          var extendRight = lastValue.length - lastSelectionEnd;
                                          var inserted = value;
                                          var restoreStart = value.length - selectionStart;
                                          var restoreEnd = value.length - selectionEnd;
                                          var i = 0;
                                          while (extendLeft > 0 && lastValue[i] == value[i]) {
                                            i++;
                                            extendLeft--;
                                          }
                                          inserted = inserted.slice(i);
                                          i = 1;
                                          while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
                                            i++;
                                            extendRight--;
                                          }
                                          restoreStart -= i - 1;
                                          restoreEnd -= i - 1;
                                          var endIndex = inserted.length - i + 1;
                                          if (endIndex < 0) {
                                            extendLeft = -endIndex;
                                            endIndex = 0;
                                          }
                                          inserted = inserted.slice(0, endIndex);
                                          if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                                            return "";
                                          sendingText = true;
                                          var shouldReset = false;
                                          if (useragent.isAndroid && inserted == ". ") {
                                            inserted = "  ";
                                            shouldReset = true;
                                          }
                                          if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                                            host.onTextInput(inserted);
                                          } else {
                                            host.onTextInput(inserted, {
                                              extendLeft,
                                              extendRight,
                                              restoreStart,
                                              restoreEnd
                                            });
                                          }
                                          sendingText = false;
                                          lastValue = value;
                                          lastSelectionStart = selectionStart;
                                          lastSelectionEnd = selectionEnd;
                                          lastRestoreEnd = restoreEnd;
                                          return shouldReset ? "\n" : inserted;
                                        }
                                      };
                                      var onInput = function(e) {
                                        if (inComposition)
                                          return onCompositionUpdate();
                                        if (e && e.inputType) {
                                          if (e.inputType == "historyUndo")
                                            return host.execCommand("undo");
                                          if (e.inputType == "historyRedo")
                                            return host.execCommand("redo");
                                        }
                                        var data = text.value;
                                        var inserted = sendText(data, true);
                                        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
                                          resetSelection();
                                        }
                                      };
                                      var handleClipboardData = function(e, data, forceIEMime) {
                                        var clipboardData = e.clipboardData || window.clipboardData;
                                        if (!clipboardData || BROKEN_SETDATA)
                                          return;
                                        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                                        try {
                                          if (data) {
                                            return clipboardData.setData(mime, data) !== false;
                                          } else {
                                            return clipboardData.getData(mime);
                                          }
                                        } catch (e2) {
                                          if (!forceIEMime)
                                            return handleClipboardData(e2, data, true);
                                        }
                                      };
                                      var doCopy = function(e, isCut) {
                                        var data = host.getCopyText();
                                        if (!data)
                                          return event.preventDefault(e);
                                        if (handleClipboardData(e, data)) {
                                          if (isIOS) {
                                            resetSelection(data);
                                            copied = data;
                                            setTimeout(function() {
                                              copied = false;
                                            }, 10);
                                          }
                                          isCut ? host.onCut() : host.onCopy();
                                          event.preventDefault(e);
                                        } else {
                                          copied = true;
                                          text.value = data;
                                          text.select();
                                          setTimeout(function() {
                                            copied = false;
                                            resetSelection();
                                            isCut ? host.onCut() : host.onCopy();
                                          });
                                        }
                                      };
                                      var onCut = function(e) {
                                        doCopy(e, true);
                                      };
                                      var onCopy = function(e) {
                                        doCopy(e, false);
                                      };
                                      var onPaste = function(e) {
                                        var data = handleClipboardData(e);
                                        if (clipboard.pasteCancelled())
                                          return;
                                        if (typeof data == "string") {
                                          if (data)
                                            host.onPaste(data, e);
                                          if (useragent.isIE)
                                            setTimeout(resetSelection);
                                          event.preventDefault(e);
                                        } else {
                                          text.value = "";
                                          pasted = true;
                                        }
                                      };
                                      event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
                                      event.addListener(text, "select", onSelect, host);
                                      event.addListener(text, "input", onInput, host);
                                      event.addListener(text, "cut", onCut, host);
                                      event.addListener(text, "copy", onCopy, host);
                                      event.addListener(text, "paste", onPaste, host);
                                      if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
                                        event.addListener(parentNode, "keydown", function(e) {
                                          if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                                            return;
                                          switch (e.keyCode) {
                                            case 67:
                                              onCopy(e);
                                              break;
                                            case 86:
                                              onPaste(e);
                                              break;
                                            case 88:
                                              onCut(e);
                                              break;
                                          }
                                        }, host);
                                      }
                                      var onCompositionStart = function(e) {
                                        if (inComposition || !host.onCompositionStart || host.$readOnly)
                                          return;
                                        inComposition = {};
                                        if (commandMode)
                                          return;
                                        if (e.data)
                                          inComposition.useTextareaForIME = false;
                                        setTimeout(onCompositionUpdate, 0);
                                        host._signal("compositionStart");
                                        host.on("mousedown", cancelComposition);
                                        var range = host.getSelectionRange();
                                        range.end.row = range.start.row;
                                        range.end.column = range.start.column;
                                        inComposition.markerRange = range;
                                        inComposition.selectionStart = lastSelectionStart;
                                        host.onCompositionStart(inComposition);
                                        if (inComposition.useTextareaForIME) {
                                          lastValue = text.value = "";
                                          lastSelectionStart = 0;
                                          lastSelectionEnd = 0;
                                        } else {
                                          if (text.msGetInputContext)
                                            inComposition.context = text.msGetInputContext();
                                          if (text.getInputContext)
                                            inComposition.context = text.getInputContext();
                                        }
                                      };
                                      var onCompositionUpdate = function() {
                                        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                                          return;
                                        if (commandMode)
                                          return cancelComposition();
                                        if (inComposition.useTextareaForIME) {
                                          host.onCompositionUpdate(text.value);
                                        } else {
                                          var data = text.value;
                                          sendText(data);
                                          if (inComposition.markerRange) {
                                            if (inComposition.context) {
                                              inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
                                            }
                                            inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                                          }
                                        }
                                      };
                                      var onCompositionEnd = function(e) {
                                        if (!host.onCompositionEnd || host.$readOnly)
                                          return;
                                        inComposition = false;
                                        host.onCompositionEnd();
                                        host.off("mousedown", cancelComposition);
                                        if (e)
                                          onInput();
                                      };
                                      function cancelComposition() {
                                        ignoreFocusEvents = true;
                                        text.blur();
                                        text.focus();
                                        ignoreFocusEvents = false;
                                      }
                                      var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
                                      function onKeyup(e) {
                                        if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                                          if (!inComposition)
                                            lastValue = text.value;
                                          lastSelectionStart = lastSelectionEnd = -1;
                                          resetSelection();
                                        }
                                        syncComposition();
                                      }
                                      event.addListener(text, "compositionstart", onCompositionStart, host);
                                      event.addListener(text, "compositionupdate", onCompositionUpdate, host);
                                      event.addListener(text, "keyup", onKeyup, host);
                                      event.addListener(text, "keydown", syncComposition, host);
                                      event.addListener(text, "compositionend", onCompositionEnd, host);
                                      this.getElement = function() {
                                        return text;
                                      };
                                      this.setCommandMode = function(value) {
                                        commandMode = value;
                                        text.readOnly = false;
                                      };
                                      this.setReadOnly = function(readOnly) {
                                        if (!commandMode)
                                          text.readOnly = readOnly;
                                      };
                                      this.setCopyWithEmptySelection = function(value) {
                                      };
                                      this.onContextMenu = function(e) {
                                        afterContextMenu = true;
                                        resetSelection();
                                        host._emit("nativecontextmenu", { target: host, domEvent: e });
                                        this.moveToMouse(e, true);
                                      };
                                      this.moveToMouse = function(e, bringToFront) {
                                        if (!tempStyle)
                                          tempStyle = text.style.cssText;
                                        text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
                                        var rect = host.container.getBoundingClientRect();
                                        var style = dom.computedStyle(host.container);
                                        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                                        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                                        var maxTop = rect.bottom - top - text.clientHeight - 2;
                                        var move = function(e2) {
                                          dom.translate(text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
                                        };
                                        move(e);
                                        if (e.type != "mousedown")
                                          return;
                                        host.renderer.$isMousePressed = true;
                                        clearTimeout(closeTimeout);
                                        if (useragent.isWin)
                                          event.capture(host.container, move, onContextMenuClose);
                                      };
                                      this.onContextMenuClose = onContextMenuClose;
                                      var closeTimeout;
                                      function onContextMenuClose() {
                                        clearTimeout(closeTimeout);
                                        closeTimeout = setTimeout(function() {
                                          if (tempStyle) {
                                            text.style.cssText = tempStyle;
                                            tempStyle = "";
                                          }
                                          host.renderer.$isMousePressed = false;
                                          if (host.renderer.$keepTextAreaAtCursor)
                                            host.renderer.$moveTextAreaToCursor();
                                        }, 0);
                                      }
                                      var onContextMenu = function(e) {
                                        host.textInput.onContextMenu(e);
                                        onContextMenuClose();
                                      };
                                      event.addListener(text, "mouseup", onContextMenu, host);
                                      event.addListener(text, "mousedown", function(e) {
                                        e.preventDefault();
                                        onContextMenuClose();
                                      }, host);
                                      event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
                                      event.addListener(text, "contextmenu", onContextMenu, host);
                                      if (isIOS)
                                        addIosSelectionHandler(parentNode, host, text);
                                      function addIosSelectionHandler(parentNode2, host2, text2) {
                                        var typingResetTimeout = null;
                                        var typing = false;
                                        text2.addEventListener("keydown", function(e) {
                                          if (typingResetTimeout)
                                            clearTimeout(typingResetTimeout);
                                          typing = true;
                                        }, true);
                                        text2.addEventListener("keyup", function(e) {
                                          typingResetTimeout = setTimeout(function() {
                                            typing = false;
                                          }, 100);
                                        }, true);
                                        var detectArrowKeys = function(e) {
                                          if (document.activeElement !== text2)
                                            return;
                                          if (typing || inComposition || host2.$mouseHandler.isMousePressed)
                                            return;
                                          if (copied) {
                                            return;
                                          }
                                          var selectionStart = text2.selectionStart;
                                          var selectionEnd = text2.selectionEnd;
                                          var key = null;
                                          var modifier = 0;
                                          if (selectionStart == 0) {
                                            key = KEYS.up;
                                          } else if (selectionStart == 1) {
                                            key = KEYS.home;
                                          } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                                            key = KEYS.end;
                                          } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                                            key = KEYS.left;
                                            modifier = MODS.option;
                                          } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                            key = KEYS.left;
                                          } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                                            key = KEYS.down;
                                          } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                                            key = KEYS.right;
                                            modifier = MODS.option;
                                          } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                            key = KEYS.right;
                                          }
                                          if (selectionStart !== selectionEnd)
                                            modifier |= MODS.shift;
                                          if (key) {
                                            var result = host2.onCommandKey({}, modifier, key);
                                            if (!result && host2.commands) {
                                              key = KEYS.keyCodeToString(key);
                                              var command = host2.commands.findKeyCommand(modifier, key);
                                              if (command)
                                                host2.execCommand(command);
                                            }
                                            lastSelectionStart = selectionStart;
                                            lastSelectionEnd = selectionEnd;
                                            resetSelection("");
                                          }
                                        };
                                        document.addEventListener("selectionchange", detectArrowKeys);
                                        host2.on("destroy", function() {
                                          document.removeEventListener("selectionchange", detectArrowKeys);
                                        });
                                      }
                                      this.destroy = function() {
                                        if (text.parentElement)
                                          text.parentElement.removeChild(text);
                                      };
                                    };
                                    exports2.k = TextInput;
                                    __webpack_unused_export__ = function(_isMobile, _isIOS) {
                                      isMobile = _isMobile;
                                      isIOS = _isIOS;
                                    };
                                  }
                                ),
                                /***/
                                845: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "no use strict";
                                    var oop = __webpack_require__22(645);
                                    var EventEmitter = __webpack_require__22(366).b;
                                    var optionsProvider = {
                                      setOptions: function(optList) {
                                        Object.keys(optList).forEach(function(key) {
                                          this.setOption(key, optList[key]);
                                        }, this);
                                      },
                                      getOptions: function(optionNames) {
                                        var result = {};
                                        if (!optionNames) {
                                          var options = this.$options;
                                          optionNames = Object.keys(options).filter(function(key) {
                                            return !options[key].hidden;
                                          });
                                        } else if (!Array.isArray(optionNames)) {
                                          result = optionNames;
                                          optionNames = Object.keys(result);
                                        }
                                        optionNames.forEach(function(key) {
                                          result[key] = this.getOption(key);
                                        }, this);
                                        return result;
                                      },
                                      setOption: function(name, value) {
                                        if (this["$" + name] === value)
                                          return;
                                        var opt = this.$options[name];
                                        if (!opt) {
                                          return warn('misspelled option "' + name + '"');
                                        }
                                        if (opt.forwardTo)
                                          return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
                                        if (!opt.handlesSet)
                                          this["$" + name] = value;
                                        if (opt && opt.set)
                                          opt.set.call(this, value);
                                      },
                                      getOption: function(name) {
                                        var opt = this.$options[name];
                                        if (!opt) {
                                          return warn('misspelled option "' + name + '"');
                                        }
                                        if (opt.forwardTo)
                                          return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                                        return opt && opt.get ? opt.get.call(this) : this["$" + name];
                                      }
                                    };
                                    function warn(message) {
                                      if (typeof console != "undefined" && console.warn)
                                        console.warn.apply(console, arguments);
                                    }
                                    function reportError2(msg, data) {
                                      var e = new Error(msg);
                                      e.data = data;
                                      if (typeof console == "object" && console.error)
                                        console.error(e);
                                      setTimeout(function() {
                                        throw e;
                                      });
                                    }
                                    var AppConfig = function() {
                                      this.$defaultOptions = {};
                                    };
                                    (function() {
                                      oop.implement(this, EventEmitter);
                                      this.defineOptions = function(obj, path, options) {
                                        if (!obj.$options)
                                          this.$defaultOptions[path] = obj.$options = {};
                                        Object.keys(options).forEach(function(key) {
                                          var opt = options[key];
                                          if (typeof opt == "string")
                                            opt = { forwardTo: opt };
                                          opt.name || (opt.name = key);
                                          obj.$options[opt.name] = opt;
                                          if ("initialValue" in opt)
                                            obj["$" + opt.name] = opt.initialValue;
                                        });
                                        oop.implement(obj, optionsProvider);
                                        return this;
                                      };
                                      this.resetOptions = function(obj) {
                                        Object.keys(obj.$options).forEach(function(key) {
                                          var opt = obj.$options[key];
                                          if ("value" in opt)
                                            obj.setOption(key, opt.value);
                                        });
                                      };
                                      this.setDefaultValue = function(path, name, value) {
                                        if (!path) {
                                          for (path in this.$defaultOptions)
                                            if (this.$defaultOptions[path][name])
                                              break;
                                          if (!this.$defaultOptions[path][name])
                                            return false;
                                        }
                                        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                                        if (opts[name]) {
                                          if (opts.forwardTo)
                                            this.setDefaultValue(opts.forwardTo, name, value);
                                          else
                                            opts[name].value = value;
                                        }
                                      };
                                      this.setDefaultValues = function(path, optionHash) {
                                        Object.keys(optionHash).forEach(function(key) {
                                          this.setDefaultValue(path, key, optionHash[key]);
                                        }, this);
                                      };
                                      this.warn = warn;
                                      this.reportError = reportError2;
                                    }).call(AppConfig.prototype);
                                    exports2.o = AppConfig;
                                  }
                                ),
                                /***/
                                435: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var useragent = __webpack_require__22(943);
                                    var XHTML_NS = "http://www.w3.org/1999/xhtml";
                                    exports2.buildDom = function buildDom(arr, parent, refs) {
                                      if (typeof arr == "string" && arr) {
                                        var txt = document.createTextNode(arr);
                                        if (parent)
                                          parent.appendChild(txt);
                                        return txt;
                                      }
                                      if (!Array.isArray(arr)) {
                                        if (arr && arr.appendChild && parent)
                                          parent.appendChild(arr);
                                        return arr;
                                      }
                                      if (typeof arr[0] != "string" || !arr[0]) {
                                        var els = [];
                                        for (var i = 0; i < arr.length; i++) {
                                          var ch = buildDom(arr[i], parent, refs);
                                          ch && els.push(ch);
                                        }
                                        return els;
                                      }
                                      var el = document.createElement(arr[0]);
                                      var options = arr[1];
                                      var childIndex = 1;
                                      if (options && typeof options == "object" && !Array.isArray(options))
                                        childIndex = 2;
                                      for (var i = childIndex; i < arr.length; i++)
                                        buildDom(arr[i], el, refs);
                                      if (childIndex == 2) {
                                        Object.keys(options).forEach(function(n) {
                                          var val = options[n];
                                          if (n === "class") {
                                            el.className = Array.isArray(val) ? val.join(" ") : val;
                                          } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                                            el[n] = val;
                                          } else if (n === "ref") {
                                            if (refs)
                                              refs[val] = el;
                                          } else if (n === "style") {
                                            if (typeof val == "string")
                                              el.style.cssText = val;
                                          } else if (val != null) {
                                            el.setAttribute(n, val);
                                          }
                                        });
                                      }
                                      if (parent)
                                        parent.appendChild(el);
                                      return el;
                                    };
                                    exports2.getDocumentHead = function(doc) {
                                      if (!doc)
                                        doc = document;
                                      return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
                                    };
                                    exports2.createElement = function(tag, ns) {
                                      return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
                                    };
                                    exports2.removeChildren = function(element) {
                                      element.innerHTML = "";
                                    };
                                    exports2.createTextNode = function(textContent, element) {
                                      var doc = element ? element.ownerDocument : document;
                                      return doc.createTextNode(textContent);
                                    };
                                    exports2.createFragment = function(element) {
                                      var doc = element ? element.ownerDocument : document;
                                      return doc.createDocumentFragment();
                                    };
                                    exports2.hasCssClass = function(el, name) {
                                      var classes = (el.className + "").split(/\s+/g);
                                      return classes.indexOf(name) !== -1;
                                    };
                                    exports2.addCssClass = function(el, name) {
                                      if (!exports2.hasCssClass(el, name)) {
                                        el.className += " " + name;
                                      }
                                    };
                                    exports2.removeCssClass = function(el, name) {
                                      var classes = el.className.split(/\s+/g);
                                      while (true) {
                                        var index = classes.indexOf(name);
                                        if (index == -1) {
                                          break;
                                        }
                                        classes.splice(index, 1);
                                      }
                                      el.className = classes.join(" ");
                                    };
                                    exports2.toggleCssClass = function(el, name) {
                                      var classes = el.className.split(/\s+/g), add = true;
                                      while (true) {
                                        var index = classes.indexOf(name);
                                        if (index == -1) {
                                          break;
                                        }
                                        add = false;
                                        classes.splice(index, 1);
                                      }
                                      if (add)
                                        classes.push(name);
                                      el.className = classes.join(" ");
                                      return add;
                                    };
                                    exports2.setCssClass = function(node, className, include) {
                                      if (include) {
                                        exports2.addCssClass(node, className);
                                      } else {
                                        exports2.removeCssClass(node, className);
                                      }
                                    };
                                    exports2.hasCssString = function(id, doc) {
                                      var index = 0, sheets;
                                      doc = doc || document;
                                      if (sheets = doc.querySelectorAll("style")) {
                                        while (index < sheets.length) {
                                          if (sheets[index++].id === id) {
                                            return true;
                                          }
                                        }
                                      }
                                    };
                                    exports2.removeElementById = function(id, doc) {
                                      doc = doc || document;
                                      if (doc.getElementById(id)) {
                                        doc.getElementById(id).remove();
                                      }
                                    };
                                    var strictCSP;
                                    var cssCache = [];
                                    exports2.useStrictCSP = function(value) {
                                      strictCSP = value;
                                      if (value == false)
                                        insertPendingStyles();
                                      else if (!cssCache)
                                        cssCache = [];
                                    };
                                    function insertPendingStyles() {
                                      var cache = cssCache;
                                      cssCache = null;
                                      cache && cache.forEach(function(item) {
                                        importCssString(item[0], item[1]);
                                      });
                                    }
                                    function importCssString(cssText, id, target) {
                                      if (typeof document == "undefined")
                                        return;
                                      if (cssCache) {
                                        if (target) {
                                          insertPendingStyles();
                                        } else if (target === false) {
                                          return cssCache.push([cssText, id]);
                                        }
                                      }
                                      if (strictCSP)
                                        return;
                                      var container = target;
                                      if (!target || !target.getRootNode) {
                                        container = document;
                                      } else {
                                        container = target.getRootNode();
                                        if (!container || container == target)
                                          container = document;
                                      }
                                      var doc = container.ownerDocument || container;
                                      if (id && exports2.hasCssString(id, container))
                                        return null;
                                      if (id)
                                        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
                                      var style = exports2.createElement("style");
                                      style.appendChild(doc.createTextNode(cssText));
                                      if (id)
                                        style.id = id;
                                      if (container == doc)
                                        container = exports2.getDocumentHead(doc);
                                      container.insertBefore(style, container.firstChild);
                                    }
                                    exports2.importCssString = importCssString;
                                    exports2.importCssStylsheet = function(uri, doc) {
                                      exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
                                    };
                                    exports2.scrollbarWidth = function(doc) {
                                      var inner = exports2.createElement("ace_inner");
                                      inner.style.width = "100%";
                                      inner.style.minWidth = "0px";
                                      inner.style.height = "200px";
                                      inner.style.display = "block";
                                      var outer = exports2.createElement("ace_outer");
                                      var style = outer.style;
                                      style.position = "absolute";
                                      style.left = "-10000px";
                                      style.overflow = "hidden";
                                      style.width = "200px";
                                      style.minWidth = "0px";
                                      style.height = "150px";
                                      style.display = "block";
                                      outer.appendChild(inner);
                                      var body = doc && doc.documentElement || document && document.documentElement;
                                      if (!body)
                                        return 0;
                                      body.appendChild(outer);
                                      var noScrollbar = inner.offsetWidth;
                                      style.overflow = "scroll";
                                      var withScrollbar = inner.offsetWidth;
                                      if (noScrollbar === withScrollbar) {
                                        withScrollbar = outer.clientWidth;
                                      }
                                      body.removeChild(outer);
                                      return noScrollbar - withScrollbar;
                                    };
                                    exports2.computedStyle = function(element, style) {
                                      return window.getComputedStyle(element, "") || {};
                                    };
                                    exports2.setStyle = function(styles, property, value) {
                                      if (styles[property] !== value) {
                                        styles[property] = value;
                                      }
                                    };
                                    exports2.HAS_CSS_ANIMATION = false;
                                    exports2.HAS_CSS_TRANSFORMS = false;
                                    exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
                                    if (useragent.isChromeOS)
                                      exports2.HI_DPI = false;
                                    if (typeof document !== "undefined") {
                                      var div = document.createElement("div");
                                      if (exports2.HI_DPI && div.style.transform !== void 0)
                                        exports2.HAS_CSS_TRANSFORMS = true;
                                      if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
                                        exports2.HAS_CSS_ANIMATION = true;
                                      div = null;
                                    }
                                    if (exports2.HAS_CSS_TRANSFORMS) {
                                      exports2.translate = function(element, tx, ty) {
                                        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
                                      };
                                    } else {
                                      exports2.translate = function(element, tx, ty) {
                                        element.style.top = Math.round(ty) + "px";
                                        element.style.left = Math.round(tx) + "px";
                                      };
                                    }
                                  }
                                ),
                                /***/
                                631: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var keys = __webpack_require__22(451);
                                    var useragent = __webpack_require__22(943);
                                    var pressedKeys = null;
                                    var ts = 0;
                                    var activeListenerOptions;
                                    function detectListenerOptionsSupport() {
                                      activeListenerOptions = false;
                                      try {
                                        document.createComment("").addEventListener("test", function() {
                                        }, {
                                          get passive() {
                                            activeListenerOptions = { passive: false };
                                          }
                                        });
                                      } catch (e) {
                                      }
                                    }
                                    function getListenerOptions() {
                                      if (activeListenerOptions == void 0)
                                        detectListenerOptionsSupport();
                                      return activeListenerOptions;
                                    }
                                    function EventListener(elem, type, callback) {
                                      this.elem = elem;
                                      this.type = type;
                                      this.callback = callback;
                                    }
                                    EventListener.prototype.destroy = function() {
                                      removeListener(this.elem, this.type, this.callback);
                                      this.elem = this.type = this.callback = void 0;
                                    };
                                    var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
                                      elem.addEventListener(type, callback, getListenerOptions());
                                      if (destroyer)
                                        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
                                    };
                                    var removeListener = exports2.removeListener = function(elem, type, callback) {
                                      elem.removeEventListener(type, callback, getListenerOptions());
                                    };
                                    exports2.stopEvent = function(e) {
                                      exports2.stopPropagation(e);
                                      exports2.preventDefault(e);
                                      return false;
                                    };
                                    exports2.stopPropagation = function(e) {
                                      if (e.stopPropagation)
                                        e.stopPropagation();
                                    };
                                    exports2.preventDefault = function(e) {
                                      if (e.preventDefault)
                                        e.preventDefault();
                                    };
                                    exports2.getButton = function(e) {
                                      if (e.type == "dblclick")
                                        return 0;
                                      if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
                                        return 2;
                                      return e.button;
                                    };
                                    exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
                                      var ownerDocument = el && el.ownerDocument || document;
                                      function onMouseUp(e) {
                                        eventHandler && eventHandler(e);
                                        releaseCaptureHandler && releaseCaptureHandler(e);
                                        removeListener(ownerDocument, "mousemove", eventHandler);
                                        removeListener(ownerDocument, "mouseup", onMouseUp);
                                        removeListener(ownerDocument, "dragstart", onMouseUp);
                                      }
                                      addListener(ownerDocument, "mousemove", eventHandler);
                                      addListener(ownerDocument, "mouseup", onMouseUp);
                                      addListener(ownerDocument, "dragstart", onMouseUp);
                                      return onMouseUp;
                                    };
                                    exports2.addMouseWheelListener = function(el, callback, destroyer) {
                                      addListener(el, "wheel", function(e) {
                                        var factor = 0.15;
                                        var deltaX = e.deltaX || 0;
                                        var deltaY = e.deltaY || 0;
                                        switch (e.deltaMode) {
                                          case e.DOM_DELTA_PIXEL:
                                            e.wheelX = deltaX * factor;
                                            e.wheelY = deltaY * factor;
                                            break;
                                          case e.DOM_DELTA_LINE:
                                            var linePixels = 15;
                                            e.wheelX = deltaX * linePixels;
                                            e.wheelY = deltaY * linePixels;
                                            break;
                                          case e.DOM_DELTA_PAGE:
                                            var pagePixels = 150;
                                            e.wheelX = deltaX * pagePixels;
                                            e.wheelY = deltaY * pagePixels;
                                            break;
                                        }
                                        callback(e);
                                      }, destroyer);
                                    };
                                    exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
                                      var clicks = 0;
                                      var startX, startY, timer;
                                      var eventNames = {
                                        2: "dblclick",
                                        3: "tripleclick",
                                        4: "quadclick"
                                      };
                                      function onMousedown(e) {
                                        if (exports2.getButton(e) !== 0) {
                                          clicks = 0;
                                        } else if (e.detail > 1) {
                                          clicks++;
                                          if (clicks > 4)
                                            clicks = 1;
                                        } else {
                                          clicks = 1;
                                        }
                                        if (useragent.isIE) {
                                          var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                                          if (!timer || isNewClick)
                                            clicks = 1;
                                          if (timer)
                                            clearTimeout(timer);
                                          timer = setTimeout(function() {
                                            timer = null;
                                          }, timeouts[clicks - 1] || 600);
                                          if (clicks == 1) {
                                            startX = e.clientX;
                                            startY = e.clientY;
                                          }
                                        }
                                        e._clicks = clicks;
                                        eventHandler[callbackName]("mousedown", e);
                                        if (clicks > 4)
                                          clicks = 0;
                                        else if (clicks > 1)
                                          return eventHandler[callbackName](eventNames[clicks], e);
                                      }
                                      if (!Array.isArray(elements))
                                        elements = [elements];
                                      elements.forEach(function(el) {
                                        addListener(el, "mousedown", onMousedown, destroyer);
                                      });
                                    };
                                    var getModifierHash = function(e) {
                                      return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
                                    };
                                    exports2.getModifierString = function(e) {
                                      return keys.KEY_MODS[getModifierHash(e)];
                                    };
                                    function normalizeCommandKeys(callback, e, keyCode) {
                                      var hashId = getModifierHash(e);
                                      if (!useragent.isMac && pressedKeys) {
                                        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                                          hashId |= 8;
                                        if (pressedKeys.altGr) {
                                          if ((3 & hashId) != 3)
                                            pressedKeys.altGr = 0;
                                          else
                                            return;
                                        }
                                        if (keyCode === 18 || keyCode === 17) {
                                          var location = "location" in e ? e.location : e.keyLocation;
                                          if (keyCode === 17 && location === 1) {
                                            if (pressedKeys[keyCode] == 1)
                                              ts = e.timeStamp;
                                          } else if (keyCode === 18 && hashId === 3 && location === 2) {
                                            var dt = e.timeStamp - ts;
                                            if (dt < 50)
                                              pressedKeys.altGr = true;
                                          }
                                        }
                                      }
                                      if (keyCode in keys.MODIFIER_KEYS) {
                                        keyCode = -1;
                                      }
                                      if (!hashId && keyCode === 13) {
                                        var location = "location" in e ? e.location : e.keyLocation;
                                        if (location === 3) {
                                          callback(e, hashId, -keyCode);
                                          if (e.defaultPrevented)
                                            return;
                                        }
                                      }
                                      if (useragent.isChromeOS && hashId & 8) {
                                        callback(e, hashId, keyCode);
                                        if (e.defaultPrevented)
                                          return;
                                        else
                                          hashId &= ~8;
                                      }
                                      if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                                        return false;
                                      }
                                      return callback(e, hashId, keyCode);
                                    }
                                    exports2.addCommandKeyListener = function(el, callback, destroyer) {
                                      if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                                        var lastKeyDownKeyCode = null;
                                        addListener(el, "keydown", function(e) {
                                          lastKeyDownKeyCode = e.keyCode;
                                        }, destroyer);
                                        addListener(el, "keypress", function(e) {
                                          return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                                        }, destroyer);
                                      } else {
                                        var lastDefaultPrevented = null;
                                        addListener(el, "keydown", function(e) {
                                          pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                                          var result = normalizeCommandKeys(callback, e, e.keyCode);
                                          lastDefaultPrevented = e.defaultPrevented;
                                          return result;
                                        }, destroyer);
                                        addListener(el, "keypress", function(e) {
                                          if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                                            exports2.stopEvent(e);
                                            lastDefaultPrevented = null;
                                          }
                                        }, destroyer);
                                        addListener(el, "keyup", function(e) {
                                          pressedKeys[e.keyCode] = null;
                                        }, destroyer);
                                        if (!pressedKeys) {
                                          resetPressedKeys();
                                          addListener(window, "focus", resetPressedKeys);
                                        }
                                      }
                                    };
                                    function resetPressedKeys() {
                                      pressedKeys = /* @__PURE__ */ Object.create(null);
                                    }
                                    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                                      var postMessageId = 1;
                                      exports2.nextTick = function(callback, win) {
                                        win = win || window;
                                        var messageName = "zero-timeout-message-" + postMessageId++;
                                        var listener = function(e) {
                                          if (e.data == messageName) {
                                            exports2.stopPropagation(e);
                                            removeListener(win, "message", listener);
                                            callback();
                                          }
                                        };
                                        addListener(win, "message", listener);
                                        win.postMessage(messageName, "*");
                                      };
                                    }
                                    exports2.$idleBlocked = false;
                                    exports2.onIdle = function(cb, timeout) {
                                      return setTimeout(function handler() {
                                        if (!exports2.$idleBlocked) {
                                          cb();
                                        } else {
                                          setTimeout(handler, 100);
                                        }
                                      }, timeout);
                                    };
                                    exports2.$idleBlockId = null;
                                    exports2.blockIdle = function(delay) {
                                      if (exports2.$idleBlockId)
                                        clearTimeout(exports2.$idleBlockId);
                                      exports2.$idleBlocked = true;
                                      exports2.$idleBlockId = setTimeout(function() {
                                        exports2.$idleBlocked = false;
                                      }, delay || 100);
                                    };
                                    exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
                                    if (exports2.nextFrame)
                                      exports2.nextFrame = exports2.nextFrame.bind(window);
                                    else
                                      exports2.nextFrame = function(callback) {
                                        setTimeout(callback, 17);
                                      };
                                  }
                                ),
                                /***/
                                366: (
                                  /***/
                                  (__unused_webpack_module, exports2) => {
                                    "use strict";
                                    var EventEmitter = {};
                                    var stopPropagation = function() {
                                      this.propagationStopped = true;
                                    };
                                    var preventDefault = function() {
                                      this.defaultPrevented = true;
                                    };
                                    EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
                                      this._eventRegistry || (this._eventRegistry = {});
                                      this._defaultHandlers || (this._defaultHandlers = {});
                                      var listeners = this._eventRegistry[eventName] || [];
                                      var defaultHandler = this._defaultHandlers[eventName];
                                      if (!listeners.length && !defaultHandler)
                                        return;
                                      if (typeof e != "object" || !e)
                                        e = {};
                                      if (!e.type)
                                        e.type = eventName;
                                      if (!e.stopPropagation)
                                        e.stopPropagation = stopPropagation;
                                      if (!e.preventDefault)
                                        e.preventDefault = preventDefault;
                                      listeners = listeners.slice();
                                      for (var i = 0; i < listeners.length; i++) {
                                        listeners[i](e, this);
                                        if (e.propagationStopped)
                                          break;
                                      }
                                      if (defaultHandler && !e.defaultPrevented)
                                        return defaultHandler(e, this);
                                    };
                                    EventEmitter._signal = function(eventName, e) {
                                      var listeners = (this._eventRegistry || {})[eventName];
                                      if (!listeners)
                                        return;
                                      listeners = listeners.slice();
                                      for (var i = 0; i < listeners.length; i++)
                                        listeners[i](e, this);
                                    };
                                    EventEmitter.once = function(eventName, callback) {
                                      var _self = this;
                                      this.on(eventName, function newCallback() {
                                        _self.off(eventName, newCallback);
                                        callback.apply(null, arguments);
                                      });
                                      if (!callback) {
                                        return new Promise(function(resolve) {
                                          callback = resolve;
                                        });
                                      }
                                    };
                                    EventEmitter.setDefaultHandler = function(eventName, callback) {
                                      var handlers = this._defaultHandlers;
                                      if (!handlers)
                                        handlers = this._defaultHandlers = { _disabled_: {} };
                                      if (handlers[eventName]) {
                                        var old = handlers[eventName];
                                        var disabled = handlers._disabled_[eventName];
                                        if (!disabled)
                                          handlers._disabled_[eventName] = disabled = [];
                                        disabled.push(old);
                                        var i = disabled.indexOf(callback);
                                        if (i != -1)
                                          disabled.splice(i, 1);
                                      }
                                      handlers[eventName] = callback;
                                    };
                                    EventEmitter.removeDefaultHandler = function(eventName, callback) {
                                      var handlers = this._defaultHandlers;
                                      if (!handlers)
                                        return;
                                      var disabled = handlers._disabled_[eventName];
                                      if (handlers[eventName] == callback) {
                                        if (disabled)
                                          this.setDefaultHandler(eventName, disabled.pop());
                                      } else if (disabled) {
                                        var i = disabled.indexOf(callback);
                                        if (i != -1)
                                          disabled.splice(i, 1);
                                      }
                                    };
                                    EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
                                      this._eventRegistry = this._eventRegistry || {};
                                      var listeners = this._eventRegistry[eventName];
                                      if (!listeners)
                                        listeners = this._eventRegistry[eventName] = [];
                                      if (listeners.indexOf(callback) == -1)
                                        listeners[capturing ? "unshift" : "push"](callback);
                                      return callback;
                                    };
                                    EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
                                      this._eventRegistry = this._eventRegistry || {};
                                      var listeners = this._eventRegistry[eventName];
                                      if (!listeners)
                                        return;
                                      var index = listeners.indexOf(callback);
                                      if (index !== -1)
                                        listeners.splice(index, 1);
                                    };
                                    EventEmitter.removeAllListeners = function(eventName) {
                                      if (!eventName)
                                        this._eventRegistry = this._defaultHandlers = void 0;
                                      if (this._eventRegistry)
                                        this._eventRegistry[eventName] = void 0;
                                      if (this._defaultHandlers)
                                        this._defaultHandlers[eventName] = void 0;
                                    };
                                    exports2.b = EventEmitter;
                                  }
                                ),
                                /***/
                                451: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    /*! @license
                                    ==========================================================================
                                    SproutCore -- JavaScript Application Framework
                                    copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
                                    
                                    Permission is hereby granted, free of charge, to any person obtaining a
                                    copy of this software and associated documentation files (the "Software"),
                                    to deal in the Software without restriction, including without limitation
                                    the rights to use, copy, modify, merge, publish, distribute, sublicense,
                                    and/or sell copies of the Software, and to permit persons to whom the
                                    Software is furnished to do so, subject to the following conditions:
                                    
                                    The above copyright notice and this permission notice shall be included in
                                    all copies or substantial portions of the Software.
                                    
                                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                                    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
                                    DEALINGS IN THE SOFTWARE.
                                    
                                    SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
                                    
                                    For more information about SproutCore, visit http://www.sproutcore.com
                                    
                                    
                                    ==========================================================================
                                    @license */
                                    var oop = __webpack_require__22(645);
                                    var Keys = function() {
                                      var ret = {
                                        MODIFIER_KEYS: {
                                          16: "Shift",
                                          17: "Ctrl",
                                          18: "Alt",
                                          224: "Meta",
                                          91: "MetaLeft",
                                          92: "MetaRight",
                                          93: "ContextMenu"
                                        },
                                        KEY_MODS: {
                                          "ctrl": 1,
                                          "alt": 2,
                                          "option": 2,
                                          "shift": 4,
                                          "super": 8,
                                          "meta": 8,
                                          "command": 8,
                                          "cmd": 8,
                                          "control": 1
                                        },
                                        FUNCTION_KEYS: {
                                          8: "Backspace",
                                          9: "Tab",
                                          13: "Return",
                                          19: "Pause",
                                          27: "Esc",
                                          32: "Space",
                                          33: "PageUp",
                                          34: "PageDown",
                                          35: "End",
                                          36: "Home",
                                          37: "Left",
                                          38: "Up",
                                          39: "Right",
                                          40: "Down",
                                          44: "Print",
                                          45: "Insert",
                                          46: "Delete",
                                          96: "Numpad0",
                                          97: "Numpad1",
                                          98: "Numpad2",
                                          99: "Numpad3",
                                          100: "Numpad4",
                                          101: "Numpad5",
                                          102: "Numpad6",
                                          103: "Numpad7",
                                          104: "Numpad8",
                                          105: "Numpad9",
                                          "-13": "NumpadEnter",
                                          112: "F1",
                                          113: "F2",
                                          114: "F3",
                                          115: "F4",
                                          116: "F5",
                                          117: "F6",
                                          118: "F7",
                                          119: "F8",
                                          120: "F9",
                                          121: "F10",
                                          122: "F11",
                                          123: "F12",
                                          144: "Numlock",
                                          145: "Scrolllock"
                                        },
                                        PRINTABLE_KEYS: {
                                          32: " ",
                                          48: "0",
                                          49: "1",
                                          50: "2",
                                          51: "3",
                                          52: "4",
                                          53: "5",
                                          54: "6",
                                          55: "7",
                                          56: "8",
                                          57: "9",
                                          59: ";",
                                          61: "=",
                                          65: "a",
                                          66: "b",
                                          67: "c",
                                          68: "d",
                                          69: "e",
                                          70: "f",
                                          71: "g",
                                          72: "h",
                                          73: "i",
                                          74: "j",
                                          75: "k",
                                          76: "l",
                                          77: "m",
                                          78: "n",
                                          79: "o",
                                          80: "p",
                                          81: "q",
                                          82: "r",
                                          83: "s",
                                          84: "t",
                                          85: "u",
                                          86: "v",
                                          87: "w",
                                          88: "x",
                                          89: "y",
                                          90: "z",
                                          107: "+",
                                          109: "-",
                                          110: ".",
                                          186: ";",
                                          187: "=",
                                          188: ",",
                                          189: "-",
                                          190: ".",
                                          191: "/",
                                          192: "`",
                                          219: "[",
                                          220: "\\",
                                          221: "]",
                                          222: "'",
                                          111: "/",
                                          106: "*"
                                        }
                                      };
                                      ret.PRINTABLE_KEYS[173] = "-";
                                      var name, i;
                                      for (i in ret.FUNCTION_KEYS) {
                                        name = ret.FUNCTION_KEYS[i].toLowerCase();
                                        ret[name] = parseInt(i, 10);
                                      }
                                      for (i in ret.PRINTABLE_KEYS) {
                                        name = ret.PRINTABLE_KEYS[i].toLowerCase();
                                        ret[name] = parseInt(i, 10);
                                      }
                                      oop.mixin(ret, ret.MODIFIER_KEYS);
                                      oop.mixin(ret, ret.PRINTABLE_KEYS);
                                      oop.mixin(ret, ret.FUNCTION_KEYS);
                                      ret.enter = ret["return"];
                                      ret.escape = ret.esc;
                                      ret.del = ret["delete"];
                                      (function() {
                                        var mods = ["cmd", "ctrl", "alt", "shift"];
                                        for (var i2 = Math.pow(2, mods.length); i2--; ) {
                                          ret.KEY_MODS[i2] = mods.filter(function(x) {
                                            return i2 & ret.KEY_MODS[x];
                                          }).join("-") + "-";
                                        }
                                      })();
                                      ret.KEY_MODS[0] = "";
                                      ret.KEY_MODS[-1] = "input-";
                                      return ret;
                                    }();
                                    oop.mixin(exports2, Keys);
                                    exports2.keyCodeToString = function(keyCode) {
                                      var keyString = Keys[keyCode];
                                      if (typeof keyString != "string")
                                        keyString = String.fromCharCode(keyCode);
                                      return keyString.toLowerCase();
                                    };
                                  }
                                ),
                                /***/
                                955: (
                                  /***/
                                  (__unused_webpack_module, exports2) => {
                                    "use strict";
                                    exports2.last = function(a) {
                                      return a[a.length - 1];
                                    };
                                    exports2.stringReverse = function(string) {
                                      return string.split("").reverse().join("");
                                    };
                                    exports2.stringRepeat = function(string, count) {
                                      var result = "";
                                      while (count > 0) {
                                        if (count & 1)
                                          result += string;
                                        if (count >>= 1)
                                          string += string;
                                      }
                                      return result;
                                    };
                                    var trimBeginRegexp = /^\s\s*/;
                                    var trimEndRegexp = /\s\s*$/;
                                    exports2.stringTrimLeft = function(string) {
                                      return string.replace(trimBeginRegexp, "");
                                    };
                                    exports2.stringTrimRight = function(string) {
                                      return string.replace(trimEndRegexp, "");
                                    };
                                    exports2.copyObject = function(obj) {
                                      var copy = {};
                                      for (var key in obj) {
                                        copy[key] = obj[key];
                                      }
                                      return copy;
                                    };
                                    exports2.copyArray = function(array) {
                                      var copy = [];
                                      for (var i = 0, l = array.length; i < l; i++) {
                                        if (array[i] && typeof array[i] == "object")
                                          copy[i] = this.copyObject(array[i]);
                                        else
                                          copy[i] = array[i];
                                      }
                                      return copy;
                                    };
                                    exports2.deepCopy = function deepCopy(obj) {
                                      if (typeof obj !== "object" || !obj)
                                        return obj;
                                      var copy;
                                      if (Array.isArray(obj)) {
                                        copy = [];
                                        for (var key = 0; key < obj.length; key++) {
                                          copy[key] = deepCopy(obj[key]);
                                        }
                                        return copy;
                                      }
                                      if (Object.prototype.toString.call(obj) !== "[object Object]")
                                        return obj;
                                      copy = {};
                                      for (var key in obj)
                                        copy[key] = deepCopy(obj[key]);
                                      return copy;
                                    };
                                    exports2.arrayToMap = function(arr) {
                                      var map = {};
                                      for (var i = 0; i < arr.length; i++) {
                                        map[arr[i]] = 1;
                                      }
                                      return map;
                                    };
                                    exports2.createMap = function(props) {
                                      var map = /* @__PURE__ */ Object.create(null);
                                      for (var i in props) {
                                        map[i] = props[i];
                                      }
                                      return map;
                                    };
                                    exports2.arrayRemove = function(array, value) {
                                      for (var i = 0; i <= array.length; i++) {
                                        if (value === array[i]) {
                                          array.splice(i, 1);
                                        }
                                      }
                                    };
                                    exports2.escapeRegExp = function(str) {
                                      return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
                                    };
                                    exports2.escapeHTML = function(str) {
                                      return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
                                    };
                                    exports2.getMatchOffsets = function(string, regExp) {
                                      var matches = [];
                                      string.replace(regExp, function(str) {
                                        matches.push({
                                          offset: arguments[arguments.length - 2],
                                          length: str.length
                                        });
                                      });
                                      return matches;
                                    };
                                    exports2.deferredCall = function(fcn) {
                                      var timer = null;
                                      var callback = function() {
                                        timer = null;
                                        fcn();
                                      };
                                      var deferred = function(timeout) {
                                        deferred.cancel();
                                        timer = setTimeout(callback, timeout || 0);
                                        return deferred;
                                      };
                                      deferred.schedule = deferred;
                                      deferred.call = function() {
                                        this.cancel();
                                        fcn();
                                        return deferred;
                                      };
                                      deferred.cancel = function() {
                                        clearTimeout(timer);
                                        timer = null;
                                        return deferred;
                                      };
                                      deferred.isPending = function() {
                                        return timer;
                                      };
                                      return deferred;
                                    };
                                    exports2.delayedCall = function(fcn, defaultTimeout) {
                                      var timer = null;
                                      var callback = function() {
                                        timer = null;
                                        fcn();
                                      };
                                      var _self = function(timeout) {
                                        if (timer == null)
                                          timer = setTimeout(callback, timeout || defaultTimeout);
                                      };
                                      _self.delay = function(timeout) {
                                        timer && clearTimeout(timer);
                                        timer = setTimeout(callback, timeout || defaultTimeout);
                                      };
                                      _self.schedule = _self;
                                      _self.call = function() {
                                        this.cancel();
                                        fcn();
                                      };
                                      _self.cancel = function() {
                                        timer && clearTimeout(timer);
                                        timer = null;
                                      };
                                      _self.isPending = function() {
                                        return timer;
                                      };
                                      return _self;
                                    };
                                  }
                                ),
                                /***/
                                552: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    /*
                                     * based on code from:
                                     *
                                     * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
                                     * Available via the MIT or new BSD license.
                                     * see: http://github.com/jrburke/requirejs for details
                                     */
                                    var dom = __webpack_require__22(435);
                                    exports2.get = function(url, callback) {
                                      var xhr = new XMLHttpRequest();
                                      xhr.open("GET", url, true);
                                      xhr.onreadystatechange = function() {
                                        if (xhr.readyState === 4) {
                                          callback(xhr.responseText);
                                        }
                                      };
                                      xhr.send(null);
                                    };
                                    exports2.loadScript = function(path, callback) {
                                      var head = dom.getDocumentHead();
                                      var s = document.createElement("script");
                                      s.src = path;
                                      head.appendChild(s);
                                      s.onload = s.onreadystatechange = function(_, isAbort) {
                                        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                                          s = s.onload = s.onreadystatechange = null;
                                          if (!isAbort)
                                            callback();
                                        }
                                      };
                                    };
                                    exports2.qualifyURL = function(url) {
                                      var a = document.createElement("a");
                                      a.href = url;
                                      return a.href;
                                    };
                                  }
                                ),
                                /***/
                                645: (
                                  /***/
                                  (__unused_webpack_module, exports2) => {
                                    "use strict";
                                    exports2.inherits = function(ctor, superCtor) {
                                      ctor.super_ = superCtor;
                                      ctor.prototype = Object.create(superCtor.prototype, {
                                        constructor: {
                                          value: ctor,
                                          enumerable: false,
                                          writable: true,
                                          configurable: true
                                        }
                                      });
                                    };
                                    exports2.mixin = function(obj, mixin) {
                                      for (var key in mixin) {
                                        obj[key] = mixin[key];
                                      }
                                      return obj;
                                    };
                                    exports2.implement = function(proto, mixin) {
                                      exports2.mixin(proto, mixin);
                                    };
                                  }
                                ),
                                /***/
                                943: (
                                  /***/
                                  (__unused_webpack_module, exports2) => {
                                    "use strict";
                                    exports2.OS = {
                                      LINUX: "LINUX",
                                      MAC: "MAC",
                                      WINDOWS: "WINDOWS"
                                    };
                                    exports2.getOS = function() {
                                      if (exports2.isMac) {
                                        return exports2.OS.MAC;
                                      } else if (exports2.isLinux) {
                                        return exports2.OS.LINUX;
                                      } else {
                                        return exports2.OS.WINDOWS;
                                      }
                                    };
                                    var _navigator = typeof navigator == "object" ? navigator : {};
                                    var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
                                    var ua = _navigator.userAgent || "";
                                    var appName = _navigator.appName || "";
                                    exports2.isWin = os == "win";
                                    exports2.isMac = os == "mac";
                                    exports2.isLinux = os == "linux";
                                    exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
                                    exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
                                    exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
                                    exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
                                    exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
                                    exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
                                    exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
                                    exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
                                    exports2.isAndroid = ua.indexOf("Android") >= 0;
                                    exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
                                    exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
                                    if (exports2.isIOS)
                                      exports2.isMac = true;
                                    exports2.isMobile = exports2.isIOS || exports2.isAndroid;
                                  }
                                ),
                                /***/
                                481: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var event = __webpack_require__22(631);
                                    var RenderLoop = function(onRender, win) {
                                      this.onRender = onRender;
                                      this.pending = false;
                                      this.changes = 0;
                                      this.$recursionLimit = 2;
                                      this.window = win || window;
                                      var _self = this;
                                      this._flush = function(ts) {
                                        _self.pending = false;
                                        var changes = _self.changes;
                                        if (changes) {
                                          event.blockIdle(100);
                                          _self.changes = 0;
                                          _self.onRender(changes);
                                        }
                                        if (_self.changes) {
                                          if (_self.$recursionLimit-- < 0)
                                            return;
                                          _self.schedule();
                                        } else {
                                          _self.$recursionLimit = 2;
                                        }
                                      };
                                    };
                                    (function() {
                                      this.schedule = function(change) {
                                        this.changes = this.changes | change;
                                        if (this.changes && !this.pending) {
                                          event.nextFrame(this._flush);
                                          this.pending = true;
                                        }
                                      };
                                      this.clear = function(change) {
                                        var changes = this.changes;
                                        this.changes = 0;
                                        return changes;
                                      };
                                    }).call(RenderLoop.prototype);
                                    exports2.x = RenderLoop;
                                  }
                                ),
                                /***/
                                745: (
                                  /***/
                                  (__unused_webpack_module, exports2, __webpack_require__22) => {
                                    "use strict";
                                    var __webpack_unused_export__;
                                    var oop = __webpack_require__22(645);
                                    var dom = __webpack_require__22(435);
                                    var event = __webpack_require__22(631);
                                    var EventEmitter = __webpack_require__22(366).b;
                                    var MAX_SCROLL_H = 32768;
                                    var ScrollBar = function(parent) {
                                      this.element = dom.createElement("div");
                                      this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
                                      this.inner = dom.createElement("div");
                                      this.inner.className = "ace_scrollbar-inner";
                                      this.inner.textContent = "\xA0";
                                      this.element.appendChild(this.inner);
                                      parent.appendChild(this.element);
                                      this.setVisible(false);
                                      this.skipEvent = false;
                                      event.addListener(this.element, "scroll", this.onScroll.bind(this));
                                      event.addListener(this.element, "mousedown", event.preventDefault);
                                    };
                                    (function() {
                                      oop.implement(this, EventEmitter);
                                      this.setVisible = function(isVisible) {
                                        this.element.style.display = isVisible ? "" : "none";
                                        this.isVisible = isVisible;
                                        this.coeff = 1;
                                      };
                                    }).call(ScrollBar.prototype);
                                    var VScrollBar = function(parent, renderer) {
                                      ScrollBar.call(this, parent);
                                      this.scrollTop = 0;
                                      this.scrollHeight = 0;
                                      renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
                                      this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
                                      this.$minWidth = 0;
                                    };
                                    oop.inherits(VScrollBar, ScrollBar);
                                    (function() {
                                      this.classSuffix = "-v";
                                      this.onScroll = function() {
                                        if (!this.skipEvent) {
                                          this.scrollTop = this.element.scrollTop;
                                          if (this.coeff != 1) {
                                            var h = this.element.clientHeight / this.scrollHeight;
                                            this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                                          }
                                          this._emit("scroll", { data: this.scrollTop });
                                        }
                                        this.skipEvent = false;
                                      };
                                      this.getWidth = function() {
                                        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
                                      };
                                      this.setHeight = function(height) {
                                        this.element.style.height = height + "px";
                                      };
                                      this.setInnerHeight = /**
                                      * Sets the scroll height of the scroll bar, in pixels.
                                      * @param {Number} height The new scroll height
                                      **/
                                      this.setScrollHeight = function(height) {
                                        this.scrollHeight = height;
                                        if (height > MAX_SCROLL_H) {
                                          this.coeff = MAX_SCROLL_H / height;
                                          height = MAX_SCROLL_H;
                                        } else if (this.coeff != 1) {
                                          this.coeff = 1;
                                        }
                                        this.inner.style.height = height + "px";
                                      };
                                      this.setScrollTop = function(scrollTop) {
                                        if (this.scrollTop != scrollTop) {
                                          this.skipEvent = true;
                                          this.scrollTop = scrollTop;
                                          this.element.scrollTop = scrollTop * this.coeff;
                                        }
                                      };
                                    }).call(VScrollBar.prototype);
                                    var HScrollBar = function(parent, renderer) {
                                      ScrollBar.call(this, parent);
                                      this.scrollLeft = 0;
                                      this.height = renderer.$scrollbarWidth;
                                      this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
                                    };
                                    oop.inherits(HScrollBar, ScrollBar);
                                    (function() {
                                      this.classSuffix = "-h";
                                      this.onScroll = function() {
                                        if (!this.skipEvent) {
                                          this.scrollLeft = this.element.scrollLeft;
                                          this._emit("scroll", { data: this.scrollLeft });
                                        }
                                        this.skipEvent = false;
                                      };
                                      this.getHeight = function() {
                                        return this.isVisible ? this.height : 0;
                                      };
                                      this.setWidth = function(width) {
                                        this.element.style.width = width + "px";
                                      };
                                      this.setInnerWidth = function(width) {
                                        this.inner.style.width = width + "px";
                                      };
                                      this.setScrollWidth = function(width) {
                                        this.inner.style.width = width + "px";
                                      };
                                      this.setScrollLeft = function(scrollLeft) {
                                        if (this.scrollLeft != scrollLeft) {
                                          this.skipEvent = true;
                                          this.scrollLeft = this.element.scrollLeft = scrollLeft;
                                        }
                                      };
                                    }).call(HScrollBar.prototype);
                                    __webpack_unused_export__ = VScrollBar;
                                    exports2.lc = VScrollBar;
                                    exports2.zy = HScrollBar;
                                    __webpack_unused_export__ = VScrollBar;
                                    __webpack_unused_export__ = HScrollBar;
                                  }
                                ),
                                /***/
                                677: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      function bindKey(win, mac) {
                                        return {
                                          win,
                                          mac
                                        };
                                      }
                                      exports3.commands = [
                                        {
                                          name: "selectAll",
                                          bindKey: bindKey("Ctrl-A", "Command-A"),
                                          exec: function(editor) {
                                            editor.selectAll();
                                          }
                                        },
                                        {
                                          name: "centerselection",
                                          bindKey: bindKey(null, "Ctrl-L"),
                                          exec: function(editor) {
                                            editor.centerSelection();
                                          }
                                        },
                                        {
                                          name: "closeOrlevelUp",
                                          bindKey: bindKey("Left", "Left|Ctrl-B"),
                                          exec: function(editor) {
                                            editor.navigateLevelUp(true);
                                          }
                                        },
                                        ,
                                        {
                                          name: "levelUp",
                                          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-B"),
                                          exec: function(editor) {
                                            editor.navigateLevelUp();
                                          }
                                        },
                                        {
                                          name: "levelDown",
                                          bindKey: bindKey("Right", "Right|Ctrl-F"),
                                          exec: function(editor) {
                                            editor.navigateLevelDown();
                                          }
                                        },
                                        {
                                          name: "goToStart",
                                          editorKey: bindKey("Ctrl-Home", "Ctrl-Home"),
                                          bindKey: bindKey("Home|Ctrl-Home", "Home|Ctrl-Home"),
                                          exec: function(editor) {
                                            editor.navigateStart();
                                          }
                                        },
                                        {
                                          name: "goToEnd",
                                          editorKey: bindKey("Ctrl-End", "Ctrl-End"),
                                          bindKey: bindKey("End|Ctrl-End", "End|Ctrl-End"),
                                          exec: function(editor) {
                                            editor.navigateEnd();
                                          }
                                        },
                                        {
                                          name: "closeAllFromSelected",
                                          bindKey: bindKey("Ctrl-Left", "Ctrl-Left"),
                                          exec: function(ed) {
                                            ed.provider.close(ed.selection.getCursor(), true);
                                          }
                                        },
                                        {
                                          name: "openAllFromSelected",
                                          bindKey: bindKey("Ctrl-Right", "Ctrl-Right"),
                                          exec: function(ed) {
                                            ed.provider.open(ed.selection.getCursor(), true);
                                          }
                                        },
                                        {
                                          name: "pageup",
                                          bindKey: "Option-PageUp",
                                          exec: function(editor) {
                                            editor.scrollPageUp();
                                          }
                                        },
                                        {
                                          name: "gotopageup",
                                          bindKey: "PageUp",
                                          exec: function(editor) {
                                            editor.gotoPageUp();
                                          }
                                        },
                                        {
                                          name: "pagedown",
                                          bindKey: "Option-PageDown",
                                          exec: function(editor) {
                                            editor.scrollPageDown();
                                          }
                                        },
                                        {
                                          name: "gotopageDown",
                                          bindKey: "PageDown",
                                          exec: function(editor) {
                                            editor.gotoPageDown();
                                          }
                                        },
                                        {
                                          name: "scrollup",
                                          bindKey: bindKey("Ctrl-Up", null),
                                          exec: function(e) {
                                            e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                                          }
                                        },
                                        {
                                          name: "scrolldown",
                                          bindKey: bindKey("Ctrl-Down", null),
                                          exec: function(e) {
                                            e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                                          }
                                        },
                                        {
                                          name: "insertstring",
                                          exec: function(e, args) {
                                            e.insertSting(args);
                                          }
                                        },
                                        {
                                          name: "goUp",
                                          bindKey: bindKey("Up", "Up|Ctrl-P"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(-1);
                                          }
                                        },
                                        {
                                          name: "goDown",
                                          bindKey: bindKey("Down", "Down|Ctrl-N"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(1);
                                          }
                                        },
                                        {
                                          name: "selectUp",
                                          bindKey: bindKey("Shift-Up", "Shift-Up"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(-1, true);
                                          }
                                        },
                                        {
                                          name: "selectDown",
                                          bindKey: bindKey("Shift-Down", "Shift-Down"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(1, true);
                                          }
                                        },
                                        {
                                          name: "selectToUp",
                                          bindKey: bindKey("Ctrl-Up", "Ctrl-Up"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(-1, false, true);
                                          }
                                        },
                                        {
                                          name: "selectToDown",
                                          bindKey: bindKey("Ctrl-Down", "Ctrl-Down"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(1, false, true);
                                          }
                                        },
                                        {
                                          name: "selectMoreUp",
                                          bindKey: bindKey("Ctrl-Shift-Up", "Ctrl-Shift-Up"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(-1, true, true);
                                          }
                                        },
                                        {
                                          name: "selectMoreDown",
                                          bindKey: bindKey("Ctrl-Shift-Down", "Ctrl-Shift-Down"),
                                          exec: function(editor) {
                                            editor.selection.moveSelection(1, true, true);
                                          }
                                        },
                                        {
                                          name: "rename",
                                          bindKey: "F2",
                                          exec: function(tree) {
                                            tree.edit && tree.edit.startRename();
                                          }
                                        },
                                        {
                                          name: "chose",
                                          bindKey: "Enter",
                                          exec: function(tree) {
                                            tree._emit("afterChoose");
                                          }
                                        },
                                        {
                                          name: "delete",
                                          bindKey: "Delete",
                                          exec: function(tree) {
                                            tree._emit("delete");
                                          }
                                        },
                                        {
                                          name: "foldOther",
                                          bindKey: bindKey("Alt-0", "Command-Option-0"),
                                          exec: function(tree) {
                                            tree.provider.close(tree.provider.root, true);
                                            tree.reveal(tree.selection.getCursor());
                                          }
                                        }
                                      ];
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                614: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "no use strict";
                                      var lang = __webpack_require__22(955);
                                      var oop = __webpack_require__22(645);
                                      var net = __webpack_require__22(552);
                                      var AppConfig = __webpack_require__22(845).o;
                                      module3.exports = exports3 = new AppConfig();
                                      var global = /* @__PURE__ */ function() {
                                        return this;
                                      }();
                                      var options = {
                                        packaged: false,
                                        workerPath: null,
                                        modePath: null,
                                        themePath: null,
                                        basePath: "",
                                        suffix: ".js",
                                        $moduleUrls: {}
                                      };
                                      exports3.get = function(key) {
                                        if (!options.hasOwnProperty(key))
                                          throw new Error("Unknown config key: " + key);
                                        return options[key];
                                      };
                                      exports3.set = function(key, value) {
                                        if (!options.hasOwnProperty(key))
                                          throw new Error("Unknown config key: " + key);
                                        options[key] = value;
                                      };
                                      exports3.all = function() {
                                        return lang.copyObject(options);
                                      };
                                      exports3.moduleUrl = function(name, component) {
                                        if (options.$moduleUrls[name])
                                          return options.$moduleUrls[name];
                                        var parts = name.split("/");
                                        component = component || parts[parts.length - 2] || "";
                                        var base = parts[parts.length - 1].replace(component, "").replace(/(^[\-_])|([\-_]$)/, "");
                                        if (!base && parts.length > 1)
                                          base = parts[parts.length - 2];
                                        var path = options[component + "Path"];
                                        if (path == null)
                                          path = options.basePath;
                                        if (path && path.slice(-1) != "/")
                                          path += "/";
                                        return path + component + "-" + base + this.get("suffix");
                                      };
                                      exports3.setModuleUrl = function(name, subst) {
                                        return options.$moduleUrls[name] = subst;
                                      };
                                      exports3.$loading = {};
                                      exports3.loadModule = function(moduleName, onLoad) {
                                        debugger;
                                      };
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                768: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      exports3.isDark = false;
                                      exports3.cssClass = "ace_tree-light";
                                      exports3.cssText = __webpack_require__22(28);
                                      var dom = __webpack_require__22(435);
                                      dom.importCssString(exports3.cssText, exports3.cssClass);
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                950: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var Scrollable = __webpack_require__22(541);
                                      var dom = __webpack_require__22(435);
                                      var escapeHTML = __webpack_require__22(955).escapeHTML;
                                      var DataProvider = function(root) {
                                        this.rowHeight = 25;
                                        this.setRoot(root);
                                      };
                                      (function() {
                                        this.rowHeight = void 0;
                                        this.rowHeightInner = void 0;
                                        this.$indentSize = 10;
                                        oop.implement(this, Scrollable);
                                        this.$sortNodes = true;
                                        this.setRoot = function(root) {
                                          if (Array.isArray(root))
                                            root = {
                                              items: root
                                            };
                                          this.root = root || {};
                                          if (this.root.$depth == void 0) {
                                            this.root.$depth = -1;
                                          }
                                          if (this.root.$depth < 0) {
                                            this.visibleItems = [];
                                            this.open(this.root);
                                            this.visibleItems.unshift();
                                          } else {
                                            this.visibleItems = [
                                              this.root
                                            ];
                                          }
                                          this.$selectedNode = this.root;
                                          this._signal("setRoot");
                                          this._signal("change");
                                        };
                                        this.open = this.expand = function(node, deep, silent) {
                                          if (typeof deep != "number")
                                            deep = deep ? 100 : 0;
                                          if (!node)
                                            return;
                                          var items = this.visibleItems;
                                          if (this.isOpen(node) && (node !== this.root || items.length))
                                            return;
                                          var ch = this.getChildren(node);
                                          if (this.loadChildren && this.shouldLoadChildren(node, ch)) {
                                            var timer = setTimeout(function() {
                                              node.status = "loading";
                                              this._signal("change", node);
                                            }.bind(this), 100);
                                            this.loadChildren(node, function(err, ch2) {
                                              clearTimeout(timer);
                                              this.collapse(node, null, true);
                                              node.status = "loaded";
                                              if (!err)
                                                this.expand(node, null, false);
                                            }.bind(this));
                                            this.setOpen(node, true);
                                            return;
                                          }
                                          this.setOpen(node, true);
                                          var i = items.indexOf(node);
                                          if (!ch) {
                                            this._signal("change", node);
                                            return;
                                          }
                                          if (i === -1 && items.length || this.forceEmpty)
                                            return;
                                          ch = [
                                            i + 1,
                                            0
                                          ].concat(ch);
                                          items.splice.apply(items, ch);
                                          for (var j = 2; j < ch.length; j++) {
                                            var childNode = ch[j];
                                            if (this.isOpen(childNode)) {
                                              this.setOpen(childNode, false);
                                              this.open(childNode, deep - 1, silent);
                                            } else if (deep > 0) {
                                              this.open(childNode, deep - 1, silent);
                                            }
                                          }
                                          this.rows = items.length;
                                          silent || this._signal("expand", node);
                                        };
                                        this.close = this.collapse = function(node, deep, silent) {
                                          if (typeof deep != "number")
                                            deep = deep ? 1e3 : 0;
                                          var items = this.visibleItems;
                                          var isRoot = node === this.root;
                                          if (isRoot) {
                                            this.setOpen(node, false);
                                            if (deep) {
                                              for (var i = 0; i < items.length; i++) {
                                                var ch = items[i];
                                                if (!ch.isRoot) {
                                                  if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                                                    this.setOpen(ch, false);
                                                    silent || this._signal("collapse", ch);
                                                  }
                                                }
                                              }
                                            }
                                            items.length = 0;
                                            if (isRoot)
                                              this.open(this.root, 0, silent);
                                            return;
                                          }
                                          if (!node || !this.isOpen(node))
                                            return;
                                          var i = items.indexOf(node);
                                          if (i === -1)
                                            return;
                                          var thisDepth = node.$depth;
                                          var deletecount = 0;
                                          for (var t = i + 1; t < items.length; t++) {
                                            if (items[t].$depth > thisDepth)
                                              deletecount++;
                                            else
                                              break;
                                          }
                                          if (deep) {
                                            for (var j = 0; j < deletecount; j++) {
                                              var ch = items[j + i];
                                              if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                                                this.setOpen(ch, false);
                                                silent || this._signal("collapse", ch);
                                              }
                                            }
                                          }
                                          items.splice(i + 1, deletecount);
                                          this.setOpen(node, false);
                                          silent || this._signal("collapse", node);
                                          if (isRoot)
                                            this.open(this.root, 0, silent);
                                        };
                                        this.toggleNode = function(node, deep, silent) {
                                          if (node && this.isOpen(node))
                                            this.close(node, deep, silent);
                                          else
                                            this.open(node, deep, silent);
                                        };
                                        this.sort = function(children, compare) {
                                          if (!compare) {
                                            compare = alphanumCompare;
                                          }
                                          return children.sort(function(a, b) {
                                            var aChildren = a.children || a.map;
                                            var bChildren = b.children || b.map;
                                            if (aChildren && !bChildren)
                                              return -1;
                                            if (!aChildren && bChildren)
                                              return 1;
                                            return compare(a.label || "", b.label || "");
                                          });
                                        };
                                        this.setFilter = function(fn) {
                                          this.$filterFn = fn;
                                          this.setRoot(this.root);
                                        };
                                        this.getChildren = function(node) {
                                          var children = node.children;
                                          if (!children) {
                                            if (node.status === "pending")
                                              return;
                                            if (node.map) {
                                              children = Object.keys(node.map).map(function(key) {
                                                var ch2 = node.map[key];
                                                ch2.parent = node;
                                                return ch2;
                                              });
                                            } else if (node.items) {
                                              children = node.items;
                                            }
                                            if (children) {
                                              node.children = children;
                                            }
                                          }
                                          var ch = children && children[0] && children[0];
                                          if (ch) {
                                            var d = node.$depth + 1 || 0;
                                            children.forEach(function(n) {
                                              n.$depth = d;
                                              n.parent = node;
                                            });
                                          }
                                          if (this.$filterFn) {
                                            children = children && children.filter(this.$filterFn);
                                          }
                                          if (this.$sortNodes && !node.$sorted) {
                                            children && this.sort(children);
                                          }
                                          return children;
                                        };
                                        this.loadChildren = null;
                                        this.shouldLoadChildren = function(node, ch) {
                                          return node.status === "pending";
                                        };
                                        this.hasChildren = function(node) {
                                          if (node.children)
                                            return node.children.length !== 0;
                                          return node.map || node.status === "pending" || node.items && node.items.length;
                                        };
                                        this.findNodeByPath = function() {
                                        };
                                        this.getSibling = function(node, dir) {
                                          if (!dir)
                                            dir = 1;
                                          var parent = node.parent;
                                          var ch = this.getChildren(parent);
                                          var pos = ch.indexOf(node);
                                          return ch[pos + dir];
                                        };
                                        this.getNodeAtIndex = function(i) {
                                          return this.visibleItems[i];
                                        };
                                        this.getIndexForNode = function(node) {
                                          return this.visibleItems.indexOf(node);
                                        };
                                        this.getMinIndex = function() {
                                          return 0;
                                        };
                                        this.getMaxIndex = function() {
                                          return this.visibleItems.length - 1;
                                        };
                                        this.setOpen = function(node, val) {
                                          return node.isOpen = val;
                                        };
                                        this.isOpen = function(node) {
                                          return node.isOpen;
                                        };
                                        this.isVisible = function(node) {
                                          return this.visibleItems.indexOf(node) !== -1;
                                        };
                                        this.isSelected = function(node) {
                                          return node.isSelected;
                                        };
                                        this.setSelected = function(node, val) {
                                          return node.isSelected = !!val;
                                        };
                                        this.isSelectable = function(node) {
                                          return !node || !(node.noSelect || node.$depth < 0);
                                        };
                                        this.isAncestor = function(node, child) {
                                          do {
                                            if (child == node)
                                              return true;
                                          } while (child = child.parent);
                                          return false;
                                        };
                                        this.setAttribute = function(node, name, value) {
                                          node[name] = value;
                                          this._signal("change", node);
                                        };
                                        this.getDataRange = function(rows, columns, callback) {
                                          var view = this.visibleItems.slice(rows.start, rows.start + rows.length);
                                          callback(null, view, false);
                                          return view;
                                        };
                                        this.getRange = function(top, bottom) {
                                          var start = Math.floor(top / this.rowHeight);
                                          var end = Math.ceil(bottom / this.rowHeight) + 1;
                                          var range = this.visibleItems.slice(start, end);
                                          range.count = start;
                                          range.size = this.rowHeight * range.count;
                                          return range;
                                        };
                                        this.getTotalHeight = function(top, bottom) {
                                          return this.rowHeight * this.visibleItems.length;
                                        };
                                        this.getNodePosition = function(node) {
                                          var i = this.visibleItems.indexOf(node);
                                          if (i == -1 && node && node.parent) {
                                            i = this.visibleItems.indexOf(node.parent);
                                          }
                                          var top = i * this.rowHeight;
                                          var height = this.rowHeight;
                                          return {
                                            top,
                                            height
                                          };
                                        };
                                        this.findItemAtOffset = function(offset, clip) {
                                          var index = Math.floor(offset / this.rowHeight);
                                          if (clip)
                                            index = Math.min(Math.max(0, index), this.visibleItems.length - 1);
                                          return this.visibleItems[index];
                                        };
                                        this.getIconHTML = function(node) {
                                          return "";
                                        };
                                        this.getClassName = function(node) {
                                          return (node.className || "") + (node.status == "loading" ? " loading" : "");
                                        };
                                        this.setClass = function(node, name, include) {
                                          node.className = node.className || "";
                                          dom.setCssClass(node, name, include);
                                          this._signal("changeClass");
                                        };
                                        this.redrawNode = null;
                                        this.getCaptionHTML = function(node) {
                                          return escapeHTML(node.label || node.name || (typeof node == "string" ? node : ""));
                                        };
                                        this.getContentHTML = null;
                                        this.getEmptyMessage = function() {
                                          return this.emptyMessage || "";
                                        };
                                        this.getText = function(node) {
                                          return node.label || node.name || "";
                                        };
                                        this.getRowIndent = function(node) {
                                          return node.$depth;
                                        };
                                        this.hideAllNodes = function() {
                                          this.visibleItems = [];
                                          this.forceEmpty = true;
                                          this.setRoot(this.root);
                                        };
                                        this.showAllNodes = function() {
                                          this.forceEmpty = false;
                                          this.setRoot(this.root);
                                        };
                                      }).call(DataProvider.prototype);
                                      function alphanumCompare(a, b) {
                                        var caseOrder = 0;
                                        for (var x = 0, l = Math.min(a.length, b.length); x < l; x++) {
                                          var ch1 = a.charCodeAt(x);
                                          var ch2 = b.charCodeAt(x);
                                          if (ch1 < 58 && ch2 < 58 && ch1 > 47 && ch2 > 47) {
                                            var num1 = 0, num2 = 0;
                                            var n = x;
                                            do {
                                              num1 = 10 * num1 + (ch1 - 48);
                                              ch1 = a.charCodeAt(++n);
                                            } while (ch1 > 47 && ch1 < 58);
                                            n = x;
                                            do {
                                              num2 = 10 * num2 + (ch2 - 48);
                                              ch2 = b.charCodeAt(++n);
                                            } while (ch2 > 47 && ch2 < 58);
                                            if (num1 === num2)
                                              x = n - 1;
                                            else
                                              return num1 - num2;
                                          } else if (ch1 !== ch2) {
                                            var ch1L = a[x].toLowerCase();
                                            var ch2L = b[x].toLowerCase();
                                            if (ch1L < ch2L)
                                              return -1;
                                            if (ch1L > ch2L)
                                              return 1;
                                            if (!caseOrder)
                                              caseOrder = ch2 - ch1;
                                          }
                                        }
                                        return caseOrder || a.length - b.length;
                                      }
                                      DataProvider.alphanumCompare = alphanumCompare;
                                      DataProvider.prototype.alphanumCompare = alphanumCompare;
                                      DataProvider.variableHeightRowMixin = function() {
                                        var reset = function() {
                                          this.$cachedTotalHeight = 0;
                                        }.bind(this);
                                        this.on("collapse", reset);
                                        this.on("expand", reset);
                                        this.getNodePosition = function(node) {
                                          var i = this.visibleItems.indexOf(node);
                                          if (i == -1 && node && node.parent) {
                                            i = this.visibleItems.indexOf(node.parent);
                                          }
                                          var items = this.visibleItems;
                                          var top = 0, height = 0;
                                          for (var index = 0; index < i; index++) {
                                            height = this.getItemHeight(items[index], index);
                                            top += height;
                                          }
                                          height = this.getItemHeight(items[i], i);
                                          return {
                                            top,
                                            height
                                          };
                                        };
                                        this.findIndexAtOffset = function(offset, clip) {
                                          var items = this.visibleItems;
                                          var top = 0, index = 0, l = items.length;
                                          while (index < l) {
                                            var height = this.getItemHeight(items[index], index);
                                            top += height;
                                            index++;
                                            if (top >= offset) {
                                              index--;
                                              top -= height;
                                              break;
                                            }
                                          }
                                          if (clip)
                                            index = Math.min(Math.max(0, index), items.length - 1);
                                          return index;
                                        };
                                        this.findItemAtOffset = function(offset, clip) {
                                          var index = this.findIndexAtOffset(offset, clip);
                                          return this.visibleItems[index];
                                        };
                                        this.getItemHeight = function(node, index) {
                                          return node.height || this.rowHeight;
                                        };
                                        this.getRange = function(top, bottom) {
                                          var items = this.visibleItems;
                                          var startH = 0, index = 0, l = items.length;
                                          while (index < l) {
                                            var height = this.getItemHeight(items[index], index);
                                            startH += height;
                                            index++;
                                            if (startH >= top) {
                                              index--;
                                              startH -= height;
                                              break;
                                            }
                                          }
                                          index = Math.min(Math.max(0, index), items.length - 1);
                                          var start = index;
                                          var end = this.findIndexAtOffset(bottom, true) + 1;
                                          var range = this.visibleItems.slice(start, end);
                                          range.count = start;
                                          range.size = startH;
                                          return range;
                                        };
                                        this.getTotalHeight = function() {
                                          if (!this.$cachedTotalHeight) {
                                            var items = this.visibleItems;
                                            var height = 0;
                                            for (var index = 0; index < items.length; index++) {
                                              height += this.getItemHeight(items[index], index);
                                            }
                                            this.$cachedTotalHeight = height;
                                          }
                                          return this.$cachedTotalHeight;
                                        };
                                      };
                                      module3.exports = DataProvider;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                365: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var dom = __webpack_require__22(435);
                                      var lang = __webpack_require__22(955);
                                      var escapeHTML = lang.escapeHTML;
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var Cells = function(parentEl) {
                                        this.element = dom.createElement("div");
                                        this.element.className = "ace_tree_layer ace_tree_cell-layer";
                                        parentEl.appendChild(this.element);
                                      };
                                      (function() {
                                        oop.implement(this, EventEmitter);
                                        this.config = {}, this.setDataProvider = function(provider) {
                                          this.provider = provider;
                                          if (provider)
                                            this.update = provider.renderRow ? this.$customUpdate : this.$treeModeUpdate;
                                        };
                                        this.update = function(config) {
                                        };
                                        this.measureSizes = function() {
                                          var domNode = this.element.firstChild;
                                          if (domNode) {
                                            this.provider.rowHeight = domNode.offsetHeight;
                                            this.provider.rowHeightInner = domNode.clientHeight;
                                          }
                                        };
                                        this.$treeModeUpdate = function(config) {
                                          this.config = config;
                                          var provider = this.provider;
                                          var row, html = [], view = config.view, datarow;
                                          var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                                          var hsize = "auto;", vsize = provider.rowHeightInner || provider.rowHeight;
                                          for (row = firstRow; row < lastRow; row++) {
                                            datarow = view[row - firstRow];
                                            if (provider.getItemHeight)
                                              vsize = provider.getItemHeight(datarow, row);
                                            this.$renderRow(html, datarow, vsize, hsize, row);
                                          }
                                          if (firstRow <= 0 && lastRow <= 0) {
                                            this.renderPlaceHolder(provider, html, config);
                                          }
                                          this.element.innerHTML = html.join("");
                                          if (!vsize) {
                                            this.measureSizes();
                                          }
                                        };
                                        this.columnNode = function(datarow, column) {
                                          return "<span class='tree-column " + (column.className || "") + "' style='" + (datarow.fullWidth ? "" : "width:" + column.$width + ";") + "'>";
                                        };
                                        this.getRowClass = function(datarow, row) {
                                          var provider = this.provider;
                                          return "tree-row " + (provider.isSelected(datarow) ? "selected " : "") + (provider.getClassName(datarow) || "") + (row & 1 ? " odd" : " even");
                                        };
                                        this.$renderRow = function(html, datarow, vsize, hsize, row) {
                                          var provider = this.provider;
                                          var columns = provider.columns;
                                          var indent = provider.$indentSize;
                                          html.push("<div style='height:" + vsize + "px;" + (columns ? "padding-right:" + columns.$fixedWidth : "") + "' class='" + this.getRowClass(datarow, row) + "'>");
                                          if (!columns || columns[0].type == "tree") {
                                            if (columns) {
                                              html.push(this.columnNode(datarow, columns[0], row));
                                            }
                                            var depth = provider.getRowIndent(datarow);
                                            html.push((depth ? "<span style='width:" + depth * indent + "px' class='tree-indent'></span>" : "") + "<span class='toggler " + (provider.hasChildren(datarow) ? provider.isOpen(datarow) ? "open" : "closed" : "empty") + "'></span>" + (provider.getCheckboxHTML ? provider.getCheckboxHTML(datarow) : "") + provider.getIconHTML(datarow) + (provider.getContentHTML ? provider.getContentHTML(datarow) : "<span class='caption' style='width: " + hsize + "px;height: " + vsize + "px'>" + provider.getCaptionHTML(datarow) + "</span>"));
                                          }
                                          if (columns) {
                                            for (var col = columns[0].type == "tree" ? 1 : 0; col < columns.length; col++) {
                                              var column = columns[col];
                                              var rowStr = column.getHTML ? column.getHTML(datarow) : escapeHTML(column.getText(datarow) + "");
                                              html.push("</span>" + this.columnNode(datarow, column, row) + rowStr);
                                            }
                                            html.push("</span>");
                                          }
                                          html.push("</div>");
                                        };
                                        this.$customUpdate = function(config) {
                                          this.config = config;
                                          var provider = this.provider;
                                          var html = [];
                                          var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                                          for (var row = firstRow; row < lastRow; row++) {
                                            provider.renderRow(row, html, config);
                                          }
                                          if (firstRow <= 0 && lastRow <= 0) {
                                            this.renderPlaceHolder(provider, html, config);
                                          }
                                          this.element.innerHTML = html.join("");
                                        };
                                        this.updateClasses = function(config) {
                                          if (this.update == this.$customUpdate && !this.provider.updateNode)
                                            return this.update(config);
                                          this.config = config;
                                          var provider = this.provider;
                                          var row, view = config.view, datarow;
                                          var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                                          var children = this.element.children;
                                          if (children.length != lastRow - firstRow)
                                            return this.update(config);
                                          for (row = firstRow; row < lastRow; row++) {
                                            datarow = view[row - firstRow];
                                            var el = children[row - firstRow];
                                            el.className = this.getRowClass(datarow, row);
                                            if (provider.redrawNode)
                                              provider.redrawNode(el, datarow);
                                          }
                                        };
                                        this.scroll = function(config) {
                                          return this.update(config);
                                          this.element.insertAdjacentHTML("afterBegin", "<span>a</span><s>r</s>");
                                          this.element.insertAdjacentHTML("beforeEnd", "<span>a</span><s>r</s>");
                                        };
                                        this.updateRows = function(config, firstRow, lastRow) {
                                        };
                                        this.destroy = function() {
                                        };
                                        this.getDomNodeAtIndex = function(i) {
                                          return this.element.children[i - this.config.firstRow];
                                        };
                                        this.renderPlaceHolder = function(provider, html, config) {
                                          if (provider.renderEmptyMessage) {
                                            provider.renderEmptyMessage(html, config);
                                          } else if (provider.getEmptyMessage) {
                                            html.push("<div class='message empty'>", escapeHTML(provider.getEmptyMessage()), "</div>");
                                          }
                                        };
                                      }).call(Cells.prototype);
                                      exports3.Cells = Cells;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                86: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var dom = __webpack_require__22(435);
                                      var lang = __webpack_require__22(955);
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var RESIZER_WIDTH = 3;
                                      function getColumnText(node) {
                                        return node[this.value] || this.defaultValue || "";
                                      }
                                      function ColumnHeader(parentEl, renderer) {
                                        this.element = dom.createElement("div");
                                        parentEl.appendChild(this.element);
                                        this.element.className = "tree-headings";
                                        this.visible = false;
                                      }
                                      (function() {
                                        this.minWidth = 25;
                                        this.update = function() {
                                          if (!this.provider || !this.visible)
                                            return;
                                          var columns = this.provider.columns;
                                          var html = [];
                                          for (var i = 0; i < columns.length; i++) {
                                            var col = columns[i];
                                            html.push("<span class='tree-column " + (col.className || "") + "' style='width:" + col.$width + ";height:'>" + col.caption + "</span><span class='tree-column-resizer' ></span>");
                                          }
                                          this.element.style.paddingRight = columns.$fixedWidth;
                                          this.element.innerHTML = html.join("");
                                        };
                                        this.setDataProvider = function(provider) {
                                          this.provider = provider;
                                          if (!provider)
                                            return;
                                          var columns = this.provider.columns;
                                          if (!columns) {
                                            this.visible = false;
                                            return;
                                          }
                                          this.visible = true;
                                          var fixedWidth = 0;
                                          columns.forEach(function(col, i) {
                                            col.index = i;
                                            if (col.value && !col.getText)
                                              col.getText = getColumnText;
                                            var w = col.width;
                                            if (typeof w == "string" && w.slice(-1) == "%") {
                                              col.flex = parseInt(w, 10) / 100;
                                              col.$width = col.width;
                                            } else {
                                              col.width = parseInt(w, 10) || this.minWidth;
                                              fixedWidth += col.width;
                                              col.$width = col.width + "px";
                                            }
                                            col.pixelWidth = 0;
                                          }, this);
                                          columns.fixedWidth = fixedWidth;
                                          columns.$fixedWidth = fixedWidth + "px";
                                          columns.width = null;
                                          provider.columns = columns;
                                        };
                                        this.updateWidth = function(width) {
                                          if (!this.provider || !this.visible)
                                            return;
                                          var columns = this.provider.columns;
                                          var fixedWidth = 0;
                                          columns.width = width;
                                          columns.forEach(function(col) {
                                            if (!col.flex) {
                                              fixedWidth += col.width;
                                            }
                                          });
                                          var flexWidth = width - fixedWidth;
                                          columns.forEach(function(col) {
                                            if (col.flex) {
                                              col.pixelWidth = flexWidth * col.flex;
                                              col.$width = col.flex * 100 + "%";
                                            } else {
                                              col.pixelWidth = col.width;
                                              col.$width = col.width + "px";
                                            }
                                          });
                                          columns.fixedWidth = fixedWidth;
                                          columns.$fixedWidth = fixedWidth + "px";
                                        };
                                        this.changeColumnWidth = function(changedColumn, dw, total) {
                                          this.updateWidth(total);
                                          var columns = this.provider.columns;
                                          var minWidth = this.minWidth;
                                          if (!dw)
                                            return;
                                          var index = columns.indexOf(changedColumn);
                                          var col, nextCol, prevCol;
                                          for (var i = index + 1; i < columns.length; i++) {
                                            col = columns[i];
                                            if (Math.floor(col.pixelWidth) > minWidth || dw < 0) {
                                              if (col.flex) {
                                                nextCol = col;
                                                break;
                                              } else if (!nextCol) {
                                                nextCol = col;
                                              }
                                            }
                                          }
                                          for (var i = index; i >= 0; i--) {
                                            col = columns[i];
                                            if (Math.floor(col.pixelWidth) > minWidth || dw > 0) {
                                              if (col.flex) {
                                                prevCol = col;
                                                break;
                                              } else if (!prevCol) {
                                                prevCol = col;
                                                if (col == changedColumn)
                                                  break;
                                              }
                                            }
                                          }
                                          if (!prevCol || !nextCol)
                                            return;
                                          if (nextCol.pixelWidth - dw < minWidth)
                                            dw = nextCol.pixelWidth - minWidth;
                                          if (prevCol.pixelWidth + dw < minWidth)
                                            dw = minWidth - prevCol.pixelWidth;
                                          nextCol.pixelWidth -= dw;
                                          prevCol.pixelWidth += dw;
                                          if (!nextCol.flex)
                                            columns.fixedWidth -= dw;
                                          if (!prevCol.flex)
                                            columns.fixedWidth += dw;
                                          var flexWidth = total - columns.fixedWidth;
                                          columns.forEach(function(col2) {
                                            if (col2.flex) {
                                              col2.flex = col2.pixelWidth / flexWidth;
                                            } else {
                                              col2.width = col2.pixelWidth;
                                            }
                                          });
                                          this.updateWidth(total);
                                        };
                                        this.findColumn = function(x) {
                                          var columns = this.provider.columns;
                                          if (this.element.offsetWidth != columns.width)
                                            this.updateWidth(this.element.offsetWidth);
                                          var w = 0;
                                          for (var i = 0; i < columns.length; i++) {
                                            var column = columns[i];
                                            w += column.pixelWidth;
                                            if (x < w + RESIZER_WIDTH) {
                                              return {
                                                index: i,
                                                column,
                                                overResizer: x > w - RESIZER_WIDTH
                                              };
                                            }
                                          }
                                        };
                                      }).call(ColumnHeader.prototype);
                                      exports3.ColumnHeader = ColumnHeader;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                611: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var dom = __webpack_require__22(435);
                                      var Selection = function(parentEl, renderer) {
                                        this.element = dom.createElement("div");
                                        this.element.className = "ace_tree_layer ace_tree_selection-layer";
                                        parentEl.appendChild(this.element);
                                        this.renderer = renderer;
                                        this.markerEl = null;
                                        this.arrowEl = null;
                                      };
                                      (function() {
                                        this.setDataProvider = function(provider) {
                                          this.provider = provider;
                                        };
                                        this.update = function(config) {
                                          if (!this.provider.markedFolder || this.provider.markedFolderType) {
                                            this.markerEl && this.clearFolderMarker();
                                          } else {
                                            this.showFolderMarker(config);
                                          }
                                          if (!this.provider.markedFolder || !this.provider.markedFolderType) {
                                            this.arrowEl && this.clearInsertionMarker();
                                          } else {
                                            this.showInsertionMarker(config);
                                          }
                                        };
                                        this.showFolderMarker = function(config) {
                                          this.config = config;
                                          var provider = this.provider;
                                          var node = provider.markedFolder;
                                          var start = provider.getIndexForNode(node);
                                          var items = provider.visibleItems;
                                          var end = start + 1;
                                          var depth = node.$depth;
                                          while (items[end] && items[end].$depth > depth) {
                                            end++;
                                          }
                                          end--;
                                          if (start > config.lastRow || end < config.firstRow || start === end) {
                                            return this.clearFolderMarker();
                                          }
                                          start++;
                                          end++;
                                          var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                                          var left = (depth + 1) * provider.$indentSize;
                                          var bottom = Math.min(end - config.firstRow, config.lastRow - config.firstRow + 2) * provider.rowHeight;
                                          if (!this.markerEl) {
                                            this.markerEl = dom.createElement("div");
                                            this.markerEl.className = "dragHighlight";
                                            this.element.appendChild(this.markerEl);
                                          }
                                          this.markerEl.style.top = top + "px";
                                          this.markerEl.style.left = left + "px";
                                          this.markerEl.style.right = "7px";
                                          this.markerEl.style.height = bottom - top + "px";
                                        };
                                        this.showInsertionMarker = function(config) {
                                          this.config = config;
                                          var provider = this.provider;
                                          var node = provider.markedFolder;
                                          var type = this.provider.markedFolderType;
                                          var start = provider.getIndexForNode(node);
                                          var depth = node.$depth;
                                          if (start > config.lastRow || start < config.firstRow) {
                                            return this.clearInsertionMarker();
                                          }
                                          if (type == 1)
                                            start++;
                                          var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                                          var left = (depth + 1) * provider.$indentSize;
                                          if (!this.arrowEl) {
                                            this.arrowEl = dom.createElement("div");
                                            this.arrowEl.className = "dragArrow";
                                            this.element.appendChild(this.arrowEl);
                                          }
                                          this.arrowEl.style.top = top + "px";
                                          this.arrowEl.style.left = left + "px";
                                          this.arrowEl.style.right = "7px";
                                        };
                                        this.clearFolderMarker = function() {
                                          if (this.markerEl) {
                                            this.markerEl.parentNode.removeChild(this.markerEl);
                                            this.markerEl = null;
                                          }
                                        };
                                        this.clearInsertionMarker = function() {
                                          if (this.arrowEl) {
                                            this.arrowEl.parentNode.removeChild(this.arrowEl);
                                            this.arrowEl = null;
                                          }
                                        };
                                        this.clear = function() {
                                          this.clearFolderMarker();
                                          this.clearInsertMarker();
                                        };
                                        this.destroy = function() {
                                        };
                                      }).call(Selection.prototype);
                                      exports3.Selection = Selection;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                127: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var dom = __webpack_require__22(435);
                                      var DRAG_OFFSET = 5;
                                      function DefaultHandlers(mouseHandler) {
                                        mouseHandler.$clickSelection = null;
                                        var editor = mouseHandler.editor;
                                        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                                        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                                        editor.setDefaultHandler("mouseleave", this.onMouseLeave.bind(mouseHandler));
                                        editor.setDefaultHandler("mousemove", this.onMouseMove.bind(mouseHandler));
                                        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                                        editor.setDefaultHandler("mouseup", this.onMouseUp.bind(mouseHandler));
                                        editor.setDefaultHandler("click", this.onClick.bind(mouseHandler));
                                        var exports4 = [
                                          "dragMoveSelection",
                                          "dragWait",
                                          "dragWaitEnd",
                                          "getRegion",
                                          "updateHoverState"
                                        ];
                                        exports4.forEach(function(x) {
                                          mouseHandler[x] = this[x];
                                        }, this);
                                      }
                                      (function() {
                                        function isTogglerClick(target) {
                                          return dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                                        }
                                        this.onMouseMove = function(e) {
                                          var editor = this.editor;
                                          var node = e.getNode();
                                          var title, provider = editor.provider;
                                          if (!node) {
                                            title = "";
                                          } else if (provider.columns) {
                                            var pos = e.getDocumentPosition();
                                            var columnData = editor.renderer.$headingLayer.findColumn(pos.x);
                                            title = columnData ? columnData.column.getText(node) : "";
                                          } else {
                                            title = provider.getTooltipText ? provider.getTooltipText(node) : provider.getText(node);
                                          }
                                          if (!editor.tooltip && editor.container.title != title)
                                            editor.container.title = title;
                                          this.updateHoverState(node);
                                        };
                                        this.onMouseLeave = function() {
                                          this.updateHoverState(null);
                                        };
                                        this.updateHoverState = function(node) {
                                          var provider = this.editor.provider;
                                          if (node !== this.node && provider) {
                                            if (this.node)
                                              provider.setClass(this.node, "hover", false);
                                            this.node = node;
                                            if (this.node)
                                              provider.setClass(this.node, "hover", true);
                                          }
                                        };
                                        this.onMouseDown = function(ev) {
                                          var editor = this.editor;
                                          var provider = editor.provider;
                                          ev.detail = 1;
                                          this.mousedownEvent = ev;
                                          this.delayedSelect = false;
                                          this.isMousePressed = true;
                                          var button = ev.getButton();
                                          var selectedNodes = editor.selection.getSelectedNodes();
                                          var isMultiSelect = selectedNodes.length > 1;
                                          if (button !== 0 && isMultiSelect) {
                                            return;
                                          }
                                          var node = ev.getNode();
                                          this.$clickNode = node;
                                          if (!node)
                                            return;
                                          var inSelection = provider.isSelected(node);
                                          var target = ev.domEvent.target;
                                          this.region = null;
                                          if (isTogglerClick(target) || node.clickAction == "toggle") {
                                            this.region = "toggler";
                                            var toggleChildren = ev.getShiftKey();
                                            var deep = ev.getAccelKey();
                                            if (button === 0) {
                                              if (toggleChildren) {
                                                if (deep) {
                                                  node = node.parent;
                                                }
                                                provider.close(node, true);
                                                provider.open(node);
                                              } else {
                                                provider.toggleNode(node, deep);
                                              }
                                            }
                                            this.$clickNode = null;
                                          } else if (dom.hasCssClass(target, "checkbox")) {
                                            var nodes = inSelection && editor.selection.getSelectedNodes();
                                            provider._signal("toggleCheckbox", {
                                              target: node,
                                              selectedNodes: nodes
                                            });
                                            node.isChecked = !node.isChecked;
                                            if (nodes) {
                                              nodes.forEach(function(n) {
                                                n.isChecked = node.isChecked;
                                              });
                                            }
                                            provider._signal(node.isChecked ? "check" : "uncheck", nodes || [
                                              node
                                            ]);
                                            provider._signal("change");
                                          } else if (dom.hasCssClass(target, "icon-ok")) {
                                            if (ev.getShiftKey()) {
                                              editor.selection.expandSelection(node, null, true);
                                            } else {
                                              editor.selection.toggleSelect(node);
                                            }
                                          } else if (ev.getAccelKey()) {
                                            if (inSelection && isMultiSelect)
                                              this.delayedSelect = "toggle";
                                            else if (!inSelection || isMultiSelect)
                                              editor.selection.toggleSelect(node);
                                          } else if (ev.getShiftKey()) {
                                            editor.selection.expandSelection(node);
                                          } else if (inSelection && isMultiSelect) {
                                            if (!editor.isFocused())
                                              this.$clickNode = null;
                                            else
                                              this.delayedSelect = true;
                                          } else {
                                            editor.selection.setSelection(node);
                                          }
                                          if (this.$clickNode)
                                            editor.$mouseHandler.captureMouse(ev, "dragWait");
                                          return ev.preventDefault();
                                        };
                                        this.onMouseUp = function(ev) {
                                          if (this.isMousePressed == 2)
                                            return;
                                          this.isMousePressed = false;
                                          var pos = ev.getDocumentPosition();
                                          var node = this.editor.provider.findItemAtOffset(pos.y);
                                          if (node && this.$clickNode && this.$clickNode == node) {
                                            ev.button = ev.getButton();
                                            ev.target = ev.domEvent.target;
                                            ev.detail = this.mousedownEvent.detail;
                                            this.onMouseEvent("click", ev);
                                          }
                                          this.$clickNode = this.mouseEvent = null;
                                        };
                                        this.onClick = function(ev) {
                                          if (this.mousedownEvent.detail === 2) {
                                            this.editor._emit("afterChoose");
                                          }
                                        };
                                        this.onDoubleClick = function(ev) {
                                          var provider = this.editor.provider;
                                          if (provider.toggleNode && !isTogglerClick(ev.domEvent.target)) {
                                            var node = ev.getNode();
                                            if (node)
                                              provider.toggleNode(node);
                                          }
                                          if (this.mousedownEvent)
                                            this.mousedownEvent.detail = 2;
                                        };
                                        this.dragMoveSelection = function() {
                                          var editor = this.editor;
                                          var ev = this.mouseEvent;
                                          ev.$pos = ev.node = null;
                                          var node = ev.getNode(true);
                                          if (node != editor.selection.getCursor() && node) {
                                            if (ev.getShiftKey()) {
                                              editor.selection.expandSelection(node, null, true);
                                            } else {
                                              editor.selection.selectNode(node);
                                            }
                                            editor.renderer.scrollCaretIntoView();
                                          }
                                        };
                                        this.dragWait = function() {
                                          var ev = this.mousedownEvent;
                                          if (Math.abs(this.x - ev.x) + Math.abs(this.y - ev.y) > DRAG_OFFSET) {
                                            this.delayedSelect = false;
                                            this.editor._emit("startDrag", ev);
                                            if (this.state == "dragWait" && ev.getButton() === 0)
                                              this.setState("dragMoveSelection");
                                          }
                                        };
                                        this.dragWaitEnd = function() {
                                          if (this.delayedSelect) {
                                            var selection = this.editor.selection;
                                            if (this.$clickNode) {
                                              if (this.delayedSelect == "toggle")
                                                selection.toggleSelect(this.$clickNode);
                                              else
                                                selection.setSelection(this.$clickNode);
                                            }
                                            this.delayedSelect = false;
                                          }
                                        };
                                        this.onMouseWheel = function(ev) {
                                          if (ev.getShiftKey() || ev.getAccelKey())
                                            return;
                                          var t = ev.domEvent.timeStamp;
                                          var dt = t - (this.$lastScrollTime || 0);
                                          var editor = this.editor;
                                          var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                          if (isScrolable || dt < 200) {
                                            this.$lastScrollTime = t;
                                            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                            return ev.stop();
                                          }
                                        };
                                      }).call(DefaultHandlers.prototype);
                                      exports3.DefaultHandlers = DefaultHandlers;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                513: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var event = __webpack_require__22(631);
                                      var useragent = __webpack_require__22(943);
                                      var DefaultHandlers = __webpack_require__22(127).DefaultHandlers;
                                      var MouseEvent = __webpack_require__22(118).MouseEvent;
                                      var config = __webpack_require__22(614);
                                      var dom = __webpack_require__22(435);
                                      function initDragHandlers(mouseHandler) {
                                        var tree = mouseHandler.editor;
                                        var UNFOLD_TIMEOUT = 500;
                                        var WIDGET_UNFOLD_TIMEOUT = 500;
                                        var AUTOSCROLL_DELAY = 300;
                                        var MIN_DRAG_T = 500;
                                        var dragInfo, x, y, dx, dy;
                                        var scrollerRect;
                                        mouseHandler.drag = function() {
                                          var ev = this.mouseEvent;
                                          if (!dragInfo || !ev)
                                            return;
                                          var node = ev.getNode();
                                          dx = ev.x - x;
                                          dy = ev.y - y;
                                          x = ev.x;
                                          y = ev.y;
                                          var isInTree = isInRect(x, y, scrollerRect);
                                          if (!isInTree) {
                                            node = null;
                                          }
                                          if (dragInfo.isInTree != isInTree && dragInfo.selectedNodes) {
                                            dragInfo.isInTree = isInTree;
                                            ev.dragInfo = dragInfo;
                                            tree._signal(isInTree ? "dragIn" : "dragOut", ev);
                                          }
                                          if (!isInTree) {
                                            ev.dragInfo = dragInfo;
                                            tree._signal("dragMoveOutside", ev);
                                          }
                                          if (dragInfo.el) {
                                            dragInfo.el.style.top = ev.y - dragInfo.offsetY + "px";
                                            dragInfo.el.style.left = ev.x - dragInfo.offsetX + "px";
                                          }
                                          var hoverNode = node;
                                          if (hoverNode) {
                                            var xOffset = x - scrollerRect.left;
                                            var depth = Math.max(0, Math.floor(xOffset / tree.provider.$indentSize));
                                            var depthDiff = hoverNode.$depth - depth;
                                            while (depthDiff > 0 && hoverNode.parent) {
                                              depthDiff--;
                                              hoverNode = hoverNode.parent;
                                            }
                                            if (!hoverNode.isFolder && dragInfo.mode != "sort") {
                                              hoverNode = hoverNode.parent;
                                            }
                                          }
                                          if (dragInfo.hoverNode !== hoverNode) {
                                            if (dragInfo.hoverNode) {
                                              tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                                              tree._signal("folderDragLeave", dragInfo);
                                            }
                                            if (hoverNode && dragInfo.selectedNodes && dragInfo.selectedNodes.indexOf(hoverNode) != -1) {
                                              hoverNode = null;
                                            }
                                            dragInfo.hoverNode = hoverNode;
                                            if (dragInfo.hoverNode) {
                                              tree._signal("folderDragEnter", dragInfo);
                                              if (dragInfo.mode !== "sort")
                                                tree.provider.setClass(dragInfo.hoverNode, "dropTarget", true);
                                            }
                                            highlightFolder(tree, dragInfo.hoverNode, dragInfo.insertPos);
                                          }
                                          var now = Date.now();
                                          var target = ev.domEvent.target;
                                          var isFoldWidget = target && dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                                          var distance = Math.abs(dx) + Math.abs(dy);
                                          var pos = ev.y - scrollerRect.top;
                                          var rowHeight = tree.provider.rowHeight;
                                          var renderer = tree.renderer;
                                          var autoScrollMargin = 1.5 * rowHeight;
                                          var scroll = pos - autoScrollMargin;
                                          if (scroll > 0) {
                                            scroll += -renderer.$size.scrollerHeight + 2 * autoScrollMargin;
                                            if (scroll < 0)
                                              scroll = 0;
                                          }
                                          if (!scroll || !isInTree)
                                            dragInfo.autoScroll = false;
                                          if (distance <= 2) {
                                            if (!dragInfo.stopTime)
                                              dragInfo.stopTime = now;
                                          } else {
                                            if (!isFoldWidget)
                                              dragInfo.stopTime = void 0;
                                          }
                                          var dt = now - dragInfo.stopTime;
                                          if (scroll && isInTree) {
                                            if (dt > AUTOSCROLL_DELAY || dragInfo.autoScroll) {
                                              tree.renderer.scrollBy(0, scroll / 2);
                                              dragInfo.autoScroll = true;
                                            }
                                          } else if (node && dragInfo.mode === "move") {
                                            if (node.parent === tree.provider.root || node.isRoot || node.parent && node.parent.isRoot)
                                              isFoldWidget = false;
                                            if (isFoldWidget && dt > WIDGET_UNFOLD_TIMEOUT && dt < 2 * WIDGET_UNFOLD_TIMEOUT) {
                                              tree.provider.toggleNode(node);
                                              dragInfo.stopTime = Infinity;
                                            } else if (!isFoldWidget && dt > UNFOLD_TIMEOUT && dt < 2 * UNFOLD_TIMEOUT) {
                                              tree.provider.open(node);
                                              dragInfo.stopTime = Infinity;
                                            }
                                          }
                                        };
                                        mouseHandler.dragEnd = function(e, cancel) {
                                          if (dragInfo) {
                                            window.removeEventListener("mousedown", keyHandler, true);
                                            window.removeEventListener("keydown", keyHandler, true);
                                            window.removeEventListener("keyup", keyHandler, true);
                                            if (dragInfo.el && dragInfo.el.parentNode)
                                              dragInfo.el.parentNode.removeChild(dragInfo.el);
                                            if (dragInfo.hoverNode) {
                                              tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                                              tree._signal("folderDragLeave", dragInfo);
                                            }
                                            highlightFolder(tree, null);
                                            if (tree.isFocused())
                                              tree.renderer.visualizeFocus();
                                            tree.renderer.setStyle("dragOver", false);
                                            dragInfo.target = dragInfo.hoverNode;
                                            if (!cancel && dragInfo.selectedNodes && Date.now() - dragInfo.startT > MIN_DRAG_T)
                                              tree._emit("drop", dragInfo);
                                            if (!dragInfo.isInTree) {
                                              if (cancel)
                                                dragInfo.selectedNodes = null;
                                              tree._signal("dropOutside", {
                                                dragInfo
                                              });
                                            }
                                            dragInfo = null;
                                          }
                                        };
                                        mouseHandler.dragStart = function() {
                                          if (dragInfo)
                                            this.dragEnd(null, true);
                                          mouseHandler.setState("drag");
                                          tree.renderer.visualizeBlur();
                                          tree.renderer.setStyle("dragOver", true);
                                          scrollerRect = tree.renderer.scroller.getBoundingClientRect();
                                          dragInfo = {};
                                        };
                                        tree.on("startDrag", function(ev) {
                                          if (!tree.getOption("enableDragDrop"))
                                            return;
                                          var node = ev.getNode();
                                          if (!node || ev.getButton())
                                            return;
                                          mouseHandler.dragStart();
                                          window.addEventListener("mousedown", keyHandler, true);
                                          window.addEventListener("keydown", keyHandler, true);
                                          window.addEventListener("keyup", keyHandler, true);
                                          var selectedNodes = tree.selection.getSelectedNodes();
                                          var el = constructDragNode(node);
                                          dragInfo = {
                                            el,
                                            node,
                                            selectedNodes,
                                            offsetX: 10,
                                            offsetY: 10,
                                            target: node,
                                            startT: Date.now(),
                                            isInTree: true,
                                            mode: "move"
                                          };
                                          ev.dragInfo = dragInfo;
                                          tree._signal("dragStarted", ev);
                                          if (mouseHandler.state == "drag")
                                            mouseHandler.drag();
                                        });
                                        function constructDragNode(node) {
                                          var i = tree.provider.getIndexForNode(node);
                                          var domNode = tree.renderer.$cellLayer.getDomNodeAtIndex(i);
                                          if (!domNode)
                                            return;
                                          var offset = domNode.offsetHeight;
                                          var selectedNodes = tree.selection.getSelectedNodes();
                                          var el = document.createElement("div");
                                          el.className = tree.container.className + " dragImage";
                                          var ch = el.appendChild(domNode.cloneNode(true));
                                          ch.removeChild(ch.firstChild);
                                          ch.style.paddingRight = "5px";
                                          ch.style.opacity = "0.8";
                                          el.style.position = "absolute";
                                          el.style.zIndex = "1000000";
                                          el.style.pointerEvents = "none";
                                          el.style.overflow = "visible";
                                          if (selectedNodes.length > 1) {
                                            ch.style.color = "transparent";
                                            ch = el.appendChild(domNode.cloneNode(true));
                                            ch.removeChild(ch.firstChild);
                                            ch.style.paddingRight = "5px";
                                            ch.style.top = -offset + 2 + "px";
                                            ch.style.left = "2px";
                                            ch.style.position = "relative";
                                            ch.style.opacity = "0.8";
                                          }
                                          document.body.appendChild(el);
                                          return el;
                                        }
                                        function keyHandler(e) {
                                          if (dragInfo) {
                                            if (e.keyCode === 27 || e.type == "mousedown") {
                                              mouseHandler.dragEnd(null, true);
                                              event.stopEvent(e);
                                            } else if (dragInfo && e.keyCode == 17 || e.keyCode == 18) {
                                              dragInfo.isCopy = e.type == "keydown";
                                              dom.setCssClass(dragInfo.el, "copy", dragInfo.isCopy);
                                            }
                                          }
                                        }
                                      }
                                      function highlightFolder(tree, node, type) {
                                        tree.provider.markedFolder = node;
                                        tree.provider.markedFolderType = type;
                                        tree.renderer.$loop.schedule(tree.renderer.CHANGE_MARKER);
                                      }
                                      function isInRect(x, y, rect) {
                                        if (x < rect.right && x > rect.left && y > rect.top && y < rect.bottom)
                                          return true;
                                      }
                                      module3.exports = initDragHandlers;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                543: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var event = __webpack_require__22(631);
                                      function HeadingHandler(mouseHandler) {
                                        var editor = mouseHandler.editor;
                                        var headingLayer = editor.renderer.$headingLayer;
                                        event.addListener(headingLayer.element, "mousedown", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseDown"));
                                        event.addListener(headingLayer.element, "mousemove", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseMove"));
                                        var overResizer, dragStartPos, columnData;
                                        editor.setDefaultHandler("headerMouseMove", function(e) {
                                          if (dragStartPos || !editor.provider || !editor.provider.columns)
                                            return;
                                          var pos = e.getDocumentPosition();
                                          var width = editor.renderer.$size.scrollerWidth;
                                          if (width != editor.provider.columns.width)
                                            headingLayer.updateWidth(width);
                                          columnData = headingLayer.findColumn(pos.x);
                                          overResizer = columnData && columnData.overResizer;
                                          headingLayer.element.style.cursor = overResizer ? "ew-resize" : "default";
                                        });
                                        editor.setDefaultHandler("headerMouseDown", function(e) {
                                          if (overResizer) {
                                            var pos = e.getDocumentPosition();
                                            dragStartPos = {
                                              x: pos.x
                                            };
                                            mouseHandler.setState("headerResize");
                                            mouseHandler.captureMouse(e);
                                            mouseHandler.mouseEvent = e;
                                          }
                                          e.stop();
                                        });
                                        mouseHandler.headerResize = function() {
                                          if (this.mouseEvent && dragStartPos) {
                                            var pos = this.mouseEvent.getDocumentPosition();
                                            var dx = pos.x;
                                            var columns = editor.renderer.provider.columns;
                                            for (var i = 0; i < columns.length; i++) {
                                              var col = columns[i];
                                              dx -= col.pixelWidth;
                                              if (col === columnData.column)
                                                break;
                                            }
                                            var total = editor.renderer.$size.scrollerWidth;
                                            headingLayer.changeColumnWidth(columnData.column, dx, total);
                                            var renderer = editor.renderer;
                                            renderer.updateFull();
                                          }
                                        };
                                        mouseHandler.headerResizeEnd = function() {
                                          dragStartPos = null;
                                          headingLayer.element.style.cursor = "";
                                          overResizer = false;
                                        };
                                      }
                                      exports3.HeadingHandler = HeadingHandler;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                118: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var event = __webpack_require__22(631);
                                      var useragent = __webpack_require__22(943);
                                      var MouseEvent = exports3.MouseEvent = function(domEvent, editor) {
                                        this.domEvent = domEvent;
                                        this.editor = editor;
                                        this.x = this.clientX = domEvent.clientX;
                                        this.y = this.clientY = domEvent.clientY;
                                        this.$pos = null;
                                        this.$inSelection = null;
                                        this.propagationStopped = false;
                                        this.defaultPrevented = false;
                                      };
                                      (function() {
                                        this.stopPropagation = function() {
                                          event.stopPropagation(this.domEvent);
                                          this.propagationStopped = true;
                                        };
                                        this.preventDefault = function() {
                                          event.preventDefault(this.domEvent);
                                          this.defaultPrevented = true;
                                        };
                                        this.stop = function() {
                                          this.stopPropagation();
                                          this.preventDefault();
                                        };
                                        this.getDocumentPosition = function() {
                                          if (this.$pos)
                                            return this.$pos;
                                          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                                          return this.$pos;
                                        };
                                        this.inSelection = function() {
                                          if (this.$inSelection !== null)
                                            return this.$inSelection;
                                          var node = this.getNode();
                                          this.$inSelection = !!(node && node.isSelected);
                                          return this.$inSelection;
                                        };
                                        this.node = null;
                                        this.getNode = function(clip) {
                                          if (this.node)
                                            return this.node;
                                          var pos = this.getDocumentPosition(clip);
                                          if (!pos || !this.editor.provider)
                                            return;
                                          return this.node = this.editor.provider.findItemAtOffset(pos.y, clip);
                                        };
                                        this.getButton = function() {
                                          return event.getButton(this.domEvent);
                                        };
                                        this.getShiftKey = function() {
                                          return this.domEvent.shiftKey;
                                        };
                                        this.getAccelKey = useragent.isMac ? function() {
                                          return this.domEvent.metaKey;
                                        } : function() {
                                          return this.domEvent.ctrlKey;
                                        };
                                      }).call(MouseEvent.prototype);
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                202: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var event = __webpack_require__22(631);
                                      var useragent = __webpack_require__22(943);
                                      var DefaultHandlers = __webpack_require__22(127).DefaultHandlers;
                                      var initDragHandlers = __webpack_require__22(513);
                                      var HeadingHandler = __webpack_require__22(543).HeadingHandler;
                                      var MouseEvent = __webpack_require__22(118).MouseEvent;
                                      var config = __webpack_require__22(614);
                                      var MouseHandler = function(editor) {
                                        this.editor = editor;
                                        new DefaultHandlers(this);
                                        new HeadingHandler(this);
                                        initDragHandlers(this);
                                        var mouseTarget = editor.renderer.getMouseEventTarget();
                                        event.addListener(mouseTarget, "mousedown", function(e) {
                                          editor.focus(true);
                                          return event.preventDefault(e);
                                        });
                                        event.addListener(mouseTarget, "mousemove", this.onMouseEvent.bind(this, "mousemove"));
                                        event.addListener(mouseTarget, "mouseup", this.onMouseEvent.bind(this, "mouseup"));
                                        event.addMultiMouseDownListener(mouseTarget, [
                                          300,
                                          300,
                                          250
                                        ], this, "onMouseEvent");
                                        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [
                                          300,
                                          300,
                                          250
                                        ], this, "onMouseEvent");
                                        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [
                                          300,
                                          300,
                                          250
                                        ], this, "onMouseEvent");
                                        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                                        event.addListener(mouseTarget, "mouseout", this.onMouseEvent.bind(this, "mouseleave"));
                                      };
                                      (function() {
                                        this.onMouseEvent = function(name, e) {
                                          this.editor._emit(name, new MouseEvent(e, this.editor));
                                        };
                                        this.onMouseWheel = function(name, e) {
                                          var mouseEvent = new MouseEvent(e, this.editor);
                                          mouseEvent.speed = this.$scrollSpeed * 2;
                                          mouseEvent.wheelX = e.wheelX;
                                          mouseEvent.wheelY = e.wheelY;
                                          this.editor._emit(name, mouseEvent);
                                        };
                                        this.setState = function(state) {
                                          this.state = state;
                                        };
                                        this.captureMouse = function(ev, state) {
                                          if (state)
                                            this.setState(state);
                                          this.x = ev.x;
                                          this.y = ev.y;
                                          this.isMousePressed = 2;
                                          var renderer = this.editor.renderer;
                                          if (renderer.$keepTextAreaAtCursor)
                                            renderer.$keepTextAreaAtCursor = null;
                                          var self2 = this;
                                          var onMouseMove = function(e) {
                                            self2.x = e.clientX;
                                            self2.y = e.clientY;
                                            self2.mouseEvent = new MouseEvent(e, self2.editor);
                                            self2.$mouseMoved = true;
                                          };
                                          var onCaptureEnd = function(e) {
                                            clearInterval(timerId);
                                            onCaptureInterval();
                                            self2[self2.state + "End"] && self2[self2.state + "End"](e);
                                            self2.$clickSelection = null;
                                            if (renderer.$keepTextAreaAtCursor == null) {
                                              renderer.$keepTextAreaAtCursor = true;
                                              renderer.$moveTextAreaToCursor();
                                            }
                                            self2.isMousePressed = false;
                                            e && self2.onMouseEvent("mouseup", e);
                                            self2.$onCaptureMouseMove = self2.releaseMouse = null;
                                          };
                                          var onCaptureInterval = function() {
                                            self2[self2.state] && self2[self2.state]();
                                            self2.$mouseMoved = false;
                                          };
                                          if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                                            return setTimeout(function() {
                                              onCaptureEnd(ev.domEvent);
                                            });
                                          }
                                          self2.$onCaptureMouseMove = onMouseMove;
                                          self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                                          var timerId = setInterval(onCaptureInterval, 20);
                                        };
                                        this.releaseMouse = null;
                                      }).call(MouseHandler.prototype);
                                      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                                        scrollSpeed: {
                                          initialValue: 2
                                        },
                                        dragDelay: {
                                          initialValue: 150
                                        },
                                        focusTimeout: {
                                          initialValue: 0
                                        },
                                        enableDragDrop: {
                                          initialValue: false
                                        }
                                      });
                                      exports3.MouseHandler = MouseHandler;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                277: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var quickSearch = function(tree, str) {
                                        var node = tree.selection.getCursor();
                                        var siblings = tree.provider.getChildren(node.parent);
                                        if (!siblings || siblings.length == 1) {
                                          return;
                                        }
                                        var index = siblings.indexOf(node);
                                        var newNode;
                                        for (var i = index + 1; i < siblings.length; i++) {
                                          node = siblings[i];
                                          var label = node.label || node.name || "";
                                          if (label[0] == str) {
                                            newNode = node;
                                            break;
                                          }
                                        }
                                        if (!newNode) {
                                          for (var i = 0; i < index; i++) {
                                            node = siblings[i];
                                            var label = node.label || node.name || "";
                                            if (label[0] == str) {
                                              newNode = node;
                                              break;
                                            }
                                          }
                                        }
                                        if (newNode) {
                                          tree.selection.selectNode(newNode);
                                          tree.renderer.scrollCaretIntoView(newNode, 0.5);
                                        }
                                      };
                                      module3.exports = quickSearch;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                541: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var scrollable = {};
                                      (function() {
                                        oop.implement(this, EventEmitter);
                                        this.$scrollTop = 0;
                                        this.getScrollTop = function() {
                                          return this.$scrollTop;
                                        };
                                        this.setScrollTop = function(scrollTop) {
                                          scrollTop = Math.round(scrollTop);
                                          if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                                            return;
                                          this.$scrollTop = scrollTop;
                                          this._signal("changeScrollTop", scrollTop);
                                        };
                                        this.$scrollLeft = 0;
                                        this.getScrollLeft = function() {
                                          return this.$scrollLeft;
                                        };
                                        this.setScrollLeft = function(scrollLeft) {
                                          scrollLeft = Math.round(scrollLeft);
                                          if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                                            return;
                                          this.$scrollLeft = scrollLeft;
                                          this._signal("changeScrollLeft", scrollLeft);
                                        };
                                      }).call(scrollable);
                                      module3.exports = scrollable;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                592: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var Selection = function(provider) {
                                        this.provider = provider;
                                        if (this.provider && !this.provider.selectedItems)
                                          this.provider.selectedItems = [];
                                        this.provider.on("remove", this.unselectRemoved = this.unselectRemoved.bind(this));
                                      };
                                      (function() {
                                        oop.implement(this, EventEmitter);
                                        this.$wrapAround = false;
                                        this.getRange = function() {
                                        };
                                        this.selectAll = function() {
                                          var sel = this.provider.selectedItems;
                                          this.expandSelection(sel[0], sel[sel.length - 1]);
                                          this._signal("change");
                                        };
                                        this.moveSelection = function(dir, select, add) {
                                          var provider = this.provider;
                                          var cursor = this.getCursor();
                                          var anchor = this.getAnchor();
                                          var i = provider.getIndexForNode(cursor);
                                          if (!add) {
                                            this.clear(true);
                                          } else if (add && !select) {
                                            this.unselectNode(cursor);
                                          }
                                          var min = provider.getMinIndex();
                                          var max = provider.getMaxIndex();
                                          var wrapped = false;
                                          var newI = i;
                                          do {
                                            newI += dir;
                                            if (newI < min) {
                                              newI = this.$wrapAround ? max : min;
                                              wrapped = true;
                                            } else if (newI > max) {
                                              newI = this.$wrapAround ? min : max;
                                              wrapped = true;
                                            }
                                            var newNode = provider.getNodeAtIndex(newI);
                                          } while (!wrapped && newNode && !provider.isSelectable(newNode));
                                          if (!newNode || !provider.isSelectable(newNode))
                                            newNode = cursor;
                                          if (select) {
                                            this.expandSelection(newNode, anchor, add);
                                          } else {
                                            this.selectNode(newNode, add);
                                          }
                                        };
                                        this.getCursor = function() {
                                          var sel = this.provider.selectedItems;
                                          return sel.cursor || sel[sel.length - 1];
                                        };
                                        this.getAnchor = function() {
                                          var sel = this.provider.selectedItems;
                                          return sel.anchor || sel.cursor || sel[0];
                                        };
                                        this.getSelectedNodes = function() {
                                          var sel = this.provider.selectedItems;
                                          return sel.slice();
                                        };
                                        this.getVisibleSelectedNodes = function() {
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          return sel.filter(function(node) {
                                            return provider.isVisible(node);
                                          });
                                        };
                                        this.isEmpty = function() {
                                          var sel = this.provider.selectedItems;
                                          return sel.length === 0;
                                        };
                                        this.isMultiRow = function() {
                                          var sel = this.provider.selectedItems;
                                          return sel.length > 1;
                                        };
                                        this.toggleSelect = function(node) {
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          var i = sel.indexOf(node);
                                          if (i != -1)
                                            sel.splice(i, 1);
                                          provider.setSelected(node, !provider.isSelected(node));
                                          if (provider.isSelected(node)) {
                                            sel.push(node);
                                            sel.anchor = sel.cursor = node;
                                          } else
                                            sel.anchor = sel.cursor = sel[sel.length - 1];
                                          this._signal("change");
                                        };
                                        this.selectNode = function(node, add, silent) {
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          if (!provider.isSelectable(node))
                                            return;
                                          if (!add)
                                            this.clear(true);
                                          if (node) {
                                            var i = sel.indexOf(node);
                                            if (i != -1)
                                              sel.splice(i, 1);
                                            provider.setSelected(node, true);
                                            if (provider.isSelected(node))
                                              sel.push(node);
                                          }
                                          sel.anchor = sel.cursor = node;
                                          this._signal("change");
                                        };
                                        this.add = function(node) {
                                          this.selectNode(node, true);
                                        };
                                        this.remove = function(node) {
                                          if (this.provider.isSelected(node))
                                            this.toggleSelect(node);
                                        };
                                        this.clear = this.clearSelection = function(silent) {
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          sel.forEach(function(node) {
                                            provider.setSelected(node, false);
                                          });
                                          sel.splice(0, sel.length);
                                          sel.anchor = sel.cursor;
                                          silent || this._signal("change");
                                        };
                                        this.unselectNode = function(node, silent) {
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          var i = sel.indexOf(node);
                                          if (i != -1) {
                                            sel.splice(i, 1);
                                            provider.setSelected(node, false);
                                            if (sel.anchor == node)
                                              sel.anchor = sel[i - 1] || sel[i];
                                            if (sel.cursor == node)
                                              sel.cursor = sel[i] || sel[i - 1];
                                            silent || this._signal("change");
                                          }
                                        };
                                        this.setSelection = function(nodes) {
                                          if (Array.isArray(nodes)) {
                                            this.clear(true);
                                            nodes.forEach(function(node) {
                                              this.selectNode(node, true, true);
                                            }, this);
                                          } else
                                            this.selectNode(nodes, false, true);
                                        };
                                        this.expandSelection = function(cursor, anchor, additive) {
                                          anchor = anchor || this.getAnchor();
                                          if (!additive)
                                            this.clear(true);
                                          var provider = this.provider;
                                          var sel = provider.selectedItems;
                                          var end = provider.getIndexForNode(cursor);
                                          var start = provider.getIndexForNode(anchor || cursor);
                                          if (end > start) {
                                            for (var i = start; i <= end; i++) {
                                              var node = provider.getNodeAtIndex(i);
                                              var index = sel.indexOf(node);
                                              if (index != -1)
                                                sel.splice(index, 1);
                                              if (provider.isSelectable(node))
                                                provider.setSelected(node, true);
                                              sel.push(node);
                                            }
                                          } else {
                                            for (var i = start; i >= end; i--) {
                                              var node = provider.getNodeAtIndex(i);
                                              var index = sel.indexOf(node);
                                              if (index != -1)
                                                sel.splice(index, 1);
                                              if (provider.isSelectable(node))
                                                provider.setSelected(node, true);
                                              sel.push(node);
                                            }
                                          }
                                          sel.cursor = cursor;
                                          sel.anchor = anchor;
                                          this._signal("change");
                                        };
                                        this.unselectRemoved = function(toRemove) {
                                          var sel = this.getSelectedNodes();
                                          var provider = this.provider;
                                          var changed, cursor = this.getCursor();
                                          sel.forEach(function(n) {
                                            if (provider.isAncestor(toRemove, n)) {
                                              changed = true;
                                              this.unselectNode(n, true);
                                            }
                                          }, this);
                                          if (changed && !provider.isSelected(cursor)) {
                                            var parent = toRemove.parent;
                                            var ch = [];
                                            if (parent && provider.isOpen(parent)) {
                                              ch = provider.getChildren(parent);
                                              var i = ch.indexOf(toRemove);
                                            }
                                            if (i == -1) {
                                              i = toRemove.index;
                                              var node = ch[i] || ch[i - 1] || parent;
                                            } else {
                                              node = ch[i + 1] || ch[i - 1] || parent;
                                            }
                                            if (node == provider.root)
                                              node = ch[0] || node;
                                            if (node)
                                              this.selectNode(node, true);
                                            this._signal("change");
                                          }
                                        };
                                      }).call(Selection.prototype);
                                      exports3.Selection = Selection;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                336: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var Renderer = __webpack_require__22(743).VirtualRenderer;
                                      exports3.config = __webpack_require__22(614);
                                      var oop = __webpack_require__22(645);
                                      var lang = __webpack_require__22(955);
                                      var useragent = __webpack_require__22(943);
                                      var TextInput = __webpack_require__22(984).k;
                                      var MouseHandler = __webpack_require__22(202).MouseHandler;
                                      var KeyBinding = __webpack_require__22(957).$;
                                      var Selection = __webpack_require__22(592).Selection;
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var CommandManager = __webpack_require__22(379).F;
                                      var defaultCommands = __webpack_require__22(677).commands;
                                      var config = __webpack_require__22(614);
                                      var quickSearch = __webpack_require__22(277);
                                      var Tree = function(element, cellWidth, cellHeight) {
                                        this.$toDestroy = [];
                                        this.cellWidth = cellWidth || 80;
                                        this.cellHeight = cellHeight || 24;
                                        this.renderer = new Renderer(element, this.cellWidth, this.cellHeight);
                                        this.container = this.renderer.container;
                                        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                                        this.textInput = new TextInput(this.container, this);
                                        this.keyBinding = new KeyBinding(this);
                                        this.$mouseHandler = new MouseHandler(this);
                                        this.$blockScrolling = 0;
                                        var _self = this;
                                        this.renderer.on("edit", function(e) {
                                          _self._emit("edit", e);
                                        });
                                        this.commands.on("exec", function() {
                                          this.selectionChanged = false;
                                        }.bind(this));
                                        this.commands.on("afterExec", function() {
                                          if (this.selectionChanged) {
                                            this.selectionChanged = false;
                                            this.renderer.scrollCaretIntoView();
                                            this._signal("userSelect");
                                          }
                                        }.bind(this));
                                        this.on("changeSelection", function() {
                                          if (this.$mouseHandler.isMousePressed)
                                            this._signal("userSelect");
                                        }.bind(this));
                                        config.resetOptions(this);
                                        config._emit("Tree", this);
                                      };
                                      (function() {
                                        oop.implement(this, EventEmitter);
                                        this.setDataProvider = function(provider) {
                                          if (this.provider) {
                                            var oldProvider = this.provider;
                                            this.selection.off("changeCaret", this.$onCaretChange);
                                            this.selection.off("change", this.$onSelectionChange);
                                            oldProvider.off("changeClass", this.$onChangeClass);
                                            oldProvider.off("expand", this.$redraw);
                                            oldProvider.off("collapse", this.$redraw);
                                            oldProvider.off("change", this.$redraw);
                                            oldProvider.off("changeScrollTop", this.$onScrollTopChange);
                                            oldProvider.off("changeScrollLeft", this.$onScrollLeftChange);
                                          }
                                          this.provider = provider;
                                          this.model = provider;
                                          if (provider) {
                                            this.renderer.setDataProvider(provider);
                                            if (!this.$redraw)
                                              this.$redraw = this.redraw.bind(this);
                                            this.provider.on("expand", this.$redraw);
                                            this.provider.on("collapse", this.$redraw);
                                            this.provider.on("change", this.$redraw);
                                            if (!this.provider.selection) {
                                              this.provider.selection = new Selection(this.provider);
                                            }
                                            this.selection = this.provider.selection;
                                            this.$onCaretChange = this.onCaretChange.bind(this);
                                            this.selection.on("changeCaret", this.$onCaretChange);
                                            this.$onChangeClass = this.$onChangeClass.bind(this);
                                            this.provider.on("changeClass", this.$onChangeClass);
                                            this.$onSelectionChange = this.onSelectionChange.bind(this);
                                            this.selection.on("change", this.$onSelectionChange);
                                            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                                            this.provider.on("changeScrollTop", this.$onScrollTopChange);
                                            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                                            this.provider.on("changeScrollLeft", this.$onScrollLeftChange);
                                            this.$blockScrolling += 1;
                                            this.onCaretChange();
                                            this.$blockScrolling -= 1;
                                            this.onScrollTopChange();
                                            this.onScrollLeftChange();
                                            this.onSelectionChange();
                                            this.renderer.updateFull();
                                          }
                                          this._emit("changeDataProvider", {
                                            provider,
                                            oldProvider
                                          });
                                        };
                                        this.redraw = function() {
                                          this.renderer.updateFull();
                                        };
                                        this.getLength = function() {
                                          return 0;
                                        };
                                        this.getLine = function(row) {
                                          return {
                                            length: 0
                                            // this.renderer.$horHeadingLayer.length - 1
                                          };
                                        };
                                        this.getDataProvider = function() {
                                          return this.provider;
                                        };
                                        this.getSelection = function() {
                                          return this.selection;
                                        };
                                        this.resize = function(force) {
                                          this.renderer.onResize(force);
                                        };
                                        this.focus = function(once) {
                                          var _self = this;
                                          once || setTimeout(function() {
                                            _self.textInput.focus();
                                          });
                                          this.textInput.focus();
                                        };
                                        this.isFocused = function() {
                                          return this.textInput.isFocused();
                                        };
                                        this.blur = function() {
                                          this.textInput.blur();
                                        };
                                        this.onFocus = function() {
                                          if (this.$isFocused)
                                            return;
                                          this.$isFocused = true;
                                          this.renderer.visualizeFocus();
                                          this._emit("focus");
                                        };
                                        this.onBlur = function() {
                                          if (!this.$isFocused)
                                            return;
                                          this.$isFocused = false;
                                          this.renderer.visualizeBlur();
                                          this._emit("blur");
                                        };
                                        this.onScrollTopChange = function() {
                                          this.renderer.scrollToY(this.provider.getScrollTop());
                                        };
                                        this.onScrollLeftChange = function() {
                                          this.renderer.scrollToX(this.renderer.getScrollLeft());
                                        };
                                        this.$onChangeClass = function() {
                                          this.renderer.updateCaret();
                                        };
                                        this.onCaretChange = function() {
                                          this.$onChangeClass();
                                          if (!this.$blockScrolling)
                                            this.selectionChanged = true;
                                          this._emit("changeSelection");
                                        };
                                        this.onSelectionChange = function(e) {
                                          this.onCaretChange();
                                        };
                                        this.execCommand = function(command, args) {
                                          this.commands.exec(command, this, args);
                                        };
                                        this.onTextInput = function(text) {
                                          this.keyBinding.onTextInput(text);
                                        };
                                        this.onCommandKey = function(e, hashId, keyCode) {
                                          this.keyBinding.onCommandKey(e, hashId, keyCode);
                                        };
                                        this.insertSting = function(str) {
                                          if (this.startFilter)
                                            return this.startFilter(str);
                                          quickSearch(this, str);
                                        };
                                        this.setTheme = function(theme) {
                                          this.renderer.setTheme(theme);
                                        };
                                        this.$getSelectedRows = function() {
                                          var range = this.getSelectionRange().collapseRows();
                                          return {
                                            first: range.start.row,
                                            last: range.end.row
                                          };
                                        };
                                        this.getVisibleNodes = function(tolerance) {
                                          return this.renderer.getVisibleNodes(tolerance);
                                        };
                                        this.isNodeVisible = function(node, tolerance) {
                                          return this.renderer.isNodeVisible(node, tolerance);
                                        };
                                        this.$moveByPage = function(dir, select) {
                                          var renderer = this.renderer;
                                          var config2 = this.renderer.layerConfig;
                                          config2.lineHeight = this.provider.rowHeight;
                                          var rows = dir * Math.floor(config2.height / config2.lineHeight);
                                          this.$blockScrolling++;
                                          this.selection.moveSelection(rows, select);
                                          this.$blockScrolling--;
                                          var scrollTop = renderer.scrollTop;
                                          renderer.scrollBy(0, rows * config2.lineHeight);
                                          if (select != null)
                                            renderer.scrollCaretIntoView(null, 0.5);
                                          renderer.animateScrolling(scrollTop);
                                        };
                                        this.selectPageDown = function() {
                                          this.$moveByPage(1, true);
                                        };
                                        this.selectPageUp = function() {
                                          this.$moveByPage(-1, true);
                                        };
                                        this.gotoPageDown = function() {
                                          this.$moveByPage(1, false);
                                        };
                                        this.gotoPageUp = function() {
                                          this.$moveByPage(-1, false);
                                        };
                                        this.scrollPageDown = function() {
                                          this.$moveByPage(1);
                                        };
                                        this.scrollPageUp = function() {
                                          this.$moveByPage(-1);
                                        };
                                        this.scrollToRow = function(row, center, animate, callback) {
                                          this.renderer.scrollToRow(row, center, animate, callback);
                                        };
                                        this.centerSelection = function() {
                                          var range = this.getSelectionRange();
                                          var pos = {
                                            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                                            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                                          };
                                          this.renderer.alignCaret(pos, 0.5);
                                        };
                                        this.getCursorPosition = function() {
                                          return this.selection.getCursor();
                                        };
                                        this.getCursorPositionScreen = function() {
                                          return this.session.documentToScreenPosition(this.getCursorPosition());
                                        };
                                        this.getSelectionRange = function() {
                                          return this.selection.getRange();
                                        };
                                        this.selectAll = function() {
                                          this.$blockScrolling += 1;
                                          this.selection.selectAll();
                                          this.$blockScrolling -= 1;
                                        };
                                        this.clearSelection = function() {
                                          this.selection.clearSelection();
                                        };
                                        this.moveCaretTo = function(row, column) {
                                          this.selection.moveCaretTo(row, column);
                                        };
                                        this.moveCaretToPosition = function(pos) {
                                          this.selection.moveCaretToPosition(pos);
                                        };
                                        this.gotoRow = function(rowNumber, column, animate) {
                                          this.selection.clearSelection();
                                          if (column === void 0)
                                            column = this.selection.getCursor().column;
                                          this.$blockScrolling += 1;
                                          this.moveCaretTo(rowNumber - 1, column || 0);
                                          this.$blockScrolling -= 1;
                                          if (!this.isRowFullyVisible(rowNumber - 1))
                                            this.scrollToRow(rowNumber - 1, true, animate);
                                        };
                                        this.navigateTo = function(row, column) {
                                          this.clearSelection();
                                          this.moveCaretTo(row, column);
                                        };
                                        this.navigateUp = function() {
                                          var node = this.provider.navigate("up");
                                          node && this.selection.setSelection(node);
                                          this.$scrollIntoView();
                                        };
                                        this.navigateDown = function() {
                                          var node = this.provider.navigate("down");
                                          node && this.selection.setSelection(node);
                                        };
                                        this.navigateLevelUp = function(toggleNode) {
                                          var node = this.selection.getCursor();
                                          if (!node) {
                                          } else if (toggleNode && this.provider.isOpen(node)) {
                                            this.provider.close(node);
                                          } else {
                                            this.selection.setSelection(node.parent);
                                          }
                                        };
                                        this.navigateLevelDown = function() {
                                          var node = this.selection.getCursor();
                                          var hasChildren = this.provider.hasChildren(node);
                                          if (!hasChildren || this.provider.isOpen(node))
                                            return this.selection.moveSelection(1);
                                          this.provider.open(node);
                                        };
                                        this.navigateStart = function() {
                                          var node = this.getFirstNode();
                                          this.selection.setSelection(node);
                                        };
                                        this.navigateEnd = function() {
                                          var node = this.getLastNode();
                                          this.selection.setSelection(node);
                                        };
                                        this.getFirstNode = function() {
                                          var index = this.provider.getMinIndex();
                                          return this.provider.getNodeAtIndex(index);
                                        };
                                        this.getLastNode = function() {
                                          var index = this.provider.getMaxIndex();
                                          return this.provider.getNodeAtIndex(index);
                                        };
                                        this.$scrollIntoView = function(node) {
                                          this.renderer.scrollCaretIntoView();
                                        };
                                        this.select = function(node) {
                                          this.selection.setSelection(node);
                                        };
                                        this.getCopyText = function(node) {
                                          return "";
                                        };
                                        this.onPaste = function(node) {
                                          return "";
                                        };
                                        this.reveal = function(node, animate) {
                                          var provider = this.provider;
                                          var parent = node.parent;
                                          while (parent) {
                                            if (!provider.isOpen(parent))
                                              provider.expand(parent);
                                            parent = parent.parent;
                                          }
                                          this.select(node);
                                          var scrollTop = this.renderer.scrollTop;
                                          this.renderer.scrollCaretIntoView(node, 0.5);
                                          if (animate !== false)
                                            this.renderer.animateScrolling(scrollTop);
                                        };
                                        this.undo = function() {
                                          this.$blockScrolling++;
                                          this.session.getUndoManager().undo();
                                          this.$blockScrolling--;
                                          this.renderer.scrollCaretIntoView(null, 0.5);
                                        };
                                        this.redo = function() {
                                          this.$blockScrolling++;
                                          this.session.getUndoManager().redo();
                                          this.$blockScrolling--;
                                          this.renderer.scrollCaretIntoView(null, 0.5);
                                        };
                                        this.getReadOnly = function() {
                                          return this.getOption("readOnly");
                                        };
                                        this.destroy = function() {
                                          this.renderer.destroy();
                                          this._emit("destroy", this);
                                        };
                                        this.setHorHeadingVisible = function(value) {
                                          this.renderer.setHorHeadingVisible(value);
                                        };
                                        this.setVerHeadingVisible = function(value) {
                                          this.renderer.setVerHeadingVisible(value);
                                        };
                                        this.enable = function() {
                                          this.$disabled = false;
                                          this.container.style.pointerEvents = "";
                                          this.container.style.opacity = "";
                                        };
                                        this.disable = function() {
                                          this.$disabled = true;
                                          this.container.style.pointerEvents = "none";
                                          this.container.style.opacity = "0.9";
                                          if (this.isFocused())
                                            this.blur();
                                        };
                                      }).call(Tree.prototype);
                                      config.defineOptions(Tree.prototype, "Tree", {
                                        toggle: {
                                          set: function(toggle) {
                                          },
                                          initialValue: false
                                        },
                                        readOnly: {
                                          set: function(readOnly) {
                                            this.textInput.setReadOnly(readOnly);
                                          },
                                          initialValue: false
                                        },
                                        animatedScroll: "renderer",
                                        maxLines: "renderer",
                                        minLines: "renderer",
                                        scrollSpeed: "$mouseHandler",
                                        enableDragDrop: "$mouseHandler"
                                      });
                                      module3.exports = Tree;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                743: (
                                  /***/
                                  (module222, exports2, __webpack_require__22) => {
                                    var __WEBPACK_AMD_DEFINE_RESULT__;
                                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require2, exports3, module3) {
                                      "use strict";
                                      var oop = __webpack_require__22(645);
                                      var dom = __webpack_require__22(435);
                                      var config = __webpack_require__22(614);
                                      var CellLayer = __webpack_require__22(365).Cells;
                                      var MarkerLayer = __webpack_require__22(611).Selection;
                                      var HeaderLayer = __webpack_require__22(86).ColumnHeader;
                                      var ScrollBarH = __webpack_require__22(745).zy;
                                      var ScrollBarV = __webpack_require__22(745).lc;
                                      var RenderLoop = __webpack_require__22(481).x;
                                      var EventEmitter = __webpack_require__22(366).b;
                                      var pivotCss = __webpack_require__22(268);
                                      dom.importCssString(pivotCss, "ace_tree");
                                      var defaultTheme = __webpack_require__22(768);
                                      var VirtualRenderer = function(container, cellWidth, cellHeight) {
                                        var _self = this;
                                        this.container = container || dom.createElement("div");
                                        dom.addCssClass(this.container, "ace_tree");
                                        dom.addCssClass(this.container, "ace_tree");
                                        this.scroller = dom.createElement("div");
                                        this.scroller.className = "ace_tree_scroller";
                                        this.container.appendChild(this.scroller);
                                        this.cells = dom.createElement("div");
                                        this.cells.className = "ace_tree_cells";
                                        this.scroller.appendChild(this.cells);
                                        this.$headingLayer = new HeaderLayer(this.container, this);
                                        this.$markerLayer = new MarkerLayer(this.cells, this);
                                        this.$cellLayer = new CellLayer(this.cells);
                                        this.canvas = this.$cellLayer.element;
                                        this.$horizScroll = false;
                                        this.scrollBarV = new ScrollBarV(this.container, this);
                                        this.scrollBarV.setVisible(true);
                                        this.scrollBarV.addEventListener("scroll", function(e) {
                                          if (!_self.$inScrollAnimation)
                                            _self.setScrollTop(e.data - _self.scrollMargin.top);
                                        });
                                        this.scrollBarH = new ScrollBarH(this.container, this);
                                        this.scrollBarH.addEventListener("scroll", function(e) {
                                          if (!_self.$inScrollAnimation)
                                            _self.setScrollLeft(e.data);
                                        });
                                        this.scrollTop = 0;
                                        this.scrollLeft = 0;
                                        this.caretPos = {
                                          row: 0,
                                          column: 0
                                        };
                                        this.$size = {
                                          width: 0,
                                          height: 0,
                                          scrollerHeight: 0,
                                          scrollerWidth: 0,
                                          headingHeight: 0
                                        };
                                        this.layerConfig = {
                                          width: 1,
                                          padding: 0,
                                          firstRow: 0,
                                          firstRowScreen: 0,
                                          lastRow: 0,
                                          lineHeight: 1,
                                          characterWidth: 1,
                                          minHeight: 1,
                                          maxHeight: 1,
                                          offset: 0,
                                          height: 1
                                        };
                                        this.scrollMargin = {
                                          left: 0,
                                          right: 0,
                                          top: 0,
                                          bottom: 0,
                                          v: 0,
                                          h: 0
                                        };
                                        this.$scrollIntoView = null;
                                        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                                        this.$loop.schedule(this.CHANGE_FULL);
                                        this.setTheme(defaultTheme);
                                        this.$windowFocus = this.$windowFocus.bind(this);
                                        window.addEventListener("focus", this.$windowFocus);
                                      };
                                      (function() {
                                        this.CHANGE_SCROLL = 1;
                                        this.CHANGE_COLUMN = 2;
                                        this.CHANGE_ROW = 4;
                                        this.CHANGE_CELLS = 8;
                                        this.CHANGE_SIZE = 16;
                                        this.CHANGE_CLASS = 32;
                                        this.CHANGE_MARKER = 64;
                                        this.CHANGE_FULL = 128;
                                        this.CHANGE_H_SCROLL = 1024;
                                        oop.implement(this, EventEmitter);
                                        this.setDataProvider = function(provider) {
                                          this.provider = provider;
                                          this.model = provider;
                                          if (this.scrollMargin.top && provider && provider.getScrollTop() <= 0)
                                            provider.setScrollTop(-this.scrollMargin.top);
                                          this.scroller.className = "ace_tree_scroller";
                                          this.$cellLayer.setDataProvider(provider);
                                          this.$markerLayer.setDataProvider(provider);
                                          this.$headingLayer.setDataProvider(provider);
                                          this.$size.headingHeight = provider && provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                                          this.$loop.schedule(this.CHANGE_FULL);
                                        };
                                        this.updateRows = function(firstRow, lastRow) {
                                          if (lastRow === void 0)
                                            lastRow = Infinity;
                                          if (!this.$changedLines) {
                                            this.$changedLines = {
                                              firstRow,
                                              lastRow
                                            };
                                          } else {
                                            if (this.$changedLines.firstRow > firstRow)
                                              this.$changedLines.firstRow = firstRow;
                                            if (this.$changedLines.lastRow < lastRow)
                                              this.$changedLines.lastRow = lastRow;
                                          }
                                          if (this.$changedLines.firstRow > this.layerConfig.lastRow || this.$changedLines.lastRow < this.layerConfig.firstRow)
                                            return;
                                          this.$loop.schedule(this.CHANGE_ROW);
                                        };
                                        this.updateCaret = function() {
                                          this.$loop.schedule(this.CHANGE_CLASS);
                                        };
                                        this.updateCells = function() {
                                          this.$loop.schedule(this.CHANGE_CELLS);
                                        };
                                        this.updateFull = function(force) {
                                          if (force)
                                            this.$renderChanges(this.CHANGE_FULL, true);
                                          else
                                            this.$loop.schedule(this.CHANGE_FULL);
                                        };
                                        this.updateHorizontalHeadings = function() {
                                          this.$loop.schedule(this.CHANGE_COLUMN);
                                        };
                                        this.updateVerticalHeadings = function() {
                                          this.$loop.schedule(this.CHANGE_ROW);
                                        };
                                        this.$changes = 0;
                                        this.onResize = function(force, width, height) {
                                          if (this.resizing > 2)
                                            return;
                                          else if (this.resizing > 0)
                                            this.resizing++;
                                          else
                                            this.resizing = force ? 1 : 0;
                                          var el = this.container;
                                          if (!height)
                                            height = el.clientHeight || el.scrollHeight;
                                          if (!width)
                                            width = el.clientWidth || el.scrollWidth;
                                          var changes = this.$updateCachedSize(force, width, height);
                                          if (!this.$size.scrollerHeight || !width && !height)
                                            return this.resizing = 0;
                                          if (force)
                                            this.$renderChanges(changes, true);
                                          else
                                            this.$loop.schedule(changes | this.$changes);
                                          if (this.resizing)
                                            this.resizing = 0;
                                        };
                                        this.$windowFocus = function() {
                                          this.onResize();
                                        };
                                        this.$updateCachedSize = function(force, width, height) {
                                          var changes = 0;
                                          var size = this.$size;
                                          var provider = this.provider;
                                          if (provider) {
                                            var headingHeight = provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                                            if (headingHeight != size.headingHeight) {
                                              size.headingHeight = headingHeight;
                                              changes |= this.CHANGE_SIZE;
                                            }
                                          }
                                          if (height && (force || size.height != height)) {
                                            size.height = height;
                                            changes |= this.CHANGE_SIZE;
                                            size.scrollerHeight = size.height;
                                            if (this.$horizScroll)
                                              size.scrollerHeight -= this.scrollBarH.getHeight();
                                            size.scrollerHeight -= size.headingHeight;
                                            this.$headingLayer.element.style.height = this.scroller.style.top = this.scrollBarV.element.style.top = size.headingHeight + "px";
                                            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                                            if (provider && provider.setScrollTop) {
                                              changes |= this.CHANGE_SCROLL;
                                            }
                                            if (this.$scrollIntoView) {
                                              if (this.$scrollIntoView.model == this.model) {
                                                this.scrollCaretIntoView(this.$scrollIntoView.caret, this.$scrollIntoView.offset);
                                                this.$scrollIntoView = null;
                                              }
                                            }
                                          }
                                          if (width && (force || size.width != width)) {
                                            changes |= this.CHANGE_SIZE;
                                            size.width = width;
                                            this.scrollBarH.element.style.left = this.scroller.style.left = "0px";
                                            size.scrollerWidth = Math.max(0, width - this.scrollBarV.getWidth());
                                            this.$headingLayer.element.style.right = this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                                            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
                                            this.$headingLayer.updateWidth(size.scrollerWidth);
                                            if (provider && provider.columns)
                                              changes |= this.CHANGE_FULL;
                                          }
                                          if (changes)
                                            this._signal("resize");
                                          return changes;
                                        };
                                        this.setVerHeadingVisible = function(value) {
                                          this.$treeLayer.visible = value;
                                          if (this.layerConfig.vRange && this.layerConfig.hRange) {
                                            this.$renderChanges(this.CHANGE_FULL, true);
                                            this.onResize(true);
                                          }
                                        };
                                        this.getContainerElement = function() {
                                          return this.container;
                                        };
                                        this.getMouseEventTarget = function() {
                                          return this.scroller;
                                        };
                                        this.getVisibleNodes = function(tolerance) {
                                          var nodes = this.layerConfig.vRange;
                                          var first = 0;
                                          var last = nodes.length - 1;
                                          while (this.isNodeVisible(nodes[first], tolerance) && first < last)
                                            first++;
                                          while (!this.isNodeVisible(nodes[last], tolerance) && last > first)
                                            last--;
                                          return nodes.slice(first, last + 1);
                                        };
                                        this.isNodeVisible = function(node, tolerance) {
                                          var layerConfig = this.layerConfig;
                                          if (!layerConfig.vRange)
                                            return;
                                          var provider = this.provider;
                                          var i = layerConfig.vRange.indexOf(node);
                                          if (i == -1)
                                            return false;
                                          var nodePos = provider.getNodePosition(node);
                                          var top = nodePos.top;
                                          var height = nodePos.height;
                                          if (tolerance === void 0)
                                            tolerance = 1 / 3;
                                          if (this.scrollTop > top + tolerance * height)
                                            return false;
                                          if (this.scrollTop + this.$size.scrollerHeight <= top + (1 - tolerance) * height)
                                            return false;
                                          return true;
                                        };
                                        this.$updateScrollBar = function() {
                                          this.$updateScrollBarH();
                                          this.$updateScrollBarV();
                                        };
                                        this.setScrollMargin = function(top, bottom, left, right) {
                                          var sm = this.scrollMargin;
                                          sm.top = top | 0;
                                          sm.bottom = bottom | 0;
                                          sm.right = right | 0;
                                          sm.left = left | 0;
                                          sm.v = sm.top + sm.bottom;
                                          sm.h = sm.left + sm.right;
                                          if (sm.top && this.scrollTop <= 0 && this.provider)
                                            this.provider.setScrollTop(-sm.top);
                                          this.updateFull();
                                        };
                                        this.$updateScrollBarV = function() {
                                          this.scrollBarV.setInnerHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
                                          this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                                        };
                                        this.$updateScrollBarH = function() {
                                          this.scrollBarH.setInnerWidth(this.layerConfig.maxWidth + this.scrollMargin.h);
                                          this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                                        };
                                        this.$frozen = false;
                                        this.freeze = function() {
                                          this.$frozen = true;
                                        };
                                        this.unfreeze = function() {
                                          this.$frozen = false;
                                        };
                                        this.$renderChanges = function(changes, force) {
                                          if (this.$changes) {
                                            changes |= this.$changes;
                                            this.$changes = 0;
                                          }
                                          if (!this.provider || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                                            this.$changes |= changes;
                                            return;
                                          }
                                          if (!this.$size.width) {
                                            this.$changes |= changes;
                                            return this.onResize(true);
                                          }
                                          this._signal("beforeRender");
                                          var config2 = this.layerConfig;
                                          if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL || changes & this.CHANGE_COLUMN || changes & this.CHANGE_ROW || changes & this.CHANGE_CELLS) {
                                            changes |= this.$computeLayerConfig();
                                            config2 = this.layerConfig;
                                            this.$updateScrollBar();
                                            this.cells.style.marginTop = -config2.vOffset + "px";
                                            this.cells.style.marginLeft = -config2.hOffset + "px";
                                            this.cells.style.width = config2.width + "px";
                                            this.cells.style.height = config2.height + config2.rowHeight + "px";
                                          }
                                          if (changes & this.CHANGE_FULL) {
                                            this.$headingLayer.update(this.layerConfig);
                                            this.$cellLayer.update(this.layerConfig);
                                            this.$markerLayer.update(this.layerConfig);
                                            this._signal("afterRender");
                                            return;
                                          }
                                          if (changes & this.CHANGE_SCROLL) {
                                            if (changes & this.CHANGE_ROW || changes & this.CHANGE_COLUMN || changes & this.CHANGE_CELLS) {
                                              this.$headingLayer.update(this.layerConfig);
                                              this.$cellLayer.update(this.layerConfig);
                                            } else {
                                              this.$headingLayer.update(this.layerConfig);
                                              this.$cellLayer.scroll(this.layerConfig);
                                            }
                                            this.$markerLayer.update(this.layerConfig);
                                            this.$updateScrollBar();
                                            this._signal("afterRender");
                                            return;
                                          }
                                          if (changes & this.CHANGE_CLASS)
                                            this.$cellLayer.updateClasses(this.layerConfig);
                                          if (changes & this.CHANGE_MARKER || changes & this.CHANGE_CELLS)
                                            this.$markerLayer.update(this.layerConfig);
                                          if (changes & this.CHANGE_COLUMN)
                                            this.$horHeadingLayer.update(this.layerConfig);
                                          if (changes & this.CHANGE_CELLS)
                                            this.$cellLayer.update(this.layerConfig);
                                          if (changes & this.CHANGE_SIZE)
                                            this.$updateScrollBar();
                                          this._signal("afterRender");
                                          if (this.$scrollIntoView)
                                            this.$scrollIntoView = null;
                                        };
                                        this.$autosize = function() {
                                          var headingHeight = this.$size.headingHeight;
                                          var height = this.provider.getTotalHeight() + headingHeight;
                                          var maxHeight = this.getMaxHeight ? this.getMaxHeight() : this.$maxLines * this.provider.rowHeight + headingHeight;
                                          var desiredHeight = Math.max((this.$minLines || 1) * this.provider.rowHeight + headingHeight, Math.min(maxHeight, height)) + this.scrollMargin.v;
                                          var vScroll = height > maxHeight;
                                          if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                                            if (vScroll != this.$vScroll) {
                                              this.$vScroll = vScroll;
                                              this.scrollBarV.setVisible(vScroll);
                                            }
                                            var w = this.container.clientWidth;
                                            this.container.style.height = desiredHeight + "px";
                                            this.$updateCachedSize(true, w, desiredHeight);
                                            this.desiredHeight = desiredHeight;
                                            this._signal("autoresize");
                                          }
                                        };
                                        this.$computeLayerConfig = function() {
                                          if (this.$maxLines)
                                            this.$autosize();
                                          var provider = this.provider;
                                          var vertical = this.$treeLayer;
                                          var horizontal = this.$horHeadingLayer;
                                          var minHeight = this.$size.scrollerHeight;
                                          var maxHeight = provider.getTotalHeight();
                                          var minWidth = this.$size.scrollerWidth;
                                          var maxWidth = 0;
                                          var hideScrollbars = this.$size.height <= 2 * 10;
                                          var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || this.$size.scrollerWidth - maxWidth < 0);
                                          var hScrollChanged = this.$horizScroll !== horizScroll;
                                          if (hScrollChanged) {
                                            this.$horizScroll = horizScroll;
                                            this.scrollBarH.setVisible(horizScroll);
                                          }
                                          var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || this.$size.scrollerHeight - maxHeight < 0);
                                          var vScrollChanged = this.$vScroll !== vScroll;
                                          if (vScrollChanged) {
                                            this.$vScroll = vScroll;
                                            this.scrollBarV.setVisible(vScroll);
                                          }
                                          this.provider.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight + this.scrollMargin.bottom)));
                                          this.provider.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, maxWidth - this.$size.scrollerWidth + this.scrollMargin.right)));
                                          if (this.provider.getScrollTop() != this.scrollTop)
                                            this.scrollTop = this.provider.getScrollTop();
                                          var top = Math.max(this.scrollTop, 0);
                                          var vRange = provider.getRange(top, top + this.$size.height);
                                          var hRange = {
                                            size: 0
                                          };
                                          var vOffset = this.scrollTop - vRange.size;
                                          var hOffset = this.scrollLeft - hRange.size;
                                          var rowCount = vRange.length;
                                          var firstRow = vRange.count;
                                          var lastRow = firstRow + rowCount - 1;
                                          var colCount = hRange.length;
                                          var firstCol = hRange.count;
                                          var lastCol = firstCol + colCount - 1;
                                          if (this.layerConfig)
                                            this.layerConfig.discard = true;
                                          var changes = 0;
                                          if (hScrollChanged || vScrollChanged) {
                                            changes = this.$updateCachedSize(true, this.$size.width, this.$size.height);
                                            this._signal("scrollbarVisibilityChanged");
                                          }
                                          this.layerConfig = {
                                            vRange,
                                            hRange,
                                            width: minWidth,
                                            height: minHeight,
                                            firstRow,
                                            lastRow,
                                            firstCol,
                                            lastCol,
                                            minHeight,
                                            maxHeight,
                                            minWidth,
                                            maxWidth,
                                            vOffset,
                                            hOffset,
                                            rowHeight: provider.rowHeight
                                          };
                                          var config2 = this.layerConfig, renderer = this;
                                          if (vRange) {
                                            config2.view = provider.getDataRange({
                                              start: vRange.count,
                                              length: vRange.length
                                            }, {
                                              start: hRange.count,
                                              length: hRange.length
                                            }, function(err, view, update) {
                                              if (err)
                                                return false;
                                              config2.view = view;
                                              if (update)
                                                renderer.$loop.schedule(renderer.CHANGE_CELLS);
                                            });
                                          }
                                          return changes;
                                        };
                                        this.$updateRows = function() {
                                          var firstRow = this.$changedLines.firstRow;
                                          var lastRow = this.$changedLines.lastRow;
                                          this.$changedLines = null;
                                          var layerConfig = this.layerConfig;
                                          if (firstRow > layerConfig.lastRow + 1) {
                                            return;
                                          }
                                          if (lastRow < layerConfig.firstRow) {
                                            return;
                                          }
                                          if (lastRow === Infinity) {
                                            this.$cellLayer.update(layerConfig);
                                            return;
                                          }
                                          this.$cellLayer.updateRows(layerConfig, firstRow, lastRow);
                                          return true;
                                        };
                                        this.scrollSelectionIntoView = function(anchor, lead, offset) {
                                          this.scrollCaretIntoView(anchor, offset);
                                          this.scrollCaretIntoView(lead, offset);
                                        };
                                        this.scrollCaretIntoView = function(caret, offset) {
                                          this.$scrollIntoView = {
                                            caret,
                                            offset,
                                            scrollTop: this.scrollTop,
                                            model: this.model,
                                            height: this.$size.scrollerHeight
                                          };
                                          if (this.$size.scrollerHeight === 0)
                                            return;
                                          var provider = this.provider;
                                          var node = caret || provider.selection.getCursor();
                                          if (!node)
                                            return;
                                          var nodePos = provider.getNodePosition(node);
                                          var top = nodePos.top;
                                          var height = nodePos.height;
                                          var left = 0;
                                          var width = 0;
                                          if (this.scrollTop > top) {
                                            if (offset)
                                              top -= offset * this.$size.scrollerHeight;
                                            if (top === 0)
                                              top = -this.scrollMargin.top;
                                            this.provider.setScrollTop(top);
                                          } else if (this.scrollTop + this.$size.scrollerHeight < top + height) {
                                            if (offset)
                                              top += offset * this.$size.scrollerHeight;
                                            this.provider.setScrollTop(top + height - this.$size.scrollerHeight);
                                          }
                                          var scrollLeft = this.scrollLeft;
                                          if (scrollLeft > left) {
                                            if (left < 0)
                                              left = 0;
                                            this.provider.setScrollLeft(left);
                                          } else if (scrollLeft + this.$size.scrollerWidth < left + width) {
                                            this.provider.setScrollLeft(Math.round(left + width - this.$size.scrollerWidth));
                                          }
                                          this.$scrollIntoView.scrollTop = this.scrollTop;
                                        };
                                        this.getScrollTop = function() {
                                          return this.scrollTop;
                                        };
                                        this.getScrollLeft = function() {
                                          return this.scrollLeft;
                                        };
                                        this.setScrollTop = function(scrollTop) {
                                          scrollTop = Math.round(scrollTop);
                                          if (this.scrollTop === scrollTop || isNaN(scrollTop))
                                            return;
                                          this.scrollToY(scrollTop);
                                        };
                                        this.setScrollLeft = function(scrollLeft) {
                                          scrollLeft = Math.round(scrollLeft);
                                          if (this.scrollLeft === scrollLeft || isNaN(scrollLeft))
                                            return;
                                          this.scrollToX(scrollLeft);
                                        };
                                        this.getScrollTopRow = function() {
                                          return this.layerConfig.firstRow;
                                        };
                                        this.getScrollBottomRow = function() {
                                          return this.layerConfig.lastRow;
                                        };
                                        this.alignCaret = function(cursor, alignment) {
                                          if (typeof cursor == "number")
                                            cursor = {
                                              row: cursor,
                                              column: 0
                                            };
                                          var node = this.provider.findNodeByIndex(cursor.row);
                                          var pos = this.provider.findSizeAtIndex(cursor.row);
                                          var h = this.$size.scrollerHeight;
                                          var offset = pos - (h - node.size) * (alignment || 0);
                                          this.setScrollTop(offset);
                                          return offset;
                                        };
                                        this.STEPS = 8;
                                        this.$calcSteps = function(fromValue, toValue) {
                                          var i = 0;
                                          var l = this.STEPS;
                                          var steps = [];
                                          var func = function(t, x_min, dx) {
                                            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                                          };
                                          for (i = 0; i < l; ++i)
                                            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                                          return steps;
                                        };
                                        this.scrollToRow = function(row, center, animate, callback) {
                                          var node = this.provider.findNodeByIndex(row);
                                          var offset = this.provider.findSizeAtIndex(row);
                                          if (center)
                                            offset -= (this.$size.scrollerHeight - node.size) / 2;
                                          var initialScroll = this.scrollTop;
                                          this.setScrollTop(offset);
                                          if (animate !== false)
                                            this.animateScrolling(initialScroll, callback);
                                        };
                                        this.animateScrolling = function(fromValue, callback) {
                                          var toValue = this.scrollTop;
                                          if (!this.$animatedScroll)
                                            return;
                                          var _self = this;
                                          if (fromValue == toValue)
                                            return;
                                          if (this.$scrollAnimation) {
                                            var oldSteps = this.$scrollAnimation.steps;
                                            if (oldSteps.length) {
                                              fromValue = oldSteps[0];
                                              if (fromValue == toValue)
                                                return;
                                            }
                                          }
                                          var steps = _self.$calcSteps(fromValue, toValue);
                                          this.$scrollAnimation = {
                                            from: fromValue,
                                            to: toValue,
                                            steps
                                          };
                                          clearInterval(this.$timer);
                                          _self.provider.setScrollTop(steps.shift());
                                          _self.provider.$scrollTop = toValue;
                                          this.$timer = setInterval(function() {
                                            if (steps.length) {
                                              _self.provider.setScrollTop(steps.shift());
                                              _self.provider.$scrollTop = toValue;
                                            } else if (toValue != null) {
                                              _self.provider.$scrollTop = -1;
                                              _self.provider.setScrollTop(toValue);
                                              toValue = null;
                                            } else {
                                              _self.$timer = clearInterval(_self.$timer);
                                              _self.$scrollAnimation = null;
                                              callback && callback();
                                            }
                                          }, 10);
                                        };
                                        this.scrollToY = function(scrollTop) {
                                          if (this.scrollTop !== scrollTop) {
                                            this.$loop.schedule(this.CHANGE_SCROLL);
                                            this.scrollTop = scrollTop;
                                          }
                                        };
                                        this.scrollToX = function(scrollLeft) {
                                          if (scrollLeft < 0)
                                            scrollLeft = 0;
                                          if (this.scrollLeft !== scrollLeft) {
                                            this.$loop.schedule(this.CHANGE_SCROLL);
                                            this.scrollLeft = scrollLeft;
                                          }
                                        };
                                        this.scrollBy = function(deltaX, deltaY) {
                                          deltaY && this.provider.setScrollTop(this.provider.getScrollTop() + deltaY);
                                          deltaX && this.provider.setScrollLeft(this.provider.getScrollLeft() + deltaX);
                                        };
                                        this.isScrollableBy = function(deltaX, deltaY) {
                                          if (deltaY < 0 && this.getScrollTop() >= 1 - this.scrollMargin.top)
                                            return true;
                                          if (deltaY > 0 && this.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
                                            return true;
                                          if (deltaX < 0 && this.getScrollLeft() >= 1)
                                            return true;
                                          if (deltaX > 0 && this.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.maxWidth < -1)
                                            return true;
                                        };
                                        this.screenToTextCoordinates = function(x, y) {
                                          var canvasPos = this.scroller.getBoundingClientRect();
                                          y -= canvasPos.top;
                                          x -= canvasPos.left;
                                          return {
                                            x: x + this.scrollLeft,
                                            y: y + this.scrollTop
                                          };
                                        };
                                        this.textToScreenCoordinates = function(row, column) {
                                          throw new Error();
                                        };
                                        this.findNodeAt = function(x, y, coords) {
                                        };
                                        this.$moveTextAreaToCursor = function() {
                                        };
                                        this.visualizeFocus = function() {
                                          dom.addCssClass(this.container, "ace_tree_focus");
                                        };
                                        this.visualizeBlur = function() {
                                          dom.removeCssClass(this.container, "ace_tree_focus");
                                        };
                                        this.setTheme = function(theme, cb) {
                                          var _self = this;
                                          this.$themeValue = theme;
                                          _self._dispatchEvent("themeChange", {
                                            theme
                                          });
                                          if (!theme || typeof theme == "string") {
                                            var moduleName = theme || "ace/theme/textmate";
                                            config.loadModule([
                                              "theme",
                                              moduleName
                                            ], afterLoad);
                                          } else {
                                            afterLoad(theme);
                                          }
                                          function afterLoad(module4) {
                                            if (_self.$themeValue != theme)
                                              return cb && cb();
                                            if (!module4.cssClass)
                                              return;
                                            dom.importCssString(module4.cssText, module4.cssClass, _self.container.ownerDocument);
                                            if (_self.theme)
                                              dom.removeCssClass(_self.container, _self.theme.cssClass);
                                            _self.$theme = module4.cssClass;
                                            _self.theme = module4;
                                            dom.addCssClass(_self.container, module4.cssClass);
                                            dom.setCssClass(_self.container, "ace_dark", module4.isDark);
                                            var padding = module4.padding || 4;
                                            if (_self.$padding && padding != _self.$padding)
                                              _self.setPadding(padding);
                                            if (_self.$size) {
                                              _self.$size.width = 0;
                                              _self.onResize();
                                            }
                                            _self._dispatchEvent("themeLoaded", {
                                              theme: module4
                                            });
                                            cb && cb();
                                          }
                                        };
                                        this.getTheme = function() {
                                          return this.$themeValue;
                                        };
                                        this.setStyle = function setStyle(style, include) {
                                          dom.setCssClass(this.container, style, include !== false);
                                        };
                                        this.unsetStyle = function unsetStyle(style) {
                                          dom.removeCssClass(this.container, style);
                                        };
                                        this.destroy = function() {
                                          window.removeEventListener("focus", this.$windowFocus);
                                          this.$cellLayer.destroy();
                                        };
                                      }).call(VirtualRenderer.prototype);
                                      config.defineOptions(VirtualRenderer.prototype, "renderer", {
                                        animatedScroll: {
                                          initialValue: true
                                        },
                                        showInvisibles: {
                                          set: function(value) {
                                            if (this.$cellLayer.setShowInvisibles(value))
                                              this.$loop.schedule(this.CHANGE_TEXT);
                                          },
                                          initialValue: false
                                        },
                                        showPrintMargin: {
                                          set: function() {
                                            this.$updatePrintMargin();
                                          },
                                          initialValue: true
                                        },
                                        printMarginColumn: {
                                          set: function() {
                                            this.$updatePrintMargin();
                                          },
                                          initialValue: 80
                                        },
                                        printMargin: {
                                          set: function(val) {
                                            if (typeof val == "number")
                                              this.$printMarginColumn = val;
                                            this.$showPrintMargin = !!val;
                                            this.$updatePrintMargin();
                                          },
                                          get: function() {
                                            return this.$showPrintMargin && this.$printMarginColumn;
                                          }
                                        },
                                        displayIndentGuides: {
                                          set: function(show) {
                                            if (this.$cellLayer.setDisplayIndentGuides(show))
                                              this.$loop.schedule(this.CHANGE_TEXT);
                                          },
                                          initialValue: true
                                        },
                                        hScrollBarAlwaysVisible: {
                                          set: function(alwaysVisible) {
                                            this.$hScrollBarAlwaysVisible = alwaysVisible;
                                            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                                              this.$loop.schedule(this.CHANGE_SCROLL);
                                          },
                                          initialValue: false
                                        },
                                        vScrollBarAlwaysVisible: {
                                          set: function(val) {
                                            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                                              this.$loop.schedule(this.CHANGE_SCROLL);
                                          },
                                          initialValue: false
                                        },
                                        fontSize: {
                                          set: function(size) {
                                            if (typeof size == "number")
                                              size = size + "px";
                                            this.container.style.fontSize = size;
                                            this.updateFontSize();
                                          },
                                          initialValue: 12
                                        },
                                        fontFamily: {
                                          set: function(name) {
                                            this.container.style.fontFamily = name;
                                            this.updateFontSize();
                                          }
                                        },
                                        maxLines: {
                                          set: function(val) {
                                            this.updateFull();
                                          }
                                        },
                                        minLines: {
                                          set: function(val) {
                                            this.updateFull();
                                          }
                                        },
                                        scrollPastEnd: {
                                          set: function(val) {
                                            val = +val || 0;
                                            if (this.$scrollPastEnd == val)
                                              return;
                                            this.$scrollPastEnd = val;
                                            this.$loop.schedule(this.CHANGE_SCROLL);
                                          },
                                          initialValue: 0,
                                          handlesSet: true
                                        }
                                      });
                                      exports3.VirtualRenderer = VirtualRenderer;
                                    }.call(exports2, __webpack_require__22, exports2, module222), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module222.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                  }
                                ),
                                /***/
                                28: (
                                  /***/
                                  (module222) => {
                                    module222.exports = ".ace_tree-light.ace_tree{\n    font: 12px Arial;\n}\n\n.ace_tree_selection_range{\n    background : rgba(0, 110, 255, 0.2);\n    border : 1px solid rgba(0,0,0,0.1);\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-light .toggler {\n    overflow: visible;\n    width: 10px;\n    height: 10px;\n}\n\n.ace_tree-light .tree-row .caption {\n    padding : 4px 5px;\n}\n.ace_tree-light .tree-row > .caption {\n    overflow: visible;\n    display: inline-block;\n}\n.ace_tree-light .tree-row {\n    border: 1px solid transparent;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n.ace_tree-light .tree-row:hover,\n.ace_tree-light .tree-row.hover{\n    background: rgba(0, 0, 0, 0.03);\n}\n.ace_tree-light .tree-row.selected {\n    background: rgba(0, 0, 0, 0.04);\n}\n\n.ace_tree_focus.ace_tree-light .tree-row.selected {\n    background: -webkit-gradient(linear, left top, left bottom, from(#2890E5), color-stop(1, #1F82D2));\n    background: -moz-linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    background: linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    color: #f8f8f8;\n}\n\n\n/* datagrid */\n\n.ace_tree-light .tree-row>.tree-column {\n    border: 1px solid rgb(204, 204, 204);\n    border-width: 0 1px 1px 0;\n    padding: 4px 5px;\n}\n\n.ace_tree-light .tree-row.selected>.tree-column {\n    background: transparent;\n}\n.ace_tree-light .tree-headings {\n    background: rgb(253, 253, 253);\n}\n.ace_tree-light .tree-headings>.tree-column {\n    background: transparent;\n    padding: 5px 3px;\n}\n\n.ace_tree-light .tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 1px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -1px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
                                  }
                                ),
                                /***/
                                268: (
                                  /***/
                                  (module222) => {
                                    module222.exports = ".ace_tree{\n    overflow : hidden;\n    font : 12px Tahoma, Arial;\n    cursor: default;\n    position: relative;\n    white-space: pre;\n}\n\n.ace_tree textarea{\n    position : absolute;\n    z-index : 0;\n}\n\n.ace_tree_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n         -o-user-select: none;\n            user-select: none;\n}\n\n.ace_tree_content {\n    position: absolute;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n.ace_scrollbar {\n    position: absolute;\n    overflow-x: hidden;\n    overflow-y: auto;\n    right: 0;\n    bottom: 0;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    position: absolute;\n    overflow-x: auto;\n    overflow-y: hidden;\n    right: 0;\n    left: 0;\n    bottom: 0;\n}\n\n.ace_tree_horheading {\n    position : absolute;\n}\n\n.ace_tree_verheading{\n    bottom : 0;\n    position : absolute;\n}\n\n.ace_tree_heading {\n    z-index: 10;\n    position: relative;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree .tree-indent {\n    display : inline-block;\n}\n\n.ace_tree_selection_range{\n    position : absolute;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-editor {\n    position : absolute;\n    z-index : 10000;\n    background : white;\n    padding : 3px 4px 3px 4px;\n    -moz-box-sizing : border-box;\n         box-sizing : border-box;\n    border : 1px dotted green;\n    left: 0;\n    right: 0\n}\n\n\n\n.ace_tree .toggler {\n    width: 10px;\n    height: 10px;\n    background-repeat: no-repeat;\n    background-position: 0px 0px;\n    background-repeat: no-repeat;\n    cursor: pointer;\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_tree .toggler.empty {\n    pointer-events: none;\n}\n\n.ace_tree .toggler.open {\n    background-position: -10px 0px;\n}\n\n.ace_tree .toggler.empty {\n    background-position: 50px 0px;\n    cursor: default;\n}\n\n.ace_tree_cells, .ace_tree_cell-layer {\n    width: 100%;\n}\n.ace_tree_selection-layer {\n    width: 100%;\n    height: 110%;\n}\n.ace_tree_cells .message.empty {\n    text-align: center;\n    opacity: 0.9;\n    cursor : default;\n}\n\n/* datagrid */\n\n.ace_tree .tree-row>.tree-column {\n    display: inline-block;\n    overflow: hidden;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n\n.tree-headings {\n    white-space: nowrap;\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    left: 0;\n    right: 0;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.tree-headings>.tree-column {\n    display: inline-block;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 2px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -2px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
                                  }
                                )
                                /******/
                              };
                              var __webpack_module_cache__22 = {};
                              function __nested_webpack_require_262623__(moduleId) {
                                var cachedModule = __webpack_module_cache__22[moduleId];
                                if (cachedModule !== void 0) {
                                  return cachedModule.exports;
                                }
                                var module222 = __webpack_module_cache__22[moduleId] = {
                                  /******/
                                  // no module.id needed
                                  /******/
                                  // no module.loaded needed
                                  /******/
                                  exports: {}
                                  /******/
                                };
                                __webpack_modules__22[moduleId](module222, module222.exports, __nested_webpack_require_262623__);
                                return module222.exports;
                              }
                              (() => {
                                __nested_webpack_require_262623__.n = (module222) => {
                                  var getter = module222 && module222.__esModule ? (
                                    /******/
                                    () => module222["default"]
                                  ) : (
                                    /******/
                                    () => module222
                                  );
                                  __nested_webpack_require_262623__.d(getter, { a: getter });
                                  return getter;
                                };
                              })();
                              (() => {
                                __nested_webpack_require_262623__.d = (exports2, definition) => {
                                  for (var key in definition) {
                                    if (__nested_webpack_require_262623__.o(definition, key) && !__nested_webpack_require_262623__.o(exports2, key)) {
                                      Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                                    }
                                  }
                                };
                              })();
                              (() => {
                                __nested_webpack_require_262623__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
                              })();
                              (() => {
                                __nested_webpack_require_262623__.r = (exports2) => {
                                  if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                                    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                                  }
                                  Object.defineProperty(exports2, "__esModule", { value: true });
                                };
                              })();
                              var __nested_webpack_exports__2 = {};
                              (() => {
                                "use strict";
                                __nested_webpack_require_262623__.r(__nested_webpack_exports__2);
                                __nested_webpack_require_262623__.d(__nested_webpack_exports__2, {
                                  /* harmony export */
                                  DataProvider: () => (
                                    /* reexport module object */
                                    _src_data_provider__WEBPACK_IMPORTED_MODULE_1__
                                  ),
                                  /* harmony export */
                                  Tree: () => (
                                    /* reexport module object */
                                    _src_tree__WEBPACK_IMPORTED_MODULE_0__
                                  )
                                  /* harmony export */
                                });
                                var _src_tree__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_262623__(336);
                                var _src_tree__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_tree__WEBPACK_IMPORTED_MODULE_0__);
                                var _src_data_provider__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_262623__(950);
                                var _src_data_provider__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_data_provider__WEBPACK_IMPORTED_MODULE_1__);
                              })();
                              return __nested_webpack_exports__2;
                            })()
                          );
                        });
                      }
                    ),
                    /***/
                    46: (
                      /***/
                      (module22) => {
                        "use strict";
                        var R = typeof Reflect === "object" ? Reflect : null;
                        var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                          return Function.prototype.apply.call(target, receiver, args);
                        };
                        var ReflectOwnKeys;
                        if (R && typeof R.ownKeys === "function") {
                          ReflectOwnKeys = R.ownKeys;
                        } else if (Object.getOwnPropertySymbols) {
                          ReflectOwnKeys = function ReflectOwnKeys2(target) {
                            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                          };
                        } else {
                          ReflectOwnKeys = function ReflectOwnKeys2(target) {
                            return Object.getOwnPropertyNames(target);
                          };
                        }
                        function ProcessEmitWarning(warning) {
                          if (console && console.warn)
                            console.warn(warning);
                        }
                        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                          return value !== value;
                        };
                        function EventEmitter() {
                          EventEmitter.init.call(this);
                        }
                        module22.exports = EventEmitter;
                        module22.exports.once = once;
                        EventEmitter.EventEmitter = EventEmitter;
                        EventEmitter.prototype._events = void 0;
                        EventEmitter.prototype._eventsCount = 0;
                        EventEmitter.prototype._maxListeners = void 0;
                        var defaultMaxListeners = 10;
                        function checkListener(listener) {
                          if (typeof listener !== "function") {
                            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                          }
                        }
                        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                          enumerable: true,
                          get: function() {
                            return defaultMaxListeners;
                          },
                          set: function(arg) {
                            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                            }
                            defaultMaxListeners = arg;
                          }
                        });
                        EventEmitter.init = function() {
                          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                            this._events = /* @__PURE__ */ Object.create(null);
                            this._eventsCount = 0;
                          }
                          this._maxListeners = this._maxListeners || void 0;
                        };
                        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                          if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                          }
                          this._maxListeners = n;
                          return this;
                        };
                        function _getMaxListeners(that) {
                          if (that._maxListeners === void 0)
                            return EventEmitter.defaultMaxListeners;
                          return that._maxListeners;
                        }
                        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                          return _getMaxListeners(this);
                        };
                        EventEmitter.prototype.emit = function emit(type) {
                          var args = [];
                          for (var i = 1; i < arguments.length; i++)
                            args.push(arguments[i]);
                          var doError = type === "error";
                          var events = this._events;
                          if (events !== void 0)
                            doError = doError && events.error === void 0;
                          else if (!doError)
                            return false;
                          if (doError) {
                            var er;
                            if (args.length > 0)
                              er = args[0];
                            if (er instanceof Error) {
                              throw er;
                            }
                            var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                            err.context = er;
                            throw err;
                          }
                          var handler = events[type];
                          if (handler === void 0)
                            return false;
                          if (typeof handler === "function") {
                            ReflectApply(handler, this, args);
                          } else {
                            var len = handler.length;
                            var listeners = arrayClone(handler, len);
                            for (var i = 0; i < len; ++i)
                              ReflectApply(listeners[i], this, args);
                          }
                          return true;
                        };
                        function _addListener(target, type, listener, prepend) {
                          var m;
                          var events;
                          var existing;
                          checkListener(listener);
                          events = target._events;
                          if (events === void 0) {
                            events = target._events = /* @__PURE__ */ Object.create(null);
                            target._eventsCount = 0;
                          } else {
                            if (events.newListener !== void 0) {
                              target.emit(
                                "newListener",
                                type,
                                listener.listener ? listener.listener : listener
                              );
                              events = target._events;
                            }
                            existing = events[type];
                          }
                          if (existing === void 0) {
                            existing = events[type] = listener;
                            ++target._eventsCount;
                          } else {
                            if (typeof existing === "function") {
                              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                            } else if (prepend) {
                              existing.unshift(listener);
                            } else {
                              existing.push(listener);
                            }
                            m = _getMaxListeners(target);
                            if (m > 0 && existing.length > m && !existing.warned) {
                              existing.warned = true;
                              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                              w.name = "MaxListenersExceededWarning";
                              w.emitter = target;
                              w.type = type;
                              w.count = existing.length;
                              ProcessEmitWarning(w);
                            }
                          }
                          return target;
                        }
                        EventEmitter.prototype.addListener = function addListener(type, listener) {
                          return _addListener(this, type, listener, false);
                        };
                        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                          return _addListener(this, type, listener, true);
                        };
                        function onceWrapper() {
                          if (!this.fired) {
                            this.target.removeListener(this.type, this.wrapFn);
                            this.fired = true;
                            if (arguments.length === 0)
                              return this.listener.call(this.target);
                            return this.listener.apply(this.target, arguments);
                          }
                        }
                        function _onceWrap(target, type, listener) {
                          var state = { fired: false, wrapFn: void 0, target, type, listener };
                          var wrapped = onceWrapper.bind(state);
                          wrapped.listener = listener;
                          state.wrapFn = wrapped;
                          return wrapped;
                        }
                        EventEmitter.prototype.once = function once2(type, listener) {
                          checkListener(listener);
                          this.on(type, _onceWrap(this, type, listener));
                          return this;
                        };
                        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                          checkListener(listener);
                          this.prependListener(type, _onceWrap(this, type, listener));
                          return this;
                        };
                        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                          var list, events, position, i, originalListener;
                          checkListener(listener);
                          events = this._events;
                          if (events === void 0)
                            return this;
                          list = events[type];
                          if (list === void 0)
                            return this;
                          if (list === listener || list.listener === listener) {
                            if (--this._eventsCount === 0)
                              this._events = /* @__PURE__ */ Object.create(null);
                            else {
                              delete events[type];
                              if (events.removeListener)
                                this.emit("removeListener", type, list.listener || listener);
                            }
                          } else if (typeof list !== "function") {
                            position = -1;
                            for (i = list.length - 1; i >= 0; i--) {
                              if (list[i] === listener || list[i].listener === listener) {
                                originalListener = list[i].listener;
                                position = i;
                                break;
                              }
                            }
                            if (position < 0)
                              return this;
                            if (position === 0)
                              list.shift();
                            else {
                              spliceOne(list, position);
                            }
                            if (list.length === 1)
                              events[type] = list[0];
                            if (events.removeListener !== void 0)
                              this.emit("removeListener", type, originalListener || listener);
                          }
                          return this;
                        };
                        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                          var listeners, events, i;
                          events = this._events;
                          if (events === void 0)
                            return this;
                          if (events.removeListener === void 0) {
                            if (arguments.length === 0) {
                              this._events = /* @__PURE__ */ Object.create(null);
                              this._eventsCount = 0;
                            } else if (events[type] !== void 0) {
                              if (--this._eventsCount === 0)
                                this._events = /* @__PURE__ */ Object.create(null);
                              else
                                delete events[type];
                            }
                            return this;
                          }
                          if (arguments.length === 0) {
                            var keys = Object.keys(events);
                            var key;
                            for (i = 0; i < keys.length; ++i) {
                              key = keys[i];
                              if (key === "removeListener")
                                continue;
                              this.removeAllListeners(key);
                            }
                            this.removeAllListeners("removeListener");
                            this._events = /* @__PURE__ */ Object.create(null);
                            this._eventsCount = 0;
                            return this;
                          }
                          listeners = events[type];
                          if (typeof listeners === "function") {
                            this.removeListener(type, listeners);
                          } else if (listeners !== void 0) {
                            for (i = listeners.length - 1; i >= 0; i--) {
                              this.removeListener(type, listeners[i]);
                            }
                          }
                          return this;
                        };
                        function _listeners(target, type, unwrap) {
                          var events = target._events;
                          if (events === void 0)
                            return [];
                          var evlistener = events[type];
                          if (evlistener === void 0)
                            return [];
                          if (typeof evlistener === "function")
                            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                        }
                        EventEmitter.prototype.listeners = function listeners(type) {
                          return _listeners(this, type, true);
                        };
                        EventEmitter.prototype.rawListeners = function rawListeners(type) {
                          return _listeners(this, type, false);
                        };
                        EventEmitter.listenerCount = function(emitter, type) {
                          if (typeof emitter.listenerCount === "function") {
                            return emitter.listenerCount(type);
                          } else {
                            return listenerCount.call(emitter, type);
                          }
                        };
                        EventEmitter.prototype.listenerCount = listenerCount;
                        function listenerCount(type) {
                          var events = this._events;
                          if (events !== void 0) {
                            var evlistener = events[type];
                            if (typeof evlistener === "function") {
                              return 1;
                            } else if (evlistener !== void 0) {
                              return evlistener.length;
                            }
                          }
                          return 0;
                        }
                        EventEmitter.prototype.eventNames = function eventNames() {
                          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                        };
                        function arrayClone(arr, n) {
                          var copy = new Array(n);
                          for (var i = 0; i < n; ++i)
                            copy[i] = arr[i];
                          return copy;
                        }
                        function spliceOne(list, index) {
                          for (; index + 1 < list.length; index++)
                            list[index] = list[index + 1];
                          list.pop();
                        }
                        function unwrapListeners(arr) {
                          var ret = new Array(arr.length);
                          for (var i = 0; i < ret.length; ++i) {
                            ret[i] = arr[i].listener || arr[i];
                          }
                          return ret;
                        }
                        function once(emitter, name) {
                          return new Promise(function(resolve, reject) {
                            function errorListener(err) {
                              emitter.removeListener(name, resolver);
                              reject(err);
                            }
                            function resolver() {
                              if (typeof emitter.removeListener === "function") {
                                emitter.removeListener("error", errorListener);
                              }
                              resolve([].slice.call(arguments));
                            }
                            ;
                            eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                            if (name !== "error") {
                              addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                            }
                          });
                        }
                        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                          if (typeof emitter.on === "function") {
                            eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                          }
                        }
                        function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                          if (typeof emitter.on === "function") {
                            if (flags.once) {
                              emitter.once(name, listener);
                            } else {
                              emitter.on(name, listener);
                            }
                          } else if (typeof emitter.addEventListener === "function") {
                            emitter.addEventListener(name, function wrapListener(arg) {
                              if (flags.once) {
                                emitter.removeEventListener(name, wrapListener);
                              }
                              listener(arg);
                            });
                          } else {
                            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                          }
                        }
                      }
                    ),
                    /***/
                    591: (
                      /***/
                      (module22) => {
                        "use strict";
                        var stylesInDOM = [];
                        function getIndexByIdentifier(identifier) {
                          var result = -1;
                          for (var i = 0; i < stylesInDOM.length; i++) {
                            if (stylesInDOM[i].identifier === identifier) {
                              result = i;
                              break;
                            }
                          }
                          return result;
                        }
                        function modulesToDom(list, options) {
                          var idCountMap = {};
                          var identifiers = [];
                          for (var i = 0; i < list.length; i++) {
                            var item = list[i];
                            var id = options.base ? item[0] + options.base : item[0];
                            var count = idCountMap[id] || 0;
                            var identifier = "".concat(id, " ").concat(count);
                            idCountMap[id] = count + 1;
                            var indexByIdentifier = getIndexByIdentifier(identifier);
                            var obj = {
                              css: item[1],
                              media: item[2],
                              sourceMap: item[3],
                              supports: item[4],
                              layer: item[5]
                            };
                            if (indexByIdentifier !== -1) {
                              stylesInDOM[indexByIdentifier].references++;
                              stylesInDOM[indexByIdentifier].updater(obj);
                            } else {
                              var updater = addElementStyle(obj, options);
                              options.byIndex = i;
                              stylesInDOM.splice(i, 0, {
                                identifier,
                                updater,
                                references: 1
                              });
                            }
                            identifiers.push(identifier);
                          }
                          return identifiers;
                        }
                        function addElementStyle(obj, options) {
                          var api = options.domAPI(options);
                          api.update(obj);
                          var updater = function updater2(newObj) {
                            if (newObj) {
                              if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
                                return;
                              }
                              api.update(obj = newObj);
                            } else {
                              api.remove();
                            }
                          };
                          return updater;
                        }
                        module22.exports = function(list, options) {
                          options = options || {};
                          list = list || [];
                          var lastIdentifiers = modulesToDom(list, options);
                          return function update(newList) {
                            newList = newList || [];
                            for (var i = 0; i < lastIdentifiers.length; i++) {
                              var identifier = lastIdentifiers[i];
                              var index = getIndexByIdentifier(identifier);
                              stylesInDOM[index].references--;
                            }
                            var newLastIdentifiers = modulesToDom(newList, options);
                            for (var _i = 0; _i < lastIdentifiers.length; _i++) {
                              var _identifier = lastIdentifiers[_i];
                              var _index = getIndexByIdentifier(_identifier);
                              if (stylesInDOM[_index].references === 0) {
                                stylesInDOM[_index].updater();
                                stylesInDOM.splice(_index, 1);
                              }
                            }
                            lastIdentifiers = newLastIdentifiers;
                          };
                        };
                      }
                    ),
                    /***/
                    128: (
                      /***/
                      (module22) => {
                        "use strict";
                        var memo = {};
                        function getTarget(target) {
                          if (typeof memo[target] === "undefined") {
                            var styleTarget = document.querySelector(target);
                            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                              try {
                                styleTarget = styleTarget.contentDocument.head;
                              } catch (e) {
                                styleTarget = null;
                              }
                            }
                            memo[target] = styleTarget;
                          }
                          return memo[target];
                        }
                        function insertBySelector(insert, style) {
                          var target = getTarget(insert);
                          if (!target) {
                            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                          }
                          target.appendChild(style);
                        }
                        module22.exports = insertBySelector;
                      }
                    ),
                    /***/
                    51: (
                      /***/
                      (module22) => {
                        "use strict";
                        function insertStyleElement(options) {
                          var element = document.createElement("style");
                          options.setAttributes(element, options.attributes);
                          options.insert(element, options.options);
                          return element;
                        }
                        module22.exports = insertStyleElement;
                      }
                    ),
                    /***/
                    855: (
                      /***/
                      (module22, __unused_webpack_exports2, __webpack_require__22) => {
                        "use strict";
                        function setAttributesWithoutAttributes(styleElement) {
                          var nonce =  true ? __webpack_require__22.nc : 0;
                          if (nonce) {
                            styleElement.setAttribute("nonce", nonce);
                          }
                        }
                        module22.exports = setAttributesWithoutAttributes;
                      }
                    ),
                    /***/
                    740: (
                      /***/
                      (module22) => {
                        "use strict";
                        function apply(styleElement, options, obj) {
                          var css = "";
                          if (obj.supports) {
                            css += "@supports (".concat(obj.supports, ") {");
                          }
                          if (obj.media) {
                            css += "@media ".concat(obj.media, " {");
                          }
                          var needLayer = typeof obj.layer !== "undefined";
                          if (needLayer) {
                            css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
                          }
                          css += obj.css;
                          if (needLayer) {
                            css += "}";
                          }
                          if (obj.media) {
                            css += "}";
                          }
                          if (obj.supports) {
                            css += "}";
                          }
                          var sourceMap = obj.sourceMap;
                          if (sourceMap && typeof btoa !== "undefined") {
                            css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
                          }
                          options.styleTagTransform(css, styleElement, options.options);
                        }
                        function removeStyleElement(styleElement) {
                          if (styleElement.parentNode === null) {
                            return false;
                          }
                          styleElement.parentNode.removeChild(styleElement);
                        }
                        function domAPI(options) {
                          if (typeof document === "undefined") {
                            return {
                              update: function update() {
                              },
                              remove: function remove() {
                              }
                            };
                          }
                          var styleElement = options.insertStyleElement(options);
                          return {
                            update: function update(obj) {
                              apply(styleElement, options, obj);
                            },
                            remove: function remove() {
                              removeStyleElement(styleElement);
                            }
                          };
                        }
                        module22.exports = domAPI;
                      }
                    ),
                    /***/
                    656: (
                      /***/
                      (module22) => {
                        "use strict";
                        function styleTagTransform(css, styleElement) {
                          if (styleElement.styleSheet) {
                            styleElement.styleSheet.cssText = css;
                          } else {
                            while (styleElement.firstChild) {
                              styleElement.removeChild(styleElement.firstChild);
                            }
                            styleElement.appendChild(document.createTextNode(css));
                          }
                        }
                        module22.exports = styleTagTransform;
                      }
                    ),
                    /***/
                    937: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAItlI+py+2fgAMSVUGvoZjHrFkeE0LmiabqagZO4CKxAM8GTONJrSv1ywoKh4oCADs=";
                      }
                    ),
                    /***/
                    592: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAACICAYAAADuxmtPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBQkU4MzRBNDE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBQkU4MzRBNTE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkFCRTgzNEEyMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFCRTgzNEEzMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+JumAiwAACF9JREFUeNrsmX9sU9cVx6/t599J6JrUSZyfjg2OnR+khB91qdRQ0a4pVA3QlgilaemP/TFtfyG1f7VSxRqgQ9M2RZUYYh2MpghNKlJAqVKphbUNtEAggRjHTuwk2IlJ45g48e8fb+cY+8XGdvADNHVdrnQU5/l+z73vnnM+795nDk3TBFthUZES/jSCFYHxSfoWBLODXbplt5vxAhUTP9Xe3r772c2bnywuLlZQFCVMpw6FQv6pqSlzb2/vedB8Ck6+o+BD1Wttbbtfb29vlUDj8XhkiSaUSqUauVxeweFyceApLmie2LJliy4vL08CIxMOh7OkYR/s+0Jz85Og3UAFg8HHKioqqvBLNg00CtSiA0oIjbBsqEFtdBHZjp7Yog64sCAP5OB/fAYCgSAMzc/n81lFArMSNGGuTCZz2Ww2y70S6G6zWq2WwsJCF7e5uXnk9OnTfRBTD65FNoZ9UYNa3r/Pnbt9+PBhemx83A+5Lc7Nzc2DeuClGxVuNTAxMWH6rKurx2g0ftnZ2dnHiZWz/I8HD9aePHmyDKotF0ZIW1F4z1Ct8607d1r37NlzDS5Nxh1gewRMBibFyGZYuwiYG+wW2BwTxhgT8uFPAwugzD1coLzz9tut+fn5EizMTIkFtysEmGgqKyuTgbJjxw5daWmpRCwWR8OUKfb4HfbBvtu3bYsChYtQ0Gq1VWxTGDSLQIF0Zg0U1KD2/svwYVXjL2EGCJQYHO4fKFCiFrYjj4+PLwLl1KlTfYFAwJMtjbAvahigHDp0iB4bG/MXxYACKcvLMO2AxWIxHT16tGdoaOiXAhSscSIrLHxq//79R0wm0w2/3++LRCJ0OsPvoI++o6PjCGqis4cPVR/BBY/H4wbq0tkY9t0HA4JWeQco27frYIEkMArJxrDvtpaWxR1KWVlZVcJiZtVAswgUeI4I0TObhhpmh8JWnFLO/+8OECiQYQ8GlJuw28A8YGMTN28uAqW7u7vP6/V6ss1E7Isa1GI5r2hra3tOqVQ246a7pKSkCp7OgkxAgb2R+cyZM31ms/nL48eP9y4D5SEAhVQqFLsMBoMeFo6+l/3j7HH6nc9+F/0Mmhuo5SYCZSk7N/Qt+fOlT4g3h5DWY2+wA4rRaiJ7v/uYqDR1ZNBwmfx9R2d6oDidTjLnc5HK4ookBx+eO0CK5OXkqk1PPtr8HtHKNIyGG3eA1m3qIa1f7CZfXOlmrr3f8wdC5YqIfsZE2hUvkeeVm5nvksrZ5pwk/xw8QTZqmkjH9wdJmBMm8/4FYgtOE/OCjazJXUV+r/tNSukzMyheUUQOvfJX0m+6QGoVa0i3uZd8cvEwmfbfJnlBiny8ZS+JhJKLKuUW5MI7TkasNwgH6qlW0UicM5PkLy0HCD9EpVRl1EEcKPGLpUI5+dvL4GRyiFwd6yd7n/+AFPFlKWLYI2QGSrmohHRu+xP57YY3yAZZ45JA4b351lu5kN/59fX1aogtP97hUf4jpLZAm1bs8/k8n5840aNSqb5ZBkoiUA4cOGIaGbkB4fHRGRp+B330Hfv2JQMFL8DKuuksG/bFARmgIKYyYSzR4kDBz4g/Bijl5eX3PPJ8PXiWAcorn75GQLMIFDzmLbXFGbLoU4CCmpQjj91uJ8NjxhQHcaBcA6B8AEB5vKwhuZzjKRoHyokL/2KuvXvq/SSgtNRsZb5LygOTbSQroKQ9saA3lVx5T6CIheKkoko58qgLVmYEyqPiX6U/MyFQEA5xr9rHqlOAsipflVLSEIHMR566Qi0DlOdWPrPkkScKlNHR0fzGxkY1xJYpInleMVlXuiatGAjowVNLRWXlN8yRxwJHHvCY3ZHn2LEe/fKRZ3mHsrxDWd6hLO9QMr+Ura6u3rimoUEAa8CDqaZ9O4dlbLPZVlzu71eA5nvmpeyqlSs3Nj39NIWxnZyaCtMZnvUcaCKxmLdp0yY+/LMRX8pSMNp6iEBk1uFwZ3NmDgYCYfgTUCoUAojEOgoQJRPw+X62J3gY2IdaCoT8OxuwAOujP2gFVGxx7vsFws/EARRH+IEcwALe/wzgUR70er00lDLNMgL4sj5ESaVSx5zLJc7JyWEVx4WFBQFoZ7hqtXrQefu2yOf1YpbR2Rj2RQ1qsZwFT+h0TZM22yqJROIWCYVBSHk6ww8UHJ/fL4CHq1heUmK6cP782TgPJLt27VL/ePGi1u12F8D9UWm3dHDPOO3169bpu7q6huGSJxEoiDFxLDKZXrZj5xCYF4N3N1DKHuhn4/8KUKanpwukOTkRAEqENVAcDseKUbO5GtfBr1b3A1BoBAo3ASgZ2+zsrHRkdLTu1Vd3ctauXe8dNhrrYvulZKBACCU4GoTKEx95fn5eCiOvbmnZDmnPd8AmRCISifxgQdQy5QwO+HAmrANnPJVSeRE7QcJIzBbL6q1bXxTAw2r2hx/OS6zWieDaxkb93NwchpNHxTbPBKa4uqnpmTwej0t/9VVvA0Tjus1qrf918wtiHoj7+y8Jx8bMIRBfn5mZWYgvNDdWGCKYgcR+y+7iC0Sz1ZoaLizQehDnwPPWOThwVTQyYqTr6+pQ7IK+4TiEqNjP4PNajebalf7LNcFAkC4vrwjKi+XBUDBMhg0GvslkDDc0NAzMOBxz4VCITgEKzCAETuya6urIwMCVGlhdqrS0LARnCmp42EBg5GsQZmfoLnESUGBaUSdQomRg8KoWOlND+uuc2pqaQVj5mbupFQcKD7JJhSXNo6gQdoLmhp2HxzBsKIAM1UNopz1ebzgMm+1Ec83PY724eDqdjsCZSSWEZIoe8WG7BIXvUVZV/QQjO8FBOBIOk0QDqHAgIaRarfbHjECB6XFwi//zB8p/BBgAHNqa8EdleScAAAAASUVORK5CYII=";
                      }
                    ),
                    /***/
                    952: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANCAYAAAB7AEQGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNEM5MTlGOTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNEM5MTlGQTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM0QzkxOUY3MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM0QzkxOUY4MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+52cTFgAAAQdJREFUeNpi+v//PwMyZuQUUEEXY2JAAkxcghMV5OVug2hkcWQTJgRFxPy/c+fOf3efwP9Afg9MDqagx9bZ4/+lS5f+Hzhw4P/Fixf/Wzu6gRS2g+WBDHNDfb0T82dNYXj18iXEDUxMDIJCQgwxSRkMN27e0oObBMRfgfg/Ev4ANwlsJ8TRXECKnQEVfPn37f1vsCKggnZOTo4KNjY2FBVfv35j+PPnDxvIKkNdY8v/V69e+//w4UM4Pn/+wn9VHSOQtZpwkzTV1Srys1IYWJiZGX79+sXQO3kmw937D5qA1tWjhJOhuc3/qdOm/Tcws8YMJ2SFojJKIAUTkMUZsMSdEroYQIABAD4w1u/PTSI1AAAAAElFTkSuQmCC";
                      }
                    ),
                    /***/
                    560: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAIjlI+py+0PDZhs2mWpyqDqCIbiSJbmEqRMyqJs4LbxSdf2UgAAOw==";
                      }
                    ),
                    /***/
                    784: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/gif;base64,R0lGODlhBAAeAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAEAB4AAAIXhA4maeyr1Jm02mvDDFpw/YVe12HmaRUAOw==";
                      }
                    ),
                    /***/
                    553: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAAqCAYAAAAXk8MDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjQyQUZBRjU3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjQyQUZBRjY3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2NDJBRkFGMzdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2NDJBRkFGNDdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv8NHYkAAASLSURBVHja3FhLbyNFEP7aHj+z3k1k5yGUxYmEtICSFRJrIXHYUyBCAo6cOEX5BZz4I9y4J3vgEIG0h0U5RQpIK22AA4l4HJIgsrE3b4f4MdN0tdPj2cnMZCZMj1eU1B67uz1dX9dX1V3FOOcgmZqa4pZlQQljzP6u5jjHqM85xz3Xa4yE1uh0Omi1Wi/1m6aJdDp9bZ9Xv/qdSqWQyWSwt7cnFzfo4/XqXV6e3UflXhuFIVKMtEMkoencBk8gr87pCjzbz4DPPvoCDx98gvKdCuKUF0d1PP7+W1RGK7xRbzBjenqaj71Tx1StjXwOyGYj4/IF45a/fwc+//RL1N78AC+eH+D5X/uxgjMMAx8+/BhGJo2JiQlukElfe7uF27eAYh5IG32FfU1kc9ADpEe/GvvzEHir+h7q9Tp0CNGd3v3g/vv4qvU1DPKN0h0gLyyWE82msuIZcynrBZpf8x81zUyhdd654sOxg7zoSj+UdiJAwhfBxNNSyvK+4szHWld05N4W7QeTDLrdLnSLWsNQypCilhkyciAABHNZEg5rQr/VXvLBHl1oV8XTuqqk7Uf29kcInS56irMmWXC0mATGewBvJF5+6YNhIOCIkhYPCBIxiMV7h3iitLQuaWn7HPP3KWdw4dzHz3ytlrDl5FXqv9IypPCkaWlbzlQ7G4GKLGTUvPxNm5g8La1eM60QoFjEyDlIWirLmWbIcy5MtPQZGwg40+pbL+qFuXd+BQNVF+uebycITvoA9/C3EH7nqSf3n2dhANHy4kxkBKVwlvM8CvzSIBfgtLi/nreaKGSLWkGdXzTlM0Xg6n9k0WkLenb7FvRrloPCgfMUDR3ziiL7+G33R2k9ne3ZLz8gl8vB2N7eZpN3J7mR2cf4vQ6Ktx0WivF2QlIcBtZ/fgRLbOIbk++K/PFWrBZr/nOKn359iu++eYLDw0PGlA9Uq1W7huKujzh/O31G1VKuq7k451JC2W63Zb6lQ6iWQsD6KY8QKthQi3tRWiybzcrCDRVwiC7UvC7U7qJSUBHKb/Od/dJylUqFLy4uYn5+HqOjo7GCo7R/dXUVy8vLGBsbk3UOVQUjsOq7U6hf9ak5zuqZc9w9dnJygqOjI+zs7DA2Pj7OFxYWMDc3JzvjzpQJzPDwMNbW1rCysoJyuay3xCBof3BwgOPjYxhExVqtpr1oMzs7i6WlJapK2TTSdeaNjIxIgLL6RdbSfbjSGtZlJh43MOf7FO3tgJJk0UYXMK/AYySd+rsVC77ehdfLa64nOL+diCVhddDyOuWj6uBmha/ldFhTvTPsu6Pq4J5veJ0z2soMCdKf1hqoz4XdhCD93If8KxNQwvraTfyf/pMoLZNeK3bLBUVaXRE4UVr6vS8p+it2JOpz/wvLvQpHAVlPgjs7O8PQ0JDWxZrNZmDYjlMoGSCWpChL3tjY0F602dzcRD6fT8RilJfSRhqNRoOJ/EfyZWZmBqVSKdbFTk9PsbW1hfX1de2JKmUeAo9su7u7/QIRAbxJ/SRsClMoFGSuFaYmEnXcfWOhih59/1eAAQAVvW4V+Ky7cAAAAABJRU5ErkJggg==";
                      }
                    ),
                    /***/
                    147: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==";
                      }
                    ),
                    /***/
                    444: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__444__2;
                      }
                    ),
                    /***/
                    910: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__910__2;
                      }
                    ),
                    /***/
                    254: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__254__2;
                      }
                    ),
                    /***/
                    685: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__685__2;
                      }
                    ),
                    /***/
                    292: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__292__2;
                      }
                    ),
                    /***/
                    736: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__736__2;
                      }
                    ),
                    /***/
                    517: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__517__2;
                      }
                    ),
                    /***/
                    540: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__540__2;
                      }
                    ),
                    /***/
                    863: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__863__2;
                      }
                    ),
                    /***/
                    387: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__387__2;
                      }
                    ),
                    /***/
                    493: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__493__2;
                      }
                    ),
                    /***/
                    748: (
                      /***/
                      (module22) => {
                        "use strict";
                        module22.exports = __WEBPACK_EXTERNAL_MODULE__748__2;
                      }
                    )
                    /******/
                  };
                  var __webpack_module_cache__2 = {};
                  function __nested_webpack_require_440138__(moduleId) {
                    var cachedModule = __webpack_module_cache__2[moduleId];
                    if (cachedModule !== void 0) {
                      return cachedModule.exports;
                    }
                    var module22 = __webpack_module_cache__2[moduleId] = {
                      /******/
                      id: moduleId,
                      /******/
                      // no module.loaded needed
                      /******/
                      exports: {}
                      /******/
                    };
                    __webpack_modules__2[moduleId].call(module22.exports, module22, module22.exports, __nested_webpack_require_440138__);
                    return module22.exports;
                  }
                  __nested_webpack_require_440138__.m = __webpack_modules__2;
                  (() => {
                    __nested_webpack_require_440138__.n = (module22) => {
                      var getter = module22 && module22.__esModule ? (
                        /******/
                        () => module22["default"]
                      ) : (
                        /******/
                        () => module22
                      );
                      __nested_webpack_require_440138__.d(getter, { a: getter });
                      return getter;
                    };
                  })();
                  (() => {
                    __nested_webpack_require_440138__.d = (exports2, definition) => {
                      for (var key in definition) {
                        if (__nested_webpack_require_440138__.o(definition, key) && !__nested_webpack_require_440138__.o(exports2, key)) {
                          Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                        }
                      }
                    };
                  })();
                  (() => {
                    __nested_webpack_require_440138__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
                  })();
                  (() => {
                    __nested_webpack_require_440138__.r = (exports2) => {
                      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                        Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                      }
                      Object.defineProperty(exports2, "__esModule", { value: true });
                    };
                  })();
                  (() => {
                    __nested_webpack_require_440138__.b = document.baseURI || self.location.href;
                    var installedChunks = {
                      /******/
                      57: 0
                      /******/
                    };
                  })();
                  (() => {
                    __nested_webpack_require_440138__.nc = void 0;
                  })();
                  var __nested_webpack_exports__ = {};
                  (() => {
                    "use strict";
                    __nested_webpack_require_440138__.r(__nested_webpack_exports__);
                    __nested_webpack_require_440138__.d(__nested_webpack_exports__, {
                      Accordion: () => (
                        /* reexport */
                        Accordion
                      ),
                      AceEditor: () => (
                        /* reexport */
                        AceEditor
                      ),
                      AceLayout: () => (
                        /* reexport */
                        AceLayout
                      ),
                      AceTreeWrapper: () => (
                        /* reexport */
                        AceTreeWrapper
                      ),
                      Box: () => (
                        /* reexport */
                        Box
                      ),
                      Button: () => (
                        /* reexport */
                        Button
                      ),
                      CommandManager: () => (
                        /* reexport */
                        CommandManager
                      ),
                      Dropdown: () => (
                        /* reexport */
                        Dropdown
                      ),
                      EditorType: () => (
                        /* reexport */
                        EditorType
                      ),
                      FileSystemWeb: () => (
                        /* reexport */
                        FileSystemWeb
                      ),
                      ListBox: () => (
                        /* reexport */
                        ListBox
                      ),
                      Menu: () => (
                        /* reexport */
                        Menu
                      ),
                      MenuBar: () => (
                        /* reexport */
                        MenuBar
                      ),
                      MenuItems: () => (
                        /* reexport */
                        MenuItems
                      ),
                      MenuManager: () => (
                        /* reexport */
                        MenuManager
                      ),
                      MenuPopup: () => (
                        /* reexport */
                        MenuPopup
                      ),
                      MenuSearchBox: () => (
                        /* reexport */
                        MenuSearchBox
                      ),
                      MenuToolbar: () => (
                        /* reexport */
                        MenuToolbar
                      ),
                      Pane: () => (
                        /* reexport */
                        Pane
                      ),
                      Panel: () => (
                        /* reexport */
                        Panel
                      ),
                      PanelBar: () => (
                        /* reexport */
                        PanelBar
                      ),
                      PanelManager: () => (
                        /* reexport */
                        PanelManager
                      ),
                      PreviewEditor: () => (
                        /* reexport */
                        PreviewEditor
                      ),
                      SettingsSearchBox: () => (
                        /* reexport */
                        SettingsSearchBox
                      ),
                      SizeUnit: () => (
                        /* reexport */
                        SizeUnit
                      ),
                      Switcher: () => (
                        /* reexport */
                        Switcher
                      ),
                      Tab: () => (
                        /* reexport */
                        Tab
                      ),
                      TabManager: () => (
                        /* reexport */
                        TabManager
                      ),
                      Toolbar: () => (
                        /* reexport */
                        Toolbar
                      ),
                      dom: () => (
                        /* reexport */
                        dom
                      )
                    });
                    var accordion_namespaceObject = {};
                    __nested_webpack_require_440138__.r(accordion_namespaceObject);
                    __nested_webpack_require_440138__.d(accordion_namespaceObject, {
                      "default": () => styles_accordion
                    });
                    var tab_namespaceObject = {};
                    __nested_webpack_require_440138__.r(tab_namespaceObject);
                    __nested_webpack_require_440138__.d(tab_namespaceObject, {
                      "default": () => styles_tab
                    });
                    var menu_namespaceObject = {};
                    __nested_webpack_require_440138__.r(menu_namespaceObject);
                    __nested_webpack_require_440138__.d(menu_namespaceObject, {
                      "default": () => styles_menu
                    });
                    var button_namespaceObject = {};
                    __nested_webpack_require_440138__.r(button_namespaceObject);
                    __nested_webpack_require_440138__.d(button_namespaceObject, {
                      "default": () => assets_styles_button
                    });
                    var dropdown_namespaceObject = {};
                    __nested_webpack_require_440138__.r(dropdown_namespaceObject);
                    __nested_webpack_require_440138__.d(dropdown_namespaceObject, {
                      "default": () => styles_dropdown
                    });
                    var switcher_namespaceObject = {};
                    __nested_webpack_require_440138__.r(switcher_namespaceObject);
                    __nested_webpack_require_440138__.d(switcher_namespaceObject, {
                      "default": () => styles_switcher
                    });
                    var panel_namespaceObject = {};
                    __nested_webpack_require_440138__.r(panel_namespaceObject);
                    __nested_webpack_require_440138__.d(panel_namespaceObject, {
                      "default": () => styles_panel
                    });
                    var layout_namespaceObject = {};
                    __nested_webpack_require_440138__.r(layout_namespaceObject);
                    __nested_webpack_require_440138__.d(layout_namespaceObject, {
                      "default": () => styles_layout
                    });
                    var ace_tree_namespaceObject = {};
                    __nested_webpack_require_440138__.r(ace_tree_namespaceObject);
                    __nested_webpack_require_440138__.d(ace_tree_namespaceObject, {
                      "default": () => styles_ace_tree
                    });
                    var hash_handler_ = __nested_webpack_require_440138__(736);
                    ;
                    const commandManager_event = __nested_webpack_require_440138__(517);
                    const keyUtil = __nested_webpack_require_440138__(863);
                    class CommandManager {
                      static registerCommands(commands, context) {
                        let menuKb = new hash_handler_.HashHandler(commands);
                        let _this = context;
                        commandManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
                          let keyString = keyUtil.keyCodeToString(keyCode);
                          let command = menuKb.findKeyCommand(hashId, keyString);
                          if (command && command.exec) {
                            commandManager_event.stopEvent(e);
                            command.exec(_this);
                          }
                        });
                      }
                    }
                    var useragent_ = __nested_webpack_require_440138__(493);
                    ;
                    var XHTML_NS = "http://www.w3.org/1999/xhtml";
                    var dom;
                    ((dom2) => {
                      dom2.buildDom = function(arr, parent, refs) {
                        if (typeof arr == "string" && arr) {
                          var txt = document.createTextNode(arr);
                          if (parent)
                            parent.appendChild(txt);
                          return txt;
                        }
                        if (!Array.isArray(arr)) {
                          if (arr && arr.appendChild && parent)
                            parent.appendChild(arr);
                          return arr;
                        }
                        if (typeof arr[0] != "string" || !arr[0]) {
                          var els = [];
                          for (var i = 0; i < arr.length; i++) {
                            var ch = (0, dom2.buildDom)(arr[i], parent, refs);
                            ch && els.push(ch);
                          }
                          return els;
                        }
                        var el = document.createElement(arr[0]);
                        var options2 = arr[1];
                        var childIndex = 1;
                        if (options2 && typeof options2 == "object" && !Array.isArray(options2))
                          childIndex = 2;
                        for (var i = childIndex; i < arr.length; i++)
                          (0, dom2.buildDom)(arr[i], el, refs);
                        if (childIndex == 2) {
                          Object.keys(options2).forEach(function(n) {
                            var val = options2[n];
                            if (n === "class") {
                              el.className = Array.isArray(val) ? val.join(" ") : val;
                            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                              el[n] = val;
                            } else if (n === "ref") {
                              if (refs)
                                refs[val] = el;
                            } else if (n === "style") {
                              if (typeof val == "string")
                                el.style.cssText = val;
                            } else if (val != null) {
                              el.setAttribute(n, val);
                            }
                          });
                        }
                        if (parent)
                          parent.appendChild(el);
                        return el;
                      };
                      dom2.getDocumentHead = function(doc) {
                        if (!doc)
                          doc = document;
                        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
                      };
                      dom2.createElement = function(tag, ns) {
                        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
                      };
                      dom2.removeChildren = function(element) {
                        element.innerHTML = "";
                      };
                      dom2.createTextNode = function(textContent, element) {
                        var doc = element ? element.ownerDocument : document;
                        return doc.createTextNode(textContent);
                      };
                      dom2.createFragment = function(element) {
                        var doc = element ? element.ownerDocument : document;
                        return doc.createDocumentFragment();
                      };
                      dom2.hasCssClass = function(el, name) {
                        var classes = (el.className + "").split(/\s+/g);
                        return classes.indexOf(name) !== -1;
                      };
                      dom2.addCssClass = function(el, name) {
                        if (!(0, dom2.hasCssClass)(el, name)) {
                          el.className += " " + name;
                        }
                      };
                      dom2.removeCssClass = function(el, name) {
                        var classes = el.className.split(/\s+/g);
                        while (true) {
                          var index = classes.indexOf(name);
                          if (index == -1) {
                            break;
                          }
                          classes.splice(index, 1);
                        }
                        el.className = classes.join(" ");
                      };
                      dom2.toggleCssClass = function(el, name) {
                        var classes = el.className.split(/\s+/g), add = true;
                        while (true) {
                          var index = classes.indexOf(name);
                          if (index == -1) {
                            break;
                          }
                          add = false;
                          classes.splice(index, 1);
                        }
                        if (add)
                          classes.push(name);
                        el.className = classes.join(" ");
                        return add;
                      };
                      dom2.setCssClass = function(node, className, include) {
                        if (include) {
                          (0, dom2.addCssClass)(node, className);
                        } else {
                          (0, dom2.removeCssClass)(node, className);
                        }
                      };
                      dom2.hasCssString = function(id, doc) {
                        var index = 0, sheets;
                        doc = doc || document;
                        if (sheets = doc.querySelectorAll("style")) {
                          while (index < sheets.length) {
                            if (sheets[index++].id === id) {
                              return true;
                            }
                          }
                        }
                      };
                      dom2.removeElementById = function(id, doc) {
                        doc = doc || document;
                        if (doc.getElementById(id)) {
                          doc.getElementById(id).remove();
                        }
                      };
                      var strictCSP;
                      var cssCache = [];
                      dom2.useStrictCSP = function(value) {
                        strictCSP = value;
                        if (value == false)
                          insertPendingStyles();
                        else if (!cssCache)
                          cssCache = [];
                      };
                      function insertPendingStyles() {
                        var cache = cssCache;
                        cssCache = null;
                        cache && cache.forEach(function(item) {
                          importCssString(item[0], item[1]);
                        });
                      }
                      function importCssString(cssText, id, target) {
                        if (typeof document == "undefined")
                          return;
                        if (cssCache) {
                          if (target) {
                            insertPendingStyles();
                          } else if (target === false) {
                            return cssCache.push([cssText, id]);
                          }
                        }
                        if (strictCSP)
                          return;
                        var container = target;
                        if (!target || !target.getRootNode) {
                          container = document;
                        } else {
                          container = target.getRootNode();
                          if (!container || container == target)
                            container = document;
                        }
                        var doc = container.ownerDocument || container;
                        if (id && (0, dom2.hasCssString)(id, container))
                          return null;
                        if (id)
                          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
                        var style = (0, dom2.createElement)("style");
                        style.appendChild(doc.createTextNode(cssText));
                        if (id)
                          style.id = id;
                        if (container == doc)
                          container = (0, dom2.getDocumentHead)(doc);
                        container.insertBefore(style, container.firstChild);
                      }
                      dom2.importCssString = importCssString;
                      dom2.importCssStylsheet = function(uri, doc) {
                        (0, dom2.buildDom)(["link", { rel: "stylesheet", href: uri }], (0, dom2.getDocumentHead)(doc));
                      };
                      dom2.scrollbarWidth = function(document2) {
                        var inner = (0, dom2.createElement)("ace_inner");
                        inner.style.width = "100%";
                        inner.style.minWidth = "0px";
                        inner.style.height = "200px";
                        inner.style.display = "block";
                        var outer = (0, dom2.createElement)("ace_outer");
                        var style = outer.style;
                        style.position = "absolute";
                        style.left = "-10000px";
                        style.overflow = "hidden";
                        style.width = "200px";
                        style.minWidth = "0px";
                        style.height = "150px";
                        style.display = "block";
                        outer.appendChild(inner);
                        var body = document2.documentElement;
                        body.appendChild(outer);
                        var noScrollbar = inner.offsetWidth;
                        style.overflow = "scroll";
                        var withScrollbar = inner.offsetWidth;
                        if (noScrollbar == withScrollbar) {
                          withScrollbar = outer.clientWidth;
                        }
                        body.removeChild(outer);
                        return noScrollbar - withScrollbar;
                      };
                      dom2.computedStyle = function(element, style) {
                        return window.getComputedStyle(element, "") || {};
                      };
                      dom2.setStyle = function(styles, property, value) {
                        if (styles[property] !== value) {
                          styles[property] = value;
                        }
                      };
                      dom2.HAS_CSS_ANIMATION = false;
                      dom2.HAS_CSS_TRANSFORMS = false;
                      dom2.HI_DPI = useragent_.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
                      if (useragent_.isChromeOS)
                        dom2.HI_DPI = false;
                      if (typeof document !== "undefined") {
                        var div = document.createElement("div");
                        if (dom2.HI_DPI && div.style.transform !== void 0)
                          dom2.HAS_CSS_TRANSFORMS = true;
                        if (!useragent_.isEdge && typeof div.style.animationName !== "undefined")
                          dom2.HAS_CSS_ANIMATION = true;
                        div = null;
                      }
                      if (dom2.HAS_CSS_TRANSFORMS) {
                        dom2.translate = function(element, tx, ty) {
                          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
                        };
                      } else {
                        dom2.translate = function(element, tx, ty) {
                          element.style.top = Math.round(ty) + "px";
                          element.style.left = Math.round(tx) + "px";
                        };
                      }
                    })(dom || (dom = {}));
                    ;
                    var SizeUnit = /* @__PURE__ */ ((SizeUnit2) => {
                      SizeUnit2[SizeUnit2["px"] = 0] = "px";
                      SizeUnit2[SizeUnit2["percent"] = 1] = "percent";
                      return SizeUnit2;
                    })(SizeUnit || {});
                    var EditorType = /* @__PURE__ */ ((EditorType2) => {
                      EditorType2["ace"] = "ace";
                      EditorType2["preview"] = "preview";
                      return EditorType2;
                    })(EditorType || {});
                    ;
                    var Utils;
                    ((Utils2) => {
                      Utils2.findHost = function(el, constructor) {
                        while (el) {
                          if (el.$host && (!constructor || el.$host.constructor === constructor))
                            return el.$host;
                          el = el.parentElement;
                        }
                      };
                      Utils2.findNode = function(node, className) {
                        while (node && node.classList) {
                          if (node.classList.contains(className))
                            return node;
                          node = node.parentNode;
                        }
                        return null;
                      };
                      Utils2.findHostTarget = function(target) {
                        while (target) {
                          if (target.$host)
                            return target;
                          target = target.parentElement;
                        }
                        return null;
                      };
                      Utils2.setBox = function(el, x, y, w, h) {
                        if (w) {
                          w = Math.max(w, 0);
                        }
                        if (h) {
                          h = Math.max(h, 0);
                        }
                        let s = el.style;
                        s.left = x + "px";
                        s.top = y + "px";
                        s.width = w + "px";
                        s.height = h + "px";
                      };
                      function getEdge(style, dir) {
                        return parseInt(style["padding" + dir], 10) + parseInt(style["margin" + dir], 10) + parseInt(style["border" + dir], 10);
                      }
                      Utils2.getEdge = getEdge;
                      function getElementEdges(element) {
                        let style = getComputedStyle(element);
                        return {
                          "top": getEdge(style, "Top"),
                          "bottom": getEdge(style, "Bottom"),
                          "left": getEdge(style, "Left"),
                          "right": getEdge(style, "Right")
                        };
                      }
                      Utils2.getElementEdges = getElementEdges;
                    })(Utils || (Utils = {}));
                    var event_ = __nested_webpack_require_440138__(517);
                    var events = __nested_webpack_require_440138__(46);
                    ;
                    const SPLITTER_SIZE = 1;
                    const BOX_MIN_SIZE = 40;
                    class Box extends events.EventEmitter {
                      constructor(options2) {
                        var _a, _b, _c, _d;
                        super();
                        this.$editorAdded = (editor) => {
                          this.emit("editorAdded", editor);
                        };
                        if (options2.splitter !== false) {
                        }
                        this.vertical = options2.vertical || false;
                        this.color = (_a = options2.color) != null ? _a : "";
                        this.isMain = options2.isMain || false;
                        this[0] = options2[0];
                        this[1] = options2[1];
                        if (this[0])
                          this[0].parent = this;
                        if (this[1])
                          this[1].parent = this;
                        this.ratio = options2.ratio;
                        this.toolBars = options2.toolBars || {};
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                        this.size = options2.size;
                        this.sizeUnit = (_b = options2.sizeUnit) != null ? _b : SizeUnit.px;
                        this.minSize = options2.minSize || BOX_MIN_SIZE;
                        this.minVerticalSize = options2.minVerticalSize || this.minSize;
                        this.minHorizontalSize = options2.minHorizontalSize || this.minSize;
                        this.classNames = (_c = options2.classNames) != null ? _c : "";
                        this.hidden = (_d = options2.hidden) != null ? _d : false;
                        this.fixedSize = options2.fixedSize;
                      }
                      //TODO
                      static enableAnimation() {
                        document.documentElement.classList.add("animateBoxes");
                      }
                      static disableAnimation() {
                        document.documentElement.classList.remove("animateBoxes");
                      }
                      static setGlobalCursor(value) {
                        if (value)
                          document.documentElement.classList.add("inheritCursor");
                        else
                          document.documentElement.classList.remove("inheritCursor");
                        document.documentElement.style.cursor = value;
                      }
                      toJSON() {
                        return {
                          0: this[0] && this[0].toJSON(),
                          1: this[1] && this[1].toJSON(),
                          ratio: this.ratio,
                          type: this.vertical ? "vbox" : "hbox",
                          fixedSize: this.fixedSize || null,
                          hidden: this.hidden,
                          color: this.color,
                          size: this.size
                        };
                      }
                      onMouseDown(e) {
                        let button = e.button;
                        if (button !== 0)
                          return;
                        let box = this;
                        let rect = this.element.getBoundingClientRect();
                        let x = e.clientX;
                        let y = e.clientY;
                        document.body.classList.add("dragging");
                        let onMouseMove = function(e2) {
                          x = e2.clientX - rect.left - box.padding.left;
                          y = e2.clientY - rect.top - box.padding.top;
                          let height = rect.height - box.padding.top - box.padding.bottom;
                          let width = rect.width - box.padding.left - box.padding.right;
                          if (box.fixedChild) {
                            if (box.vertical) {
                              box.fixedChild.fixedSize = box.fixedChild === box[1] ? height - y : y;
                            } else {
                              box.fixedChild.fixedSize = box.fixedChild === box[1] ? width - x : x;
                            }
                            box.fixedChild.fixedSize = Math.max(box.fixedChild.fixedSize, box.fixedChild.minSize);
                            box.ratio = void 0;
                          } else {
                            if (box.vertical) {
                              box.ratio = y / height;
                            } else {
                              box.ratio = x / width;
                            }
                            box.ratio = Math.max(box.minRatio, Math.min(box.ratio, box.maxRatio));
                          }
                          box.resize();
                        };
                        let onResizeEnd = function(e2) {
                          Box.setGlobalCursor("");
                          document.body.classList.remove("dragging");
                        };
                        Box.setGlobalCursor(`${box.vertical ? "ns" : "ew"}-resize`);
                        event_.capture(window, onMouseMove, onResizeEnd);
                        return e.preventDefault();
                      }
                      resize() {
                        if (!this.box)
                          return;
                        this.setBox(...this.box);
                      }
                      calculateMinMaxRatio() {
                        if (!this.box || !this[0] && !this[1])
                          return;
                        let propertyName = this.vertical ? "minVerticalSize" : "minHorizontalSize";
                        let size = this.vertical ? this.box[3] - this.padding.top - this.padding.bottom : this.box[2] - this.padding.left - this.padding.right;
                        this.minRatio = this[0] ? this[0][propertyName] / size : 0;
                        this.maxRatio = this[1] ? (size - this[1][propertyName]) / size : 1;
                      }
                      render() {
                        var _a;
                        if ((_a = this.element) == null ? void 0 : _a.$host)
                          return this.element;
                        this.renderElement();
                        this.splitter = dom.buildDom(["div", {
                          class: `splitter splitter${this.vertical ? "-v" : "-h"}`
                        }, ["div"]]);
                        this.splitter.onmousedown = this.onMouseDown.bind(this);
                        this.element.appendChild(this.splitter);
                        this.element.$host = this;
                        this.element.style.backgroundColor = this.color;
                        this.element.style.position = "absolute";
                        this.renderToolBarList();
                        this.renderChildren();
                        if (!this.ratio)
                          this.calculateRatio();
                        return this.element;
                      }
                      renderElement() {
                        var _a;
                        (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", {
                          class: "box" + this.classNames
                        }]);
                      }
                      renderToolBarList() {
                        for (let position in this.toolBars) {
                          this.addToolBar(position, this.toolBars[position]);
                        }
                      }
                      addToolBar(position, bar) {
                        var _a, _b;
                        if (position == "left" || position == "right")
                          bar.direction = "vertical";
                        (_b = (_a = this.toolBars[position]) == null ? void 0 : _a.element) == null ? void 0 : _b.remove();
                        bar.position = position;
                        this.padding[position] = bar.size;
                        this.element.appendChild(bar.render());
                        this.toolBars[position] = bar;
                      }
                      removeToolBar(position) {
                        delete this.toolBars[position];
                        this.padding[position] = 0;
                      }
                      renderChildren() {
                        this.renderChild(this[0]);
                        this.renderChild(this[1]);
                        this.calculateMinSize();
                      }
                      renderChild(child) {
                        if (!child)
                          return;
                        if (!this.element)
                          this.render();
                        child.on("editorAdded", this.$editorAdded);
                        this.element.appendChild(child.render());
                      }
                      calculateMinSize(forceChildrenSize = false) {
                        let childrenMinVerticalSize = 0;
                        let childrenMinHorizontalSize = 0;
                        let calculateChildBoxMinSize = (childBox) => {
                          if (this.vertical) {
                            childrenMinVerticalSize += childBox.minVerticalSize;
                            childrenMinHorizontalSize = Math.max(childBox.minHorizontalSize, childrenMinHorizontalSize);
                          } else {
                            childrenMinVerticalSize = Math.max(childBox.minVerticalSize, childrenMinVerticalSize);
                            childrenMinHorizontalSize += childBox.minHorizontalSize;
                          }
                        };
                        if (this[0])
                          calculateChildBoxMinSize(this[0]);
                        if (this[1])
                          calculateChildBoxMinSize(this[1]);
                        if (forceChildrenSize) {
                          this.minVerticalSize = childrenMinVerticalSize;
                          this.minHorizontalSize = childrenMinHorizontalSize;
                        } else {
                          this.minVerticalSize = Math.max(this.minVerticalSize, childrenMinVerticalSize);
                          this.minHorizontalSize = Math.max(this.minHorizontalSize, childrenMinHorizontalSize);
                        }
                        this.minSize = this.vertical ? this.minVerticalSize : this.minHorizontalSize;
                        this.calculateMinMaxRatio();
                      }
                      calculateRatio() {
                        if (this[0]) {
                          this.calculateChildRatio(this[0]);
                        }
                        if (this.ratio || this.fixedChild) {
                          return;
                        }
                        if (this[1]) {
                          this.calculateChildRatio(this[1]);
                        }
                        if (!this.ratio && !this.fixedChild) {
                          this.ratio = 0.5;
                        }
                      }
                      calculateChildRatio(childBox, isSecond = false) {
                        if (!childBox.size) {
                          return;
                        }
                        let size = childBox.size;
                        switch (this.sizeUnit) {
                          case SizeUnit.px:
                            childBox.fixedSize = size;
                            this.fixedChild = childBox;
                            break;
                          case SizeUnit.percent:
                            if (isSecond) {
                              size = 100 - size;
                            }
                            this.ratio = Math.min(size / 100, 1);
                            break;
                        }
                      }
                      renderButtons(buttonList) {
                        let buttons = buttonList.map((button) => {
                          return dom.buildDom(["div", {
                            class: "button " + button.class,
                            title: button.title,
                            onclick: button.onclick
                          }, button.content]);
                        });
                        this.setButtons(buttons);
                      }
                      /**
                       * Sets buttons of this box top-right tabBar
                       */
                      setButtons(buttons) {
                        this.buttons = buttons;
                        if (this.topRightPane)
                          this.topRightPane.removeButtons();
                        this.topRightPane = this.getTopRightPane();
                        if (this.topRightPane)
                          this.topRightPane.setButtons(buttons);
                      }
                      addButton(button) {
                        this.topRightPane = this.getTopRightPane();
                        if (this.topRightPane)
                          this.topRightPane.addButton(button);
                      }
                      /**
                       * Finds the most top-right Pane
                       */
                      getTopRightPane() {
                        let childBox = this.vertical ? this[0] || this[1] : this[1] || this[0];
                        if (!childBox)
                          return;
                        return childBox.getTopRightPane();
                      }
                      setBox(x, y, w, h) {
                        this.box = [x, y, w, h];
                        if (this.isMaximized) {
                          x = 0;
                          y = 0;
                          w = window.innerWidth;
                          h = window.innerHeight;
                        }
                        Utils.setBox(this.element, x, y, w, h);
                        this.calculateMinMaxRatio();
                        this.$updateChildSize(x, y, w, h);
                      }
                      $updateChildSize(x, y, w, h) {
                        var _a;
                        let splitterSize = SPLITTER_SIZE;
                        if (!this[0] || this[0].hidden || !this[1] || this[1].hidden) {
                          this.splitter.style.display = "none";
                          splitterSize = 0;
                        } else {
                          this.splitter.style.display = "";
                        }
                        this.updateToolBarSize(w, h);
                        w -= this.padding.left + this.padding.right;
                        h -= this.padding.top + this.padding.bottom;
                        x = this.padding.left;
                        y = this.padding.top;
                        if (this.fixedChild) {
                          let size = this.fixedChild.fixedSize;
                          if (this.fixedChild === this[1]) {
                            size = this.vertical ? h - size : w - size;
                          }
                          this.ratio = this.vertical ? size / h : size / w;
                        }
                        this.ratio = Math.max(this.minRatio, Math.min((_a = this.ratio) != null ? _a : this.maxRatio, this.maxRatio));
                        let ratio = this.ratio;
                        if (!this[0] || this[0].hidden) {
                          ratio = 0;
                        } else if (!this[1] || this[1].hidden) {
                          ratio = 1;
                        }
                        if (this.vertical) {
                          let splitY = h * ratio - splitterSize;
                          if (this.splitter)
                            Utils.setBox(this.splitter, x, y + splitY, w, splitterSize);
                          if (this[0])
                            this[0].setBox(x, y, w, splitY);
                          if (this[1])
                            this[1].setBox(x, y + splitY + splitterSize, w, h - splitY - splitterSize);
                        } else {
                          let splitX = w * ratio - splitterSize;
                          if (this.splitter)
                            Utils.setBox(this.splitter, x + splitX, y, splitterSize, h);
                          if (this[0])
                            this[0].setBox(x, y, splitX, h);
                          if (this[1])
                            this[1].setBox(x + splitX + splitterSize, y, w - splitX - splitterSize, h);
                        }
                      }
                      updateToolBarSize(width, height) {
                        let bar, x, y, w, h;
                        for (let type in this.toolBars) {
                          x = 0;
                          y = 0;
                          w = width;
                          h = height;
                          bar = this.toolBars[type];
                          switch (type) {
                            case "top":
                            case "bottom":
                              h = bar.size;
                              if (type === "bottom")
                                y = height - bar.size;
                              break;
                            case "left":
                            case "right":
                              w = bar.size;
                              y = this.padding.top;
                              h -= this.padding.top + this.padding.bottom;
                              if (type === "right")
                                x = width - bar.size;
                              break;
                            default:
                              continue;
                          }
                          bar.setBox(x, y, w, h);
                        }
                      }
                      restore(disableAnimation = false) {
                        let node = this.element;
                        function rmClass(ch, cls) {
                          for (let i = 0; i < ch.length; i++) {
                            if (ch[i].classList)
                              ch[i].classList.remove(cls);
                          }
                        }
                        let finishRestore = () => {
                          classes.forEach(function(className) {
                            rmClass(document.querySelectorAll("." + className), className);
                          });
                          this.setBox(...this.box);
                        };
                        let classes = [
                          "fullScreenSibling",
                          "fullScreenNode",
                          "fullScreenParent"
                        ];
                        this.isMaximized = false;
                        if (disableAnimation) {
                          finishRestore();
                        } else {
                          Box.enableAnimation();
                          node.addEventListener("transitionend", function handler(l) {
                            Box.disableAnimation();
                            node.removeEventListener("transitionend", handler);
                            finishRestore();
                          });
                        }
                        let parentRect = node.parentNode.getBoundingClientRect();
                        let top = parentRect.top + this.box[1];
                        let left = parentRect.left + this.box[0];
                        Utils.setBox(node, left, top, this.box[2], this.box[3]);
                      }
                      maximize(disableAnimation = false) {
                        let node = this.element;
                        function addClasses() {
                          node.classList.add("fullScreenNode");
                          let parent = node.parentNode;
                          while (parent && parent !== document.body) {
                            if (parent.classList)
                              parent.classList.add("fullScreenParent");
                            let childNodes = parent.childNodes;
                            for (let i = 0; i < childNodes.length; i++) {
                              let childNode = childNodes[i];
                              if (childNode != node && childNode.classList && !childNode.classList.contains("fullScreenParent"))
                                childNode.classList.add("fullScreenSibling");
                            }
                            parent = parent.parentNode;
                          }
                        }
                        let rect = node.getBoundingClientRect();
                        Utils.setBox(node, rect.left, rect.top, rect.width, rect.height);
                        addClasses();
                        this.isMaximized = true;
                        node.getBoundingClientRect();
                        if (!disableAnimation) {
                          Box.enableAnimation();
                          node.addEventListener("transitionend", function handler() {
                            node.removeEventListener("transitionend", handler);
                            Box.disableAnimation();
                          });
                        }
                        this.setBox(...this.box);
                      }
                      toggleMaximize() {
                        if (this.isMaximized)
                          this.restore();
                        else
                          this.maximize();
                      }
                      remove() {
                        this.removeAllChildren();
                        if (this.element)
                          this.element.remove();
                        if (this.parent) {
                          if (this.parent[0] == this)
                            this.parent[0] = void 0;
                          if (this.parent[1] == this)
                            this.parent[1] = void 0;
                          this.parent.recalculateAllMinSizes();
                          this.parent = void 0;
                        }
                      }
                      removeAllChildren() {
                        this.removeChild(this[0]);
                        this.removeChild(this[1]);
                        this[0] = void 0;
                        this[1] = void 0;
                      }
                      removeChild(child) {
                        if (!child)
                          return;
                        child.off("editorAdded", this.$editorAdded);
                        child.remove();
                        child.element.remove();
                      }
                      toggleShowHide() {
                        var _a;
                        Box.enableAnimation();
                        this.hidden = !this.hidden;
                        (_a = this.parent) == null ? void 0 : _a.resize();
                        let node = this.element;
                        let self2 = this;
                        node.addEventListener("transitionend", function handler() {
                          var _a2;
                          node.removeEventListener("transitionend", handler);
                          Box.disableAnimation();
                          (_a2 = self2.parent) == null ? void 0 : _a2.resize();
                        });
                      }
                      hide() {
                        var _a;
                        Box.enableAnimation();
                        this.hidden = true;
                        (_a = this.parent) == null ? void 0 : _a.resize();
                        let node = this.element;
                        let self2 = this;
                        node.addEventListener("transitionend", function handler() {
                          var _a2;
                          node.removeEventListener("transitionend", handler);
                          Box.disableAnimation();
                          (_a2 = self2.parent) == null ? void 0 : _a2.resize();
                        });
                      }
                      show() {
                        var _a;
                        Box.enableAnimation();
                        this.hidden = false;
                        (_a = this.parent) == null ? void 0 : _a.resize();
                        let node = this.element;
                        let self2 = this;
                        node.addEventListener("transitionend", function handler() {
                          var _a2;
                          node.removeEventListener("transitionend", handler);
                          Box.disableAnimation();
                          (_a2 = self2.parent) == null ? void 0 : _a2.resize();
                        });
                      }
                      /**
                       *
                       * @param {Number} previousBoxIndex
                       * @param {Box} box
                       * @returns {Box}
                       */
                      addChildBox(previousBoxIndex, box) {
                        let previousBox, index;
                        if (previousBoxIndex instanceof Box) {
                          previousBox = previousBoxIndex;
                          index = this[0] == previousBox ? 0 : 1;
                        } else {
                          index = previousBoxIndex;
                          previousBox = this[index];
                        }
                        if (previousBox && previousBox === box)
                          return previousBox;
                        let previousParent = box.parent;
                        if (previousParent && previousParent !== this) {
                          let previousIndex = previousParent[0] === box ? 0 : 1;
                          previousParent[previousIndex] = null;
                          previousParent.ratio = 1;
                          if (previousParent.fixedChild && previousParent.fixedChild === box) {
                            previousParent.fixedChild = null;
                          }
                          previousParent.resize();
                        }
                        this[index] = box;
                        box.parent = this;
                        this.renderChild(box);
                        if (previousBox && previousBox.isMaximized) {
                          previousBox.restore(true);
                          box.maximize(true);
                        }
                        if (previousBox && previousBox.parent === this) {
                          if (this.fixedChild && this.fixedChild == previousBox) {
                            box.fixedSize = previousBox.fixedSize;
                            if (!box.size)
                              box.size = previousBox.size;
                            previousBox.fixedSize = previousBox.size = null;
                            this.fixedChild = box;
                          }
                          previousBox.remove();
                        }
                        if (!this.fixedChild)
                          this.calculateChildRatio(box);
                        this.recalculateAllMinSizes();
                        this.resize();
                        return box;
                      }
                      recalculateAllMinSizes() {
                        let node = this;
                        while (node) {
                          node.calculateMinSize(true);
                          node = node.parent;
                        }
                      }
                    }
                    ;
                    let accordion_handler_event = __nested_webpack_require_440138__(517);
                    var AccordionHandler;
                    ((AccordionHandler2) => {
                      AccordionHandler2.toggleBarMouseDown = function(e, accordionConstructor) {
                        let toggleBlock = Utils.findNode(e.target, "toggle-block");
                        if (!toggleBlock)
                          return;
                        let accordionBox, accordionBoxRect, toggleBlockDragging, toggleBlockRect;
                        let startIndex, changeIndex, previousIndex;
                        let toggleBar, section, splitter;
                        let startX = e.clientX, startY = e.clientY;
                        let isDragging = false;
                        let posX, posY, prevY, prevX;
                        let prevBlock, topMaxY, nextBlock, bottomMaxY;
                        function distance(dx, dy) {
                          return dx * dx + dy * dy;
                        }
                        function calculateNearbyBlocksData() {
                          if (!accordionBox)
                            return;
                          prevBlock = accordionBox.toggleBlockList[changeIndex - 1] || null;
                          nextBlock = accordionBox.toggleBlockList[changeIndex + 1] || null;
                          topMaxY = prevBlock && parseInt(prevBlock.style.top, 10) + parseInt(prevBlock.style.height, 10) / 2 + accordionBoxRect.top;
                          bottomMaxY = nextBlock && parseInt(nextBlock.style.top, 10) + parseInt(nextBlock.style.height, 10) / 2 + accordionBoxRect.top;
                        }
                        function startDragging() {
                          if (isDragging)
                            return;
                          accordionBox = Utils.findHost(toggleBlock, accordionConstructor);
                          if (!accordionBox)
                            return;
                          accordionBoxRect = accordionBox.element.getBoundingClientRect();
                          startIndex = changeIndex = previousIndex = toggleBlock.$index;
                          toggleBlockRect = toggleBlock.getBoundingClientRect();
                          toggleBlockDragging = toggleBlock.cloneNode(true);
                          toggleBlockDragging.$hostAccordionBox = accordionBox;
                          toggleBlockDragging.$hostIndex = startIndex;
                          toggleBlockDragging.classList.add("toggleBlockDragging");
                          Utils.setBox(toggleBlockDragging, toggleBlockRect.left, toggleBlockRect.top, toggleBlockRect.width, toggleBlockRect.height);
                          posX = startX - toggleBlockRect.left;
                          posY = startY - toggleBlockRect.top;
                          document.body.appendChild(toggleBlockDragging);
                          toggleBlock.style.opacity = 0;
                          calculateNearbyBlocksData();
                          isDragging = true;
                        }
                        function recalculateIndexes(arr) {
                          for (let i = 0; i < arr.length; i++) {
                            arr[i].$index = i;
                          }
                        }
                        function accordionDataChanged() {
                          if (!accordionBox)
                            return;
                          recalculateIndexes(accordionBox.sections);
                          recalculateIndexes(accordionBox.toggleBarList);
                          recalculateIndexes(accordionBox.toggleBlockList);
                          recalculateIndexes(accordionBox.splitterList);
                          accordionBox.resize();
                        }
                        function addToAccordionBox(index) {
                          if (!accordionBox)
                            return;
                          accordionBox.sections.splice(index, 0, section);
                          accordionBox.toggleBarList.splice(index, 0, toggleBar);
                          accordionBox.toggleBlockList.splice(index, 0, toggleBlock);
                          calculateNearbyBlocksData();
                          if (nextBlock) {
                            accordionBox.element.insertBefore(splitter, nextBlock);
                            accordionBox.element.insertBefore(toggleBlock, splitter);
                            accordionBox.splitterList.splice(index - 1, 0, splitter);
                          } else {
                            accordionBox.element.appendChild(splitter);
                            accordionBox.element.appendChild(toggleBlock);
                            accordionBox.splitterList.push(splitter);
                          }
                          toggleBlock.$parent = accordionBox;
                          splitter.$parent = accordionBox;
                          accordionBox.calculateSectionsSizesPercents();
                          accordionBox.recalculateChildrenSizes();
                          accordionDataChanged();
                        }
                        function removeFromAccordionBox() {
                          if (!accordionBox)
                            return;
                          section = accordionBox.sections.splice(previousIndex, 1)[0];
                          toggleBar = accordionBox.toggleBarList.splice(previousIndex, 1)[0];
                          toggleBlock = accordionBox.toggleBlockList.splice(previousIndex, 1)[0];
                          let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex - 1;
                          splitter = accordionBox.splitterList.splice(splitterIndex, 1)[0];
                          toggleBlockDragging.style.height = accordionBox.toggleBarHeight + "px";
                          toggleBlock.remove();
                          splitter.remove();
                          accordionBox.calculateSectionsSizesPercents();
                          accordionBox.recalculateChildrenSizes();
                          accordionDataChanged();
                          accordionBox = void 0;
                          toggleBlock.$parent = null;
                          splitter.$parent = null;
                        }
                        function finishDragging() {
                          if (!accordionBox) {
                            accordionBox = toggleBlockDragging.$hostAccordionBox;
                            addToAccordionBox(toggleBlockDragging.$hostIndex);
                          }
                          toggleBlockDragging.remove();
                          toggleBlock.style.opacity = 1;
                          isDragging = false;
                        }
                        let onMouseMove = function(e2) {
                          if (e2.type !== "mousemove")
                            return;
                          if (!isDragging) {
                            if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
                              return;
                            startDragging();
                          }
                          let left = e2.clientX - posX;
                          let top = e2.clientY - posY;
                          if (accordionBox) {
                            if (left < accordionBoxRect.left - accordionBoxRect.width || left > accordionBoxRect.left + accordionBoxRect.width) {
                              removeFromAccordionBox();
                            }
                          }
                          if (!accordionBox) {
                            accordionBox = Utils.findHost(e2.target, accordionConstructor);
                            if (accordionBox) {
                              accordionBoxRect = accordionBox.element.getBoundingClientRect();
                              nextBlock = Utils.findNode(e2.target, "toggle-block");
                              if (nextBlock) {
                                startIndex = nextBlock.$index;
                              } else {
                                startIndex = accordionBox.toggleBlockList.length;
                              }
                              previousIndex = changeIndex = startIndex;
                              addToAccordionBox(previousIndex);
                              toggleBlockDragging.style.height = toggleBlock.style.height;
                            }
                          }
                          if (accordionBox) {
                            left = accordionBoxRect.left;
                            if (e2.clientY < prevY && topMaxY && top < topMaxY) {
                              changeIndex--;
                            } else if (e2.clientY > prevY && bottomMaxY && top + toggleBlockRect.height > bottomMaxY) {
                              changeIndex++;
                            }
                            if (changeIndex !== previousIndex) {
                              accordionBox.element.insertBefore(toggleBlock, accordionBox.toggleBlockList[changeIndex]);
                              let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex + 1;
                              accordionBox.element.insertBefore(accordionBox.toggleBlockList[changeIndex], accordionBox.splitterList[splitterIndex]);
                              accordionBox.sections.splice(changeIndex, 0, accordionBox.sections.splice(previousIndex, 1)[0]);
                              accordionBox.toggleBarList.splice(changeIndex, 0, accordionBox.toggleBarList.splice(previousIndex, 1)[0]);
                              accordionBox.toggleBlockList.splice(changeIndex, 0, accordionBox.toggleBlockList.splice(previousIndex, 1)[0]);
                              calculateNearbyBlocksData();
                              accordionDataChanged();
                              previousIndex = changeIndex;
                            }
                          }
                          toggleBlockDragging.style.left = left + "px";
                          toggleBlockDragging.style.top = top + "px";
                          prevX = e2.clientX;
                          prevY = e2.clientY;
                        };
                        let onMouseUp = function(e2) {
                          if (!isDragging)
                            return;
                          finishDragging();
                        };
                        accordion_handler_event.capture(window, onMouseMove, onMouseUp);
                        return e.preventDefault();
                      };
                      AccordionHandler2.toggleBarOnClick = function(e) {
                        let toggleBlock = Utils.findNode(e.target, "toggle-block");
                        if (!toggleBlock)
                          return;
                        let accordionBox = toggleBlock.$parent;
                        let index = toggleBlock.$index;
                        let isOpened = accordionBox.isOpenedBlock(toggleBlock);
                        if (!isOpened) {
                          toggleBlock.classList.add("toggle-opened");
                          index = void 0;
                        } else {
                          toggleBlock.classList.remove("toggle-opened");
                        }
                        accordionBox.recalculateChildrenSizes(index);
                        Box.enableAnimation();
                        let node = accordionBox.element;
                        node.addEventListener("transitionend", function handler() {
                          node.removeEventListener("transitionend", handler);
                          Box.disableAnimation();
                        });
                        accordionBox.resize();
                      };
                      AccordionHandler2.splitterMouseDown = function(e) {
                        let button = e.button;
                        if (button !== 0)
                          return;
                        let splitter = Utils.findNode(e.target, "splitter");
                        if (!splitter)
                          return;
                        let accordionBox = splitter.$parent;
                        let x = e.clientX;
                        let y = e.clientY;
                        let splitterIndex = splitter.$index + 1;
                        let prevX = x;
                        let prevY = y;
                        if (!accordionBox.hasNextOpenedBlocks(splitterIndex) || !accordionBox.hasPrevOpenedBlocks(splitterIndex))
                          return;
                        accordionBox.keepState();
                        let onMouseMove = function(e2) {
                          x = e2.clientX;
                          y = e2.clientY;
                          let changedSize = 0;
                          if (prevY > y) {
                            changedSize = accordionBox.recalculatePreviousSectionsSize(splitterIndex, y);
                            if (changedSize === 0)
                              return;
                            accordionBox.expandNextSections(splitterIndex, changedSize);
                          } else if (prevY < y) {
                            changedSize = accordionBox.recalculateNextSectionsSize(splitterIndex, y);
                            if (changedSize === 0)
                              return;
                            accordionBox.expandPreviousSections(splitterIndex, changedSize);
                          } else {
                            return;
                          }
                          prevY = y;
                          accordionBox.resize();
                        };
                        let onResizeEnd = function(e2) {
                          accordionBox.dischargeState();
                          Box.setGlobalCursor("");
                          accordionBox.calculateSectionsSizesPercents();
                        };
                        Box.setGlobalCursor(`${accordionBox.vertical ? "ns" : "ew"}-resize`);
                        accordion_handler_event.capture(window, onMouseMove, onResizeEnd);
                        return e.preventDefault();
                      };
                    })(AccordionHandler || (AccordionHandler = {}));
                    var injectStylesIntoStyleTag = __nested_webpack_require_440138__(591);
                    var injectStylesIntoStyleTag_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(injectStylesIntoStyleTag);
                    var styleDomAPI = __nested_webpack_require_440138__(740);
                    var styleDomAPI_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(styleDomAPI);
                    var insertBySelector = __nested_webpack_require_440138__(128);
                    var insertBySelector_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(insertBySelector);
                    var setAttributesWithoutAttributes = __nested_webpack_require_440138__(855);
                    var setAttributesWithoutAttributes_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(setAttributesWithoutAttributes);
                    var insertStyleElement = __nested_webpack_require_440138__(51);
                    var insertStyleElement_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(insertStyleElement);
                    var styleTagTransform = __nested_webpack_require_440138__(656);
                    var styleTagTransform_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(styleTagTransform);
                    var accordion = __nested_webpack_require_440138__(286);
                    ;
                    var options = {};
                    options.styleTagTransform = styleTagTransform_default();
                    options.setAttributes = setAttributesWithoutAttributes_default();
                    options.insert = insertBySelector_default().bind(null, "head");
                    options.domAPI = styleDomAPI_default();
                    options.insertStyleElement = insertStyleElement_default();
                    var update = injectStylesIntoStyleTag_default()(accordion.A, options);
                    const styles_accordion = accordion.A && accordion.A.locals ? accordion.A.locals : void 0;
                    ;
                    dom.importCssString(accordion_namespaceObject, "accordion.css");
                    const accordion_BOX_MIN_SIZE = 80;
                    class Accordion extends Box {
                      constructor(options2) {
                        var _a;
                        super(options2);
                        this.toggleBarList = [];
                        this.splitterList = [];
                        this.toggleBlockList = [];
                        this.boxMinSize = 30;
                        this.toggleBarHeight = 20;
                        this.splitterSize = 1;
                        this.vertical = options2.vertical || false;
                        this.color = (_a = options2.color) != null ? _a : "";
                        this.sections = options2.sections;
                        this.minSize = options2.minSize || accordion_BOX_MIN_SIZE;
                        this.minVerticalSize = options2.minVerticalSize || this.minSize;
                        this.minHorizontalSize = options2.minHorizontalSize || this.minSize;
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                        this.size = options2.size;
                      }
                      hasNextOpenedBlocks(index) {
                        for (let i = index; i < this.toggleBlockList.length; i++) {
                          if (this.isOpenedByIndex(i))
                            return true;
                        }
                        return false;
                      }
                      hasPrevOpenedBlocks(index) {
                        for (let i = index - 1; i >= 0; i--) {
                          if (this.isOpenedByIndex(i))
                            return true;
                        }
                        return false;
                      }
                      isOpenedByIndex(index) {
                        return this.isOpenedBlock(this.toggleBlockList[index]);
                      }
                      isOpenedBlock(toggleBlock) {
                        return toggleBlock.classList.contains("toggle-opened");
                      }
                      keepState() {
                        this.nextChangedIndexes = [];
                        this.prevChangedIndexes = [];
                        for (let i = 0; i < this.toggleBlockList.length; i++) {
                          if (this.isOpenedByIndex(i)) {
                            let section = this.sections[i];
                            section.previousSize = section.currentSize;
                          }
                        }
                      }
                      dischargeState() {
                        this.nextChangedIndexes = void 0;
                        this.prevChangedIndexes = void 0;
                        for (let i = 0; i < this.toggleBlockList.length; i++) {
                          if (this.isOpenedByIndex(i))
                            this.sections[i].previousSize = void 0;
                        }
                      }
                      recalculatePreviousSectionsSize(index, top, maxChangeSize) {
                        let changedSize = 0;
                        for (let i = index - 1; i >= 0; i--) {
                          if (this.isOpenedByIndex(i)) {
                            let section = this.sections[i];
                            let rect = section.box.element.getBoundingClientRect();
                            let done = false;
                            let prevSize = rect.height;
                            let currentSize = Math.max(top - rect.top, this.boxMinSize);
                            top -= rect.height;
                            if (currentSize < prevSize) {
                              if (currentSize > this.boxMinSize)
                                done = true;
                              if (!this.prevChangedIndexes.includes(i))
                                this.prevChangedIndexes.unshift(i);
                              section.currentSize = currentSize;
                              changedSize += prevSize - currentSize;
                              if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
                                break;
                            }
                          }
                          top -= this.toggleBarHeight;
                        }
                        return changedSize;
                      }
                      recalculateNextSectionsSize(index, top, maxChangeSize) {
                        let changedSize = 0;
                        for (let i = index; i < this.toggleBlockList.length; i++) {
                          if (this.isOpenedByIndex(i)) {
                            let section = this.sections[i];
                            let rect = section.box.element.getBoundingClientRect();
                            let done = false;
                            let prevSize = rect.height;
                            let currentSize = Math.max(rect.bottom - top - this.toggleBarHeight, this.boxMinSize);
                            top += rect.height;
                            if (currentSize < prevSize) {
                              if (currentSize > this.boxMinSize)
                                done = true;
                              if (!this.nextChangedIndexes.includes(i))
                                this.nextChangedIndexes.unshift(i);
                              section.currentSize = currentSize;
                              changedSize += prevSize - currentSize;
                              if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
                                break;
                            }
                          }
                          top += this.toggleBarHeight;
                          top += this.splitterSize;
                        }
                        return changedSize;
                      }
                      restoreChangedSizes(size, changedIndexes) {
                        if (!changedIndexes)
                          return size;
                        while (changedIndexes.length && size > 0) {
                          let index = changedIndexes[0];
                          let section = this.sections[index];
                          let currSize = section.currentSize;
                          section.currentSize = Math.min(section.previousSize, currSize + size);
                          size -= section.currentSize - currSize;
                          if (section.currentSize >= section.previousSize)
                            changedIndexes.shift();
                        }
                        return size;
                      }
                      expandPreviousSections(index, size) {
                        size = this.restoreChangedSizes(size, this.prevChangedIndexes);
                        if (size <= 0)
                          return;
                        let openedSectionsList = [];
                        for (let i = index - 1; i >= 0; i--) {
                          if (this.isOpenedByIndex(i))
                            openedSectionsList.push(this.sections[i]);
                        }
                        this.applySizeToOpenedSections(size, openedSectionsList);
                      }
                      expandNextSections(index, size) {
                        size = this.restoreChangedSizes(size, this.nextChangedIndexes);
                        if (size <= 0)
                          return;
                        let openedSectionsList = [];
                        for (let i = index; i < this.toggleBlockList.length; i++) {
                          if (this.isOpenedByIndex(i)) {
                            openedSectionsList.push(this.sections[i]);
                          }
                        }
                        this.applySizeToOpenedSections(size, openedSectionsList);
                      }
                      applySizeToOpenedSections(size, openedSections) {
                        let count = openedSections.length;
                        if (!count)
                          return;
                        let remainder = size % count;
                        let addSize = (size - remainder) / count;
                        for (let i = 0; i < count; i++) {
                          openedSections[i].currentSize += addSize;
                        }
                        openedSections[0].currentSize += remainder;
                      }
                      resize() {
                        this.$updateChildSize(...this.rect);
                      }
                      render() {
                        var _a, _b;
                        if (this.element)
                          return this.element;
                        this.element = dom.buildDom(["div", {
                          class: "box accordion",
                          $host: this
                        }]);
                        let section;
                        let splitter;
                        let toggleBlock;
                        let toggleBar;
                        for (let i = 0; i < this.sections.length; i++) {
                          section = this.sections[i];
                          if (i > 0) {
                            splitter = dom.buildDom(["div", {
                              class: `splitter accordion-splitter splitter${this.vertical ? "-v" : "-h"}`,
                              $index: i - 1,
                              $parent: this,
                              onmousedown: function(e) {
                                AccordionHandler.splitterMouseDown(e);
                              }
                            }, ["div"]]);
                            this.element.appendChild(splitter);
                            this.splitterList.push(splitter);
                          }
                          toggleBlock = dom.buildDom(["div", {
                            class: `toggle-block`,
                            $index: i,
                            $parent: this
                          }]);
                          toggleBar = dom.buildDom(["div", {
                            class: `toggle-bar toggle-bar${this.vertical ? "-v" : "-h"}`,
                            onmousedown: function(e) {
                              AccordionHandler.toggleBarMouseDown(e, Accordion);
                            },
                            onclick: function(e) {
                              AccordionHandler.toggleBarOnClick(e);
                            }
                          }, ["div", { class: "title" }, section.title]]);
                          section.currentSize = section.savedSize = parseInt((_b = (_a = section.box.size) == null ? void 0 : _a.toString()) != null ? _b : "", 10);
                          toggleBlock.appendChild(toggleBar);
                          this.toggleBarList.push(toggleBar);
                          toggleBlock.appendChild(section.box.render());
                          this.element.appendChild(toggleBlock);
                          this.toggleBlockList.push(toggleBlock);
                        }
                        this.element.style.backgroundColor = this.color;
                        this.element.style.position = "absolute";
                        this.calculateSectionsSizesPercents();
                        return this.element;
                      }
                      calculateSectionsSizesPercents() {
                        let totalSize = 0;
                        let actualSizes = [];
                        for (let i = 0; i < this.sections.length; i++) {
                          let section = this.sections[i];
                          actualSizes.push(this.isOpenedByIndex(i) ? section.currentSize : section.savedSize);
                          totalSize += actualSizes[i];
                        }
                        let minPercent = Math.floor(this.boxMinSize / totalSize * 100);
                        let maxPercent = 100 - minPercent * (this.sections.length - 1);
                        let totalPercent = 0;
                        for (let i = 0; i < this.sections.length; i++) {
                          let section = this.sections[i];
                          section.sizePercent = Math.floor(actualSizes[i] / totalSize * 100);
                          section.sizePercent = Math.min(Math.max(section.sizePercent, minPercent), maxPercent);
                          totalPercent += section.sizePercent;
                        }
                        if (totalPercent !== 100)
                          this.sections[this.sections.length - 1].sizePercent += 100 - totalPercent;
                      }
                      setBox(x, y, w, h) {
                        this.rect = [x, y, w, h];
                        Utils.setBox(this.element, x, y, w, h);
                        this.recalculateChildrenSizes();
                        this.$updateChildSize(x, y, w, h);
                      }
                      recalculateChildrenSizes(index) {
                        let height = this.rect[3];
                        height -= this.toggleBarHeight * this.toggleBarList.length;
                        height -= this.splitterSize * this.splitterList.length;
                        let totalSize = 0;
                        let openedIndexes = [];
                        for (let i = 0; i < this.sections.length; i++) {
                          let section = this.sections[i];
                          section.currentSize = Math.max(Math.floor(height * section.sizePercent / 100), this.boxMinSize);
                          if (this.isOpenedByIndex(i)) {
                            totalSize += section.currentSize;
                            openedIndexes.push(i);
                          } else {
                            section.savedSize = section.currentSize;
                            section.currentSize = 0;
                          }
                        }
                        let spareSize = height - totalSize;
                        if (!spareSize)
                          return;
                        if (index !== void 0) {
                          let prevOpenedIndexes = [];
                          while (openedIndexes.length && openedIndexes[0] < index) {
                            prevOpenedIndexes.push(openedIndexes.shift());
                          }
                          if (!openedIndexes.length)
                            openedIndexes = prevOpenedIndexes;
                        }
                        let prevSize, changedSize, openedBoxesCount, remainder, addSize;
                        while (openedIndexes.length && spareSize) {
                          let changedIndexes = [];
                          openedBoxesCount = openedIndexes.length;
                          remainder = spareSize % openedBoxesCount;
                          addSize = (spareSize - remainder) / openedBoxesCount;
                          for (let i = 0; i < openedIndexes.length; i++) {
                            let section = this.sections[openedIndexes[i]];
                            prevSize = section.currentSize;
                            if (openedBoxesCount === 1)
                              addSize += remainder;
                            section.currentSize += addSize;
                            section.currentSize = Math.max(section.currentSize, this.boxMinSize);
                            changedSize = section.currentSize - prevSize;
                            spareSize -= changedSize;
                            openedBoxesCount--;
                            if (changedSize < 0)
                              changedIndexes.push(openedIndexes[i]);
                          }
                          openedIndexes = changedIndexes;
                        }
                      }
                      $updateChildSize(x, y, w, h) {
                        x = 0;
                        y = 0;
                        for (let i = 0; i < this.toggleBlockList.length; i++) {
                          let toggleBlock = this.toggleBlockList[i];
                          let section = this.sections[i];
                          let boxSize = section.currentSize;
                          h = this.toggleBarHeight + boxSize;
                          Utils.setBox(toggleBlock, x, y, w, h);
                          y += this.toggleBarHeight;
                          section.box.setBox(0, this.toggleBarHeight, w, boxSize);
                          y += boxSize;
                          if (this.splitterList[i]) {
                            Utils.setBox(this.splitterList[i], x, y, w, this.splitterSize);
                            y += this.splitterSize;
                          }
                        }
                      }
                      remove() {
                        if (this.element)
                          this.element.remove();
                        if (this.parent) {
                          if (this.vertical === this.parent.vertical)
                            this.parent.minSize -= this.minSize;
                          if (this.parent[0] == this)
                            this.parent[0] = void 0;
                          if (this.parent[1] == this)
                            this.parent[1] = void 0;
                        }
                      }
                      toJSON() {
                        let sections = [];
                        let section;
                        for (let i = 0; i < this.sections.length; i++) {
                          section = this.sections[i];
                          sections.push({
                            title: section.title,
                            boxData: section.box.toJSON()
                          });
                        }
                        return {
                          type: "accordion",
                          vertical: this.vertical,
                          size: this.size,
                          sections
                        };
                      }
                    }
                    var popup_ = __nested_webpack_require_440138__(910);
                    ;
                    class ListBox extends Box {
                      render() {
                        if (this.element)
                          return this.element;
                        this.element = super.render();
                        let popup = new popup_.AcePopup();
                        popup.renderer.setStyle("ace_listBox");
                        popup.container.style.display = "block";
                        popup.container.style.position = "absolute";
                        popup.container.style.zIndex = "0";
                        popup.container.style.boxShadow = "none";
                        popup.renderer.setScrollMargin(2, 2, 0, 0);
                        popup.autoSelect = false;
                        popup.renderer["$maxLines"] = null;
                        popup.setRow(-1);
                        popup.on("click", (e) => {
                          e.stop();
                          let data = popup.getData(popup.getRow());
                        });
                        popup.on("dblclick", (e) => {
                          e.stop();
                          let data = popup.getData(popup.getRow());
                        });
                        popup.on("tripleclick", (e) => {
                          e.stop();
                        });
                        popup.on("quadclick", (e) => {
                          e.stop();
                        });
                        this.element.appendChild(popup.container);
                        this.popup = popup;
                        delete popup.focus;
                        return this.element;
                      }
                      $updateChildSize(x, y, w, h) {
                        Utils.setBox(this.popup.container, x, y, w, h);
                        this.popup.resize(true);
                      }
                    }
                    var esm_resolver_ = __nested_webpack_require_440138__(444);
                    var esm_resolver_default = /* @__PURE__ */ __nested_webpack_require_440138__.n(esm_resolver_);
                    var editor_ = __nested_webpack_require_440138__(254);
                    var virtual_renderer_ = __nested_webpack_require_440138__(748);
                    var language_tools_ = __nested_webpack_require_440138__(685);
                    ;
                    const modeList = __nested_webpack_require_440138__(292);
                    class AceEditor {
                      resize() {
                        this.editor.resize();
                      }
                      focus() {
                        this.editor.focus();
                      }
                      destroy() {
                        this.editor.setSession(esm_resolver_default().createEditSession("", this.getMode()));
                        this.editor.destroy();
                        this.container.remove();
                      }
                      constructor() {
                        this.editor = new editor_.Editor(new virtual_renderer_.VirtualRenderer(null));
                        this.container = this.editor.container;
                        this.container.style.position = "absolute";
                        this.editor.setOptions({
                          customScrollbar: false,
                          newLineMode: "unix",
                          enableLiveAutocompletion: true,
                          enableBasicAutocompletion: true,
                          showPrintMargin: false
                        });
                      }
                      setSession(tab2, value) {
                        this.tab = tab2;
                        this.initTabSession(value);
                        this.editor.setSession(this.tab.session);
                      }
                      initTabSession(value) {
                        var _a, _b;
                        if (this.tab.session && value == null)
                          return;
                        (_b = (_a = this.tab).session) != null ? _b : _a.session = esm_resolver_default().createEditSession(value != null ? value : "", this.getMode());
                        if (value == null) {
                          this.restoreSessionFromJson(this.tab);
                        } else {
                          this.tab.session.setValue(value);
                        }
                      }
                      getMode() {
                        if (this.tab.path !== void 0) {
                          return modeList.getModeForPath(this.tab.path).mode;
                        }
                        return null;
                      }
                      static getSessionState(tab2) {
                        let session = tab2.session;
                        let undoManager = session.getUndoManager();
                        return JSON.stringify({
                          selection: session.selection.toJSON(),
                          //@ts-ignore
                          undoManager: undoManager.toJSON(),
                          value: session.getValue(),
                          scroll: [
                            session.getScrollLeft(),
                            session.getScrollTop()
                          ]
                        });
                      }
                      sessionToJSON(tab2) {
                        return AceEditor.getSessionState(tab2);
                      }
                      restoreSessionFromJson(tab2) {
                        if (!tab2.session || !tab2.sessionValue)
                          return;
                        let session = tab2.session;
                        let json = JSON.parse(tab2.sessionValue);
                        try {
                          if (typeof json.value == "string" && json.value != session.getValue())
                            session.doc.setValue(json.value);
                          if (json.selection)
                            session.selection.fromJSON(json.selection);
                          if (json.scroll) {
                            session.setScrollLeft(json.scroll[0]);
                            session.setScrollTop(json.scroll[1]);
                          }
                          tab2.sessionValue = void 0;
                        } catch (e) {
                          console.error(e);
                        }
                      }
                    }
                    ;
                    class PreviewEditor {
                      resize() {
                      }
                      focus() {
                      }
                      destroy() {
                        this.container.remove();
                      }
                      constructor() {
                        this.container = document.createElement("iframe");
                        this.container.style.position = "absolute";
                      }
                      setSession(tab2, value) {
                        this.tab = tab2;
                        value != null ? value : value = tab2.session;
                        tab2.session = value;
                        this.container.setAttribute("srcdoc", value);
                      }
                      restoreSessionFromJson(tab2) {
                        var _a;
                        tab2.session = (_a = tab2.sessionValue) != null ? _a : "";
                        tab2.sessionValue = void 0;
                      }
                      sessionToJSON(tab2) {
                        return tab2.session;
                      }
                    }
                    ;
                    let tabbar_handler_event = __nested_webpack_require_440138__(517);
                    var TabbarHandler;
                    ((TabbarHandler2) => {
                      TabbarHandler2.tabbarMouseDown = function(e, tabConstructor, tabBarConstructor, showSplit = false) {
                        let divSplit, splitPosition, pane;
                        function hideSplitPosition() {
                          if (!divSplit)
                            return;
                          divSplit.remove();
                          divSplit = splitPosition = pane = null;
                        }
                        function showSplitPosition(e2) {
                          let el = e2.target;
                          if (tabBar) {
                            hideSplitPosition();
                            return;
                          }
                          pane = Utils.findHost(el);
                          if (!pane || !pane.acceptsTab || !pane.acceptsTab(tab2)) {
                            hideSplitPosition();
                            return;
                          }
                          if (pane.tabBar.tabList.length === 0) {
                            hideSplitPosition();
                            return;
                          }
                          let dark = false;
                          if (!divSplit) {
                            divSplit = document.createElement("div");
                            document.body.appendChild(divSplit);
                          }
                          divSplit.className = "split-area" + (dark ? " dark" : "");
                          let rect = pane.element.getBoundingClientRect();
                          let bHeight = pane.tabBar.element.clientHeight - 1;
                          rect = {
                            left: rect.left,
                            top: rect.top + bHeight,
                            width: rect.width,
                            height: rect.height - bHeight
                          };
                          let left = (e2.clientX - rect.left) / rect.width;
                          let right = 1 - left;
                          let top = (e2.clientY - rect.top) / rect.height;
                          let bottom = 1 - top;
                          let min = Math.min(left, top, right, bottom);
                          if (min == left) {
                            splitPosition = [true, false];
                            Utils.setBox(divSplit, rect.left, rect.top, rect.width / 2, rect.height);
                          } else if (min == right) {
                            splitPosition = [false, false];
                            Utils.setBox(divSplit, rect.left + rect.width / 2, rect.top, rect.width / 2, rect.height);
                          } else if (min == top) {
                            splitPosition = [true, true];
                            Utils.setBox(divSplit, rect.left, rect.top, rect.width, rect.height / 2);
                          } else if (min == bottom) {
                            splitPosition = [false, true];
                            Utils.setBox(divSplit, rect.left, rect.top + rect.height / 2, rect.width, rect.height / 2);
                          }
                        }
                        if (e.target.classList.contains("tabCloseButton")) {
                          return;
                        }
                        let tab2 = Utils.findHost(e.target, tabConstructor);
                        if (!tab2)
                          return;
                        let tabBar = Utils.findHost(e.target, tabBarConstructor);
                        if (!tabBar)
                          return;
                        let isVertical = tabBar.isVertical();
                        tabBar.tabMouseDown(tab2, e.shiftKey, e.ctrlKey);
                        if (e.shiftKey || e.ctrlKey)
                          return;
                        let isDragging = false;
                        let posX, posY, prevX, prevY;
                        let startX = e.clientX, startY = e.clientY;
                        let parentRect, tabElement, index, selectedTabs, hostTabBar, hostIndex;
                        let prevTab, leftMaxX, topMaxY, nextTab, rightMaxX, bottomMaxY;
                        let tabDragElementSize = 0;
                        let tabDragElementLeft = 0;
                        let tabDragElementTop = 0;
                        let calculateNearbyTabsData = function() {
                          if (isVertical) {
                            topMaxY = prevTab && parseInt(prevTab.style.top, 10) + parseInt(prevTab.style.height, 10) / 2 + parentRect.top;
                            bottomMaxY = nextTab && parseInt(nextTab.style.top, 10) + parseInt(nextTab.style.height, 10) / 2 + parentRect.top;
                          } else {
                            if (prevTab) {
                              let prevSibling = prevTab.previousSibling;
                              leftMaxX = prevSibling ? parseInt(prevSibling.style.left, 10) + parseInt(prevSibling.style.width, 10) + parentRect.left : parentRect.left;
                            }
                            rightMaxX = nextTab && parseInt(nextTab.style.left, 10) + parseInt(nextTab.style.width, 10) / 2 + parentRect.left;
                          }
                        };
                        let startDragging = function() {
                          if (isDragging || !tabBar)
                            return;
                          tabElement = dom.buildDom(["div", {
                            class: "tabDragging"
                          }]);
                          let activeIndex = index = tabBar.tabList.indexOf(tab2);
                          tabBar.tabContainer.insertBefore(tabElement, tab2.element);
                          tabDragElementLeft = parseInt(tab2.element.style.left, 10);
                          tabDragElementTop = parseInt(tab2.element.style.top, 10);
                          selectedTabs = [];
                          let selectedTab, selectedTabElement;
                          for (let i = 0; i < tabBar.selectedTabs.length; i++) {
                            selectedTab = tabBar.selectedTabs[i];
                            selectedTab.currentIndex = tabBar.tabList.indexOf(selectedTab);
                            if (selectedTab.currentIndex < activeIndex) {
                              index--;
                              if (isVertical) {
                                tabDragElementTop -= parseInt(selectedTab.element.style.top, 10);
                              } else {
                                tabDragElementLeft -= parseInt(selectedTab.element.style.width, 10);
                              }
                            }
                            selectedTabs.push(selectedTab);
                          }
                          selectedTabs.sort(function(tab1, tab22) {
                            return tab1.currentIndex - tab22.currentIndex;
                          });
                          for (let i = 0; i < selectedTabs.length; i++) {
                            selectedTab = selectedTabs[i];
                            selectedTabElement = selectedTab.element;
                            tabElement.appendChild(selectedTabElement);
                            selectedTabElement.style.pointerEvents = "none";
                            if (isVertical) {
                              selectedTabElement.style.top = tabDragElementSize + "px";
                              tabDragElementSize += parseInt(selectedTabElement.style.height, 10);
                            } else {
                              selectedTabElement.style.left = tabDragElementSize + "px";
                              tabDragElementSize += parseInt(selectedTabElement.style.width, 10);
                            }
                            tabBar.removeTab(selectedTab);
                          }
                          prevTab = tabElement.previousSibling;
                          nextTab = tabElement.nextSibling;
                          parentRect = tabBar.element.getBoundingClientRect();
                          if (isVertical) {
                            tabDragElementTop += parentRect.top;
                            posY = startY - tabDragElementTop;
                            posX = startX - parentRect.left;
                          } else {
                            tabDragElementLeft += parentRect.left;
                            posX = startX - tabDragElementLeft;
                            posY = startY - parentRect.top;
                          }
                          prevX = e.clientX;
                          prevY = e.clientY;
                          hostTabBar = tabBar;
                          hostIndex = index;
                          calculateNearbyTabsData();
                          isDragging = true;
                          document.body.appendChild(tabElement);
                          if (isVertical) {
                            Utils.setBox(tabElement, tabDragElementTop, parentRect.left, parentRect.width, tabDragElementSize);
                          } else {
                            Utils.setBox(tabElement, tabDragElementLeft, parentRect.top, tabDragElementSize, parentRect.height);
                          }
                          tabBar.startTabDragging(tabElement, index);
                        };
                        let finishDragging = function() {
                          if (pane && pane.split && splitPosition) {
                            let newPane = pane.split(...splitPosition);
                            tabBar = newPane.tabBar;
                          } else if (!tabBar) {
                            tabBar = hostTabBar;
                          }
                          tabBar.removeSelections();
                          tabElement.remove();
                          let selectedTab;
                          for (let i = 0; i < selectedTabs.length; i++) {
                            selectedTab = selectedTabs[i];
                            selectedTab.element.style.pointerEvents = "";
                            if (selectedTab === tab2) {
                              selectedTab.active = true;
                            }
                            tabBar.addTab(selectedTab, index++);
                            tabBar.addSelection(selectedTab);
                          }
                          if (tabBar !== hostTabBar) {
                            hostTabBar.removeSelections();
                            hostTabBar.activatePrevious(hostIndex);
                          }
                          tabBar.finishTabDragging();
                          isDragging = false;
                          hideSplitPosition();
                        };
                        function distance(dx, dy) {
                          return dx * dx + dy * dy;
                        }
                        let onMouseMove = function(e2) {
                          if (e2.type !== "mousemove")
                            return;
                          if (!isDragging) {
                            if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
                              return;
                            startDragging();
                          }
                          function removeTabFromBar() {
                            tabBar.finishTabDragging();
                            tabBar = void 0;
                          }
                          if (tabBar) {
                            tabBar.startTabDragging(tabElement, index);
                            if (!isVertical && (e2.clientX < parentRect.left || e2.clientX > parentRect.left + parentRect.width) || isVertical && (e2.clientY < parentRect.top || e2.clientY > parentRect.top + parentRect.height)) {
                              removeTabFromBar();
                            }
                          } else {
                            tabBar = Utils.findHost(e2.target, tabBarConstructor);
                            if (tabBar) {
                              isVertical = tabBar.isVertical();
                              let nextTabHost = Utils.findHost(e2.target, tabConstructor);
                              if (nextTabHost) {
                                index = tabBar.tabList.indexOf(nextTabHost);
                                nextTab = nextTabHost.element;
                                prevTab = nextTab.previousSibling;
                              } else {
                                index = tabBar.tabList.length;
                                nextTab = null;
                                prevTab = tabBar.tabContainer.childNodes[index - 1];
                              }
                              tabBar.startTabDragging(tabElement, index);
                              parentRect = tabBar.element.getBoundingClientRect();
                              calculateNearbyTabsData();
                            }
                          }
                          if (showSplit)
                            showSplitPosition(e2);
                          let left = e2.clientX - posX;
                          let top = e2.clientY - posY;
                          let x = left;
                          let y = top;
                          if (tabBar) {
                            if (isVertical && (x < parentRect.left - parentRect.width || x > parentRect.left + parentRect.width) || !isVertical && (y < parentRect.top - parentRect.height || y > parentRect.top + parentRect.height)) {
                              removeTabFromBar();
                            } else {
                              if (isVertical) {
                                x = parentRect.left;
                              } else {
                                y = parentRect.top;
                              }
                              if (isVertical && e2.clientY < prevY && topMaxY && top < topMaxY || !isVertical && e2.clientX < prevX && leftMaxX && left < leftMaxX) {
                                if (isVertical) {
                                  prevTab.style.top = parseInt(prevTab.style.top, 10) + tabDragElementSize + "px";
                                } else {
                                  prevTab.style.left = parseInt(prevTab.style.left, 10) + tabDragElementSize + "px";
                                }
                                index--;
                                [prevTab, nextTab] = [prevTab.previousSibling, prevTab];
                                calculateNearbyTabsData();
                              } else if (isVertical && e2.clientY > prevY && bottomMaxY && top + tabDragElementSize > bottomMaxY || !isVertical && e2.clientX > prevX && rightMaxX && left + tabDragElementSize > rightMaxX) {
                                if (isVertical) {
                                  nextTab.style.top = parseInt(nextTab.style.top, 10) - tabDragElementSize + "px";
                                } else {
                                  nextTab.style.left = parseInt(nextTab.style.left, 10) - tabDragElementSize + "px";
                                }
                                index++;
                                [prevTab, nextTab] = [nextTab, nextTab.nextSibling];
                                calculateNearbyTabsData();
                              }
                            }
                          }
                          prevX = e2.clientX;
                          prevY = e2.clientY;
                          tabElement.style.left = x + "px";
                          tabElement.style.top = y + "px";
                        };
                        let onMouseUp = function(e2) {
                          if (!isDragging) {
                            if (tabBar.selectedTabs.length > 1) {
                              tabBar.removeSelections();
                              tabBar.addSelection(tab2);
                            }
                          } else {
                            finishDragging();
                          }
                        };
                        tabbar_handler_event.capture(window, onMouseMove, onMouseUp);
                        return e.preventDefault();
                      };
                    })(TabbarHandler || (TabbarHandler = {}));
                    window.addEventListener("mousedown", function() {
                      document.body.classList.add("disableIframe");
                    }, true);
                    window.addEventListener("mouseup", function() {
                      document.body.classList.remove("disableIframe");
                    }, true);
                    var tab = __nested_webpack_require_440138__(129);
                    ;
                    var tab_options = {};
                    tab_options.styleTagTransform = styleTagTransform_default();
                    tab_options.setAttributes = setAttributesWithoutAttributes_default();
                    tab_options.insert = insertBySelector_default().bind(null, "head");
                    tab_options.domAPI = styleDomAPI_default();
                    tab_options.insertStyleElement = insertStyleElement_default();
                    var tab_update = injectStylesIntoStyleTag_default()(tab.A, tab_options);
                    const styles_tab = tab.A && tab.A.locals ? tab.A.locals : void 0;
                    ;
                    class TabPanel {
                      constructor(options2) {
                        var _a;
                        this.active = (_a = options2.active) != null ? _a : false;
                        this.title = options2.title;
                      }
                      activate() {
                        this.active = true;
                        this.element.classList.add("active");
                      }
                      deactivate() {
                        this.active = false;
                        this.element.classList.remove("active");
                      }
                    }
                    ;
                    dom.importCssString(tab_namespaceObject, "tab.css");
                    class Tab extends TabPanel {
                      constructor(options2) {
                        var _a, _b, _c;
                        super(options2);
                        this.contextMenu = "tabs";
                        this.tabIcon = (_a = options2.icon) != null ? _a : "";
                        this.path = options2.path;
                        this.preview = (_b = options2.preview) != null ? _b : false;
                        this.editorType = (_c = options2.editorType) != null ? _c : EditorType.ace;
                      }
                      toJSON() {
                        return {
                          title: this.title,
                          icon: this.tabIcon || void 0,
                          active: this.active || void 0,
                          path: this.path,
                          preview: this.preview || void 0,
                          editorType: this.editorType
                        };
                      }
                      activate(content) {
                        super.activate();
                        this.activatePane();
                        let tabManager = TabManager.getInstance();
                        tabManager.loadFile(this, content);
                        tabManager.activePane.resize();
                      }
                      activatePane() {
                        var _a;
                        TabManager.getInstance().activePane = (_a = this.parent) == null ? void 0 : _a.parent;
                      }
                      remove() {
                        var _a;
                        (_a = this.parent) == null ? void 0 : _a.closeTab(this);
                      }
                      set caption(value) {
                        this.$caption = value;
                      }
                      get caption() {
                        return this.$caption;
                      }
                      render() {
                        this.element = dom.buildDom([
                          "div",
                          {
                            class: "tab" + (this.active ? " active" : ""),
                            title: this.path
                          },
                          ["span", { class: "tabIcon" }, this.tabIcon],
                          ["span", { class: "tabTitle", ref: "$title" }, this.title],
                          ["span", { class: "tabCloseButton" }]
                        ], void 0, this);
                        if (this.preview)
                          this.element.style.fontStyle = "italic";
                        this.element.$host = this;
                        return this.element;
                      }
                      setTitle(title) {
                        this.title = title;
                        this.element.getElementsByClassName("tabTitle")[0].innerHTML = title;
                      }
                      get isActive() {
                        var _a;
                        return ((_a = this.parent) == null ? void 0 : _a.activeTab) == this;
                      }
                      get editor() {
                        var _a;
                        return (_a = this.parent) == null ? void 0 : _a.parent.getEditor(this.editorType);
                      }
                    }
                    ;
                    function getCurrentPaneTabs(element) {
                      var _a, _b, _c, _d;
                      if (element instanceof Tab) {
                        return {
                          tabs: [...(_b = (_a = element.parent) == null ? void 0 : _a.tabList) != null ? _b : []],
                          activeTab: element
                        };
                      } else {
                        return {
                          tabs: [...(_d = (_c = element.activePane) == null ? void 0 : _c.tabBar.tabList) != null ? _d : []],
                          activeTab: element.activeTab
                        };
                      }
                    }
                    function goToTab(el, tabNum) {
                      let currentPaneTabs = getCurrentPaneTabs(el);
                      let tabs = currentPaneTabs.tabs;
                      let activeTab = currentPaneTabs.activeTab;
                      let index = tabNum != null ? tabNum : tabs.indexOf(activeTab);
                      TabManager.getInstance().navigateToTab(index, activeTab, tabs);
                    }
                    let tabCommands = [
                      {
                        name: "clonetab",
                        mac: "",
                        win: "",
                        desc: "Create a new tab with a view on the same file"
                      },
                      {
                        name: "Close Tab",
                        mac: "Option-W",
                        win: "Alt-W",
                        desc: "close the tab that is currently active",
                        position: 300,
                        exec: (el) => {
                          if (el instanceof Tab) {
                            el.remove();
                          } else {
                            el.activeTab.remove();
                          }
                        }
                      },
                      {
                        name: "Close All Tabs",
                        mac: "Option-Shift-W",
                        win: "Alt-Shift-W",
                        desc: "Close all opened tabs",
                        position: 310,
                        exec: () => {
                          let tabs = TabManager.getInstance().tabs;
                          for (let i in tabs) {
                            tabs[i].remove();
                          }
                        }
                      },
                      {
                        name: "Close other tabs",
                        mac: "Option-Ctrl-W",
                        win: "Ctrl-Alt-W",
                        desc: "close all opened tabs, except the tab that is currently active",
                        position: 320,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          for (let tab2 of tabs) {
                            if (tab2 != activeTab)
                              tab2.remove();
                          }
                        }
                      },
                      {
                        name: "Go to tab right",
                        mac: "Command-}",
                        win: "Ctrl-}",
                        //TODO: used by ace
                        desc: "navigate to the next tab, right to the tab that is currently active",
                        position: 330,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
                        }
                      },
                      {
                        name: "Go to tab left",
                        mac: "Command-{",
                        win: "Ctrl-{",
                        //TODO: used by ace
                        desc: "navigate to the next tab, left to the tab that is currently active",
                        position: 340,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
                        }
                      },
                      {
                        name: "movetabright",
                        mac: "Command-Option-Shift-Right",
                        win: "Ctrl-Meta-Right",
                        desc: "move the tab that is currently active to the right. Will create a split tab to the right if it's the right most tab."
                      },
                      {
                        name: "movetableft",
                        mac: "Command-Option-Shift-Left",
                        win: "Ctrl-Meta-Left",
                        desc: "move the tab that is currently active to the left. Will create a split tab to the left if it's the left most tab."
                      },
                      {
                        name: "movetabup",
                        mac: "Command-Option-Shift-Up",
                        win: "Ctrl-Meta-Up",
                        desc: "move the tab that is currently active to the up. Will create a split tab to the top if it's the top most tab."
                      },
                      {
                        name: "movetabdown",
                        mac: "Command-Option-Shift-Down",
                        win: "Ctrl-Meta-Down",
                        desc: "move the tab that is currently active to the down. Will create a split tab to the bottom if it's the bottom most tab."
                      },
                      {
                        name: "Go to first tab",
                        mac: "Command-1",
                        win: "Ctrl-1",
                        desc: "navigate to the first tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 0);
                        }
                      },
                      {
                        name: "Go to second tab",
                        mac: "Command-2",
                        win: "Ctrl-2",
                        desc: "navigate to the second tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 1);
                        }
                      },
                      {
                        name: "Go to third tab",
                        mac: "Command-3",
                        win: "Ctrl-3",
                        desc: "navigate to the third tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 2);
                        }
                      },
                      {
                        name: "tab4",
                        mac: "Command-4",
                        win: "Ctrl-4",
                        desc: "navigate to the fourth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 3);
                        }
                      },
                      {
                        name: "tab5",
                        mac: "Command-5",
                        win: "Ctrl-5",
                        desc: "navigate to the fifth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 4);
                        }
                      },
                      {
                        name: "tab6",
                        mac: "Command-6",
                        win: "Ctrl-6",
                        desc: "navigate to the sixth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 5);
                        }
                      },
                      {
                        name: "tab7",
                        mac: "Command-7",
                        win: "Ctrl-7",
                        desc: "navigate to the seventh tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 6);
                        }
                      },
                      {
                        name: "tab8",
                        mac: "Command-8",
                        win: "Ctrl-8",
                        desc: "navigate to the eighth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 7);
                        }
                      },
                      {
                        name: "tab9",
                        mac: "Command-9",
                        win: "Ctrl-9",
                        desc: "navigate to the ninth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 8);
                        }
                      },
                      {
                        name: "tab0",
                        mac: "Command-0",
                        win: "Ctrl-0",
                        desc: "navigate to the tenth tab",
                        position: 340,
                        exec: (el) => {
                          goToTab(el, 9);
                        }
                      },
                      {
                        name: "Reveal tab",
                        mac: "Command-Shift-L",
                        win: "Ctrl-Shift-L",
                        //TODO: used by ace
                        desc: "reveal current tab in the file tree",
                        position: 340,
                        exec: (el) => {
                        }
                      },
                      {
                        name: "Go to next tab",
                        mac: "Option-Tab",
                        win: "Ctrl-Tab|Alt-`",
                        desc: "navigate to the next tab in the stack of accessed tabs",
                        position: 340,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          if (index < tabs.length - 1) {
                            TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
                          } else {
                            TabManager.getInstance().navigateToTab(0, activeTab, tabs);
                          }
                        }
                      },
                      {
                        name: "Go to previous tab",
                        mac: "Option-Shift-Tab",
                        win: "Ctrl-Shift-Tab|Alt-Shift-`",
                        desc: "navigate to the previous tab in the stack of accessed tabs",
                        position: 340,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          if (index > 0) {
                            TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
                          } else {
                            TabManager.getInstance().navigateToTab(tabs.length - 1, activeTab, tabs);
                          }
                        }
                      },
                      {
                        name: "nextpane",
                        mac: "Option-ESC",
                        win: "Ctrl-`",
                        desc: "navigate to the next tab in the stack of panes"
                      },
                      {
                        name: "previouspane",
                        mac: "Option-Shift-ESC",
                        win: "Ctrl-Shift-`",
                        desc: "navigate to the previous tab in the stack of panes"
                      },
                      {
                        name: "gotopaneright",
                        mac: "Ctrl-Meta-Right",
                        win: "Ctrl-Meta-Right",
                        desc: "navigate to the pane on the right"
                      },
                      {
                        name: "gotopaneleft",
                        mac: "Ctrl-Meta-Left",
                        win: "Ctrl-Meta-Left",
                        desc: "navigate to the pane on the left"
                      },
                      {
                        name: "gotopaneup",
                        mac: "Ctrl-Meta-Up",
                        win: "Ctrl-Meta-Up",
                        desc: "navigate to the pane on the top"
                      },
                      {
                        name: "gotopanedown",
                        mac: "Ctrl-Meta-Down",
                        win: "Ctrl-Meta-Down",
                        desc: "navigate to the pane on the bottom"
                      },
                      {
                        name: "reopenLastTab",
                        mac: "Option-Shift-T",
                        win: "Alt-Shift-T",
                        /*exec: function () {
                            return menuClosedItems.length;
                        },*/
                        desc: "reopen last closed tab"
                      },
                      {
                        name: "Close all to the right",
                        mac: "",
                        win: "",
                        desc: "close all tabs to the right of the focussed tab",
                        position: 340,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          if (index < tabs.length - 1) {
                            for (let i = index + 1; i < tabs.length; i++) {
                              tabs[i].remove();
                            }
                          }
                        }
                      },
                      {
                        name: "Close all to the left",
                        mac: "",
                        win: "",
                        desc: "close all tabs to the left of the focussed tab",
                        position: 340,
                        exec: (el) => {
                          let currentPaneTabs = getCurrentPaneTabs(el);
                          let tabs = currentPaneTabs.tabs;
                          let activeTab = currentPaneTabs.activeTab;
                          let index = tabs.indexOf(activeTab);
                          if (index > 0) {
                            for (let i = 0; i < index; i++) {
                              tabs[i].remove();
                            }
                          }
                        }
                      },
                      {
                        name: "Close pane",
                        mac: "Command-Ctrl-W",
                        win: "Ctrl-W",
                        desc: "close this pane",
                        position: 340,
                        exec: (el) => {
                          var _a, _b;
                          let tabs;
                          if (el instanceof Tab) {
                            tabs = [...(_b = (_a = el.parent) == null ? void 0 : _a.tabList) != null ? _b : []];
                          } else {
                            tabs = [...el.activePane.tabBar.tabList];
                          }
                          for (let tab2 of tabs) {
                            tab2.remove();
                          }
                        }
                      },
                      {
                        name: "nosplit",
                        mac: "",
                        win: "",
                        desc: "no split"
                      },
                      {
                        name: "hsplit",
                        mac: "",
                        win: "",
                        desc: "split the current pane in two columns and move the active tab to it"
                      },
                      {
                        name: "vsplit",
                        mac: "",
                        win: "",
                        desc: "split the current pane in two rows and move the active tab to it"
                      },
                      {
                        name: "twovsplit",
                        mac: "",
                        win: "",
                        desc: "create a two pane row layout"
                      },
                      {
                        name: "twohsplit",
                        mac: "",
                        win: "",
                        desc: "create a two pane column layout"
                      },
                      {
                        name: "foursplit",
                        mac: "",
                        win: "",
                        desc: "create a four pane layout"
                      },
                      {
                        name: "threeleft",
                        mac: "",
                        win: "",
                        desc: "create a three pane layout with the stack on the left side"
                      },
                      {
                        name: "threeright",
                        mac: "",
                        win: "",
                        desc: "create a three pane layout with the stack on the right side"
                      }
                    ];
                    var event_emitter_ = __nested_webpack_require_440138__(540);
                    var menu = __nested_webpack_require_440138__(807);
                    ;
                    var menu_options = {};
                    menu_options.styleTagTransform = styleTagTransform_default();
                    menu_options.setAttributes = setAttributesWithoutAttributes_default();
                    menu_options.insert = insertBySelector_default().bind(null, "head");
                    menu_options.domAPI = styleDomAPI_default();
                    menu_options.insertStyleElement = insertStyleElement_default();
                    var menu_update = injectStylesIntoStyleTag_default()(menu.A, menu_options);
                    const styles_menu = menu.A && menu.A.locals ? menu.A.locals : void 0;
                    ;
                    dom.importCssString(menu_namespaceObject, "menu.css");
                    class Menu {
                      getLastOpenPopup() {
                        return !this.menuPopup ? this : this.menuPopup.getLastOpenPopup();
                      }
                      getLastSelectedMenu() {
                        return !this.menuPopup || !this.menuPopup.selectedMenu ? this.selectedMenu : this.menuPopup.getLastSelectedMenu();
                      }
                      closeLastMenu() {
                        if (this.menuPopup && this.menuPopup.menuPopup) {
                          this.menuPopup.closeLastMenu();
                        } else {
                          this.closeMenu();
                        }
                      }
                      selectMenu(menu2) {
                        menu2.buttonElement.classList.add(this.selectedClass);
                        this.selectedMenu = menu2;
                      }
                      unselectMenu() {
                        if (!this.selectedMenu)
                          return;
                        this.selectedMenu.buttonElement.classList.remove(this.selectedClass);
                        this.selectedMenu = void 0;
                      }
                      openMenu(direction) {
                        if (!direction && this.constructor.name === "MenuPopup")
                          direction = "right";
                        if (this.menuPopup)
                          return this.menuPopup;
                        this.menuPopup = new MenuPopup();
                        this.menuPopup.direction = direction != null ? direction : "";
                        this.menuPopup.isSubMenu = this.constructor.name === "MenuPopup";
                        this.menuPopup.menuManager = this.menuManager;
                        this.menuPopup.menu = this.selectedMenu;
                        this.menuPopup.parentMenu = this;
                        this.menuPopup.open();
                        if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen) {
                          if (!this.menuPopup.isSubMenu) {
                            this.menuManager.searchBox.setParentPopup(this.menuPopup);
                          } else {
                            this.menuManager.searchBox.addSymbol("/");
                          }
                        }
                        return this.menuPopup;
                      }
                      closeMenu() {
                        if (!this.menuPopup) {
                          return;
                        }
                        if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen && this.menuPopup.isSubMenu && this.menuManager.searchBox.value.substring(this.menuManager.searchBox.value.length - 1) === "/") {
                          this.menuManager.searchBox.removeSymbol();
                        }
                        this.menuPopup.close();
                        this.menuPopup = void 0;
                      }
                      moveOnTarget(target) {
                        let host = target ? target.$host : null;
                        if (!host) {
                          return;
                        }
                        if (this.selectedMenu) {
                          if (host.path === this.selectedMenu.path) {
                            return;
                          } else {
                            this.unselectMenu();
                          }
                        }
                        if (this.menuPopup) {
                          this.closeMenu();
                        }
                        host.buttonElement = host.$buttonElement || target;
                        this.selectMenu(host);
                      }
                      openMenuByPath(path) {
                        var _a;
                        if (typeof path === "string")
                          path = path.split("/");
                        let menu2 = this.getMenuByPath(path.shift());
                        if (!menu2)
                          return;
                        if (!menu2.$host)
                          menu2.$host = menu2;
                        this.moveOnTarget(menu2);
                        if (!menu2.$host.map)
                          return;
                        this.openMenu();
                        if (path.length)
                          (_a = this.menuPopup) == null ? void 0 : _a.openMenuByPath(path);
                      }
                    }
                    class MenuBar extends Menu {
                      constructor() {
                        super(...arguments);
                        this.selectedClass = "menuButtonDown";
                        this.onMouseMove = (e) => {
                          let target = this.menuManager.getTarget(e.target);
                          this.moveOnTarget(target);
                        };
                      }
                      build(parent) {
                        this.element = parent;
                        let items = this.menus.map || {};
                        Object.keys(items).filter(Boolean).map((key) => items[key]).sort(function(item1, item2) {
                          return item1.position - item2.position;
                        }).map((item) => {
                          item.$buttonElement = dom.buildDom(["div", {
                            class: "menuButton" + (item.className ? " " + item.className : ""),
                            $host: item,
                            onmousedown: (e) => this.onMouseDown(e)
                          }, item.label + ""], this.element);
                        });
                        let rect = this.element.getBoundingClientRect();
                        this.bottom = rect.bottom;
                      }
                      activateMenu() {
                        this.element.addEventListener("mousemove", this.onMouseMove);
                      }
                      inactivateMenu() {
                        this.unselectMenu();
                        this.closeMenu();
                        this.element.removeEventListener("mousemove", this.onMouseMove);
                      }
                      /*** event handlers ***/
                      onMouseDown(e) {
                        e.preventDefault();
                        let activate = true;
                        if (this.menuManager.isActive) {
                          this.menuManager.inactivateMenu();
                        } else {
                          let target = e.target;
                          target.$host.buttonElement = target.$host.$buttonElement;
                          this.selectMenu(target.$host);
                          this.openMenu();
                          this.menuManager.activeMenu = this;
                          this.menuManager.activateMenu();
                        }
                      }
                      moveOnTarget(target) {
                        var _a;
                        super.moveOnTarget(target);
                        if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
                          this.openMenu();
                      }
                      getMenuByPath(path) {
                        return this.menuManager.find(path);
                      }
                    }
                    class MenuPopup extends Menu {
                      constructor() {
                        super(...arguments);
                        this.selectedClass = "hover";
                        this.isSubMenu = false;
                        this.onMouseMove = (e) => {
                          var _a;
                          if (e.target === this.element)
                            return;
                          if (this.menuPopup && this.isDirectedToSubMenu(e))
                            return;
                          let target = this.menuManager.getTarget(e.target);
                          if (target === this.element)
                            return;
                          this.moveOnTarget(target);
                          if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
                            this.openMenu();
                        };
                        this.onMouseUp = (e) => {
                          if (e.target === this.element)
                            return;
                          let target = this.menuManager.getTarget(e.target);
                          if (!target || target === this.element)
                            return;
                          let host = target.$host;
                          if (host && host.buttonElement) {
                            e.preventDefault();
                            if (host.exec)
                              host.exec(this.menuManager.currentHost);
                          }
                          if (!host.map)
                            this.menuManager.inactivateMenu();
                        };
                      }
                      inactivateMenu() {
                        this.close();
                      }
                      activateMenu() {
                      }
                      open() {
                        this.build();
                        this.render();
                      }
                      build() {
                        if (this.element) {
                          return;
                        }
                        if (this.menu.element) {
                          this.element = this.menu.element;
                          return;
                        }
                        let result = [];
                        if (this.menu.map) {
                          let items = Object.values(this.menu.map).sort(function(item1, item2) {
                            return item1.position - item2.position;
                          });
                          let afterDivider = true;
                          result = items.map((item) => {
                            if (item.label[0] === "~") {
                              if (afterDivider)
                                return;
                              afterDivider = true;
                              return [
                                "div",
                                {
                                  class: "menu_divider",
                                  $host: item
                                }
                              ];
                            }
                            afterDivider = false;
                            let classList = ["menu_item"];
                            if (item.checked)
                              classList.push(item.type === "check" ? "checked" : "selected");
                            if (item.map)
                              classList.push("submenu");
                            if (item.disabled)
                              classList.push("disabled");
                            return [
                              "div",
                              {
                                class: classList.join(" "),
                                $host: item
                              },
                              ["u", " "],
                              ["a", item.label + ""],
                              [
                                "span",
                                {
                                  class: "shortcut"
                                },
                                item.hotKey
                              ]
                            ];
                          }).filter(Boolean);
                          if (afterDivider)
                            result.pop();
                        }
                        this.menu.element = dom.buildDom(
                          [
                            "blockquote",
                            {
                              class: "menu",
                              style: "display:block",
                              $host: this.menu,
                              onmousemove: this.onMouseMove,
                              onmouseup: this.onMouseUp
                            },
                            result
                          ],
                          document.body
                        );
                        this.element = this.menu.element;
                      }
                      render() {
                        if (!this.element)
                          return;
                        if (this.element.style.maxWidth)
                          this.element.style.maxWidth = window.innerWidth + "px";
                        if (this.element.style.maxHeight)
                          this.element.style.maxHeight = window.innerHeight + "px";
                        let elRect = this.element.getBoundingClientRect();
                        let edge = Utils.getElementEdges(this.element);
                        let parentRect, top, left;
                        if (this.menu && this.menu.buttonElement)
                          parentRect = this.menu.buttonElement.getBoundingClientRect();
                        if (parentRect) {
                          if (this.isSubMenu) {
                            top = parentRect.top - edge.top;
                            left = parentRect.right;
                          } else {
                            top = parentRect.bottom;
                            left = parentRect.left;
                          }
                        } else {
                          top = this.position.y;
                          left = this.position.x;
                        }
                        let targetH = Math.min(elRect.height, window.innerHeight);
                        let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
                        if (availableH < targetH && (!parentRect || this.isSubMenu)) {
                          let tmpTop = parentRect ? window.innerHeight : top;
                          top = tmpTop - targetH - edge.top;
                          top = Math.max(top, this.menuManager.menuBar.bottom);
                          availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
                        }
                        this.element.style.maxHeight = availableH - 10 + "px";
                        elRect = this.element.getBoundingClientRect();
                        let availableW = window.innerWidth - left - edge.left - edge.right - 2;
                        if (availableW < elRect.width) {
                          if (parentRect) {
                            let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
                            if (tmpLeft > availableW) {
                              this.direction = "left";
                              left = tmpLeft - elRect.width + edge.left;
                              left = Math.max(left, 0);
                              availableW = tmpLeft + edge.left + edge.right;
                            }
                            if (availableW < elRect.width) {
                              this.element.style.maxWidth = availableW + "px";
                              this.element.style.overflowX = "auto";
                            }
                          } else {
                            left = window.innerWidth - elRect.width - edge.left - edge.right;
                          }
                        }
                        this.element.style.top = top + "px";
                        this.element.style.left = left + "px";
                        this.element.style.position = "absolute";
                        this.element.style.zIndex = String(195055);
                        this.element.style.overflowY = "auto";
                      }
                      close() {
                        if (this.menuPopup) {
                          this.closeMenu();
                        }
                        if (this.element) {
                          this.element.remove();
                          delete this.element;
                        }
                        if (this.menu.element) {
                          delete this.menu.element;
                        }
                      }
                      scrollIfNeeded() {
                        if (!this.selectedMenu)
                          return;
                        let menu2 = this.element;
                        let item = this.selectedMenu.buttonElement;
                        let menuRect = menu2.getBoundingClientRect();
                        let itemRect = item.getBoundingClientRect();
                        if (itemRect.top < menuRect.top) {
                          item.scrollIntoView(true);
                        } else if (itemRect.bottom > menuRect.bottom) {
                          item.scrollIntoView(false);
                        }
                      }
                      moveOnTarget(target) {
                        super.moveOnTarget(target);
                      }
                      isDirectedToSubMenu(e) {
                        let currPos = { x: e.clientX, y: e.clientY };
                        let prevPos = this.menuManager.prevPos;
                        let rect = this.menuPopup.element.getBoundingClientRect();
                        let rectYTop = rect.top;
                        let rectYBottom = rect.bottom;
                        if (currPos.y < rectYTop || currPos.y > rectYBottom) {
                          return false;
                        }
                        let rectX = this.menuPopup.direction === "left" ? rect.right : rect.left;
                        let prevDiffX = Math.abs(rectX - prevPos.x);
                        let currDiffX = Math.abs(rectX - currPos.x);
                        if (prevDiffX < currDiffX) {
                          return false;
                        }
                        let directedToBottom = currPos.y > prevPos.y;
                        let prevDiffY = directedToBottom ? rectYBottom - prevPos.y : prevPos.y - rectYTop;
                        let tng = prevDiffY / prevDiffX;
                        let maxYDiff = tng * currDiffX;
                        return directedToBottom && rectYBottom - maxYDiff >= currPos.y || !directedToBottom && rectYTop + maxYDiff <= currPos.y;
                      }
                      renderRecursive() {
                        this.render();
                        if (this.menuPopup) {
                          this.menuPopup.renderRecursive();
                        }
                      }
                      getMenuByPath(path) {
                        let childNode;
                        let childNodes = this.element.childNodes;
                        for (let i = 0; i < childNodes.length; i++) {
                          childNode = childNodes[i];
                          if (childNode.$host && childNode.$host.id === path) {
                            if (childNode.classList.contains("menu_item") && !childNode.classList.contains("disabled")) {
                              return childNode;
                            }
                          }
                        }
                        return null;
                      }
                    }
                    class MenuSearchBox {
                      constructor() {
                        this.isOpen = false;
                        this.hideFiltered = false;
                        this.value = "";
                        this.currValue = "";
                      }
                      open() {
                        if (!this.element) {
                          this.build();
                        }
                        this.isOpen = true;
                        document.body.appendChild(this.element);
                        this.calcElementPosition();
                      }
                      close() {
                        this.isOpen = false;
                        if (this.parentPopup && this.parentPopup.element) {
                          if (this.parentPopup.prevMaxHeight) {
                            this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
                          }
                        }
                        if (this.value.length) {
                          this.value = "";
                          this.currValue = "";
                          this.update();
                        }
                        this.parentPopup = void 0;
                        this.element.remove();
                      }
                      setParentPopup(parentPopup) {
                        var _a;
                        if (this.parentPopup && this.parentPopup.element) {
                          if (this.parentPopup.prevMaxHeight) {
                            this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
                          }
                        }
                        this.parentPopup = parentPopup;
                        this.currPopupMenu = parentPopup;
                        if (this.isOpen) {
                          this.calcElementPosition();
                          let currPopupMenu = parentPopup;
                          let valueArr = this.value.split("/");
                          while (currPopupMenu) {
                            this.currPopupMenu = currPopupMenu;
                            this.currValue = (_a = valueArr.shift()) != null ? _a : "";
                            this.isChanged = true;
                            this.update();
                            this.isOpen = false;
                            currPopupMenu = this.currPopupMenu.selectedMenu && this.currPopupMenu.selectedMenu.map ? this.currPopupMenu.openMenu() : null;
                            this.isOpen = true;
                          }
                        }
                      }
                      calcElementPosition() {
                        if (!this.parentPopup)
                          return;
                        this.parentPopup.prevMaxHeight = null;
                        let parentRect = this.parentPopup.element.getBoundingClientRect();
                        let top = parentRect.top - 20;
                        if (top < this.menuManager.menuBar.bottom) {
                          top = parentRect.bottom;
                          if (parentRect.bottom + 20 > window.innerHeight) {
                            this.parentPopup.prevMaxHeight = this.parentPopup.element.style.maxHeight;
                            this.parentPopup.element.style.maxHeight = parseInt(this.parentPopup.element.style.maxHeight, 10) - 20 + "px";
                            top -= 20;
                          }
                        }
                        this.element.style.top = top + "px";
                        this.element.style.right = window.innerWidth - parentRect.right + "px";
                      }
                      addSymbol(symbol) {
                        var _a;
                        if (symbol === "/" && this.value.substring(this.value.length - 1) === "/") {
                          return;
                        }
                        this.value += symbol;
                        if (symbol === "/") {
                          if (((_a = this.currPopupMenu) == null ? void 0 : _a.selectedMenu) && this.currPopupMenu.selectedMenu.map) {
                            this.currPopupMenu = this.currPopupMenu.openMenu();
                            this.currValue = "";
                          }
                          this.isChanged = false;
                        } else {
                          this.currValue += symbol;
                          this.isChanged = true;
                        }
                        this.update();
                      }
                      removeSymbol() {
                        var _a, _b;
                        if (!this.isOpen) {
                          return;
                        }
                        let removed = this.value.substring(this.value.length - 1);
                        this.value = this.value.substring(0, this.value.length - 1);
                        if (removed === "/") {
                          this.currValue = (_a = this.value.split("/").pop()) != null ? _a : "";
                          this.currPopupMenu = ((_b = this.currPopupMenu) == null ? void 0 : _b.parentMenu) instanceof MenuPopup ? this.currPopupMenu.parentMenu : void 0;
                          this.isChanged = false;
                        } else {
                          this.currValue = this.currValue.substring(0, this.currValue.length - 1);
                          this.isChanged = true;
                        }
                        this.update();
                        if (!this.value.length) {
                          this.close();
                        }
                      }
                      update() {
                        this.searchField.textContent = this.value;
                        if (this.currPopupMenu && this.currPopupMenu.element && this.isChanged) {
                          this.setPopupMenuHighlights();
                          if (this.hideFiltered) {
                            this.calcElementPosition();
                          }
                        }
                      }
                      switchShowHideFiltered() {
                        this.hideFiltered = !this.hideFiltered;
                        this.update();
                        if (!this.hideFiltered) {
                          this.calcElementPosition();
                        }
                      }
                      showHideMenuNode(menu2, show) {
                        var _a;
                        show = show || false;
                        if (!show && menu2.classList.contains("hover") && ((_a = this.currPopupMenu) == null ? void 0 : _a.menuPopup)) {
                          show = true;
                        }
                        menu2.isFiltered = !show;
                        show = show || !this.hideFiltered;
                        menu2.style.display = show ? "block" : "none";
                      }
                      setPopupMenuHighlights() {
                        var _a;
                        if (!((_a = this.currPopupMenu) == null ? void 0 : _a.element))
                          return;
                        let childNode;
                        let width = 0;
                        this.selectMenu = null;
                        this.secondarySelectMenu = null;
                        if (this.hideFiltered) {
                          let rect = this.currPopupMenu.element.getBoundingClientRect();
                          let edges = Utils.getElementEdges(this.currPopupMenu.element);
                          width = rect.width - edges.left - edges.right;
                        }
                        let afterDivider = true;
                        let noResult = true;
                        for (let i = 0; i < this.currPopupMenu.element.childNodes.length; i++) {
                          childNode = this.currPopupMenu.element.childNodes[i];
                          if (childNode.classList.contains("menu_item")) {
                            this.setHighlights(childNode);
                            afterDivider = afterDivider && childNode.isFiltered;
                            if (noResult && !childNode.isFiltered) {
                              noResult = false;
                            }
                          } else if (childNode.classList.contains("menu_divider")) {
                            this.showHideMenuNode(childNode, !afterDivider);
                            afterDivider = true;
                          }
                        }
                        if (this.hideFiltered) {
                          this.currPopupMenu.element.style.width = Math.ceil(width) + "px";
                          let noResultEl = this.currPopupMenu.element.querySelector(".menu_no_result");
                          if (noResult && !noResultEl) {
                            dom.buildDom(["div", { class: "menu_no_result" }, "No matching result"], this.currPopupMenu.element);
                          } else if (!noResult && noResultEl) {
                            noResultEl.remove();
                          }
                        }
                        this.selectMenu = this.selectMenu || this.secondarySelectMenu;
                        if (this.selectMenu) {
                          this.currPopupMenu.moveOnTarget(this.selectMenu);
                          this.currPopupMenu.scrollIfNeeded();
                        }
                        if (this.hideFiltered) {
                          this.currPopupMenu.renderRecursive();
                        }
                        if (this.suggestionPopup) {
                          this.suggestionPopup.close();
                        }
                        if (noResult) {
                          this.currValue = this.value;
                          let suggestionList = {};
                          let addToSuggestionList = (menus) => {
                            Object.keys(menus).forEach((name) => {
                              let item = menus[name];
                              if (item.label && item.label[0] === "~") {
                                return;
                              }
                              if (!item.path) {
                                console.log(item);
                                return;
                              }
                              let path = item.path;
                              let tokens = this.getTokens(path);
                              if (tokens) {
                                suggestionList[path] = {
                                  label: path,
                                  tokens
                                };
                              }
                              if (item.map) {
                                addToSuggestionList(item.map);
                              }
                            });
                          };
                          addToSuggestionList(this.menuManager.menus.map);
                          this.suggestionPopup = new MenuPopup();
                          this.suggestionPopup.direction = "right";
                          this.suggestionPopup.isSubMenu = true;
                          this.suggestionPopup.menuManager = this.menuManager;
                          this.suggestionPopup.menu = {
                            buttonElement: this.element,
                            map: suggestionList
                          };
                          this.suggestionPopup.parentMenu = this;
                          this.suggestionPopup.open();
                          for (let i = 0; i < this.suggestionPopup.element.childNodes.length; i++) {
                            let childNode2 = this.suggestionPopup.element.childNodes[i];
                            let menuTitle = childNode2.querySelector("a");
                            let innerHtml = "";
                            for (let t = 0; t < childNode2.$host.tokens.length; t++) {
                              innerHtml += "<span class='menu-" + childNode2.$host.tokens[t].type + "'>" + childNode2.$host.tokens[t].value + "</span>";
                            }
                            menuTitle.innerHTML = innerHtml;
                          }
                        }
                      }
                      setHighlights(menu2) {
                        let text = menu2.$host.label;
                        let menuTitle = menu2.querySelector("a");
                        if (!this.currValue || !this.currValue.length) {
                          menuTitle.innerHTML = text;
                          this.showHideMenuNode(menu2, true);
                          return;
                        }
                        let tokens = this.getTokens(text);
                        let innerHtml = "";
                        let show = true;
                        if (tokens) {
                          if (menu2.classList.contains("disabled")) {
                            innerHtml = text;
                          } else {
                            this.secondarySelectMenu = this.secondarySelectMenu || menu2;
                            if (!this.selectMenu && tokens[0].type === "completion-highlight") {
                              this.selectMenu = menu2;
                            }
                            for (let i = 0; i < tokens.length; i++) {
                              innerHtml += "<span class='menu-" + tokens[i].type + "'>" + tokens[i].value + "</span>";
                            }
                          }
                        } else {
                          innerHtml = text;
                          show = false;
                        }
                        this.showHideMenuNode(menu2, show);
                        menuTitle.innerHTML = innerHtml;
                      }
                      getTokens(string) {
                        let tokens = [];
                        let caption = string.toLowerCase();
                        let lower = this.currValue.toLowerCase();
                        let upper = this.currValue.toUpperCase();
                        function addToken(value, className) {
                          value && tokens.push({
                            type: className || "",
                            value
                          });
                        }
                        let lastIndex = -1;
                        let matchMask = 0;
                        let index, distance;
                        let fullMatchIndex = caption.indexOf(lower);
                        if (fullMatchIndex === -1) {
                          for (let j = 0; j < this.currValue.length; j++) {
                            let i1 = caption.indexOf(lower[j], lastIndex + 1);
                            let i2 = caption.indexOf(upper[j], lastIndex + 1);
                            index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                            if (index < 0)
                              return;
                            distance = index - lastIndex - 1;
                            if (distance > 0) {
                              matchMask = matchMask | 1 << j;
                            }
                            lastIndex = index;
                          }
                        }
                        let filterText = lower;
                        lower = caption.toLowerCase();
                        lastIndex = 0;
                        let lastI = 0;
                        for (let i = 0; i <= filterText.length; i++) {
                          if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
                            let sub = filterText.slice(lastI, i);
                            lastI = i;
                            index = lower.indexOf(sub, lastIndex);
                            if (index === -1)
                              continue;
                            addToken(string.slice(lastIndex, index), "");
                            lastIndex = index + sub.length;
                            addToken(string.slice(index, lastIndex), "completion-highlight");
                          }
                        }
                        addToken(string.slice(lastIndex, string.length), "");
                        return tokens;
                      }
                      build() {
                        var _a, _b, _c, _d;
                        this.element = dom.buildDom([
                          "div",
                          { class: "menu_searchbox" },
                          ["span", { class: "search_field" }],
                          ["span", { class: "searchbtn_filter" }],
                          ["span", { class: "searchbtn_close" }]
                        ]);
                        this.element.$host = this;
                        this.searchField = this.element.querySelector(".search_field");
                        let _this = this;
                        (_b = (_a = this.element) == null ? void 0 : _a.querySelector(".searchbtn_close")) == null ? void 0 : _b.addEventListener("mousedown", function(e) {
                          _this.close();
                        });
                        (_d = (_c = this.element) == null ? void 0 : _c.querySelector(".searchbtn_filter")) == null ? void 0 : _d.addEventListener("mousedown", function(e) {
                          _this.switchShowHideFiltered();
                        });
                      }
                    }
                    ;
                    const menuManager_event = __nested_webpack_require_440138__(517);
                    const menuManager_keyUtil = __nested_webpack_require_440138__(863);
                    function getPrevSibling(node, conditionFn, parentElement) {
                      parentElement = node ? node.parentElement : parentElement;
                      let wrapped = false;
                      do {
                        node = node && node.previousSibling;
                        if (!node && !wrapped) {
                          node = parentElement == null ? void 0 : parentElement.lastChild;
                          wrapped = true;
                        }
                        if (!node)
                          return;
                      } while (!conditionFn(node));
                      return node;
                    }
                    function getNextSibling(node, conditionFn, parentElement) {
                      parentElement = node ? node.parentElement : parentElement;
                      let wrapped = false;
                      do {
                        node = node && node.nextSibling;
                        if (!node && !wrapped) {
                          node = parentElement == null ? void 0 : parentElement.firstChild;
                          wrapped = true;
                        }
                        if (!node)
                          return;
                      } while (!conditionFn(node));
                      return node;
                    }
                    class MenuManager {
                      constructor() {
                        this.menus = new MenuItems();
                        this.onMouseDown = (e) => {
                          let target = this.getTarget(e.target, (target2) => target2.$host instanceof MenuItems);
                          if (!target)
                            this.inactivateMenu();
                        };
                        this.onMouseMove = (e) => {
                          let lastPos = { x: e.clientX, y: e.clientY };
                          if (this.lastPos && this.lastPos.x === lastPos.x && this.lastPos.y === lastPos.y) {
                            return;
                          }
                          this.prevPos = this.lastPos;
                          this.lastPos = lastPos;
                        };
                        this.onWindowResize = (e) => {
                          if (!this.activeMenu) {
                            return;
                          }
                          let menuPopup = this.activeMenu instanceof MenuPopup ? this.activeMenu : this.activeMenu.menuPopup;
                          if (menuPopup) {
                            menuPopup.renderRecursive();
                          }
                        };
                        this.onContextMenuOpen = (e) => {
                          e.preventDefault();
                          let target = this.getTarget(e.target, (target2) => target2.$host.contextMenu);
                          if (!target) {
                            return;
                          }
                          let pos = { x: e.clientX + 2, y: e.clientY + 2 };
                          this.openMenuByPath("/context/" + target.$host.contextMenu, pos);
                          this.currentHost = target.$host;
                        };
                        this.add = this.addByPath;
                      }
                      static getInstance() {
                        if (!MenuManager._instance) {
                          MenuManager._instance = new MenuManager();
                        }
                        return MenuManager._instance;
                      }
                      find(path, item) {
                        if (typeof path === "string")
                          path = path.split("/");
                        item = item || this.menus;
                        path.forEach(function(part) {
                          if (!item || !item.map)
                            return;
                          item = item.map[part];
                        });
                        return item;
                      }
                      addByPath(path, options2 = {}) {
                        var _a, _b, _c, _d, _e;
                        if (typeof path == "string")
                          path = path.split("/");
                        let item = this.menus;
                        path.forEach(function(part) {
                          var _a2, _b2, _c2;
                          (_a2 = item.map) != null ? _a2 : item.map = {};
                          (_c2 = (_b2 = item.map)[part]) != null ? _c2 : _b2[part] = new MenuItems();
                          item = item.map[part];
                        });
                        item.path = path.join("/");
                        let name = path.pop();
                        item.id = name;
                        item.label = options2.label || name;
                        item.position = (_a = options2.position) != null ? _a : 0;
                        item.hotKey = options2.hotKey;
                        item.type = (_b = options2.type) != null ? _b : "";
                        item.checked = (_c = options2.checked) != null ? _c : false;
                        item.disabled = (_d = options2.disabled) != null ? _d : false;
                        item.className = (_e = options2.className) != null ? _e : "";
                        item.exec = options2.exec;
                      }
                      getTarget(target, callback) {
                        while (target) {
                          if (target.$host && (!callback || callback(target)))
                            return target;
                          target = target.parentElement;
                        }
                        return;
                      }
                      bindKeys() {
                        function isMenuBarItem(node) {
                          return node.classList.contains("menuButton");
                        }
                        function isMenuPopupActiveItem(node) {
                          return node.classList.contains("menu_item") && !node.classList.contains("disabled") && !node.isFiltered;
                        }
                        function menuKeyDown(menuManager) {
                          var _a;
                          let menuPopup = (_a = menuManager.activeMenu) == null ? void 0 : _a.getLastOpenPopup();
                          if (!menuPopup)
                            return;
                          let menu2 = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
                          let nextMenu = getNextSibling(menu2, isMenuPopupActiveItem, menuPopup.element);
                          menuPopup.moveOnTarget(nextMenu);
                          menuPopup.scrollIfNeeded();
                        }
                        let menuKb = new hash_handler_.HashHandler([
                          {
                            bindKey: "Esc",
                            name: "Esc",
                            exec: function(menuManager) {
                              if (menuManager.searchBox && menuManager.searchBox.isOpen) {
                                menuManager.searchBox.close();
                                return;
                              }
                              let activeMenu = menuManager.activeMenu;
                              if (!activeMenu.menuPopup && activeMenu !== menuManager.menuBar) {
                                activeMenu.close();
                                menuManager.inactivateMenu();
                              } else {
                                activeMenu.closeLastMenu();
                                if (!activeMenu.menuPopup && activeMenu === menuManager.menuBar) {
                                  menuManager.inactivateMenu();
                                }
                              }
                            }
                          },
                          {
                            bindKey: "Left",
                            name: "Left",
                            exec: function(menuManager) {
                              let activeMenu = menuManager.activeMenu;
                              activeMenu.closeLastMenu();
                              if (!activeMenu.menuPopup) {
                                if (activeMenu === menuManager.menuBar) {
                                  let prevMenu = getPrevSibling(activeMenu.selectedMenu.buttonElement, isMenuBarItem);
                                  if (prevMenu) {
                                    activeMenu.moveOnTarget(prevMenu);
                                  }
                                } else if (!activeMenu.element) {
                                  menuManager.inactivateMenu();
                                }
                              }
                            }
                          },
                          {
                            bindKey: "Right",
                            name: "Right",
                            exec: function(menuManager) {
                              function moveToNextOnBar() {
                                if (menuManager.activeMenu !== menuManager.menuBar) {
                                  return;
                                }
                                let nextMenu = getNextSibling(menuManager.menuBar.selectedMenu.buttonElement, isMenuBarItem);
                                if (nextMenu) {
                                  menuManager.menuBar.moveOnTarget(nextMenu);
                                }
                              }
                              let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                              let menu2 = menuManager.activeMenu.getLastSelectedMenu();
                              if (!menu2) {
                                return;
                              }
                              let moveToNext = !menu2.map || menuManager.activeMenu === menuManager.menuBar && !menuManager.activeMenu.menuPopup.selectedMenu;
                              if (!moveToNext && (!menuPopup.selectedMenu && (menuManager.activeMenu.menuPopup !== menuPopup || menuManager.activeMenu !== menuPopup) || menuPopup.selectedMenu === menu2)) {
                                let isNewOpened = false;
                                if (menuPopup.selectedMenu === menu2) {
                                  menuPopup.openMenu();
                                  isNewOpened = true;
                                }
                                menuKeyDown(menuManager);
                                if (!isNewOpened && !menuPopup.selectedMenu) {
                                  moveToNext = true;
                                }
                              }
                              if (moveToNext) {
                                moveToNextOnBar();
                              }
                            }
                          },
                          {
                            bindKey: "Enter",
                            name: "Enter",
                            exec: function(menuManager) {
                              let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                              let menu2 = menuManager.activeMenu.getLastSelectedMenu();
                              if (menu2 && menu2.map && menuPopup.selectedMenu === menu2) {
                                menuPopup.openMenu();
                              }
                            }
                          },
                          {
                            bindKey: "Up",
                            name: "Up",
                            exec: function(menuManager) {
                              let menuPopup = menuManager.activeMenu.getLastOpenPopup();
                              let menu2 = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
                              let prevMenu = getPrevSibling(menu2, isMenuPopupActiveItem, menuPopup.element);
                              menuPopup.moveOnTarget(prevMenu);
                              menuPopup.scrollIfNeeded();
                            }
                          },
                          {
                            bindKey: "Backspace",
                            name: "Backspace",
                            exec: function(menuManager) {
                              menuManager.searchBox.removeSymbol();
                            }
                          },
                          {
                            bindKey: "Down",
                            name: "Down",
                            exec: menuKeyDown
                          }
                        ]);
                        let _this = this;
                        menuManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
                          if (!_this.isActive) {
                            return;
                          }
                          menuManager_event.stopEvent(e);
                          let keyString = menuManager_keyUtil.keyCodeToString(keyCode);
                          let command = menuKb.findKeyCommand(hashId, keyString);
                          if (command && command.exec) {
                            command.exec(_this);
                          } else if (e.key.length === 1) {
                            MenuManager.getInstance().addSymbolToSearchBox(e.key);
                          }
                        });
                      }
                      build() {
                        window.addEventListener("contextmenu", this.onContextMenuOpen);
                      }
                      buildMenuBar(parent) {
                        this.menuBar = new MenuBar();
                        this.menuBar.menus = this.menus;
                        this.menuBar.menuManager = this;
                        this.menuBar.build(parent);
                      }
                      openMenuByPath(path, position) {
                        if (typeof path === "string")
                          path = path.split("/");
                        if (path[0] && path[0].length) {
                          this.activeMenu = this.menuBar;
                        } else {
                          this.activeMenu = new MenuPopup();
                          this.activeMenu.menuManager = this;
                          this.activeMenu.position = position;
                          this.activeMenu.menu = this.find(path);
                          this.activeMenu.open();
                        }
                        this.activateMenu();
                        this.activeMenu.openMenuByPath(path);
                      }
                      activateMenu() {
                        var _a;
                        this.isActive = true;
                        window.addEventListener("mousedown", this.onMouseDown);
                        window.addEventListener("mousemove", this.onMouseMove);
                        window.addEventListener("resize", this.onWindowResize);
                        if ((_a = this.activeMenu) == null ? void 0 : _a.activateMenu)
                          this.activeMenu.activateMenu();
                      }
                      inactivateMenu() {
                        var _a;
                        this.isActive = false;
                        window.removeEventListener("mousedown", this.onMouseDown);
                        window.removeEventListener("mousemove", this.onMouseMove);
                        window.removeEventListener("resize", this.onWindowResize);
                        if ((_a = this.activeMenu) == null ? void 0 : _a.inactivateMenu)
                          this.activeMenu.inactivateMenu();
                        this.activeMenu = void 0;
                        if (this.searchBox)
                          this.searchBox.close();
                        this.currentHost = null;
                      }
                      addSymbolToSearchBox(symbol) {
                        if (!this.searchBox || !this.searchBox.isOpen) {
                          this.openSearchBox();
                        }
                        this.searchBox.addSymbol(symbol);
                      }
                      openSearchBox() {
                        var _a;
                        if (!this.searchBox) {
                          this.searchBox = new MenuSearchBox();
                          this.searchBox.menuManager = this;
                        }
                        this.searchBox.setParentPopup((_a = this.activeMenu) == null ? void 0 : _a.getLastOpenPopup());
                        this.searchBox.open();
                      }
                    }
                    class MenuItems {
                    }
                    ;
                    const oop = __nested_webpack_require_440138__(387);
                    const useragent = __nested_webpack_require_440138__(493);
                    let newTabCounter = 1;
                    class TabManager {
                      constructor(options2) {
                        this.$setBoxState = (box, state) => {
                          if (!box)
                            return;
                          box.removeAllChildren();
                          this.setBoxData(box, state);
                          if (!box[0] && box.isMain)
                            this.setChildBoxData(box, [{ type: "pane" }], 0);
                        };
                        this.containers = options2.containers;
                        this.tabs = {};
                        this.fileSystem = options2.fileSystem;
                        this.commandsInit();
                        this.initFileSystem();
                      }
                      static getInstance(options2) {
                        if (!TabManager._instance)
                          TabManager._instance = new TabManager(options2);
                        return TabManager._instance;
                      }
                      initFileSystem() {
                        var _a;
                        (_a = this.fileSystem) == null ? void 0 : _a.on("openFile", (treeNode, fileContent) => {
                          this.open({
                            path: treeNode.path,
                            title: treeNode.path.split("/").pop()
                          }, void 0, fileContent);
                        });
                      }
                      commandsInit() {
                        MenuManager.getInstance().addByPath("/context/tabs");
                        let commandsKeys = [];
                        for (let command of tabCommands) {
                          if (command.exec !== void 0) {
                            MenuManager.getInstance().addByPath("/context/tabs/" + command.name, {
                              position: command.position,
                              hotKey: useragent.isMac ? command.mac : command.win,
                              exec: command.exec
                            });
                            commandsKeys.push({
                              bindKey: {
                                win: command.win,
                                mac: command.mac
                              },
                              exec: command.exec
                            });
                          }
                        }
                        CommandManager.registerCommands(commandsKeys, this);
                      }
                      toJSON() {
                        let containers = Object.keys(this.containers);
                        return Object.fromEntries(containers.map((container) => {
                          var _a;
                          return [container, (_a = this.containers[container]) == null ? void 0 : _a.toJSON()];
                        }));
                      }
                      setChildBoxData(box, boxData, index) {
                        if (!boxData[index])
                          return;
                        let boxType = boxData[index].type;
                        if (!box[index])
                          box.addChildBox(index, boxType === "pane" ? new Pane() : new Box({ vertical: boxType === "vbox" }));
                        this.setBoxData(box[index], boxData[index]);
                      }
                      setBoxData(box, boxData) {
                        if (!boxData)
                          return;
                        if (boxData.fixedSize)
                          box.fixedSize = boxData.fixedSize;
                        if (box instanceof Pane) {
                          if (boxData.tabBar) {
                            box.tabBar.scrollLeft = boxData.tabBar.scrollLeft;
                            if (boxData.tabBar.tabList) {
                              box.tabBar.freeze = true;
                              boxData.tabBar.tabList.forEach((tabData) => {
                                let tab2 = box.tabBar.addTab(new Tab(tabData));
                                this.tabs[tab2.path] = tab2;
                                if (tab2.preview)
                                  this.previewTab = tab2;
                              });
                              box.tabBar.freeze = false;
                              box.tabBar.configure();
                            }
                          }
                        } else {
                          box.hidden = boxData.hidden;
                          box.ratio = boxData.ratio;
                          this.setChildBoxData(box, boxData, 0);
                          this.setChildBoxData(box, boxData, 1);
                          box.buttons && box.setButtons(box.buttons);
                        }
                      }
                      setState(state) {
                        this.activePane = void 0;
                        this.tabs = {};
                        this.previewTab = void 0;
                        for (let container in this.containers) {
                          this.setContainerState(container, state[container]);
                        }
                      }
                      setContainerState(container, state) {
                        this.$setBoxState(this.containers[container], state);
                      }
                      clear() {
                      }
                      getPanes() {
                      }
                      getTabs() {
                        return this.tabs;
                      }
                      get activeTab() {
                        var _a;
                        return (_a = this.activePane) == null ? void 0 : _a.tabBar.activeTab;
                      }
                      open(tabOptions, container, fileContent) {
                        var _a;
                        let tab2 = this.tabs[tabOptions.path];
                        tabOptions.active = (_a = tabOptions.active) != null ? _a : true;
                        if (!tab2 || !tab2.parent) {
                          let pane;
                          if (container) {
                            pane = this.getContainerPane(container);
                          } else {
                            pane = this.activePane && this.activePane.tabBar.tabList.length > 0 ? this.activePane : this.getContainerPane("main");
                          }
                          if (this.previewTab)
                            this.previewTab.remove();
                          tab2 = pane.tabBar.addTab(new Tab(tabOptions), void 0, fileContent);
                          if (tabOptions.preview)
                            this.previewTab = tab2;
                          tab2.parent.scrollTabIntoView(tab2);
                          this.tabs[tab2.path] = tab2;
                        }
                        if (!tabOptions.preview) {
                          if (this.previewTab == tab2) {
                            this.clearPreviewStatus(tab2);
                          } else if (this.previewTab) {
                            this.previewTab.remove();
                          }
                        }
                        tab2.parent.removeSelections();
                        tab2.parent.activateTab(tab2, fileContent);
                        return tab2;
                      }
                      getContainerPane(container) {
                        return this.containers[container].element.querySelector(".tabPanel").$host;
                      }
                      clearPreviewStatus(tab2) {
                        tab2.preview = false;
                        tab2.element.style.fontStyle = "";
                        if (this.previewTab == tab2)
                          this.previewTab = void 0;
                      }
                      get newTabPath() {
                        return `untitled_${newTabCounter}`;
                      }
                      addNewTab(pane, options2) {
                        while (this.tabs.hasOwnProperty(this.newTabPath)) {
                          newTabCounter++;
                        }
                        options2 != null ? options2 : options2 = { title: `Untitled ${newTabCounter}`, path: this.newTabPath };
                        options2.active = true;
                        let newTab = pane.tabBar.addTab(new Tab(options2));
                        this.tabs[this.newTabPath] = newTab;
                        return newTab;
                      }
                      removeTab(tab2) {
                        delete this.tabs[tab2.path];
                      }
                      //TODO: move to separate class
                      loadFile(tab2, fileContent) {
                        let editor = tab2.parent.parent.getOrCreateEditor(tab2.editorType);
                        editor.setSession(tab2, fileContent);
                      }
                      navigateToTab(index, tab2, tabs) {
                        var _a;
                        let tabsList = tabs || Object.values(this.tabs);
                        let activeTab = tab2 || this.activeTab;
                        if (index >= 0 && tabsList.length > index)
                          (_a = activeTab == null ? void 0 : activeTab.parent) == null ? void 0 : _a.activateTab(tabsList[index], void 0, true);
                      }
                      saveTo(storage) {
                        for (let [path, tab2] of Object.entries(this.tabs)) {
                          storage["@file@" + path] = tab2.session ? tab2.editor.sessionToJSON(tab2) : tab2.sessionValue;
                        }
                      }
                      restoreFrom(storage) {
                        for (let [path, tab2] of Object.entries(this.tabs)) {
                          tab2.sessionValue = storage["@file@" + path];
                          if (tab2.session)
                            tab2.editor.restoreSessionFromJson(tab2);
                        }
                      }
                      getTab(path) {
                        return this.tabs[path];
                      }
                    }
                    oop.implement(TabManager.prototype, event_emitter_.EventEmitter);
                    ;
                    class Toolbar {
                      setBox(x, y, w, h) {
                        Utils.setBox(this.element, x, y, w, h);
                      }
                      constructor(options2) {
                        this.direction = (options2 == null ? void 0 : options2.direction) || "horizontal";
                        this.size = (options2 == null ? void 0 : options2.size) || 27;
                        this.position = options2 == null ? void 0 : options2.position;
                      }
                    }
                    ;
                    class TabPanelBar extends Toolbar {
                      constructor(options2) {
                        var _a, _b;
                        super(options2);
                        this.selectedTabs = [];
                        this.tabList = [];
                        this.scrollLeft = 0;
                        this.animationSteps = 0;
                        this.MIN_TAB_SIZE = 120;
                        this.MAX_TAB_SIZE = 150;
                        this.activeTabHistory = [];
                        this.onMouseWheel = (e) => {
                          let d = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
                          if (Math.abs(d) > 50) {
                            this.animateScroll(d);
                          } else {
                            this.stopScrollAnimation();
                            this.setScrollPosition((this.scrollLeft || 0) + d);
                          }
                        };
                        this.initTabList = (_b = (_a = options2.tabList) != null ? _a : options2.panelList) != null ? _b : [];
                      }
                      isVertical() {
                        return this.direction === "vertical";
                      }
                      getDraggingElementSize() {
                        if (!this.tabDraggingElement)
                          return 0;
                        let draggingElementSize = this.isVertical() ? this.tabDraggingElement.style.height : this.tabDraggingElement.style.width;
                        return parseInt(draggingElementSize, 10);
                      }
                      tabMouseDown(tab2, expand = false, toggle = false) {
                        if (expand) {
                          this.expandSelection(tab2, toggle);
                        } else {
                          this.anchorTab = null;
                          if (toggle) {
                            this.toggleSelection(tab2);
                          } else {
                            this.activateTab(tab2, void 0, this.selectedTabs.indexOf(tab2) < 0);
                          }
                        }
                      }
                      expandSelection(tab2, toggle = false) {
                        if (!this.anchorTab)
                          this.anchorTab = this.activeTab;
                        let prevSelectedTabs = this.selectedTabs;
                        this.selectedTabs = [];
                        let start = this.tabList.indexOf(this.anchorTab);
                        let end = this.tabList.indexOf(tab2);
                        if (end < start) {
                          [start, end] = [end, start];
                        }
                        for (let i = start; i <= end; i++) {
                          this.addSelection(this.tabList[i]);
                        }
                        prevSelectedTabs.forEach((selectedTab) => {
                          if (this.selectedTabs.indexOf(selectedTab) < 0) {
                            if (!toggle) {
                              this.deselectTab(selectedTab);
                            } else {
                              this.addSelection(selectedTab);
                            }
                          }
                        });
                        this.activateTab(tab2);
                      }
                      toggleSelection(tab2) {
                        let index = this.selectedTabs.indexOf(tab2);
                        if (index < 0) {
                          this.activateTab(tab2);
                        } else if (tab2 !== this.activeTab) {
                          this.removeSelection(tab2);
                        }
                      }
                      addSelection(tab2) {
                        if (this.selectedTabs.indexOf(tab2) < 0) {
                          this.selectTab(tab2);
                          this.selectedTabs.push(tab2);
                        }
                      }
                      selectTab(tab2) {
                        tab2.element.classList.add("selected");
                      }
                      deselectTab(tab2) {
                        tab2.element.classList.remove("selected");
                      }
                      removeSelection(tab2) {
                        if (this.selectedTabs.indexOf(tab2) < 0)
                          return;
                        this.deselectTab(tab2);
                        this.selectedTabs.splice(this.selectedTabs.indexOf(tab2), 1);
                      }
                      removeSelections() {
                        this.selectedTabs.forEach((selectedTab) => {
                          this.deselectTab(selectedTab);
                        });
                        this.selectedTabs = [];
                      }
                      scrollTabIntoView(tab2) {
                        let index = this.tabList.indexOf(tab2);
                        this.setScrollPosition((index + 1) * this.tabWidth);
                      }
                      activateTab(tab2, content, removeSelections = false) {
                        removeSelections && this.removeSelections();
                        this.activeTabClicked = false;
                        this.addSelection(tab2);
                        if (this.activeTab) {
                          if (this.activeTab === tab2) {
                            this.activeTabClicked = true;
                            return;
                          }
                          if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
                            this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
                          this.activeTabHistory.push(this.activeTab);
                          this.activeTab.deactivate();
                        }
                        tab2.activate();
                        this.activeTab = tab2;
                        this.configure();
                      }
                      removeTab(tab2) {
                        if (tab2 === this.activeTab)
                          this.activeTab = void 0;
                        let index = this.tabList.indexOf(tab2);
                        if (index >= 0)
                          this.tabList.splice(index, 1);
                        tab2.parent = void 0;
                      }
                      activatePrevious(index) {
                        if (this.tabList.length) {
                          let tab2 = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
                          this.activateTab(tab2);
                        }
                      }
                      addTab(tab2, index, content) {
                        if (!tab2.element)
                          tab2.render();
                        tab2.parent = this;
                        if (index === void 0 || index === null || index >= this.tabList.length) {
                          this.tabContainer.appendChild(tab2.element);
                          this.tabList.push(tab2);
                        } else {
                          this.tabContainer.insertBefore(tab2.element, this.tabContainer.childNodes[index]);
                          this.tabList.splice(index, 0, tab2);
                        }
                        if (tab2.active)
                          this.activateTab(tab2, content, true);
                        this.configure();
                        return tab2;
                      }
                      setScrollPosition(scrollLeft) {
                        this.scrollLeft = scrollLeft;
                        this.configure();
                      }
                      animateScroll(v) {
                        this.vX = v / 80;
                        this.animationSteps += 15;
                        if (this.animationSteps > 15) {
                          this.vX *= 1.2 * this.animationSteps / 10;
                          this.animationSteps = 15 + Math.ceil((this.animationSteps - 15) * 0.75);
                        }
                        if (this.animationTimer)
                          return;
                        this.animationTimer = setInterval(() => {
                          if (this.animationSteps-- <= 0) {
                            return this.stopScrollAnimation();
                          }
                          let vX = this.vX;
                          if (Math.abs(this.vX) < 0.01)
                            vX = 0;
                          vX = 0.9 * vX;
                          let oldScrollLeft = this.scrollLeft;
                          this.setScrollPosition(this.scrollLeft + 10 * vX);
                          if (oldScrollLeft == this.scrollLeft)
                            this.animationSteps = 0;
                          this.vX = vX;
                        }, 10);
                      }
                      stopScrollAnimation() {
                        clearInterval(this.animationTimer);
                        this.animationTimer = null;
                        this.animationScrollLeft = null;
                        this.vX = 0;
                      }
                      transform(el, dx, dy) {
                        el.style.left = Math.round(dx) + "px";
                        el.dx = dx;
                        el.dy = dy;
                      }
                      startTabDragging(element, index) {
                        if (this.isDragging)
                          return;
                        this.tabDraggingElement = element;
                        this.draggingElementIndex = index;
                        this.configure();
                        this.isDragging = true;
                      }
                      finishTabDragging() {
                        this.draggingElementIndex = void 0;
                        this.tabDraggingElement = void 0;
                        if (this.activeTabHistory.length) {
                          let removedHistoryTabs = [];
                          for (let i = 0; i < this.activeTabHistory.length; i++) {
                            if (this.tabList.indexOf(this.activeTabHistory[i]) < 0) {
                              removedHistoryTabs.push(this.activeTabHistory[i]);
                            }
                          }
                          removedHistoryTabs.forEach((tab2) => {
                            let index = this.activeTabHistory.indexOf(tab2);
                            if (index >= 0) {
                              this.activeTabHistory.splice(index, 1);
                            }
                          });
                        }
                        this.configure();
                        this.isDragging = false;
                      }
                      toJSON() {
                        return {
                          tabList: this.tabList.map((tab2) => tab2.toJSON()),
                          scrollLeft: this.scrollLeft
                        };
                      }
                    }
                    ;
                    class TabBar extends TabPanelBar {
                      constructor() {
                        super(...arguments);
                        this.inverted = true;
                        this.buttonsWidth = 0;
                        this.buttons = [];
                        this.onTabMouseUp = (e) => {
                          if (e.button == 1) {
                            let tab2 = Utils.findHost(e.target, Tab);
                            if (tab2)
                              tab2.remove();
                          }
                        };
                        this.onTabMouseDown = (e) => {
                          if (e.button == 0)
                            TabbarHandler.tabbarMouseDown(e, Tab, TabBar, true);
                        };
                        this.onTabPlusClick = (e) => {
                          this.removeSelections();
                          TabManager.getInstance().addNewTab(this.parent);
                        };
                        this.onTabClick = (e) => {
                          let target = e.target;
                          let tab2 = Utils.findHost(target, Tab);
                          if (tab2) {
                            if (e.button == 0 && target.classList.contains("tabCloseButton")) {
                              this.closeTab(tab2);
                            } else if (e.button == 0 && tab2.isActive && tab2.editor) {
                              tab2.editor.focus();
                            } else if (e.button == 1) {
                              tab2.remove();
                            }
                          }
                        };
                      }
                      setBox(x, y, w, h) {
                        super.setBox(x, y, w, h);
                        this.width = w;
                        this.configure();
                      }
                      renderElement() {
                        this.element = dom.buildDom([
                          "div",
                          {
                            class: "tabbar " + this.direction,
                            onwheel: this.onMouseWheel,
                            $host: this
                          },
                          ["span", { class: "tabMenuButton" }],
                          [
                            "div",
                            {
                              class: "tabScroller"
                            },
                            ["div", {
                              class: "tabContainer",
                              ref: "tabContainer",
                              onclick: this.onTabClick,
                              onmouseup: this.onTabMouseUp,
                              onmousedown: this.onTabMouseDown
                            }]
                          ],
                          ["span", {
                            class: "tabPlusButton",
                            ref: "tabPlusButton",
                            onclick: this.onTabPlusClick
                          }, "+"],
                          ["span", {
                            class: "sizer"
                          }],
                          ["span", {
                            class: "buttons",
                            ref: "additionalButtons"
                          }]
                        ], void 0, this);
                        if (this.initTabList && this.initTabList.length) {
                          for (let i = 0; i < this.initTabList.length; i++) {
                            this.addTab(this.initTabList[i]);
                          }
                        }
                      }
                      render() {
                        if (!this.element)
                          this.renderElement();
                        return this.element;
                      }
                      computeConfig() {
                        let draggingElementSize = this.getDraggingElementSize();
                        this.plusButtonWidth = this.tabPlusButton.getBoundingClientRect().width;
                        this.containerWidth = this.width - this.plusButtonWidth - this.buttonsWidth;
                        let tabsCount = this.tabList.length;
                        if (tabsCount * this.MAX_TAB_SIZE + draggingElementSize < this.containerWidth) {
                          this.tabWidth = this.MAX_TAB_SIZE;
                          this.containerWidth = tabsCount * this.tabWidth + draggingElementSize;
                        } else if (tabsCount * this.MIN_TAB_SIZE + draggingElementSize < this.containerWidth) {
                          this.tabWidth = (this.containerWidth - draggingElementSize) / tabsCount;
                        } else {
                          this.tabWidth = this.MIN_TAB_SIZE;
                        }
                        let tabsWidth = this.tabWidth * tabsCount + draggingElementSize;
                        this.scrollLeft = Math.min(Math.max(this.scrollLeft, 0), tabsWidth - this.containerWidth);
                      }
                      configure() {
                        if (!this.width || this.freeze)
                          return;
                        let shadowWidth = 4;
                        this.computeConfig();
                        this.tabContainer.style.width = this.containerWidth + "px";
                        let draggingElementSize = this.getDraggingElementSize();
                        if (this.inverted) {
                          let zIndex = this.tabList.length;
                          let min = shadowWidth - this.tabWidth;
                          let max = this.containerWidth;
                          let maxPos = (max - this.tabWidth) / 2;
                          let i = 0;
                          for (; i < this.tabList.length; i++) {
                            let tab2 = this.tabList[i];
                            let el = tab2.element;
                            let pos = this.tabWidth * i - this.scrollLeft;
                            if (this.tabDraggingElement && i >= this.draggingElementIndex) {
                              pos += draggingElementSize;
                            }
                            if (tab2 === this.activeTab) {
                              let activeMin = Math.max(min + this.tabWidth * 0.25, -this.tabWidth * 0.75);
                              if (pos < activeMin)
                                min = activeMin;
                            }
                            if (pos < min) {
                              pos = min;
                              min += shadowWidth;
                              el.classList.add("scrolledLeft");
                            } else if (pos > maxPos) {
                              break;
                            } else {
                              el.classList.remove("scrolledLeft");
                            }
                            el.style.width = this.tabWidth + "px";
                            el.style.zIndex = String(zIndex);
                            zIndex--;
                            this.transform(el, pos, 0);
                          }
                          let lastRendered = i;
                          zIndex = this.tabList.length;
                          for (let i2 = this.tabList.length - 1; i2 >= lastRendered; i2--) {
                            let tab2 = this.tabList[i2];
                            let el = tab2.element;
                            let pos = this.tabWidth * i2 - this.scrollLeft;
                            if (this.tabDraggingElement && i2 >= this.draggingElementIndex) {
                              pos += draggingElementSize;
                            }
                            if (tab2 === this.activeTab) {
                              let activeMax = Math.min(max - this.tabWidth * 0.25, this.containerWidth - this.tabWidth * 0.25);
                              if (pos > activeMax)
                                max = activeMax;
                            }
                            if (pos > max) {
                              pos = max;
                              max -= shadowWidth;
                              el.classList.add("scrolledLeft");
                            } else {
                              el.classList.remove("scrolledLeft");
                            }
                            el.style.width = this.tabWidth + "px";
                            el.style.zIndex = String(zIndex);
                            zIndex--;
                            this.transform(el, pos, 0);
                          }
                        } else {
                        }
                      }
                      addButton(button) {
                        this.buttons.push(button);
                        this.setButtons(this.buttons);
                      }
                      setButtons(buttons) {
                        this.additionalButtons.innerHTML = "";
                        this.buttons = buttons;
                        buttons.forEach((button) => this.additionalButtons.appendChild(button));
                        let rect = this.additionalButtons.getBoundingClientRect();
                        this.buttonsWidth = rect.width;
                        this.configure();
                      }
                      removeButtons() {
                        if (!this.buttons.length)
                          return;
                        this.buttons = [];
                        this.additionalButtons.innerHTML = "";
                        this.buttonsWidth = 0;
                        this.configure();
                      }
                      clear() {
                        this.removeButtons();
                        this.tabList = [];
                      }
                      remove() {
                      }
                      closeTab(tab2) {
                        let index = this.tabList.indexOf(tab2);
                        let isActiveTab = this.activeTab === tab2;
                        let isAnchorTab = this.anchorTab === tab2;
                        this.removeTab(tab2);
                        this.removeSelection(tab2);
                        if (isActiveTab) {
                          this.activeTab = void 0;
                          this.activatePrevious(index);
                        }
                        if (isAnchorTab)
                          this.anchorTab = null;
                        if (tab2.element)
                          tab2.element.remove();
                        TabManager.getInstance().removeTab(tab2);
                        this.configure();
                      }
                      activateTab(tab2, content, removeSelections = false) {
                        removeSelections && this.removeSelections();
                        this.activeTabClicked = false;
                        this.addSelection(tab2);
                        if (this.activeTab) {
                          if (this.activeTab === tab2) {
                            this.activeTabClicked = true;
                            tab2.activatePane();
                            return;
                          }
                          if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
                            this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
                          this.activeTabHistory.push(this.activeTab);
                          this.activeTab.deactivate();
                        }
                        tab2.activate(content);
                        this.activeTab = tab2;
                        this.configure();
                      }
                      activatePrevious(index) {
                        if (this.tabList.length) {
                          let tab2 = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
                          this.activateTab(tab2);
                        } else if (this.parent) {
                          this.parent.remove();
                        }
                      }
                    }
                    ;
                    class Pane extends Box {
                      constructor(options2 = {}) {
                        var _a;
                        let tabBar = new TabBar({
                          tabList: options2.tabList
                        });
                        options2.toolBars = (_a = options2.toolBars) != null ? _a : {};
                        options2.toolBars.top = tabBar;
                        super(options2);
                        tabBar.parent = this;
                        this.tabBar = tabBar;
                      }
                      toJSON() {
                        return {
                          type: "pane",
                          tabBar: this.tabBar.toJSON()
                        };
                      }
                      render() {
                        super.render();
                        this.element.classList.add("tabPanel");
                        this.tabEditorBoxElement = dom.buildDom(["div", {
                          class: `tab-editor`
                        }]);
                        this.element.appendChild(this.tabEditorBoxElement);
                        return this.element;
                      }
                      acceptsTab(tab2) {
                        return true;
                      }
                      split(far, vertical) {
                        let newPane = new Pane({});
                        let root = this.parent;
                        let wrapper = new Box({
                          [far ? 1 : 0]: this,
                          [far ? 0 : 1]: newPane,
                          vertical,
                          ratio: 0.5
                        });
                        root.addChildBox(this, wrapper);
                        if (this.isButtonHost) {
                          let buttons = this.tabBar.buttons;
                          this.removeButtons();
                          wrapper.setButtons(buttons);
                        }
                        return newPane;
                      }
                      setButtons(buttons) {
                        this.isButtonHost = true;
                        if (buttons) {
                          this.tabBar.setButtons(buttons);
                        } else {
                          this.tabBar.removeButtons();
                        }
                      }
                      addButton(button) {
                        this.isButtonHost = true;
                        this.tabBar.addButton(button);
                      }
                      $updateChildSize(x, y, w, h) {
                        this.updateToolBarSize(w, h);
                        w -= this.padding.left + this.padding.right;
                        h -= this.padding.top + this.padding.bottom;
                        x = this.padding.left;
                        y = this.padding.top;
                        if (this.editor) {
                          Utils.setBox(this.editor.container, x, y, w, h);
                          this.editor.resize();
                        }
                      }
                      removeButtons() {
                        this.tabBar.removeButtons();
                        this.isButtonHost = false;
                      }
                      remove() {
                        let wrapper = this.parent;
                        let root = wrapper.parent;
                        let paneIndex = wrapper[0] == this ? 1 : 0;
                        let pane = wrapper[paneIndex] || null;
                        let rootIndex = root[0] == wrapper ? 0 : 1;
                        if (pane) {
                          pane.parent = root;
                          root[rootIndex] = pane;
                          root.element.appendChild(pane.element);
                          if (root.fixedChild && root.fixedChild == wrapper) {
                            pane.fixedSize = wrapper.fixedSize;
                            pane.size = wrapper.size;
                            root.fixedChild = pane;
                          }
                          wrapper.element.remove();
                        } else {
                          if (wrapper.isMain) {
                            root = wrapper;
                          } else {
                            wrapper.element.remove();
                          }
                          root.ratio = 1;
                        }
                        root.recalculateAllMinSizes();
                        root.resize();
                        if (this.isButtonHost)
                          root.setButtons(this.tabBar.buttons);
                        this.clearEditors();
                        this.tabBar.clear();
                      }
                      getTopRightPane() {
                        return this;
                      }
                      createEditor() {
                        let editor = this.createEditorByType();
                        this.emit("editorAdded", editor);
                        return editor;
                      }
                      createEditorByType() {
                        switch (this.currentEditorType) {
                          case EditorType.preview:
                            return new PreviewEditor();
                          case EditorType.ace:
                          default:
                            return new AceEditor();
                        }
                      }
                      initEditor(editorType = EditorType.ace) {
                        var _a, _b, _c;
                        if (this.currentEditorType == editorType)
                          return;
                        this.hidePreviousEditor();
                        (_a = this.editors) != null ? _a : this.editors = {};
                        this.currentEditorType = editorType;
                        (_c = (_b = this.editors)[editorType]) != null ? _c : _b[editorType] = this.createEditor();
                        this.editor = this.editors[editorType];
                        this.element.appendChild(this.editor.container);
                      }
                      hidePreviousEditor() {
                        if (!this.editor)
                          return;
                        this.element.removeChild(this.editor.container);
                      }
                      getEditor(editorType = EditorType.ace) {
                        return this.editors[editorType];
                      }
                      getOrCreateEditor(editorType = EditorType.ace) {
                        this.initEditor(editorType);
                        return this.editor;
                      }
                      clearEditors() {
                        for (let i in this.editors) {
                          this.editors[i].destroy();
                        }
                        this.editors = {};
                        this.currentEditorType = void 0;
                        this.editor = void 0;
                      }
                    }
                    var styles_button = __nested_webpack_require_440138__(382);
                    ;
                    var button_options = {};
                    button_options.styleTagTransform = styleTagTransform_default();
                    button_options.setAttributes = setAttributesWithoutAttributes_default();
                    button_options.insert = insertBySelector_default().bind(null, "head");
                    button_options.domAPI = styleDomAPI_default();
                    button_options.insertStyleElement = insertStyleElement_default();
                    var button_update = injectStylesIntoStyleTag_default()(styles_button.A, button_options);
                    const assets_styles_button = styles_button.A && styles_button.A.locals ? styles_button.A.locals : void 0;
                    ;
                    var __defProp = Object.defineProperty;
                    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
                    var __hasOwnProp = Object.prototype.hasOwnProperty;
                    var __propIsEnum = Object.prototype.propertyIsEnumerable;
                    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
                    var __spreadValues = (a, b) => {
                      for (var prop in b || (b = {}))
                        if (__hasOwnProp.call(b, prop))
                          __defNormalProp(a, prop, b[prop]);
                      if (__getOwnPropSymbols)
                        for (var prop of __getOwnPropSymbols(b)) {
                          if (__propIsEnum.call(b, prop))
                            __defNormalProp(a, prop, b[prop]);
                        }
                      return a;
                    };
                    var __objRest = (source, exclude) => {
                      var target = {};
                      for (var prop in source)
                        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
                          target[prop] = source[prop];
                      if (source != null && __getOwnPropSymbols)
                        for (var prop of __getOwnPropSymbols(source)) {
                          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
                            target[prop] = source[prop];
                        }
                      return target;
                    };
                    dom.importCssString(button_namespaceObject, "button.css");
                    class Button {
                      constructor(options2) {
                        let _a = options2, {
                          disabled,
                          value,
                          className,
                          onClick
                        } = _a, other = __objRest(_a, [
                          "disabled",
                          "value",
                          "className",
                          "onClick"
                        ]);
                        this.disabled = disabled;
                        this.value = value;
                        this.className = className || "blackbutton";
                        this.onClick = onClick;
                        this.options = other;
                      }
                      remove() {
                      }
                      render() {
                        var _a;
                        this.renderElement();
                        this.element.$host = this;
                        this.element.onclick = (_a = this.onClick) != null ? _a : null;
                        this.disabled && this.element.classList.add("Disabled");
                        this.onClick && this.element.addEventListener("click", this.onClick);
                        this.element.addEventListener("mousedown", (e) => this.addClass(e, "Down"));
                        this.element.addEventListener("mouseup", (e) => this.removeClass(e, "Down"));
                        this.element.addEventListener("mouseover", (e) => this.addClass(e, "Over"));
                        this.element.addEventListener("mouseout", (e) => this.removeClass(e, "Over"));
                        this.element.addEventListener("focus", (e) => this.addClass(e, "Focus"));
                        this.element.addEventListener("unfocus", (e) => this.removeClass(e, "Focus"));
                        return this.element;
                      }
                      addClass(e, className) {
                        e.preventDefault();
                        this.element.classList.add(className);
                      }
                      removeClass(e, className) {
                        this.element.classList.remove(className);
                      }
                      renderElement() {
                        var _a;
                        (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", __spreadValues({}, this.options), this.value]);
                        this.element.classList.add(this.className);
                      }
                      toJSON() {
                      }
                    }
                    var dropdown = __nested_webpack_require_440138__(593);
                    ;
                    var dropdown_options = {};
                    dropdown_options.styleTagTransform = styleTagTransform_default();
                    dropdown_options.setAttributes = setAttributesWithoutAttributes_default();
                    dropdown_options.insert = insertBySelector_default().bind(null, "head");
                    dropdown_options.domAPI = styleDomAPI_default();
                    dropdown_options.insertStyleElement = insertStyleElement_default();
                    var dropdown_update = injectStylesIntoStyleTag_default()(dropdown.A, dropdown_options);
                    const styles_dropdown = dropdown.A && dropdown.A.locals ? dropdown.A.locals : void 0;
                    ;
                    var dropdown_defProp = Object.defineProperty;
                    var dropdown_getOwnPropSymbols = Object.getOwnPropertySymbols;
                    var dropdown_hasOwnProp = Object.prototype.hasOwnProperty;
                    var dropdown_propIsEnum = Object.prototype.propertyIsEnumerable;
                    var dropdown_defNormalProp = (obj, key, value) => key in obj ? dropdown_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
                    var dropdown_spreadValues = (a, b) => {
                      for (var prop in b || (b = {}))
                        if (dropdown_hasOwnProp.call(b, prop))
                          dropdown_defNormalProp(a, prop, b[prop]);
                      if (dropdown_getOwnPropSymbols)
                        for (var prop of dropdown_getOwnPropSymbols(b)) {
                          if (dropdown_propIsEnum.call(b, prop))
                            dropdown_defNormalProp(a, prop, b[prop]);
                        }
                      return a;
                    };
                    var dropdown_objRest = (source, exclude) => {
                      var target = {};
                      for (var prop in source)
                        if (dropdown_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
                          target[prop] = source[prop];
                      if (source != null && dropdown_getOwnPropSymbols)
                        for (var prop of dropdown_getOwnPropSymbols(source)) {
                          if (exclude.indexOf(prop) < 0 && dropdown_propIsEnum.call(source, prop))
                            target[prop] = source[prop];
                        }
                      return target;
                    };
                    dom.importCssString(dropdown_namespaceObject, "dropdown.css");
                    dom.importCssString(menu_namespaceObject, "menu.css");
                    const DEFAULT_WIDTH = 200;
                    class Dropdown {
                      constructor(options2) {
                        this.onMouseDown = (e) => {
                          e.preventDefault();
                          let node = Utils.findNode(e.target, this.className);
                          if (node && node == this.element)
                            return;
                          node = Utils.findNode(e.target, this.popup.element.className);
                          if (node && node == this.popup.element)
                            return;
                          this.closePopup();
                        };
                        this.onMouseWheel = (e) => {
                          this.closePopup();
                        };
                        let _a = options2, { disabled, items, value, className, width } = _a, other = dropdown_objRest(_a, ["disabled", "items", "value", "className", "width"]);
                        this.disabled = disabled != null ? disabled : false;
                        this.items = items;
                        this.value = value != null ? value : items[0].value;
                        this.className = className || "black_dropdown";
                        this.width = width != null ? width : DEFAULT_WIDTH;
                        this.options = other;
                      }
                      render() {
                        this.element = dom.buildDom(["div", dropdown_spreadValues({
                          class: this.className + (this.disabled ? this.className + "Disabled" : ""),
                          style: "width: " + this.width + "px",
                          onmousedown: (e) => {
                            e.preventDefault();
                            this.element.className = this.className + " " + this.className + "Down";
                            this.togglePopup();
                          },
                          onmouseup: (e) => {
                            this.element.className = this.className;
                          },
                          onmouseover: (e) => {
                            this.element.className = this.className + " " + this.className + "Over";
                          },
                          onfocus: (e) => {
                            this.element.className = this.className + " " + this.className + "Focus";
                          },
                          onunfocus: (e) => {
                            this.element.className = this.className;
                          },
                          onmouseout: (e) => {
                            this.element.className = this.className;
                          }
                        }, this.options), [
                          ["div", {
                            class: "lbl",
                            ref: "lbl"
                          }],
                          ["div", {
                            class: "button"
                          }]
                        ]], void 0, this);
                        this.element.$host = this;
                        this.updateLabel();
                        return this.element;
                      }
                      togglePopup() {
                        if (this.isPopupOpen) {
                          this.closePopup();
                        } else {
                          this.openPopup();
                        }
                      }
                      openPopup() {
                        if (this.isPopupOpen)
                          return;
                        this.popup = new Popup();
                        this.popup.items = this.items;
                        this.popup.selectedItem = this.value;
                        this.popup.parent = this;
                        this.popup.selectCallback = (host) => {
                          this.select(host.value);
                          this.closePopup();
                        };
                        this.popup.open();
                        window.addEventListener("mousedown", this.onMouseDown);
                        window.addEventListener("wheel", this.onMouseWheel);
                        this.isPopupOpen = true;
                      }
                      closePopup() {
                        if (!this.isPopupOpen)
                          return;
                        this.popup.close();
                        this.isPopupOpen = false;
                        window.removeEventListener("mousedown", this.onMouseDown);
                        window.removeEventListener("wheel", this.onMouseWheel);
                      }
                      select(value) {
                        this.setValue(value);
                      }
                      setValue(value) {
                        if (this.value !== value) {
                          this.value = value;
                          this.updateLabel();
                        }
                      }
                      updateLabel() {
                        let items = this.items;
                        for (let i = 0; i < items.length; i++) {
                          let x = items[i];
                          let itemValue = x.value;
                          if (this.value === itemValue) {
                            this.lbl.innerHTML = x.caption;
                            return;
                          }
                        }
                      }
                      toJSON() {
                      }
                    }
                    class Popup {
                      open() {
                        this.build();
                        this.render();
                      }
                      build() {
                        if (this.element) {
                          return;
                        }
                        let result = [];
                        if (this.items) {
                          let items = Object.values(this.items).sort(function(item1, item2) {
                            return item1.position - item2.position;
                          });
                          let afterDivider = true;
                          result = items.map((item) => {
                            if (item.caption[0] === "~") {
                              if (afterDivider)
                                return;
                              afterDivider = true;
                              return [
                                "div",
                                {
                                  class: "menu_divider",
                                  $host: item
                                }
                              ];
                            }
                            afterDivider = false;
                            let classList = ["menu_item"];
                            if (item.checked)
                              classList.push(item.type === "check" ? "checked" : "selected");
                            if (item.map)
                              classList.push("submenu");
                            if (item.disabled)
                              classList.push("disabled");
                            if (item.value === this.selectedItem)
                              classList.push("selected");
                            return [
                              "div",
                              {
                                class: classList.join(" "),
                                $host: item
                              },
                              ["u", " "],
                              ["a", item.caption + ""],
                              [
                                "span",
                                {
                                  class: "shortcut"
                                },
                                item.hotKey
                              ]
                            ];
                          }).filter(Boolean);
                          if (afterDivider)
                            result.pop();
                        }
                        this.element = dom.buildDom(
                          [
                            "blockquote",
                            {
                              class: "menu",
                              style: "display:block",
                              $host: this.parent,
                              onmousemove: this.onMouseMove.bind(this),
                              onclick: this.onClick.bind(this)
                            },
                            result
                          ],
                          document.body
                        );
                      }
                      render() {
                        if (this.element.style.maxWidth) {
                          this.element.style.maxWidth = window.innerWidth + "px";
                        }
                        if (this.element.style.maxHeight) {
                          this.element.style.maxHeight = window.innerHeight + "px";
                        }
                        let elRect = this.element.getBoundingClientRect();
                        let edge = Utils.getElementEdges(this.element);
                        let parentRect, top, left;
                        if (this.parent && this.parent.element) {
                          parentRect = this.parent.element.getBoundingClientRect();
                        }
                        if (parentRect) {
                          if (this.isSubMenu) {
                            top = parentRect.top - edge.top;
                            left = parentRect.right;
                          } else {
                            top = parentRect.bottom;
                            left = parentRect.left;
                          }
                        } else {
                          top = this.position.y;
                          left = this.position.x;
                        }
                        let targetH = Math.min(elRect.height, window.innerHeight);
                        let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
                        if (availableH < targetH && (!parentRect || this.isSubMenu)) {
                          let tmpTop = parentRect ? window.innerHeight : top;
                          top = tmpTop - targetH - edge.top;
                          availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
                        }
                        this.element.style.maxHeight = availableH - 10 + "px";
                        elRect = this.element.getBoundingClientRect();
                        let availableW = window.innerWidth - left - edge.left - edge.right - 2;
                        if (availableW < elRect.width) {
                          if (parentRect) {
                            let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
                            if (tmpLeft > availableW) {
                              this.direction = "left";
                              left = tmpLeft - elRect.width + edge.left;
                              left = Math.max(left, 0);
                              availableW = tmpLeft + edge.left + edge.right;
                            }
                            if (availableW < elRect.width) {
                              this.element.style.maxWidth = availableW + "px";
                              this.element.style.overflowX = "auto";
                            }
                          } else {
                            left = window.innerWidth - elRect.width - edge.left - edge.right;
                          }
                        }
                        this.element.style.top = top + "px";
                        this.element.style.left = left + "px";
                        this.element.style.position = "absolute";
                        this.element.style.zIndex = 195055;
                        this.element.style.overflowY = "auto";
                      }
                      close() {
                        if (this.element) {
                          this.element.remove();
                          delete this.element;
                        }
                      }
                      scrollIfNeeded() {
                        if (!this.selectedMenu) {
                          return;
                        }
                        let menu2 = this.element;
                        let item = this.selectedMenu.buttonElement;
                        let menuRect = menu2.getBoundingClientRect();
                        let itemRect = item.getBoundingClientRect();
                        if (itemRect.top < menuRect.top) {
                          item.scrollIntoView(true);
                        } else if (itemRect.bottom > menuRect.bottom) {
                          item.scrollIntoView(false);
                        }
                      }
                      //handle events
                      onMouseMove(e) {
                        if (e.target === this.element) {
                          return;
                        }
                        let target = Utils.findHostTarget(e.target);
                        if (target === this.element) {
                          return;
                        }
                        if (target == this.activeItem) {
                          return;
                        }
                        if (this.activeItem) {
                          this.activeItem.classList.remove("hover");
                        }
                        this.activeItem = target;
                        this.activeItem.classList.add("hover");
                      }
                      onClick(e) {
                        if (e.target === this.element)
                          return;
                        let target = Utils.findHostTarget(e.target);
                        if (target === this.element)
                          return;
                        let host = target.$host;
                        this.selectCallback && this.selectCallback(host);
                      }
                    }
                    ;
                    class SettingsSearchBox {
                      constructor(prefsParentNode) {
                        this.hideFiltered = false;
                        this.value = "";
                        this.currValue = "";
                        this.searchResultsCount = 0;
                        this.prefsParentNode = prefsParentNode;
                      }
                      filter() {
                        let childNode;
                        let noResult = true;
                        this.searchResultsCount = 0;
                        for (let i = 0; i < this.prefsParentNode.childNodes.length; i++) {
                          childNode = this.prefsParentNode.childNodes[i];
                          this.updateVisibility(childNode);
                          if (noResult && !childNode.isFiltered) {
                            noResult = false;
                          }
                        }
                        if (this.currValue != "") {
                          this.searchResults.innerHTML = " " + this.searchResultsCount + " Preferences Found";
                        } else {
                          this.searchResults.innerHTML = "";
                        }
                      }
                      showHide(item, show) {
                        show = show || false;
                        item.isFiltered = !show;
                        item.style.display = show ? "block" : "none";
                      }
                      updateVisibility(item) {
                        let text = item.innerText;
                        let tokens = this.getTokens(text);
                        let show = true;
                        if (!tokens) {
                          show = false;
                        } else {
                          this.searchResultsCount++;
                        }
                        this.showHide(item, show);
                      }
                      getTokens(string) {
                        let tokens = [];
                        let caption = string.toLowerCase();
                        let lower = this.currValue.toLowerCase();
                        let upper = this.currValue.toUpperCase();
                        function addToken(value, className) {
                          value && tokens.push({
                            type: className || "",
                            value
                          });
                        }
                        let lastIndex = -1;
                        let matchMask = 0;
                        let index, distance;
                        let fullMatchIndex = caption.indexOf(lower);
                        if (fullMatchIndex === -1) {
                          for (let j = 0; j < this.currValue.length; j++) {
                            let i1 = caption.indexOf(lower[j], lastIndex + 1);
                            let i2 = caption.indexOf(upper[j], lastIndex + 1);
                            index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                            if (index < 0)
                              return null;
                            distance = index - lastIndex - 1;
                            if (distance > 0) {
                              matchMask = matchMask | 1 << j;
                            }
                            lastIndex = index;
                          }
                        }
                        let filterText = lower;
                        lower = caption.toLowerCase();
                        lastIndex = 0;
                        let lastI = 0;
                        for (let i = 0; i <= filterText.length; i++) {
                          if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
                            let sub = filterText.slice(lastI, i);
                            lastI = i;
                            index = lower.indexOf(sub, lastIndex);
                            if (index === -1)
                              continue;
                            addToken(string.slice(lastIndex, index), "");
                            lastIndex = index + sub.length;
                            addToken(string.slice(index, lastIndex), "completion-highlight");
                          }
                        }
                        addToken(string.slice(lastIndex, string.length), "");
                        return tokens;
                      }
                      build() {
                        this.element = dom.buildDom([
                          "div",
                          {},
                          ["input", { class: "search_field tbsimple", placeholder: "Search preferences" }],
                          ["span", { class: "search_results" }],
                          ["span", { class: "searchbtn_close" }]
                        ]);
                        this.element.$host = this;
                        this.searchField = this.element.querySelector(".search_field");
                        this.searchResults = this.element.querySelector(".search_results");
                        let _this = this;
                        this.element.querySelector(".searchbtn_close").addEventListener("mousedown", function(e) {
                          _this.clear();
                        });
                        this.searchField.addEventListener("input", function(e) {
                          _this.currValue = e.target.value;
                          _this.filter();
                        });
                      }
                      clear() {
                        if (this.currValue.length) {
                          this.searchField.value = "";
                          this.currValue = "";
                          this.filter();
                        }
                      }
                    }
                    var switcher = __nested_webpack_require_440138__(915);
                    ;
                    var switcher_options = {};
                    switcher_options.styleTagTransform = styleTagTransform_default();
                    switcher_options.setAttributes = setAttributesWithoutAttributes_default();
                    switcher_options.insert = insertBySelector_default().bind(null, "head");
                    switcher_options.domAPI = styleDomAPI_default();
                    switcher_options.insertStyleElement = insertStyleElement_default();
                    var switcher_update = injectStylesIntoStyleTag_default()(switcher.A, switcher_options);
                    const styles_switcher = switcher.A && switcher.A.locals ? switcher.A.locals : void 0;
                    ;
                    var switcher_defProp = Object.defineProperty;
                    var switcher_getOwnPropSymbols = Object.getOwnPropertySymbols;
                    var switcher_hasOwnProp = Object.prototype.hasOwnProperty;
                    var switcher_propIsEnum = Object.prototype.propertyIsEnumerable;
                    var switcher_defNormalProp = (obj, key, value) => key in obj ? switcher_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
                    var switcher_spreadValues = (a, b) => {
                      for (var prop in b || (b = {}))
                        if (switcher_hasOwnProp.call(b, prop))
                          switcher_defNormalProp(a, prop, b[prop]);
                      if (switcher_getOwnPropSymbols)
                        for (var prop of switcher_getOwnPropSymbols(b)) {
                          if (switcher_propIsEnum.call(b, prop))
                            switcher_defNormalProp(a, prop, b[prop]);
                        }
                      return a;
                    };
                    var switcher_objRest = (source, exclude) => {
                      var target = {};
                      for (var prop in source)
                        if (switcher_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
                          target[prop] = source[prop];
                      if (source != null && switcher_getOwnPropSymbols)
                        for (var prop of switcher_getOwnPropSymbols(source)) {
                          if (exclude.indexOf(prop) < 0 && switcher_propIsEnum.call(source, prop))
                            target[prop] = source[prop];
                        }
                      return target;
                    };
                    dom.importCssString(switcher_namespaceObject, "switcher.css");
                    class Switcher {
                      constructor(options2) {
                        let _a = options2, { className, checked } = _a, other = switcher_objRest(_a, ["className", "checked"]);
                        this.className = className || "cboffline";
                        this.options = other;
                        this.checked = checked || false;
                      }
                      render() {
                        this.element = dom.buildDom(["div", switcher_spreadValues({
                          class: this.className + (this.checked ? " " + this.className + "Checked" : ""),
                          onmousedown: (e) => {
                            e.preventDefault();
                            this.checked = !this.checked;
                            e.target.className = this.className + (this.checked ? " " + this.className + "Down" : "");
                          },
                          onclick: (e) => {
                            e.preventDefault();
                            e.target.className = this.className + (this.checked ? " " + this.className + "Checked" : "");
                          }
                        }, this.options), ""]);
                        this.element.$host = this;
                        return this.element;
                      }
                      toJSON() {
                        return {};
                      }
                      remove() {
                      }
                    }
                    ;
                    class MenuToolbar extends Toolbar {
                      render() {
                        if (!this.element) {
                          this.element = dom.buildDom(["div", {
                            class: "menuToolBar"
                          }, [
                            "div",
                            {
                              class: "menuBar",
                              ref: "menuBar"
                            }
                          ]], void 0, this);
                          let menuManager = MenuManager.getInstance();
                          menuManager.build();
                          menuManager.buildMenuBar(this.menuBar);
                          menuManager.bindKeys();
                        }
                        return this.element;
                      }
                      remove() {
                      }
                      toJSON() {
                      }
                    }
                    ;
                    class PanelBar extends TabPanelBar {
                      setBox(x, y, w, h) {
                        super.setBox(x, y, w, h);
                        this.configure();
                      }
                      configure() {
                        let tabElement;
                        let tabSize = 30;
                        let position = 0;
                        for (let i = 0; i < this.tabList.length; i++) {
                          tabElement = this.tabList[i].element;
                          if (this.draggingElementIndex === i)
                            position += this.getDraggingElementSize();
                          if (this.isVertical()) {
                            tabElement.style.left = "0px";
                            tabElement.style.height = tabSize + "px";
                            tabElement.style.top = position + "px";
                          } else {
                            tabElement.style.top = "0px";
                            tabElement.style.width = tabSize + "px";
                            tabElement.style.left = position + "px";
                          }
                          position += tabSize;
                        }
                      }
                      render() {
                        if (!this.element) {
                          this.element = dom.buildDom(["div", {
                            class: "panelbar " + this.direction + " " + this.position
                          }, ["div", {
                            class: "tabContainer",
                            ref: "tabContainer",
                            onmousedown: function(e) {
                              TabbarHandler.tabbarMouseDown(e, Panel, PanelBar);
                            },
                            onmouseup: (e) => {
                              if (this.activeTabClicked) {
                                let activeTab = this.activeTab;
                                this.removeSelection(activeTab);
                                activeTab.deactivate();
                                this.activeTab = void 0;
                                if (this.activeTabHistory.length && activeTab.autoHide) {
                                  let previousTab = activeTab;
                                  while (previousTab === activeTab && this.activeTabHistory.length) {
                                    previousTab = this.activeTabHistory.pop();
                                  }
                                  if (previousTab !== activeTab)
                                    this.activateTab(previousTab);
                                }
                              }
                            }
                          }]], void 0, this);
                        }
                        if (this.initTabList && this.initTabList.length) {
                          for (let i = 0; i < this.initTabList.length; i++) {
                            this.addTab(this.initTabList[i]);
                          }
                        }
                        this.element.$host = this;
                        return this.element;
                      }
                      addTabList(tabList, index) {
                        index = index || this.tabList.length;
                        let tab2;
                        for (let i = 0; i < tabList.length; i++) {
                          tab2 = new Panel(tabList[i]);
                          this.addTab(tab2, index++);
                        }
                      }
                      remove() {
                      }
                    }
                    ;
                    class PanelManager {
                      constructor(options2) {
                        this.layout = options2.layout;
                        this.locations = options2.locations;
                      }
                      static getInstance(options2) {
                        if (!PanelManager._instance)
                          PanelManager._instance = new PanelManager(options2);
                        return PanelManager._instance;
                      }
                      toJSON() {
                        return {
                          panelBars: this.panelBarsToJSON()
                        };
                      }
                      panelBarsToJSON() {
                        let panelBars = {};
                        for (let [position, panelBar] of Object.entries(this.layout.toolBars)) {
                          if (panelBar instanceof PanelBar)
                            panelBars[position] = panelBar.toJSON();
                        }
                        return panelBars;
                      }
                      setState(state) {
                        var _a;
                        let panelBars = (_a = state.panelBars) != null ? _a : {};
                        let panelBar, panelList, panel2;
                        let panelBody, panelBodyData;
                        for (let position of Object.keys(panelBars)) {
                          panelList = [];
                          let tabList = panelBars[position].tabList;
                          for (let i = 0; i < tabList.length; i++) {
                            panel2 = tabList[i];
                            panelBodyData = panel2.panelBody;
                            if (panelBodyData.type === "accordion") {
                              let accordionSections = [];
                              let sections = panelBodyData.sections;
                              for (let index = 0; index < sections.length; index++) {
                                accordionSections.push({
                                  title: sections[index].title,
                                  box: new Box(sections[index].boxData)
                                });
                              }
                              panelBody = new Accordion({
                                vertical: panelBodyData.vertical,
                                size: panelBodyData.size,
                                sections: accordionSections
                              });
                            } else {
                              panelBody = new Box({
                                vertical: panelBodyData.type === "vbox",
                                color: panelBodyData.color,
                                size: panelBodyData.size,
                                hidden: panelBodyData.hidden,
                                fixedSize: panelBodyData.fixedSize
                              });
                            }
                            panelList.push({
                              active: panel2.active,
                              title: panel2.title,
                              autoHide: panel2.autoHide,
                              panelBody
                            });
                          }
                          panelBar = new PanelBar({ panelList: {} });
                          this.layout.addToolBar(position, panelBar);
                          panelBar.addTabList(panelList);
                        }
                      }
                      activatePanel(panel2) {
                        let location = this.locations[panel2.parent.position];
                        if (!location)
                          return;
                        let index = location.index;
                        let parent = location.parent;
                        panel2.panelBody.size = location.size;
                        let newBox = parent.addChildBox(index, panel2.panelBody);
                        if (newBox.fixedSize && !parent.fixedChild)
                          parent.fixedChild = newBox;
                        location.box = newBox;
                        newBox.show();
                      }
                      deactivatePanel(panel2) {
                        let location = this.locations[panel2.parent.position];
                        location == null ? void 0 : location.box.hide();
                      }
                    }
                    var panel = __nested_webpack_require_440138__(174);
                    ;
                    var panel_options = {};
                    panel_options.styleTagTransform = styleTagTransform_default();
                    panel_options.setAttributes = setAttributesWithoutAttributes_default();
                    panel_options.insert = insertBySelector_default().bind(null, "head");
                    panel_options.domAPI = styleDomAPI_default();
                    panel_options.insertStyleElement = insertStyleElement_default();
                    var panel_update = injectStylesIntoStyleTag_default()(panel.A, panel_options);
                    const styles_panel = panel.A && panel.A.locals ? panel.A.locals : void 0;
                    ;
                    dom.importCssString(panel_namespaceObject, "panel.css");
                    class Panel extends TabPanel {
                      constructor(options2) {
                        var _a;
                        super(options2);
                        this.location = options2.location;
                        this.panelBody = options2.panelBody;
                        this.autoHide = (_a = options2.autoHide) != null ? _a : false;
                        this.title = options2.title;
                      }
                      activate() {
                        super.activate();
                        PanelManager.getInstance().activatePanel(this);
                      }
                      deactivate() {
                        super.deactivate();
                        PanelManager.getInstance().deactivatePanel(this);
                      }
                      render() {
                        this.element = dom.buildDom(["div", {
                          class: "panelButton" + (this.active ? " active" : "")
                        }, ["span", {
                          class: "panelTitle"
                        }, this.title]]);
                        this.element.$host = this;
                        return this.element;
                      }
                      toJSON() {
                        return {
                          active: this.active,
                          title: this.title,
                          autoHide: this.autoHide,
                          panelBody: this.panelBody.toJSON()
                        };
                      }
                      remove() {
                      }
                    }
                    var layout = __nested_webpack_require_440138__(0);
                    ;
                    var layout_options = {};
                    layout_options.styleTagTransform = styleTagTransform_default();
                    layout_options.setAttributes = setAttributesWithoutAttributes_default();
                    layout_options.insert = insertBySelector_default().bind(null, "head");
                    layout_options.domAPI = styleDomAPI_default();
                    layout_options.insertStyleElement = insertStyleElement_default();
                    var layout_update = injectStylesIntoStyleTag_default()(layout.A, layout_options);
                    const styles_layout = layout.A && layout.A.locals ? layout.A.locals : void 0;
                    ;
                    class AceLayout {
                      constructor(startBox, css) {
                        dom.importCssString(css != null ? css : layout_namespaceObject, "layout.css");
                        this.box = startBox;
                      }
                    }
                    var ace_tree_lib = __nested_webpack_require_440138__(532);
                    ;
                    const getIconUrl = (path, isDir) => {
                      return `https://raw.githubusercontent.com/vscode-icons/vscode-icons/master/icons/${getIconName(
                        path,
                        isDir
                      )}.svg`;
                    };
                    function getIconName(path, isDir) {
                      if (!path)
                        return "default_file";
                      if (isDir)
                        return "default_folder";
                      const filename = path.substring(path.lastIndexOf("/") + 1);
                      const ext = filename.split(".").pop() || "";
                      return getIconNameFromExtension(ext) || getIconNameFromFileName(filename) || "default_file";
                    }
                    function getIconNameFromExtension(ext) {
                      switch (ext.toLowerCase()) {
                        case "js":
                          return "file_type_js";
                        case "ts":
                          return "file_type_typescript";
                        case "html":
                          return "file_type_html";
                        case "css":
                          return "file_type_css";
                        case "less":
                          return "file_type_less";
                        case "sass":
                          return "file_type_sass";
                        case "scss":
                          return "file_type_scss";
                        case "json":
                          return "file_type_json";
                        case "py":
                          return "file_type_python";
                        case "rb":
                          return "file_type_ruby";
                        case "go":
                          return "file_type_go";
                        case "rust":
                          return "file_type_rust";
                        case "java":
                          return "file_type_java";
                        case "scala":
                          return "file_type_scala";
                        case "swift":
                          return "file_type_swift";
                        case "sh":
                          return "file_type_shell";
                        case "makefile":
                          return "file_type_shell";
                        case "bat":
                          return "file_type_shell";
                        case "bash":
                          return "file_type_shell";
                        case "cs":
                          return "file_type_csharp";
                        case "yml":
                          return "file_type_yaml";
                        case "yaml":
                          return "file_type_yaml";
                        case "xml":
                          return "file_type_xml";
                        case "md":
                          return "file_type_markdown";
                        case "sql":
                          return "file_type_sql";
                        case "jpg":
                          return "file_type_image";
                        case "svg":
                          return "file_type_image";
                        case "jpeg":
                          return "file_type_image";
                        case "png":
                          return "file_type_image";
                        case "gif":
                          return "file_type_image";
                        case "bmp":
                          return "file_type_image";
                        default:
                          return null;
                      }
                    }
                    function getIconNameFromFileName(filename) {
                      switch (filename.toLowerCase()) {
                        case "dockerfile":
                          return "file_type_docker";
                        case ".gitignore":
                          return "file_type_git2";
                        case ".gitattributes":
                          return "file_type_git2";
                        default:
                          return null;
                      }
                    }
                    var ace_tree = __nested_webpack_require_440138__(216);
                    ;
                    var ace_tree_options = {};
                    ace_tree_options.styleTagTransform = styleTagTransform_default();
                    ace_tree_options.setAttributes = setAttributesWithoutAttributes_default();
                    ace_tree_options.insert = insertBySelector_default().bind(null, "head");
                    ace_tree_options.domAPI = styleDomAPI_default();
                    ace_tree_options.insertStyleElement = insertStyleElement_default();
                    var ace_tree_update = injectStylesIntoStyleTag_default()(ace_tree.A, ace_tree_options);
                    const styles_ace_tree = ace_tree.A && ace_tree.A.locals ? ace_tree.A.locals : void 0;
                    ;
                    const ace_tree_oop = __nested_webpack_require_440138__(387);
                    dom.importCssString(ace_tree_namespaceObject, "ace-tree.css");
                    function transform(node) {
                      const path = node["path"] || "";
                      const name = path.slice(path.lastIndexOf("/") + 1);
                      let children = node["nodes"] || node["children"];
                      if (children)
                        children = children.map(transform);
                      return {
                        fsNode: node,
                        name,
                        children
                      };
                    }
                    class AceTreeWrapper {
                      render() {
                        var _a;
                        if (this.tree) {
                          return this.element;
                        }
                        (_a = this.element) != null ? _a : this.element = dom.buildDom(["div"]);
                        this.element.className = "ace-tree-wrapper";
                        this.tree = new ace_tree_lib.Tree(this.element);
                        this.model = new ace_tree_lib.DataProvider({});
                        this.setupAceTree();
                        return this.element;
                      }
                      remove() {
                        this.element.remove();
                      }
                      toJSON() {
                        return {};
                      }
                      setupAceTree() {
                        this.tree.setDataProvider(this.model);
                        this.provideIcons();
                        if (typeof window !== "undefined") {
                          window["fileTree"] = this.tree;
                        }
                      }
                      updateTreeData(fileTree) {
                        const model = this.model;
                        const tree = this.tree;
                        if (!model.root || model.root.fsNode != fileTree) {
                          const treeNodes = transform(fileTree);
                          if (treeNodes.children.length == 1) {
                            treeNodes.children[0].isOpen = true;
                          }
                          model.setRoot(treeNodes);
                          tree.on("afterChoose", () => {
                            var _a;
                            const fsNode = (_a = tree.selection.getCursor()) == null ? void 0 : _a.fsNode;
                            if (fsNode && fsNode.kind != "directory") {
                              const event = new CustomEvent("item-click", {
                                detail: fsNode
                              });
                              this.element.dispatchEvent(event);
                            }
                          });
                        }
                        this.tree.resize();
                      }
                      provideIcons() {
                        this.model.getIconHTML = function(node) {
                          const treeNode = node.fsNode;
                          const isDir = treeNode.kind === "directory";
                          const size = 16;
                          return `<span class="file-icon">
<svg width="${size}" height="${size}">
     <image xlink:href="${getIconUrl(
                            treeNode.path,
                            isDir
                          )}" width="${size}" height="${size}"/>
</svg>
</span>`;
                        };
                      }
                    }
                    ace_tree_oop.implement(AceTreeWrapper.prototype, event_emitter_.EventEmitter);
                    ;
                    var __knownSymbol = (name, symbol) => {
                      return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
                    };
                    var __async = (__this, __arguments, generator) => {
                      return new Promise((resolve, reject) => {
                        var fulfilled = (value) => {
                          try {
                            step(generator.next(value));
                          } catch (e) {
                            reject(e);
                          }
                        };
                        var rejected = (value) => {
                          try {
                            step(generator.throw(value));
                          } catch (e) {
                            reject(e);
                          }
                        };
                        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
                        step((generator = generator.apply(__this, __arguments)).next());
                      });
                    };
                    var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
                    const MAX_SIZE = 8e6;
                    class FileSystemEntry {
                      constructor(fileSystemHandle, filePath = "") {
                        this.fileSystemHandle = fileSystemHandle;
                        this.filePath = filePath;
                      }
                      get path() {
                        return [this.filePath, this.name].join("/");
                      }
                      get name() {
                        return this.fileSystemHandle.name;
                      }
                      get leaf() {
                        const { name, kind, path } = this;
                        const leaf = { name, kind, path, self: this };
                        if (kind == "directory")
                          leaf["children"] = [];
                        return leaf;
                      }
                    }
                    class File extends FileSystemEntry {
                      constructor(fileSystemHandle, filePath = "") {
                        super(fileSystemHandle, filePath);
                        this.fileSystemHandle = fileSystemHandle;
                        this.filePath = filePath;
                        this.kind = "file";
                      }
                      getFileData() {
                        return __async(this, null, function* () {
                          return yield this.fileSystemHandle.getFile();
                        });
                      }
                      getFileText() {
                        return __async(this, null, function* () {
                          const fileData = yield this.getFileData();
                          if (fileData.size > MAX_SIZE)
                            throw new Error(
                              `File size to large: ${fileData.size}, max ${MAX_SIZE} supported`
                            );
                          return yield fileData.text();
                        });
                      }
                    }
                    class Directory extends FileSystemEntry {
                      constructor(fileSystemHandle, filePath = "") {
                        super(fileSystemHandle, filePath);
                        this.fileSystemHandle = fileSystemHandle;
                        this.filePath = filePath;
                        this.childNodes = [];
                        this.kind = "directory";
                      }
                      static openFilehandle(fileHandle) {
                        return __async(this, null, function* () {
                          if (!fileHandle)
                            throw new Error("FileHandle undefined");
                          return new Directory(fileHandle);
                        });
                      }
                      getFileTee() {
                        return __async(this, null, function* () {
                          const root = this.leaf;
                          const entries = [root];
                          while (entries.length) {
                            const entry = entries.pop();
                            const dir = entry.self;
                            for (const childNode of yield dir.children()) {
                              const child = childNode.leaf;
                              if (child.kind == "directory") {
                                entries.push(child);
                              }
                              entry.children.push(child);
                            }
                            delete entry.self;
                          }
                          return root;
                        });
                      }
                      getFileByPath(pathname) {
                        return __async(this, null, function* () {
                          const entries = yield this.children();
                          while (entries.length) {
                            const entry = entries.pop();
                            if (entry.path == pathname)
                              return entry;
                            if (entry.kind == "directory")
                              entries.push(...yield entry.children());
                          }
                          throw new Error(`File not found in tree: ${pathname}`);
                        });
                      }
                      getDirectoryHandle(name) {
                        return __async(this, null, function* () {
                          return this.fileSystemHandle.getDirectoryHandle(name);
                        });
                      }
                      children() {
                        return __async(this, null, function* () {
                          if (!this.childNodes.length) {
                            try {
                              for (var iter = __forAwait(this.fileSystemHandle.values()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                                const child = temp.value;
                                let childNode;
                                if (child.kind == "directory") {
                                  const fileHandle = yield this.getDirectoryHandle(
                                    child.name
                                  );
                                  childNode = new Directory(fileHandle, this.path);
                                } else {
                                  const fileHandle = yield this.fileSystemHandle.getFileHandle(child.name);
                                  childNode = new File(fileHandle, this.path);
                                }
                                this.childNodes.push(childNode);
                              }
                            } catch (temp2) {
                              error = [temp2];
                            } finally {
                              try {
                                more && (temp = iter.return) && (yield temp.call(iter));
                              } finally {
                                if (error)
                                  throw error[0];
                              }
                            }
                          }
                          return [...this.childNodes];
                        });
                      }
                    }
                    ;
                    var file_system_web_async = (__this, __arguments, generator) => {
                      return new Promise((resolve, reject) => {
                        var fulfilled = (value) => {
                          try {
                            step(generator.next(value));
                          } catch (e) {
                            reject(e);
                          }
                        };
                        var rejected = (value) => {
                          try {
                            step(generator.throw(value));
                          } catch (e) {
                            reject(e);
                          }
                        };
                        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
                        step((generator = generator.apply(__this, __arguments)).next());
                      });
                    };
                    class FileSystemWeb extends events.EventEmitter {
                      get dir() {
                        if (!this.directory)
                          throw new Error("Accessing directory before created");
                        return this.directory;
                      }
                      open() {
                        return file_system_web_async(this, null, function* () {
                          const handle = yield window.showDirectoryPicker().catch((err) => console.error("showDirectoryPicker:", err.message));
                          if (handle) {
                            const { err, dir } = yield Directory.openFilehandle(handle).then((dir2) => ({ dir: dir2, err: null })).catch((err2) => ({ err: err2, dir: null }));
                            this.directory = dir;
                            return this.getFileTree();
                          }
                        });
                      }
                      getFileTree() {
                        return file_system_web_async(this, null, function* () {
                          if (this.directory) {
                            const nodes = [yield this.dir.getFileTee()];
                            return { nodes };
                          }
                        });
                      }
                      openFile(treeNode) {
                        return file_system_web_async(this, null, function* () {
                          const file = yield this.dir.getFileByPath(treeNode.path);
                          const fileText = yield file.getFileText();
                          this.emit("openFile", treeNode, fileText);
                        });
                      }
                    }
                    ;
                  })();
                  return __nested_webpack_exports__;
                })()
              );
            });
          }
        ),
        /***/
        974: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var __webpack_unused_export__;
            /**
             * @license React
             * react-dom-client.production.js
             *
             * Copyright (c) Meta Platforms, Inc. and affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var Scheduler = __webpack_require__2(967), React = __webpack_require__2(41), ReactDOM = __webpack_require__2(144);
            function formatProdErrorMessage(code) {
              var url = "https://react.dev/errors/" + code;
              if (1 < arguments.length) {
                url += "?args[]=" + encodeURIComponent(arguments[1]);
                for (var i = 2; i < arguments.length; i++)
                  url += "&args[]=" + encodeURIComponent(arguments[i]);
              }
              return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
            }
            function isValidContainer(node) {
              return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
            }
            var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
            Symbol.for("react.scope");
            Symbol.for("react.debug_trace_mode");
            var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
            Symbol.for("react.legacy_hidden");
            Symbol.for("react.tracing_marker");
            var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
            function getIteratorFn(maybeIterable) {
              if (null === maybeIterable || "object" !== typeof maybeIterable)
                return null;
              maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
              return "function" === typeof maybeIterable ? maybeIterable : null;
            }
            var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
            function getComponentNameFromType(type) {
              if (null == type)
                return null;
              if ("function" === typeof type)
                return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
              if ("string" === typeof type)
                return type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return "Fragment";
                case REACT_PORTAL_TYPE:
                  return "Portal";
                case REACT_PROFILER_TYPE:
                  return "Profiler";
                case REACT_STRICT_MODE_TYPE:
                  return "StrictMode";
                case REACT_SUSPENSE_TYPE:
                  return "Suspense";
                case REACT_SUSPENSE_LIST_TYPE:
                  return "SuspenseList";
              }
              if ("object" === typeof type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    return (type.displayName || "Context") + ".Provider";
                  case REACT_CONSUMER_TYPE:
                    return (type._context.displayName || "Context") + ".Consumer";
                  case REACT_FORWARD_REF_TYPE:
                    var innerType = type.render;
                    type = type.displayName;
                    type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                    return type;
                  case REACT_MEMO_TYPE:
                    return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
                  case REACT_LAZY_TYPE:
                    innerType = type._payload;
                    type = type._init;
                    try {
                      return getComponentNameFromType(type(innerType));
                    } catch (x) {
                    }
                }
              return null;
            }
            var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, assign = Object.assign, prefix, suffix;
            function describeBuiltInComponentFrame(name) {
              if (void 0 === prefix)
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                  suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
                }
              return "\n" + prefix + name + suffix;
            }
            var reentry = false;
            function describeNativeComponentFrame(fn, construct) {
              if (!fn || reentry)
                return "";
              reentry = true;
              var previousPrepareStackTrace = Error.prepareStackTrace;
              Error.prepareStackTrace = void 0;
              try {
                var RunInRootFrame = {
                  DetermineComponentFrameRoot: function() {
                    try {
                      if (construct) {
                        var Fake = function() {
                          throw Error();
                        };
                        Object.defineProperty(Fake.prototype, "props", {
                          set: function() {
                            throw Error();
                          }
                        });
                        if ("object" === typeof Reflect && Reflect.construct) {
                          try {
                            Reflect.construct(Fake, []);
                          } catch (x) {
                            var control = x;
                          }
                          Reflect.construct(fn, [], Fake);
                        } else {
                          try {
                            Fake.call();
                          } catch (x$0) {
                            control = x$0;
                          }
                          fn.call(Fake.prototype);
                        }
                      } else {
                        try {
                          throw Error();
                        } catch (x$1) {
                          control = x$1;
                        }
                        (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                        });
                      }
                    } catch (sample) {
                      if (sample && control && "string" === typeof sample.stack)
                        return [sample.stack, control.stack];
                    }
                    return [null, null];
                  }
                };
                RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var namePropDescriptor = Object.getOwnPropertyDescriptor(
                  RunInRootFrame.DetermineComponentFrameRoot,
                  "name"
                );
                namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
                  RunInRootFrame.DetermineComponentFrameRoot,
                  "name",
                  { value: "DetermineComponentFrameRoot" }
                );
                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
                if (sampleStack && controlStack) {
                  var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                  for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
                    RunInRootFrame++;
                  for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
                    "DetermineComponentFrameRoot"
                  ); )
                    namePropDescriptor++;
                  if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
                    for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                      namePropDescriptor--;
                  for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
                    if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                        do
                          if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                            var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                            fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                            return frame;
                          }
                        while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                      }
                      break;
                    }
                }
              } finally {
                reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
              }
              return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
            }
            function describeFiber(fiber) {
              switch (fiber.tag) {
                case 26:
                case 27:
                case 5:
                  return describeBuiltInComponentFrame(fiber.type);
                case 16:
                  return describeBuiltInComponentFrame("Lazy");
                case 13:
                  return describeBuiltInComponentFrame("Suspense");
                case 19:
                  return describeBuiltInComponentFrame("SuspenseList");
                case 0:
                case 15:
                  return fiber = describeNativeComponentFrame(fiber.type, false), fiber;
                case 11:
                  return fiber = describeNativeComponentFrame(fiber.type.render, false), fiber;
                case 1:
                  return fiber = describeNativeComponentFrame(fiber.type, true), fiber;
                default:
                  return "";
              }
            }
            function getStackByFiberInDevAndProd(workInProgress2) {
              try {
                var info = "";
                do
                  info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
                while (workInProgress2);
                return info;
              } catch (x) {
                return "\nError generating stack: " + x.message + "\n" + x.stack;
              }
            }
            function getNearestMountedFiber(fiber) {
              var node = fiber, nearestMounted = fiber;
              if (fiber.alternate)
                for (; node.return; )
                  node = node.return;
              else {
                fiber = node;
                do
                  node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
                while (fiber);
              }
              return 3 === node.tag ? nearestMounted : null;
            }
            function getSuspenseInstanceFromFiber(fiber) {
              if (13 === fiber.tag) {
                var suspenseState = fiber.memoizedState;
                null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
                if (null !== suspenseState)
                  return suspenseState.dehydrated;
              }
              return null;
            }
            function assertIsMounted(fiber) {
              if (getNearestMountedFiber(fiber) !== fiber)
                throw Error(formatProdErrorMessage(188));
            }
            function findCurrentFiberUsingSlowPath(fiber) {
              var alternate = fiber.alternate;
              if (!alternate) {
                alternate = getNearestMountedFiber(fiber);
                if (null === alternate)
                  throw Error(formatProdErrorMessage(188));
                return alternate !== fiber ? null : fiber;
              }
              for (var a = fiber, b = alternate; ; ) {
                var parentA = a.return;
                if (null === parentA)
                  break;
                var parentB = parentA.alternate;
                if (null === parentB) {
                  b = parentA.return;
                  if (null !== b) {
                    a = b;
                    continue;
                  }
                  break;
                }
                if (parentA.child === parentB.child) {
                  for (parentB = parentA.child; parentB; ) {
                    if (parentB === a)
                      return assertIsMounted(parentA), fiber;
                    if (parentB === b)
                      return assertIsMounted(parentA), alternate;
                    parentB = parentB.sibling;
                  }
                  throw Error(formatProdErrorMessage(188));
                }
                if (a.return !== b.return)
                  a = parentA, b = parentB;
                else {
                  for (var didFindChild = false, child$2 = parentA.child; child$2; ) {
                    if (child$2 === a) {
                      didFindChild = true;
                      a = parentA;
                      b = parentB;
                      break;
                    }
                    if (child$2 === b) {
                      didFindChild = true;
                      b = parentA;
                      a = parentB;
                      break;
                    }
                    child$2 = child$2.sibling;
                  }
                  if (!didFindChild) {
                    for (child$2 = parentB.child; child$2; ) {
                      if (child$2 === a) {
                        didFindChild = true;
                        a = parentB;
                        b = parentA;
                        break;
                      }
                      if (child$2 === b) {
                        didFindChild = true;
                        b = parentB;
                        a = parentA;
                        break;
                      }
                      child$2 = child$2.sibling;
                    }
                    if (!didFindChild)
                      throw Error(formatProdErrorMessage(189));
                  }
                }
                if (a.alternate !== b)
                  throw Error(formatProdErrorMessage(190));
              }
              if (3 !== a.tag)
                throw Error(formatProdErrorMessage(188));
              return a.stateNode.current === a ? fiber : alternate;
            }
            function findCurrentHostFiberImpl(node) {
              var tag = node.tag;
              if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
                return node;
              for (node = node.child; null !== node; ) {
                tag = findCurrentHostFiberImpl(node);
                if (null !== tag)
                  return tag;
                node = node.sibling;
              }
              return null;
            }
            var isArrayImpl = Array.isArray, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
              pending: false,
              data: null,
              method: null,
              action: null
            }, valueStack = [], index = -1;
            function createCursor(defaultValue) {
              return { current: defaultValue };
            }
            function pop(cursor) {
              0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
            }
            function push(cursor, value) {
              index++;
              valueStack[index] = cursor.current;
              cursor.current = value;
            }
            var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
            function pushHostContainer(fiber, nextRootInstance) {
              push(rootInstanceStackCursor, nextRootInstance);
              push(contextFiberStackCursor, fiber);
              push(contextStackCursor, null);
              fiber = nextRootInstance.nodeType;
              switch (fiber) {
                case 9:
                case 11:
                  nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : 0 : 0;
                  break;
                default:
                  if (fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance, nextRootInstance = fiber.tagName, fiber = fiber.namespaceURI)
                    fiber = getOwnHostContext(fiber), nextRootInstance = getChildHostContextProd(fiber, nextRootInstance);
                  else
                    switch (nextRootInstance) {
                      case "svg":
                        nextRootInstance = 1;
                        break;
                      case "math":
                        nextRootInstance = 2;
                        break;
                      default:
                        nextRootInstance = 0;
                    }
              }
              pop(contextStackCursor);
              push(contextStackCursor, nextRootInstance);
            }
            function popHostContainer() {
              pop(contextStackCursor);
              pop(contextFiberStackCursor);
              pop(rootInstanceStackCursor);
            }
            function pushHostContext(fiber) {
              null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
              var context = contextStackCursor.current;
              var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
              context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
            }
            function popHostContext(fiber) {
              contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
              hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
            }
            var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
            function onCommitRoot(root2) {
              if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
                try {
                  injectedHook.onCommitFiberRoot(
                    rendererID,
                    root2,
                    void 0,
                    128 === (root2.current.flags & 128)
                  );
                } catch (err) {
                }
            }
            function setIsStrictModeForDevtools(newIsStrictMode) {
              "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
              if (injectedHook && "function" === typeof injectedHook.setStrictMode)
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                }
            }
            var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
            function clz32Fallback(x) {
              x >>>= 0;
              return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
            }
            var nextTransitionLane = 128, nextRetryLane = 4194304;
            function getHighestPriorityLanes(lanes) {
              var pendingSyncLanes = lanes & 42;
              if (0 !== pendingSyncLanes)
                return pendingSyncLanes;
              switch (lanes & -lanes) {
                case 1:
                  return 1;
                case 2:
                  return 2;
                case 4:
                  return 4;
                case 8:
                  return 8;
                case 16:
                  return 16;
                case 32:
                  return 32;
                case 64:
                  return 64;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                  return lanes & 4194176;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  return lanes & 62914560;
                case 67108864:
                  return 67108864;
                case 134217728:
                  return 134217728;
                case 268435456:
                  return 268435456;
                case 536870912:
                  return 536870912;
                case 1073741824:
                  return 0;
                default:
                  return lanes;
              }
            }
            function getNextLanes(root2, wipLanes) {
              var pendingLanes = root2.pendingLanes;
              if (0 === pendingLanes)
                return 0;
              var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, warmLanes = root2.warmLanes;
              root2 = 0 !== root2.finishedLanes;
              var nonIdlePendingLanes = pendingLanes & 134217727;
              0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
              return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
            }
            function checkIfRootIsPrerendering(root2, renderLanes2) {
              return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
            }
            function computeExpirationTime(lane, currentTime) {
              switch (lane) {
                case 1:
                case 2:
                case 4:
                case 8:
                  return currentTime + 250;
                case 16:
                case 32:
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                  return currentTime + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                  return -1;
                default:
                  return -1;
              }
            }
            function claimNextTransitionLane() {
              var lane = nextTransitionLane;
              nextTransitionLane <<= 1;
              0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
              return lane;
            }
            function claimNextRetryLane() {
              var lane = nextRetryLane;
              nextRetryLane <<= 1;
              0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
              return lane;
            }
            function createLaneMap(initial) {
              for (var laneMap = [], i = 0; 31 > i; i++)
                laneMap.push(initial);
              return laneMap;
            }
            function markRootUpdated$1(root2, updateLane) {
              root2.pendingLanes |= updateLane;
              268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
            }
            function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
              var previouslyPendingLanes = root2.pendingLanes;
              root2.pendingLanes = remainingLanes;
              root2.suspendedLanes = 0;
              root2.pingedLanes = 0;
              root2.warmLanes = 0;
              root2.expiredLanes &= remainingLanes;
              root2.entangledLanes &= remainingLanes;
              root2.errorRecoveryDisabledLanes &= remainingLanes;
              root2.shellSuspendCounter = 0;
              var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
              for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
                var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
                entanglements[index$7] = 0;
                expirationTimes[index$7] = -1;
                var hiddenUpdatesForLane = hiddenUpdates[index$7];
                if (null !== hiddenUpdatesForLane)
                  for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
                    var update = hiddenUpdatesForLane[index$7];
                    null !== update && (update.lane &= -536870913);
                  }
                remainingLanes &= ~lane;
              }
              0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
              0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
            }
            function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
              root2.pendingLanes |= spawnedLane;
              root2.suspendedLanes &= ~spawnedLane;
              var spawnedLaneIndex = 31 - clz32(spawnedLane);
              root2.entangledLanes |= spawnedLane;
              root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
            }
            function markRootEntangled(root2, entangledLanes) {
              var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
              for (root2 = root2.entanglements; rootEntangledLanes; ) {
                var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
                lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
                rootEntangledLanes &= ~lane;
              }
            }
            function lanesToEventPriority(lanes) {
              lanes &= -lanes;
              return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
            }
            function resolveUpdatePriority() {
              var updatePriority = ReactDOMSharedInternals.p;
              if (0 !== updatePriority)
                return updatePriority;
              updatePriority = window.event;
              return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
            }
            function runWithPriority(priority, fn) {
              var previousPriority = ReactDOMSharedInternals.p;
              try {
                return ReactDOMSharedInternals.p = priority, fn();
              } finally {
                ReactDOMSharedInternals.p = previousPriority;
              }
            }
            var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
            function detachDeletedInstance(node) {
              delete node[internalInstanceKey];
              delete node[internalPropsKey];
              delete node[internalEventHandlersKey];
              delete node[internalEventHandlerListenersKey];
              delete node[internalEventHandlesSetKey];
            }
            function getClosestInstanceFromNode(targetNode) {
              var targetInst = targetNode[internalInstanceKey];
              if (targetInst)
                return targetInst;
              for (var parentNode = targetNode.parentNode; parentNode; ) {
                if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
                  parentNode = targetInst.alternate;
                  if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                    for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                      if (parentNode = targetNode[internalInstanceKey])
                        return parentNode;
                      targetNode = getParentSuspenseInstance(targetNode);
                    }
                  return targetInst;
                }
                targetNode = parentNode;
                parentNode = targetNode.parentNode;
              }
              return null;
            }
            function getInstanceFromNode(node) {
              if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
                var tag = node.tag;
                if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
                  return node;
              }
              return null;
            }
            function getNodeFromInstance(inst) {
              var tag = inst.tag;
              if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
                return inst.stateNode;
              throw Error(formatProdErrorMessage(33));
            }
            function getResourcesFromRoot(root2) {
              var resources = root2[internalRootNodeResourcesKey];
              resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
              return resources;
            }
            function markNodeAsHoistable(node) {
              node[internalHoistableMarker] = true;
            }
            var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
            function registerTwoPhaseEvent(registrationName, dependencies) {
              registerDirectEvent(registrationName, dependencies);
              registerDirectEvent(registrationName + "Capture", dependencies);
            }
            function registerDirectEvent(registrationName, dependencies) {
              registrationNameDependencies[registrationName] = dependencies;
              for (registrationName = 0; registrationName < dependencies.length; registrationName++)
                allNativeEvents.add(dependencies[registrationName]);
            }
            var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), VALID_ATTRIBUTE_NAME_REGEX = RegExp(
              "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
            ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
            function isAttributeNameSafe(attributeName) {
              if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
                return true;
              if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
                return false;
              if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
                return validatedAttributeNameCache[attributeName] = true;
              illegalAttributeNameCache[attributeName] = true;
              return false;
            }
            function setValueForAttribute(node, name, value) {
              if (isAttributeNameSafe(name))
                if (null === value)
                  node.removeAttribute(name);
                else {
                  switch (typeof value) {
                    case "undefined":
                    case "function":
                    case "symbol":
                      node.removeAttribute(name);
                      return;
                    case "boolean":
                      var prefix$10 = name.toLowerCase().slice(0, 5);
                      if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                        node.removeAttribute(name);
                        return;
                      }
                  }
                  node.setAttribute(name, "" + value);
                }
            }
            function setValueForKnownAttribute(node, name, value) {
              if (null === value)
                node.removeAttribute(name);
              else {
                switch (typeof value) {
                  case "undefined":
                  case "function":
                  case "symbol":
                  case "boolean":
                    node.removeAttribute(name);
                    return;
                }
                node.setAttribute(name, "" + value);
              }
            }
            function setValueForNamespacedAttribute(node, namespace, name, value) {
              if (null === value)
                node.removeAttribute(name);
              else {
                switch (typeof value) {
                  case "undefined":
                  case "function":
                  case "symbol":
                  case "boolean":
                    node.removeAttribute(name);
                    return;
                }
                node.setAttributeNS(namespace, name, "" + value);
              }
            }
            function getToStringValue(value) {
              switch (typeof value) {
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                  return value;
                case "object":
                  return value;
                default:
                  return "";
              }
            }
            function isCheckable(elem) {
              var type = elem.type;
              return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
            }
            function trackValueOnNode(node) {
              var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
                node.constructor.prototype,
                valueField
              ), currentValue = "" + node[valueField];
              if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
                var get = descriptor.get, set = descriptor.set;
                Object.defineProperty(node, valueField, {
                  configurable: true,
                  get: function() {
                    return get.call(this);
                  },
                  set: function(value) {
                    currentValue = "" + value;
                    set.call(this, value);
                  }
                });
                Object.defineProperty(node, valueField, {
                  enumerable: descriptor.enumerable
                });
                return {
                  getValue: function() {
                    return currentValue;
                  },
                  setValue: function(value) {
                    currentValue = "" + value;
                  },
                  stopTracking: function() {
                    node._valueTracker = null;
                    delete node[valueField];
                  }
                };
              }
            }
            function track(node) {
              node._valueTracker || (node._valueTracker = trackValueOnNode(node));
            }
            function updateValueIfChanged(node) {
              if (!node)
                return false;
              var tracker = node._valueTracker;
              if (!tracker)
                return true;
              var lastValue = tracker.getValue();
              var value = "";
              node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
              node = value;
              return node !== lastValue ? (tracker.setValue(node), true) : false;
            }
            function getActiveElement(doc) {
              doc = doc || ("undefined" !== typeof document ? document : void 0);
              if ("undefined" === typeof doc)
                return null;
              try {
                return doc.activeElement || doc.body;
              } catch (e) {
                return doc.body;
              }
            }
            var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
            function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
              return value.replace(
                escapeSelectorAttributeValueInsideDoubleQuotesRegex,
                function(ch) {
                  return "\\" + ch.charCodeAt(0).toString(16) + " ";
                }
              );
            }
            function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
              element.name = "";
              null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
              if (null != value)
                if ("number" === type) {
                  if (0 === value && "" === element.value || element.value != value)
                    element.value = "" + getToStringValue(value);
                } else
                  element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
              else
                "submit" !== type && "reset" !== type || element.removeAttribute("value");
              null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
              null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
              null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
              null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
            }
            function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
              null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
              if (null != value || null != defaultValue) {
                if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
                  return;
                defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
                value = null != value ? "" + getToStringValue(value) : defaultValue;
                isHydrating2 || value === element.value || (element.value = value);
                element.defaultValue = value;
              }
              checked = null != checked ? checked : defaultChecked;
              checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
              element.checked = isHydrating2 ? element.checked : !!checked;
              element.defaultChecked = !!checked;
              null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
            }
            function setDefaultValue(node, type, value) {
              "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
            }
            function updateOptions(node, multiple, propValue, setDefaultSelected) {
              node = node.options;
              if (multiple) {
                multiple = {};
                for (var i = 0; i < propValue.length; i++)
                  multiple["$" + propValue[i]] = true;
                for (propValue = 0; propValue < node.length; propValue++)
                  i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
              } else {
                propValue = "" + getToStringValue(propValue);
                multiple = null;
                for (i = 0; i < node.length; i++) {
                  if (node[i].value === propValue) {
                    node[i].selected = true;
                    setDefaultSelected && (node[i].defaultSelected = true);
                    return;
                  }
                  null !== multiple || node[i].disabled || (multiple = node[i]);
                }
                null !== multiple && (multiple.selected = true);
              }
            }
            function updateTextarea(element, value, defaultValue) {
              if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
                element.defaultValue !== value && (element.defaultValue = value);
                return;
              }
              element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            }
            function initTextarea(element, value, defaultValue, children) {
              if (null == value) {
                if (null != children) {
                  if (null != defaultValue)
                    throw Error(formatProdErrorMessage(92));
                  if (isArrayImpl(children)) {
                    if (1 < children.length)
                      throw Error(formatProdErrorMessage(93));
                    children = children[0];
                  }
                  defaultValue = children;
                }
                null == defaultValue && (defaultValue = "");
                value = defaultValue;
              }
              defaultValue = getToStringValue(value);
              element.defaultValue = defaultValue;
              children = element.textContent;
              children === defaultValue && "" !== children && null !== children && (element.value = children);
            }
            function setTextContent(node, text) {
              if (text) {
                var firstChild = node.firstChild;
                if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
                  firstChild.nodeValue = text;
                  return;
                }
              }
              node.textContent = text;
            }
            var unitlessNumbers = new Set(
              "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
                " "
              )
            );
            function setValueForStyle(style2, styleName, value) {
              var isCustomProperty = 0 === styleName.indexOf("--");
              null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
            }
            function setValueForStyles(node, styles, prevStyles) {
              if (null != styles && "object" !== typeof styles)
                throw Error(formatProdErrorMessage(62));
              node = node.style;
              if (null != prevStyles) {
                for (var styleName in prevStyles)
                  !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
                for (var styleName$16 in styles)
                  styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
              } else
                for (var styleName$17 in styles)
                  styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
            }
            function isCustomElement(tagName) {
              if (-1 === tagName.indexOf("-"))
                return false;
              switch (tagName) {
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                  return false;
                default:
                  return true;
              }
            }
            var aliases = /* @__PURE__ */ new Map([
              ["acceptCharset", "accept-charset"],
              ["htmlFor", "for"],
              ["httpEquiv", "http-equiv"],
              ["crossOrigin", "crossorigin"],
              ["accentHeight", "accent-height"],
              ["alignmentBaseline", "alignment-baseline"],
              ["arabicForm", "arabic-form"],
              ["baselineShift", "baseline-shift"],
              ["capHeight", "cap-height"],
              ["clipPath", "clip-path"],
              ["clipRule", "clip-rule"],
              ["colorInterpolation", "color-interpolation"],
              ["colorInterpolationFilters", "color-interpolation-filters"],
              ["colorProfile", "color-profile"],
              ["colorRendering", "color-rendering"],
              ["dominantBaseline", "dominant-baseline"],
              ["enableBackground", "enable-background"],
              ["fillOpacity", "fill-opacity"],
              ["fillRule", "fill-rule"],
              ["floodColor", "flood-color"],
              ["floodOpacity", "flood-opacity"],
              ["fontFamily", "font-family"],
              ["fontSize", "font-size"],
              ["fontSizeAdjust", "font-size-adjust"],
              ["fontStretch", "font-stretch"],
              ["fontStyle", "font-style"],
              ["fontVariant", "font-variant"],
              ["fontWeight", "font-weight"],
              ["glyphName", "glyph-name"],
              ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
              ["glyphOrientationVertical", "glyph-orientation-vertical"],
              ["horizAdvX", "horiz-adv-x"],
              ["horizOriginX", "horiz-origin-x"],
              ["imageRendering", "image-rendering"],
              ["letterSpacing", "letter-spacing"],
              ["lightingColor", "lighting-color"],
              ["markerEnd", "marker-end"],
              ["markerMid", "marker-mid"],
              ["markerStart", "marker-start"],
              ["overlinePosition", "overline-position"],
              ["overlineThickness", "overline-thickness"],
              ["paintOrder", "paint-order"],
              ["panose-1", "panose-1"],
              ["pointerEvents", "pointer-events"],
              ["renderingIntent", "rendering-intent"],
              ["shapeRendering", "shape-rendering"],
              ["stopColor", "stop-color"],
              ["stopOpacity", "stop-opacity"],
              ["strikethroughPosition", "strikethrough-position"],
              ["strikethroughThickness", "strikethrough-thickness"],
              ["strokeDasharray", "stroke-dasharray"],
              ["strokeDashoffset", "stroke-dashoffset"],
              ["strokeLinecap", "stroke-linecap"],
              ["strokeLinejoin", "stroke-linejoin"],
              ["strokeMiterlimit", "stroke-miterlimit"],
              ["strokeOpacity", "stroke-opacity"],
              ["strokeWidth", "stroke-width"],
              ["textAnchor", "text-anchor"],
              ["textDecoration", "text-decoration"],
              ["textRendering", "text-rendering"],
              ["transformOrigin", "transform-origin"],
              ["underlinePosition", "underline-position"],
              ["underlineThickness", "underline-thickness"],
              ["unicodeBidi", "unicode-bidi"],
              ["unicodeRange", "unicode-range"],
              ["unitsPerEm", "units-per-em"],
              ["vAlphabetic", "v-alphabetic"],
              ["vHanging", "v-hanging"],
              ["vIdeographic", "v-ideographic"],
              ["vMathematical", "v-mathematical"],
              ["vectorEffect", "vector-effect"],
              ["vertAdvY", "vert-adv-y"],
              ["vertOriginX", "vert-origin-x"],
              ["vertOriginY", "vert-origin-y"],
              ["wordSpacing", "word-spacing"],
              ["writingMode", "writing-mode"],
              ["xmlnsXlink", "xmlns:xlink"],
              ["xHeight", "x-height"]
            ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
            function sanitizeURL(url) {
              return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
            }
            var currentReplayingEvent = null;
            function getEventTarget(nativeEvent) {
              nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
              nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
              return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
            }
            var restoreTarget = null, restoreQueue = null;
            function restoreStateOfTarget(target) {
              var internalInstance = getInstanceFromNode(target);
              if (internalInstance && (target = internalInstance.stateNode)) {
                var props = target[internalPropsKey] || null;
                a:
                  switch (target = internalInstance.stateNode, internalInstance.type) {
                    case "input":
                      updateInput(
                        target,
                        props.value,
                        props.defaultValue,
                        props.defaultValue,
                        props.checked,
                        props.defaultChecked,
                        props.type,
                        props.name
                      );
                      internalInstance = props.name;
                      if ("radio" === props.type && null != internalInstance) {
                        for (props = target; props.parentNode; )
                          props = props.parentNode;
                        props = props.querySelectorAll(
                          'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                            "" + internalInstance
                          ) + '"][type="radio"]'
                        );
                        for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                          var otherNode = props[internalInstance];
                          if (otherNode !== target && otherNode.form === target.form) {
                            var otherProps = otherNode[internalPropsKey] || null;
                            if (!otherProps)
                              throw Error(formatProdErrorMessage(90));
                            updateInput(
                              otherNode,
                              otherProps.value,
                              otherProps.defaultValue,
                              otherProps.defaultValue,
                              otherProps.checked,
                              otherProps.defaultChecked,
                              otherProps.type,
                              otherProps.name
                            );
                          }
                        }
                        for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                          otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                      }
                      break a;
                    case "textarea":
                      updateTextarea(target, props.value, props.defaultValue);
                      break a;
                    case "select":
                      internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
                  }
              }
            }
            var isInsideEventHandler = false;
            function batchedUpdates$1(fn, a, b) {
              if (isInsideEventHandler)
                return fn(a, b);
              isInsideEventHandler = true;
              try {
                var JSCompiler_inline_result = fn(a);
                return JSCompiler_inline_result;
              } finally {
                if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
                  if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                    for (a = 0; a < fn.length; a++)
                      restoreStateOfTarget(fn[a]);
                }
              }
            }
            function getListener(inst, registrationName) {
              var stateNode = inst.stateNode;
              if (null === stateNode)
                return null;
              var props = stateNode[internalPropsKey] || null;
              if (null === props)
                return null;
              stateNode = props[registrationName];
              a:
                switch (registrationName) {
                  case "onClick":
                  case "onClickCapture":
                  case "onDoubleClick":
                  case "onDoubleClickCapture":
                  case "onMouseDown":
                  case "onMouseDownCapture":
                  case "onMouseMove":
                  case "onMouseMoveCapture":
                  case "onMouseUp":
                  case "onMouseUpCapture":
                  case "onMouseEnter":
                    (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
                    inst = !props;
                    break a;
                  default:
                    inst = false;
                }
              if (inst)
                return null;
              if (stateNode && "function" !== typeof stateNode)
                throw Error(
                  formatProdErrorMessage(231, registrationName, typeof stateNode)
                );
              return stateNode;
            }
            var passiveBrowserEventsSupported = false;
            if (canUseDOM)
              try {
                var options = {};
                Object.defineProperty(options, "passive", {
                  get: function() {
                    passiveBrowserEventsSupported = true;
                  }
                });
                window.addEventListener("test", options, options);
                window.removeEventListener("test", options, options);
              } catch (e) {
                passiveBrowserEventsSupported = false;
              }
            var root = null, startText = null, fallbackText = null;
            function getData() {
              if (fallbackText)
                return fallbackText;
              var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
              for (start = 0; start < startLength && startValue[start] === endValue[start]; start++)
                ;
              var minEnd = startLength - start;
              for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
                ;
              return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
            }
            function getEventCharCode(nativeEvent) {
              var keyCode = nativeEvent.keyCode;
              "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
              10 === nativeEvent && (nativeEvent = 13);
              return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
            }
            function functionThatReturnsTrue() {
              return true;
            }
            function functionThatReturnsFalse() {
              return false;
            }
            function createSyntheticEvent(Interface) {
              function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
                this._reactName = reactName;
                this._targetInst = targetInst;
                this.type = reactEventType;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = null;
                for (var propName in Interface)
                  Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
                this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
                this.isPropagationStopped = functionThatReturnsFalse;
                return this;
              }
              assign(SyntheticBaseEvent.prototype, {
                preventDefault: function() {
                  this.defaultPrevented = true;
                  var event = this.nativeEvent;
                  event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
                },
                stopPropagation: function() {
                  var event = this.nativeEvent;
                  event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
                },
                persist: function() {
                },
                isPersistent: functionThatReturnsTrue
              });
              return SyntheticBaseEvent;
            }
            var EventInterface = {
              eventPhase: 0,
              bubbles: 0,
              cancelable: 0,
              timeStamp: function(event) {
                return event.timeStamp || Date.now();
              },
              defaultPrevented: 0,
              isTrusted: 0
            }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
              screenX: 0,
              screenY: 0,
              clientX: 0,
              clientY: 0,
              pageX: 0,
              pageY: 0,
              ctrlKey: 0,
              shiftKey: 0,
              altKey: 0,
              metaKey: 0,
              getModifierState: getEventModifierState,
              button: 0,
              buttons: 0,
              relatedTarget: function(event) {
                return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
              },
              movementX: function(event) {
                if ("movementX" in event)
                  return event.movementX;
                event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
                return lastMovementX;
              },
              movementY: function(event) {
                return "movementY" in event ? event.movementY : lastMovementY;
              }
            }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
              animationName: 0,
              elapsedTime: 0,
              pseudoElement: 0
            }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
              clipboardData: function(event) {
                return "clipboardData" in event ? event.clipboardData : window.clipboardData;
              }
            }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
              Esc: "Escape",
              Spacebar: " ",
              Left: "ArrowLeft",
              Up: "ArrowUp",
              Right: "ArrowRight",
              Down: "ArrowDown",
              Del: "Delete",
              Win: "OS",
              Menu: "ContextMenu",
              Apps: "ContextMenu",
              Scroll: "ScrollLock",
              MozPrintableKey: "Unidentified"
            }, translateToKey = {
              8: "Backspace",
              9: "Tab",
              12: "Clear",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              19: "Pause",
              20: "CapsLock",
              27: "Escape",
              32: " ",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "ArrowLeft",
              38: "ArrowUp",
              39: "ArrowRight",
              40: "ArrowDown",
              45: "Insert",
              46: "Delete",
              112: "F1",
              113: "F2",
              114: "F3",
              115: "F4",
              116: "F5",
              117: "F6",
              118: "F7",
              119: "F8",
              120: "F9",
              121: "F10",
              122: "F11",
              123: "F12",
              144: "NumLock",
              145: "ScrollLock",
              224: "Meta"
            }, modifierKeyToProp = {
              Alt: "altKey",
              Control: "ctrlKey",
              Meta: "metaKey",
              Shift: "shiftKey"
            };
            function modifierStateGetter(keyArg) {
              var nativeEvent = this.nativeEvent;
              return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
            }
            function getEventModifierState() {
              return modifierStateGetter;
            }
            var KeyboardEventInterface = assign({}, UIEventInterface, {
              key: function(nativeEvent) {
                if (nativeEvent.key) {
                  var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                  if ("Unidentified" !== key)
                    return key;
                }
                return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
              },
              code: 0,
              location: 0,
              ctrlKey: 0,
              shiftKey: 0,
              altKey: 0,
              metaKey: 0,
              repeat: 0,
              locale: 0,
              getModifierState: getEventModifierState,
              charCode: function(event) {
                return "keypress" === event.type ? getEventCharCode(event) : 0;
              },
              keyCode: function(event) {
                return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
              },
              which: function(event) {
                return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
              }
            }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
              pointerId: 0,
              width: 0,
              height: 0,
              pressure: 0,
              tangentialPressure: 0,
              tiltX: 0,
              tiltY: 0,
              twist: 0,
              pointerType: 0,
              isPrimary: 0
            }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
              touches: 0,
              targetTouches: 0,
              changedTouches: 0,
              altKey: 0,
              metaKey: 0,
              ctrlKey: 0,
              shiftKey: 0,
              getModifierState: getEventModifierState
            }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
              propertyName: 0,
              elapsedTime: 0,
              pseudoElement: 0
            }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
              deltaX: function(event) {
                return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
              },
              deltaY: function(event) {
                return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
              },
              deltaZ: 0,
              deltaMode: 0
            }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
              newState: 0,
              oldState: 0
            }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
            canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
            var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
            function isFallbackCompositionEnd(domEventName, nativeEvent) {
              switch (domEventName) {
                case "keyup":
                  return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
                case "keydown":
                  return 229 !== nativeEvent.keyCode;
                case "keypress":
                case "mousedown":
                case "focusout":
                  return true;
                default:
                  return false;
              }
            }
            function getDataFromCustomEvent(nativeEvent) {
              nativeEvent = nativeEvent.detail;
              return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
            }
            var isComposing = false;
            function getNativeBeforeInputChars(domEventName, nativeEvent) {
              switch (domEventName) {
                case "compositionend":
                  return getDataFromCustomEvent(nativeEvent);
                case "keypress":
                  if (32 !== nativeEvent.which)
                    return null;
                  hasSpaceKeypress = true;
                  return SPACEBAR_CHAR;
                case "textInput":
                  return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
                default:
                  return null;
              }
            }
            function getFallbackBeforeInputChars(domEventName, nativeEvent) {
              if (isComposing)
                return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
              switch (domEventName) {
                case "paste":
                  return null;
                case "keypress":
                  if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                    if (nativeEvent.char && 1 < nativeEvent.char.length)
                      return nativeEvent.char;
                    if (nativeEvent.which)
                      return String.fromCharCode(nativeEvent.which);
                  }
                  return null;
                case "compositionend":
                  return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
                default:
                  return null;
              }
            }
            var supportedInputTypes = {
              color: true,
              date: true,
              datetime: true,
              "datetime-local": true,
              email: true,
              month: true,
              number: true,
              password: true,
              range: true,
              search: true,
              tel: true,
              text: true,
              time: true,
              url: true,
              week: true
            };
            function isTextInputElement(elem) {
              var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
              return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
            }
            function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
              restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
              inst = accumulateTwoPhaseListeners(inst, "onChange");
              0 < inst.length && (nativeEvent = new SyntheticEvent(
                "onChange",
                "change",
                null,
                nativeEvent,
                target
              ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
            }
            var activeElement$1 = null, activeElementInst$1 = null;
            function runEventInBatch(dispatchQueue) {
              processDispatchQueue(dispatchQueue, 0);
            }
            function getInstIfValueChanged(targetInst) {
              var targetNode = getNodeFromInstance(targetInst);
              if (updateValueIfChanged(targetNode))
                return targetInst;
            }
            function getTargetInstForChangeEvent(domEventName, targetInst) {
              if ("change" === domEventName)
                return targetInst;
            }
            var isInputEventSupported = false;
            if (canUseDOM) {
              var JSCompiler_inline_result$jscomp$283;
              if (canUseDOM) {
                var isSupported$jscomp$inline_418 = "oninput" in document;
                if (!isSupported$jscomp$inline_418) {
                  var element$jscomp$inline_419 = document.createElement("div");
                  element$jscomp$inline_419.setAttribute("oninput", "return;");
                  isSupported$jscomp$inline_418 = "function" === typeof element$jscomp$inline_419.oninput;
                }
                JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;
              } else
                JSCompiler_inline_result$jscomp$283 = false;
              isInputEventSupported = JSCompiler_inline_result$jscomp$283 && (!document.documentMode || 9 < document.documentMode);
            }
            function stopWatchingForValueChange() {
              activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
            }
            function handlePropertyChange(nativeEvent) {
              if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
                var dispatchQueue = [];
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  activeElementInst$1,
                  nativeEvent,
                  getEventTarget(nativeEvent)
                );
                batchedUpdates$1(runEventInBatch, dispatchQueue);
              }
            }
            function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
              "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
            }
            function getTargetInstForInputEventPolyfill(domEventName) {
              if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
                return getInstIfValueChanged(activeElementInst$1);
            }
            function getTargetInstForClickEvent(domEventName, targetInst) {
              if ("click" === domEventName)
                return getInstIfValueChanged(targetInst);
            }
            function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
              if ("input" === domEventName || "change" === domEventName)
                return getInstIfValueChanged(targetInst);
            }
            function is(x, y) {
              return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
            }
            var objectIs = "function" === typeof Object.is ? Object.is : is;
            function shallowEqual(objA, objB) {
              if (objectIs(objA, objB))
                return true;
              if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
                return false;
              var keysA = Object.keys(objA), keysB = Object.keys(objB);
              if (keysA.length !== keysB.length)
                return false;
              for (keysB = 0; keysB < keysA.length; keysB++) {
                var currentKey = keysA[keysB];
                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
                  return false;
              }
              return true;
            }
            function getLeafNode(node) {
              for (; node && node.firstChild; )
                node = node.firstChild;
              return node;
            }
            function getNodeForCharacterOffset(root2, offset) {
              var node = getLeafNode(root2);
              root2 = 0;
              for (var nodeEnd; node; ) {
                if (3 === node.nodeType) {
                  nodeEnd = root2 + node.textContent.length;
                  if (root2 <= offset && nodeEnd >= offset)
                    return { node, offset: offset - root2 };
                  root2 = nodeEnd;
                }
                a: {
                  for (; node; ) {
                    if (node.nextSibling) {
                      node = node.nextSibling;
                      break a;
                    }
                    node = node.parentNode;
                  }
                  node = void 0;
                }
                node = getLeafNode(node);
              }
            }
            function containsNode(outerNode, innerNode) {
              return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
            }
            function getActiveElementDeep(containerInfo) {
              containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
              for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
                try {
                  var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
                } catch (err) {
                  JSCompiler_inline_result = false;
                }
                if (JSCompiler_inline_result)
                  containerInfo = element.contentWindow;
                else
                  break;
                element = getActiveElement(containerInfo.document);
              }
              return element;
            }
            function hasSelectionCapabilities(elem) {
              var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
              return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
            }
            function restoreSelection(priorSelectionInformation, containerInfo) {
              var curFocusedElem = getActiveElementDeep(containerInfo);
              containerInfo = priorSelectionInformation.focusedElem;
              var priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) {
                  if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo)
                    containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(
                      curFocusedElem,
                      containerInfo.value.length
                    );
                  else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
                    curFocusedElem = curFocusedElem.getSelection();
                    var length = containerInfo.textContent.length, start = Math.min(priorSelectionRange.start, length);
                    priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length);
                    !curFocusedElem.extend && start > priorSelectionRange && (length = priorSelectionRange, priorSelectionRange = start, start = length);
                    length = getNodeForCharacterOffset(containerInfo, start);
                    var endMarker = getNodeForCharacterOffset(
                      containerInfo,
                      priorSelectionRange
                    );
                    length && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length.node || curFocusedElem.anchorOffset !== length.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length.node, length.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(
                      endMarker.node,
                      endMarker.offset
                    ), curFocusedElem.addRange(priorSelectionInformation)));
                  }
                }
                priorSelectionInformation = [];
                for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode; )
                  1 === curFocusedElem.nodeType && priorSelectionInformation.push({
                    element: curFocusedElem,
                    left: curFocusedElem.scrollLeft,
                    top: curFocusedElem.scrollTop
                  });
                "function" === typeof containerInfo.focus && containerInfo.focus();
                for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++)
                  curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
              }
            }
            var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
            function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
              var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
              mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
                anchorNode: doc.anchorNode,
                anchorOffset: doc.anchorOffset,
                focusNode: doc.focusNode,
                focusOffset: doc.focusOffset
              }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
                "onSelect",
                "select",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
            }
            function makePrefixMap(styleProp, eventName) {
              var prefixes = {};
              prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
              prefixes["Webkit" + styleProp] = "webkit" + eventName;
              prefixes["Moz" + styleProp] = "moz" + eventName;
              return prefixes;
            }
            var vendorPrefixes = {
              animationend: makePrefixMap("Animation", "AnimationEnd"),
              animationiteration: makePrefixMap("Animation", "AnimationIteration"),
              animationstart: makePrefixMap("Animation", "AnimationStart"),
              transitionrun: makePrefixMap("Transition", "TransitionRun"),
              transitionstart: makePrefixMap("Transition", "TransitionStart"),
              transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
              transitionend: makePrefixMap("Transition", "TransitionEnd")
            }, prefixedEventNames = {}, style = {};
            canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
            function getVendorPrefixedEventName(eventName) {
              if (prefixedEventNames[eventName])
                return prefixedEventNames[eventName];
              if (!vendorPrefixes[eventName])
                return eventName;
              var prefixMap = vendorPrefixes[eventName], styleProp;
              for (styleProp in prefixMap)
                if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
                  return prefixedEventNames[eventName] = prefixMap[styleProp];
              return eventName;
            }
            var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
              " "
            );
            function registerSimpleEvent(domEventName, reactName) {
              topLevelEventsToReactNames.set(domEventName, reactName);
              registerTwoPhaseEvent(reactName, [domEventName]);
            }
            var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
            function finishQueueingConcurrentUpdates() {
              for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
                var fiber = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var queue = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var update = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var lane = concurrentQueues[i];
                concurrentQueues[i++] = null;
                if (null !== queue && null !== update) {
                  var pending = queue.pending;
                  null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
                  queue.pending = update;
                }
                0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
              }
            }
            function enqueueUpdate$1(fiber, queue, update, lane) {
              concurrentQueues[concurrentQueuesIndex++] = fiber;
              concurrentQueues[concurrentQueuesIndex++] = queue;
              concurrentQueues[concurrentQueuesIndex++] = update;
              concurrentQueues[concurrentQueuesIndex++] = lane;
              concurrentlyUpdatedLanes |= lane;
              fiber.lanes |= lane;
              fiber = fiber.alternate;
              null !== fiber && (fiber.lanes |= lane);
            }
            function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
              enqueueUpdate$1(fiber, queue, update, lane);
              return getRootForUpdatedFiber(fiber);
            }
            function enqueueConcurrentRenderForLane(fiber, lane) {
              enqueueUpdate$1(fiber, null, null, lane);
              return getRootForUpdatedFiber(fiber);
            }
            function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
              sourceFiber.lanes |= lane;
              var alternate = sourceFiber.alternate;
              null !== alternate && (alternate.lanes |= lane);
              for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
                parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
              isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
            }
            function getRootForUpdatedFiber(sourceFiber) {
              if (50 < nestedUpdateCount)
                throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
              for (var parent = sourceFiber.return; null !== parent; )
                sourceFiber = parent, parent = sourceFiber.return;
              return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
            }
            var emptyContextObject = {}, CapturedStacks = /* @__PURE__ */ new WeakMap();
            function createCapturedValueAtFiber(value, source) {
              if ("object" === typeof value && null !== value) {
                var existing = CapturedStacks.get(value);
                if (void 0 !== existing)
                  return existing;
                source = {
                  value,
                  source,
                  stack: getStackByFiberInDevAndProd(source)
                };
                CapturedStacks.set(value, source);
                return source;
              }
              return {
                value,
                source,
                stack: getStackByFiberInDevAndProd(source)
              };
            }
            var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
            function pushTreeFork(workInProgress2, totalChildren) {
              forkStack[forkStackIndex++] = treeForkCount;
              forkStack[forkStackIndex++] = treeForkProvider;
              treeForkProvider = workInProgress2;
              treeForkCount = totalChildren;
            }
            function pushTreeId(workInProgress2, totalChildren, index2) {
              idStack[idStackIndex++] = treeContextId;
              idStack[idStackIndex++] = treeContextOverflow;
              idStack[idStackIndex++] = treeContextProvider;
              treeContextProvider = workInProgress2;
              var baseIdWithLeadingBit = treeContextId;
              workInProgress2 = treeContextOverflow;
              var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
              baseIdWithLeadingBit &= ~(1 << baseLength);
              index2 += 1;
              var length = 32 - clz32(totalChildren) + baseLength;
              if (30 < length) {
                var numberOfOverflowBits = baseLength - baseLength % 5;
                length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
                baseIdWithLeadingBit >>= numberOfOverflowBits;
                baseLength -= numberOfOverflowBits;
                treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
                treeContextOverflow = length + workInProgress2;
              } else
                treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
            }
            function pushMaterializedTreeId(workInProgress2) {
              null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
            }
            function popTreeContext(workInProgress2) {
              for (; workInProgress2 === treeForkProvider; )
                treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
              for (; workInProgress2 === treeContextProvider; )
                treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
            }
            var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
            function throwOnHydrationMismatch(fiber) {
              var error = Error(formatProdErrorMessage(418, ""));
              queueHydrationError(createCapturedValueAtFiber(error, fiber));
              throw HydrationMismatchException;
            }
            function prepareToHydrateHostInstance(fiber) {
              var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
              instance[internalInstanceKey] = fiber;
              instance[internalPropsKey] = props;
              switch (type) {
                case "dialog":
                  listenToNonDelegatedEvent("cancel", instance);
                  listenToNonDelegatedEvent("close", instance);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  listenToNonDelegatedEvent("load", instance);
                  break;
                case "video":
                case "audio":
                  for (type = 0; type < mediaEventTypes.length; type++)
                    listenToNonDelegatedEvent(mediaEventTypes[type], instance);
                  break;
                case "source":
                  listenToNonDelegatedEvent("error", instance);
                  break;
                case "img":
                case "image":
                case "link":
                  listenToNonDelegatedEvent("error", instance);
                  listenToNonDelegatedEvent("load", instance);
                  break;
                case "details":
                  listenToNonDelegatedEvent("toggle", instance);
                  break;
                case "input":
                  listenToNonDelegatedEvent("invalid", instance);
                  initInput(
                    instance,
                    props.value,
                    props.defaultValue,
                    props.checked,
                    props.defaultChecked,
                    props.type,
                    props.name,
                    true
                  );
                  track(instance);
                  break;
                case "select":
                  listenToNonDelegatedEvent("invalid", instance);
                  break;
                case "textarea":
                  listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
              }
              type = props.children;
              "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
              instance || throwOnHydrationMismatch(fiber);
            }
            function popToNextHostParent(fiber) {
              for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
                switch (hydrationParentFiber.tag) {
                  case 3:
                  case 27:
                    rootOrSingletonContext = true;
                    return;
                  case 5:
                  case 13:
                    rootOrSingletonContext = false;
                    return;
                  default:
                    hydrationParentFiber = hydrationParentFiber.return;
                }
            }
            function popHydrationState(fiber) {
              if (fiber !== hydrationParentFiber)
                return false;
              if (!isHydrating)
                return popToNextHostParent(fiber), isHydrating = true, false;
              var shouldClear = false, JSCompiler_temp;
              if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
                if (JSCompiler_temp = 5 === fiber.tag)
                  JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
                JSCompiler_temp = !JSCompiler_temp;
              }
              JSCompiler_temp && (shouldClear = true);
              shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
              popToNextHostParent(fiber);
              if (13 === fiber.tag) {
                fiber = fiber.memoizedState;
                fiber = null !== fiber ? fiber.dehydrated : null;
                if (!fiber)
                  throw Error(formatProdErrorMessage(317));
                a: {
                  fiber = fiber.nextSibling;
                  for (shouldClear = 0; fiber; ) {
                    if (8 === fiber.nodeType)
                      if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                        if (0 === shouldClear) {
                          nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                          break a;
                        }
                        shouldClear--;
                      } else
                        "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || shouldClear++;
                    fiber = fiber.nextSibling;
                  }
                  nextHydratableInstance = null;
                }
              } else
                nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
              return true;
            }
            function resetHydrationState() {
              nextHydratableInstance = hydrationParentFiber = null;
              isHydrating = false;
            }
            function queueHydrationError(error) {
              null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
            }
            var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), noopSuspenseyCommitThenable = { then: function() {
            } };
            function isThenableResolved(thenable) {
              thenable = thenable.status;
              return "fulfilled" === thenable || "rejected" === thenable;
            }
            function noop$3() {
            }
            function trackUsedThenable(thenableState2, thenable, index2) {
              index2 = thenableState2[index2];
              void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  thenableState2 = thenable.reason;
                  if (thenableState2 === SuspenseException)
                    throw Error(formatProdErrorMessage(483));
                  throw thenableState2;
                default:
                  if ("string" === typeof thenable.status)
                    thenable.then(noop$3, noop$3);
                  else {
                    thenableState2 = workInProgressRoot;
                    if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                      throw Error(formatProdErrorMessage(482));
                    thenableState2 = thenable;
                    thenableState2.status = "pending";
                    thenableState2.then(
                      function(fulfilledValue) {
                        if ("pending" === thenable.status) {
                          var fulfilledThenable = thenable;
                          fulfilledThenable.status = "fulfilled";
                          fulfilledThenable.value = fulfilledValue;
                        }
                      },
                      function(error) {
                        if ("pending" === thenable.status) {
                          var rejectedThenable = thenable;
                          rejectedThenable.status = "rejected";
                          rejectedThenable.reason = error;
                        }
                      }
                    );
                  }
                  switch (thenable.status) {
                    case "fulfilled":
                      return thenable.value;
                    case "rejected":
                      thenableState2 = thenable.reason;
                      if (thenableState2 === SuspenseException)
                        throw Error(formatProdErrorMessage(483));
                      throw thenableState2;
                  }
                  suspendedThenable = thenable;
                  throw SuspenseException;
              }
            }
            var suspendedThenable = null;
            function getSuspendedThenable() {
              if (null === suspendedThenable)
                throw Error(formatProdErrorMessage(459));
              var thenable = suspendedThenable;
              suspendedThenable = null;
              return thenable;
            }
            var thenableState$1 = null, thenableIndexCounter$1 = 0;
            function unwrapThenable(thenable) {
              var index2 = thenableIndexCounter$1;
              thenableIndexCounter$1 += 1;
              null === thenableState$1 && (thenableState$1 = []);
              return trackUsedThenable(thenableState$1, thenable, index2);
            }
            function coerceRef(workInProgress2, element) {
              element = element.props.ref;
              workInProgress2.ref = void 0 !== element ? element : null;
            }
            function throwOnInvalidObjectType(returnFiber, newChild) {
              if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
                throw Error(formatProdErrorMessage(525));
              returnFiber = Object.prototype.toString.call(newChild);
              throw Error(
                formatProdErrorMessage(
                  31,
                  "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
                )
              );
            }
            function resolveLazy(lazyType) {
              var init = lazyType._init;
              return init(lazyType._payload);
            }
            function createChildReconciler(shouldTrackSideEffects) {
              function deleteChild(returnFiber, childToDelete) {
                if (shouldTrackSideEffects) {
                  var deletions = returnFiber.deletions;
                  null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
                }
              }
              function deleteRemainingChildren(returnFiber, currentFirstChild) {
                if (!shouldTrackSideEffects)
                  return null;
                for (; null !== currentFirstChild; )
                  deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
                return null;
              }
              function mapRemainingChildren(currentFirstChild) {
                for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
                  null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
                return existingChildren;
              }
              function useFiber(fiber, pendingProps) {
                fiber = createWorkInProgress(fiber, pendingProps);
                fiber.index = 0;
                fiber.sibling = null;
                return fiber;
              }
              function placeChild(newFiber, lastPlacedIndex, newIndex) {
                newFiber.index = newIndex;
                if (!shouldTrackSideEffects)
                  return newFiber.flags |= 1048576, lastPlacedIndex;
                newIndex = newFiber.alternate;
                if (null !== newIndex)
                  return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
                newFiber.flags |= 33554434;
                return lastPlacedIndex;
              }
              function placeSingleChild(newFiber) {
                shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
                return newFiber;
              }
              function updateTextNode(returnFiber, current, textContent, lanes) {
                if (null === current || 6 !== current.tag)
                  return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
                current = useFiber(current, textContent);
                current.return = returnFiber;
                return current;
              }
              function updateElement(returnFiber, current, element, lanes) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE)
                  return updateFragment(
                    returnFiber,
                    current,
                    element.props.children,
                    lanes,
                    element.key
                  );
                if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
                  return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
                current = createFiberFromTypeAndProps(
                  element.type,
                  element.key,
                  element.props,
                  null,
                  returnFiber.mode,
                  lanes
                );
                coerceRef(current, element);
                current.return = returnFiber;
                return current;
              }
              function updatePortal(returnFiber, current, portal, lanes) {
                if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
                  return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
                current = useFiber(current, portal.children || []);
                current.return = returnFiber;
                return current;
              }
              function updateFragment(returnFiber, current, fragment, lanes, key) {
                if (null === current || 7 !== current.tag)
                  return current = createFiberFromFragment(
                    fragment,
                    returnFiber.mode,
                    lanes,
                    key
                  ), current.return = returnFiber, current;
                current = useFiber(current, fragment);
                current.return = returnFiber;
                return current;
              }
              function createChild(returnFiber, newChild, lanes) {
                if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                  return newChild = createFiberFromText(
                    "" + newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild;
                if ("object" === typeof newChild && null !== newChild) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                      return lanes = createFiberFromTypeAndProps(
                        newChild.type,
                        newChild.key,
                        newChild.props,
                        null,
                        returnFiber.mode,
                        lanes
                      ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
                    case REACT_PORTAL_TYPE:
                      return newChild = createFiberFromPortal(
                        newChild,
                        returnFiber.mode,
                        lanes
                      ), newChild.return = returnFiber, newChild;
                    case REACT_LAZY_TYPE:
                      var init = newChild._init;
                      newChild = init(newChild._payload);
                      return createChild(returnFiber, newChild, lanes);
                  }
                  if (isArrayImpl(newChild) || getIteratorFn(newChild))
                    return newChild = createFiberFromFragment(
                      newChild,
                      returnFiber.mode,
                      lanes,
                      null
                    ), newChild.return = returnFiber, newChild;
                  if ("function" === typeof newChild.then)
                    return createChild(returnFiber, unwrapThenable(newChild), lanes);
                  if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                    return createChild(
                      returnFiber,
                      readContextDuringReconciliation(returnFiber, newChild),
                      lanes
                    );
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
              }
              function updateSlot(returnFiber, oldFiber, newChild, lanes) {
                var key = null !== oldFiber ? oldFiber.key : null;
                if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                  return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
                if ("object" === typeof newChild && null !== newChild) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                      return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
                    case REACT_PORTAL_TYPE:
                      return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                    case REACT_LAZY_TYPE:
                      return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
                  }
                  if (isArrayImpl(newChild) || getIteratorFn(newChild))
                    return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                  if ("function" === typeof newChild.then)
                    return updateSlot(
                      returnFiber,
                      oldFiber,
                      unwrapThenable(newChild),
                      lanes
                    );
                  if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                    return updateSlot(
                      returnFiber,
                      oldFiber,
                      readContextDuringReconciliation(returnFiber, newChild),
                      lanes
                    );
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
              }
              function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
                if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                  return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
                if ("object" === typeof newChild && null !== newChild) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                      return existingChildren = existingChildren.get(
                        null === newChild.key ? newIdx : newChild.key
                      ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
                    case REACT_PORTAL_TYPE:
                      return existingChildren = existingChildren.get(
                        null === newChild.key ? newIdx : newChild.key
                      ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                    case REACT_LAZY_TYPE:
                      var init = newChild._init;
                      newChild = init(newChild._payload);
                      return updateFromMap(
                        existingChildren,
                        returnFiber,
                        newIdx,
                        newChild,
                        lanes
                      );
                  }
                  if (isArrayImpl(newChild) || getIteratorFn(newChild))
                    return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
                  if ("function" === typeof newChild.then)
                    return updateFromMap(
                      existingChildren,
                      returnFiber,
                      newIdx,
                      unwrapThenable(newChild),
                      lanes
                    );
                  if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                    return updateFromMap(
                      existingChildren,
                      returnFiber,
                      newIdx,
                      readContextDuringReconciliation(returnFiber, newChild),
                      lanes
                    );
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
              }
              function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
                for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
                  oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                  var newFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChildren[newIdx],
                    lanes
                  );
                  if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                  }
                  shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                  currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                  null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                  previousNewFiber = newFiber;
                  oldFiber = nextOldFiber;
                }
                if (newIdx === newChildren.length)
                  return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
                if (null === oldFiber) {
                  for (; newIdx < newChildren.length; newIdx++)
                    oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                      oldFiber,
                      currentFirstChild,
                      newIdx
                    ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
                  isHydrating && pushTreeFork(returnFiber, newIdx);
                  return resultingFirstChild;
                }
                for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
                  nextOldFiber = updateFromMap(
                    oldFiber,
                    returnFiber,
                    newIdx,
                    newChildren[newIdx],
                    lanes
                  ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                    null === nextOldFiber.key ? newIdx : nextOldFiber.key
                  ), currentFirstChild = placeChild(
                    nextOldFiber,
                    currentFirstChild,
                    newIdx
                  ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
                shouldTrackSideEffects && oldFiber.forEach(function(child) {
                  return deleteChild(returnFiber, child);
                });
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
              }
              function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
                if (null == newChildren)
                  throw Error(formatProdErrorMessage(151));
                for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
                  oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                  var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                  if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                  }
                  shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                  currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                  null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                  previousNewFiber = newFiber;
                  oldFiber = nextOldFiber;
                }
                if (step.done)
                  return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
                if (null === oldFiber) {
                  for (; !step.done; newIdx++, step = newChildren.next())
                    step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
                  isHydrating && pushTreeFork(returnFiber, newIdx);
                  return resultingFirstChild;
                }
                for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
                  step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
                shouldTrackSideEffects && oldFiber.forEach(function(child) {
                  return deleteChild(returnFiber, child);
                });
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
              }
              function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
                "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
                if ("object" === typeof newChild && null !== newChild) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                      a: {
                        for (var key = newChild.key; null !== currentFirstChild; ) {
                          if (currentFirstChild.key === key) {
                            key = newChild.type;
                            if (key === REACT_FRAGMENT_TYPE) {
                              if (7 === currentFirstChild.tag) {
                                deleteRemainingChildren(
                                  returnFiber,
                                  currentFirstChild.sibling
                                );
                                lanes = useFiber(
                                  currentFirstChild,
                                  newChild.props.children
                                );
                                lanes.return = returnFiber;
                                returnFiber = lanes;
                                break a;
                              }
                            } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                              deleteRemainingChildren(
                                returnFiber,
                                currentFirstChild.sibling
                              );
                              lanes = useFiber(currentFirstChild, newChild.props);
                              coerceRef(lanes, newChild);
                              lanes.return = returnFiber;
                              returnFiber = lanes;
                              break a;
                            }
                            deleteRemainingChildren(returnFiber, currentFirstChild);
                            break;
                          } else
                            deleteChild(returnFiber, currentFirstChild);
                          currentFirstChild = currentFirstChild.sibling;
                        }
                        newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                          newChild.props.children,
                          returnFiber.mode,
                          lanes,
                          newChild.key
                        ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                          newChild.type,
                          newChild.key,
                          newChild.props,
                          null,
                          returnFiber.mode,
                          lanes
                        ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                      }
                      return placeSingleChild(returnFiber);
                    case REACT_PORTAL_TYPE:
                      a: {
                        for (key = newChild.key; null !== currentFirstChild; ) {
                          if (currentFirstChild.key === key)
                            if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                              deleteRemainingChildren(
                                returnFiber,
                                currentFirstChild.sibling
                              );
                              lanes = useFiber(currentFirstChild, newChild.children || []);
                              lanes.return = returnFiber;
                              returnFiber = lanes;
                              break a;
                            } else {
                              deleteRemainingChildren(returnFiber, currentFirstChild);
                              break;
                            }
                          else
                            deleteChild(returnFiber, currentFirstChild);
                          currentFirstChild = currentFirstChild.sibling;
                        }
                        lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                      }
                      return placeSingleChild(returnFiber);
                    case REACT_LAZY_TYPE:
                      return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                        returnFiber,
                        currentFirstChild,
                        newChild,
                        lanes
                      );
                  }
                  if (isArrayImpl(newChild))
                    return reconcileChildrenArray(
                      returnFiber,
                      currentFirstChild,
                      newChild,
                      lanes
                    );
                  if (getIteratorFn(newChild)) {
                    key = getIteratorFn(newChild);
                    if ("function" !== typeof key)
                      throw Error(formatProdErrorMessage(150));
                    newChild = key.call(newChild);
                    return reconcileChildrenIterator(
                      returnFiber,
                      currentFirstChild,
                      newChild,
                      lanes
                    );
                  }
                  if ("function" === typeof newChild.then)
                    return reconcileChildFibersImpl(
                      returnFiber,
                      currentFirstChild,
                      unwrapThenable(newChild),
                      lanes
                    );
                  if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                    return reconcileChildFibersImpl(
                      returnFiber,
                      currentFirstChild,
                      readContextDuringReconciliation(returnFiber, newChild),
                      lanes
                    );
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
              }
              return function(returnFiber, currentFirstChild, newChild, lanes) {
                try {
                  thenableIndexCounter$1 = 0;
                  var firstChildFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  );
                  thenableState$1 = null;
                  return firstChildFiber;
                } catch (x) {
                  if (x === SuspenseException)
                    throw x;
                  var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
                  fiber.lanes = lanes;
                  fiber.return = returnFiber;
                  return fiber;
                } finally {
                }
              };
            }
            var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
            function pushHiddenContext(fiber, context) {
              fiber = entangledRenderLanes;
              push(prevEntangledRenderLanesCursor, fiber);
              push(currentTreeHiddenStackCursor, context);
              entangledRenderLanes = fiber | context.baseLanes;
            }
            function reuseHiddenContextOnStack() {
              push(prevEntangledRenderLanesCursor, entangledRenderLanes);
              push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
            }
            function popHiddenContext() {
              entangledRenderLanes = prevEntangledRenderLanesCursor.current;
              pop(currentTreeHiddenStackCursor);
              pop(prevEntangledRenderLanesCursor);
            }
            var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
            function pushPrimaryTreeSuspenseHandler(handler) {
              var current = handler.alternate;
              push(suspenseStackCursor, suspenseStackCursor.current & 1);
              push(suspenseHandlerStackCursor, handler);
              null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
            }
            function pushOffscreenSuspenseHandler(fiber) {
              if (22 === fiber.tag) {
                if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
                  var current = fiber.alternate;
                  null !== current && null !== current.memoizedState && (shellBoundary = fiber);
                }
              } else
                reuseSuspenseHandlerOnStack(fiber);
            }
            function reuseSuspenseHandlerOnStack() {
              push(suspenseStackCursor, suspenseStackCursor.current);
              push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
            }
            function popSuspenseHandler(fiber) {
              pop(suspenseHandlerStackCursor);
              shellBoundary === fiber && (shellBoundary = null);
              pop(suspenseStackCursor);
            }
            var suspenseStackCursor = createCursor(0);
            function findFirstSuspended(row) {
              for (var node = row; null !== node; ) {
                if (13 === node.tag) {
                  var state = node.memoizedState;
                  if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || "$!" === state.data))
                    return node;
                } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
                  if (0 !== (node.flags & 128))
                    return node;
                } else if (null !== node.child) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === row)
                  break;
                for (; null === node.sibling; ) {
                  if (null === node.return || node.return === row)
                    return null;
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
              return null;
            }
            var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
              var listeners = [], signal = this.signal = {
                aborted: false,
                addEventListener: function(type, listener) {
                  listeners.push(listener);
                }
              };
              this.abort = function() {
                signal.aborted = true;
                listeners.forEach(function(listener) {
                  return listener();
                });
              };
            }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
              $$typeof: REACT_CONTEXT_TYPE,
              Consumer: null,
              Provider: null,
              _currentValue: null,
              _currentValue2: null,
              _threadCount: 0
            };
            function createCache() {
              return {
                controller: new AbortControllerLocal(),
                data: /* @__PURE__ */ new Map(),
                refCount: 0
              };
            }
            function releaseCache(cache) {
              cache.refCount--;
              0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
                cache.controller.abort();
              });
            }
            var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
            function entangleAsyncAction(transition, thenable) {
              if (null === currentEntangledListeners) {
                var entangledListeners = currentEntangledListeners = [];
                currentEntangledPendingCount = 0;
                currentEntangledLane = requestTransitionLane();
                currentEntangledActionThenable = {
                  status: "pending",
                  value: void 0,
                  then: function(resolve) {
                    entangledListeners.push(resolve);
                  }
                };
              }
              currentEntangledPendingCount++;
              thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
              return thenable;
            }
            function pingEngtangledActionScope() {
              if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
                null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
                var listeners = currentEntangledListeners;
                currentEntangledListeners = null;
                currentEntangledLane = 0;
                currentEntangledActionThenable = null;
                for (var i = 0; i < listeners.length; i++)
                  (0, listeners[i])();
              }
            }
            function chainThenableValue(thenable, result) {
              var listeners = [], thenableWithOverride = {
                status: "pending",
                value: null,
                reason: null,
                then: function(resolve) {
                  listeners.push(resolve);
                }
              };
              thenable.then(
                function() {
                  thenableWithOverride.status = "fulfilled";
                  thenableWithOverride.value = result;
                  for (var i = 0; i < listeners.length; i++)
                    (0, listeners[i])(result);
                },
                function(error) {
                  thenableWithOverride.status = "rejected";
                  thenableWithOverride.reason = error;
                  for (error = 0; error < listeners.length; error++)
                    (0, listeners[error])(void 0);
                }
              );
              return thenableWithOverride;
            }
            var prevOnStartTransitionFinish = ReactSharedInternals.S;
            ReactSharedInternals.S = function(transition, returnValue) {
              "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
              null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
            };
            var resumedCache = createCursor(null);
            function peekCacheFromPool() {
              var cacheResumedFromPreviousRender = resumedCache.current;
              return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
            }
            function pushTransition(offscreenWorkInProgress, prevCachePool) {
              null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
            }
            function getSuspendedCache() {
              var cacheFromPool = peekCacheFromPool();
              return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
            }
            var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
            function throwInvalidHookError() {
              throw Error(formatProdErrorMessage(321));
            }
            function areHookInputsEqual(nextDeps, prevDeps) {
              if (null === prevDeps)
                return false;
              for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
                if (!objectIs(nextDeps[i], prevDeps[i]))
                  return false;
              return true;
            }
            function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
              renderLanes = nextRenderLanes;
              currentlyRenderingFiber$1 = workInProgress2;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.lanes = 0;
              ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
              shouldDoubleInvokeUserFnsInHooksDEV = false;
              nextRenderLanes = Component(props, secondArg);
              shouldDoubleInvokeUserFnsInHooksDEV = false;
              didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              ));
              finishRenderingHooks(current);
              return nextRenderLanes;
            }
            function finishRenderingHooks(current) {
              ReactSharedInternals.H = ContextOnlyDispatcher;
              var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
              renderLanes = 0;
              workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
              didScheduleRenderPhaseUpdate = false;
              thenableIndexCounter = 0;
              thenableState = null;
              if (didRenderTooFewHooks)
                throw Error(formatProdErrorMessage(300));
              null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
            }
            function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
              currentlyRenderingFiber$1 = workInProgress2;
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
                thenableIndexCounter = 0;
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (25 <= numberOfReRenders)
                  throw Error(formatProdErrorMessage(301));
                numberOfReRenders += 1;
                workInProgressHook = currentHook = null;
                if (null != workInProgress2.updateQueue) {
                  var children = workInProgress2.updateQueue;
                  children.lastEffect = null;
                  children.events = null;
                  children.stores = null;
                  null != children.memoCache && (children.memoCache.index = 0);
                }
                ReactSharedInternals.H = HooksDispatcherOnRerender;
                children = Component(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
              return children;
            }
            function TransitionAwareHostComponent() {
              var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
              maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
              dispatcher = dispatcher.useState()[0];
              (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
              return maybeThenable;
            }
            function checkDidRenderIdHook() {
              var didRenderIdHook = 0 !== localIdCounter;
              localIdCounter = 0;
              return didRenderIdHook;
            }
            function bailoutHooks(current, workInProgress2, lanes) {
              workInProgress2.updateQueue = current.updateQueue;
              workInProgress2.flags &= -2053;
              current.lanes &= ~lanes;
            }
            function resetHooksOnUnwind(workInProgress2) {
              if (didScheduleRenderPhaseUpdate) {
                for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
                  var queue = workInProgress2.queue;
                  null !== queue && (queue.pending = null);
                  workInProgress2 = workInProgress2.next;
                }
                didScheduleRenderPhaseUpdate = false;
              }
              renderLanes = 0;
              workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              thenableIndexCounter = localIdCounter = 0;
              thenableState = null;
            }
            function mountWorkInProgressHook() {
              var hook = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
              };
              null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
              return workInProgressHook;
            }
            function updateWorkInProgressHook() {
              if (null === currentHook) {
                var nextCurrentHook = currentlyRenderingFiber$1.alternate;
                nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
              } else
                nextCurrentHook = currentHook.next;
              var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
              if (null !== nextWorkInProgressHook)
                workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
              else {
                if (null === nextCurrentHook) {
                  if (null === currentlyRenderingFiber$1.alternate)
                    throw Error(formatProdErrorMessage(467));
                  throw Error(formatProdErrorMessage(310));
                }
                currentHook = nextCurrentHook;
                nextCurrentHook = {
                  memoizedState: currentHook.memoizedState,
                  baseState: currentHook.baseState,
                  baseQueue: currentHook.baseQueue,
                  queue: currentHook.queue,
                  next: null
                };
                null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
              }
              return workInProgressHook;
            }
            var createFunctionComponentUpdateQueue;
            createFunctionComponentUpdateQueue = function() {
              return { lastEffect: null, events: null, stores: null, memoCache: null };
            };
            function useThenable(thenable) {
              var index2 = thenableIndexCounter;
              thenableIndexCounter += 1;
              null === thenableState && (thenableState = []);
              thenable = trackUsedThenable(thenableState, thenable, index2);
              index2 = currentlyRenderingFiber$1;
              null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
              return thenable;
            }
            function use(usable) {
              if (null !== usable && "object" === typeof usable) {
                if ("function" === typeof usable.then)
                  return useThenable(usable);
                if (usable.$$typeof === REACT_CONTEXT_TYPE)
                  return readContext(usable);
              }
              throw Error(formatProdErrorMessage(438, String(usable)));
            }
            function useMemoCache(size) {
              var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;
              null !== updateQueue && (memoCache = updateQueue.memoCache);
              if (null == memoCache) {
                var current = currentlyRenderingFiber$1.alternate;
                null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
                  data: current.data.map(function(array) {
                    return array.slice();
                  }),
                  index: 0
                })));
              }
              null == memoCache && (memoCache = { data: [], index: 0 });
              null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
              updateQueue.memoCache = memoCache;
              updateQueue = memoCache.data[memoCache.index];
              if (void 0 === updateQueue)
                for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
                  updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
              memoCache.index++;
              return updateQueue;
            }
            function basicStateReducer(state, action) {
              return "function" === typeof action ? action(state) : action;
            }
            function updateReducer(reducer) {
              var hook = updateWorkInProgressHook();
              return updateReducerImpl(hook, currentHook, reducer);
            }
            function updateReducerImpl(hook, current, reducer) {
              var queue = hook.queue;
              if (null === queue)
                throw Error(formatProdErrorMessage(311));
              queue.lastRenderedReducer = reducer;
              var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
              if (null !== pendingQueue) {
                if (null !== baseQueue) {
                  var baseFirst = baseQueue.next;
                  baseQueue.next = pendingQueue.next;
                  pendingQueue.next = baseFirst;
                }
                current.baseQueue = baseQueue = pendingQueue;
                queue.pending = null;
              }
              pendingQueue = hook.baseState;
              if (null === baseQueue)
                hook.memoizedState = pendingQueue;
              else {
                current = baseQueue.next;
                var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$54 = false;
                do {
                  var updateLane = update.lane & -536870913;
                  if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                    var revertLane = update.revertLane;
                    if (0 === revertLane)
                      null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                        lane: 0,
                        revertLane: 0,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null
                      }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = true);
                    else if ((renderLanes & revertLane) === revertLane) {
                      update = update.next;
                      revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = true);
                      continue;
                    } else
                      updateLane = {
                        lane: 0,
                        revertLane: update.revertLane,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null
                      }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                    updateLane = update.action;
                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
                  } else
                    revertLane = {
                      lane: updateLane,
                      revertLane: update.revertLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
                  update = update.next;
                } while (null !== update && update !== current);
                null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
                if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$54 && (reducer = currentEntangledActionThenable, null !== reducer)))
                  throw reducer;
                hook.memoizedState = pendingQueue;
                hook.baseState = baseFirst;
                hook.baseQueue = newBaseQueueLast;
                queue.lastRenderedState = pendingQueue;
              }
              null === baseQueue && (queue.lanes = 0);
              return [hook.memoizedState, queue.dispatch];
            }
            function rerenderReducer(reducer) {
              var hook = updateWorkInProgressHook(), queue = hook.queue;
              if (null === queue)
                throw Error(formatProdErrorMessage(311));
              queue.lastRenderedReducer = reducer;
              var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
              if (null !== lastRenderPhaseUpdate) {
                queue.pending = null;
                var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                do
                  newState = reducer(newState, update.action), update = update.next;
                while (update !== lastRenderPhaseUpdate);
                objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
                hook.memoizedState = newState;
                null === hook.baseQueue && (hook.baseState = newState);
                queue.lastRenderedState = newState;
              }
              return [newState, dispatch];
            }
            function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
              var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
              if (isHydrating$jscomp$0) {
                if (void 0 === getServerSnapshot)
                  throw Error(formatProdErrorMessage(407));
                getServerSnapshot = getServerSnapshot();
              } else
                getServerSnapshot = getSnapshot();
              var snapshotChanged = !objectIs(
                (currentHook || hook).memoizedState,
                getServerSnapshot
              );
              snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
              hook = hook.queue;
              updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
                subscribe
              ]);
              if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
                fiber.flags |= 2048;
                pushEffect(
                  9,
                  updateStoreInstance.bind(
                    null,
                    fiber,
                    hook,
                    getServerSnapshot,
                    getSnapshot
                  ),
                  { destroy: void 0 },
                  null
                );
                if (null === workInProgressRoot)
                  throw Error(formatProdErrorMessage(349));
                isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
              }
              return getServerSnapshot;
            }
            function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
              fiber.flags |= 16384;
              fiber = { getSnapshot, value: renderedSnapshot };
              getSnapshot = currentlyRenderingFiber$1.updateQueue;
              null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
            }
            function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
              inst.value = nextSnapshot;
              inst.getSnapshot = getSnapshot;
              checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
            }
            function subscribeToStore(fiber, inst, subscribe) {
              return subscribe(function() {
                checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
              });
            }
            function checkIfSnapshotChanged(inst) {
              var latestGetSnapshot = inst.getSnapshot;
              inst = inst.value;
              try {
                var nextValue = latestGetSnapshot();
                return !objectIs(inst, nextValue);
              } catch (error) {
                return true;
              }
            }
            function forceStoreRerender(fiber) {
              var root2 = enqueueConcurrentRenderForLane(fiber, 2);
              null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
            }
            function mountStateImpl(initialState) {
              var hook = mountWorkInProgressHook();
              if ("function" === typeof initialState) {
                var initialStateInitializer = initialState;
                initialState = initialStateInitializer();
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                  setIsStrictModeForDevtools(true);
                  try {
                    initialStateInitializer();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              hook.memoizedState = hook.baseState = initialState;
              hook.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialState
              };
              return hook;
            }
            function updateOptimisticImpl(hook, current, passthrough, reducer) {
              hook.baseState = passthrough;
              return updateReducerImpl(
                hook,
                currentHook,
                "function" === typeof reducer ? reducer : basicStateReducer
              );
            }
            function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
              if (isRenderPhaseUpdate(fiber))
                throw Error(formatProdErrorMessage(485));
              fiber = actionQueue.action;
              if (null !== fiber) {
                var actionNode = {
                  payload,
                  action: fiber,
                  next: null,
                  isTransition: true,
                  status: "pending",
                  value: null,
                  reason: null,
                  listeners: [],
                  then: function(listener) {
                    actionNode.listeners.push(listener);
                  }
                };
                null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
                setState(actionNode);
                setPendingState = actionQueue.pending;
                null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
              }
            }
            function runActionStateAction(actionQueue, node) {
              var action = node.action, payload = node.payload, prevState = actionQueue.state;
              if (node.isTransition) {
                var prevTransition = ReactSharedInternals.T, currentTransition = {};
                ReactSharedInternals.T = currentTransition;
                try {
                  var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
                  null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                  handleActionReturnValue(actionQueue, node, returnValue);
                } catch (error) {
                  onActionError(actionQueue, node, error);
                } finally {
                  ReactSharedInternals.T = prevTransition;
                }
              } else
                try {
                  prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
                } catch (error$60) {
                  onActionError(actionQueue, node, error$60);
                }
            }
            function handleActionReturnValue(actionQueue, node, returnValue) {
              null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
                function(nextState) {
                  onActionSuccess(actionQueue, node, nextState);
                },
                function(error) {
                  return onActionError(actionQueue, node, error);
                }
              ) : onActionSuccess(actionQueue, node, returnValue);
            }
            function onActionSuccess(actionQueue, actionNode, nextState) {
              actionNode.status = "fulfilled";
              actionNode.value = nextState;
              notifyActionListeners(actionNode);
              actionQueue.state = nextState;
              actionNode = actionQueue.pending;
              null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
            }
            function onActionError(actionQueue, actionNode, error) {
              var last = actionQueue.pending;
              actionQueue.pending = null;
              if (null !== last) {
                last = last.next;
                do
                  actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
                while (actionNode !== last);
              }
              actionQueue.action = null;
            }
            function notifyActionListeners(actionNode) {
              actionNode = actionNode.listeners;
              for (var i = 0; i < actionNode.length; i++)
                (0, actionNode[i])();
            }
            function actionStateReducer(oldState, newState) {
              return newState;
            }
            function mountActionState(action, initialStateProp) {
              if (isHydrating) {
                var ssrFormState = workInProgressRoot.formState;
                if (null !== ssrFormState) {
                  a: {
                    var JSCompiler_inline_result = currentlyRenderingFiber$1;
                    if (isHydrating) {
                      if (nextHydratableInstance) {
                        b: {
                          var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                          for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                            if (!inRootOrSingleton) {
                              JSCompiler_inline_result$jscomp$0 = null;
                              break b;
                            }
                            JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                              JSCompiler_inline_result$jscomp$0.nextSibling
                            );
                            if (null === JSCompiler_inline_result$jscomp$0) {
                              JSCompiler_inline_result$jscomp$0 = null;
                              break b;
                            }
                          }
                          inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                          JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                        }
                        if (JSCompiler_inline_result$jscomp$0) {
                          nextHydratableInstance = getNextHydratable(
                            JSCompiler_inline_result$jscomp$0.nextSibling
                          );
                          JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                          break a;
                        }
                      }
                      throwOnHydrationMismatch(JSCompiler_inline_result);
                    }
                    JSCompiler_inline_result = false;
                  }
                  JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
                }
              }
              ssrFormState = mountWorkInProgressHook();
              ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
              JSCompiler_inline_result = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: actionStateReducer,
                lastRenderedState: initialStateProp
              };
              ssrFormState.queue = JSCompiler_inline_result;
              ssrFormState = dispatchSetState.bind(
                null,
                currentlyRenderingFiber$1,
                JSCompiler_inline_result
              );
              JSCompiler_inline_result.dispatch = ssrFormState;
              JSCompiler_inline_result = mountStateImpl(false);
              inRootOrSingleton = dispatchOptimisticSetState.bind(
                null,
                currentlyRenderingFiber$1,
                false,
                JSCompiler_inline_result.queue
              );
              JSCompiler_inline_result = mountWorkInProgressHook();
              JSCompiler_inline_result$jscomp$0 = {
                state: initialStateProp,
                dispatch: null,
                action,
                pending: null
              };
              JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
              ssrFormState = dispatchActionState.bind(
                null,
                currentlyRenderingFiber$1,
                JSCompiler_inline_result$jscomp$0,
                inRootOrSingleton,
                ssrFormState
              );
              JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
              JSCompiler_inline_result.memoizedState = action;
              return [initialStateProp, ssrFormState, false];
            }
            function updateActionState(action) {
              var stateHook = updateWorkInProgressHook();
              return updateActionStateImpl(stateHook, currentHook, action);
            }
            function updateActionStateImpl(stateHook, currentStateHook, action) {
              currentStateHook = updateReducerImpl(
                stateHook,
                currentStateHook,
                actionStateReducer
              )[0];
              stateHook = updateReducer(basicStateReducer)[0];
              currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
              var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;
              action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(
                9,
                actionStateActionEffect.bind(null, actionQueue, action),
                { destroy: void 0 },
                null
              ));
              return [currentStateHook, dispatch, stateHook];
            }
            function actionStateActionEffect(actionQueue, action) {
              actionQueue.action = action;
            }
            function rerenderActionState(action) {
              var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
              if (null !== currentStateHook)
                return updateActionStateImpl(stateHook, currentStateHook, action);
              updateWorkInProgressHook();
              stateHook = stateHook.memoizedState;
              currentStateHook = updateWorkInProgressHook();
              var dispatch = currentStateHook.queue.dispatch;
              currentStateHook.memoizedState = action;
              return [stateHook, dispatch, false];
            }
            function pushEffect(tag, create, inst, deps) {
              tag = { tag, create, inst, deps, next: null };
              create = currentlyRenderingFiber$1.updateQueue;
              null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
              inst = create.lastEffect;
              null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
              return tag;
            }
            function updateRef() {
              return updateWorkInProgressHook().memoizedState;
            }
            function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
              var hook = mountWorkInProgressHook();
              currentlyRenderingFiber$1.flags |= fiberFlags;
              hook.memoizedState = pushEffect(
                1 | hookFlags,
                create,
                { destroy: void 0 },
                void 0 === deps ? null : deps
              );
            }
            function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
              var hook = updateWorkInProgressHook();
              deps = void 0 === deps ? null : deps;
              var inst = hook.memoizedState.inst;
              null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps));
            }
            function mountEffect(create, deps) {
              mountEffectImpl(8390656, 8, create, deps);
            }
            function updateEffect(create, deps) {
              updateEffectImpl(2048, 8, create, deps);
            }
            function updateInsertionEffect(create, deps) {
              return updateEffectImpl(4, 2, create, deps);
            }
            function updateLayoutEffect(create, deps) {
              return updateEffectImpl(4, 4, create, deps);
            }
            function imperativeHandleEffect(create, ref) {
              if ("function" === typeof ref) {
                create = create();
                var refCleanup = ref(create);
                return function() {
                  "function" === typeof refCleanup ? refCleanup() : ref(null);
                };
              }
              if (null !== ref && void 0 !== ref)
                return create = create(), ref.current = create, function() {
                  ref.current = null;
                };
            }
            function updateImperativeHandle(ref, create, deps) {
              deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
              updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
            }
            function mountDebugValue() {
            }
            function updateCallback(callback, deps) {
              var hook = updateWorkInProgressHook();
              deps = void 0 === deps ? null : deps;
              var prevState = hook.memoizedState;
              if (null !== deps && areHookInputsEqual(deps, prevState[1]))
                return prevState[0];
              hook.memoizedState = [callback, deps];
              return callback;
            }
            function updateMemo(nextCreate, deps) {
              var hook = updateWorkInProgressHook();
              deps = void 0 === deps ? null : deps;
              var prevState = hook.memoizedState;
              if (null !== deps && areHookInputsEqual(deps, prevState[1]))
                return prevState[0];
              prevState = nextCreate();
              if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                try {
                  nextCreate();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              hook.memoizedState = [prevState, deps];
              return prevState;
            }
            function mountDeferredValueImpl(hook, value, initialValue) {
              if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
                return hook.memoizedState = value;
              hook.memoizedState = initialValue;
              hook = requestDeferredLane();
              currentlyRenderingFiber$1.lanes |= hook;
              workInProgressRootSkippedLanes |= hook;
              return initialValue;
            }
            function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
              if (objectIs(value, prevValue))
                return value;
              if (null !== currentTreeHiddenStackCursor.current)
                return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
              if (0 === (renderLanes & 42))
                return didReceiveUpdate = true, hook.memoizedState = value;
              hook = requestDeferredLane();
              currentlyRenderingFiber$1.lanes |= hook;
              workInProgressRootSkippedLanes |= hook;
              return prevValue;
            }
            function startTransition(fiber, queue, pendingState, finishedState, callback) {
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
              var prevTransition = ReactSharedInternals.T, currentTransition = {};
              ReactSharedInternals.T = currentTransition;
              dispatchOptimisticSetState(fiber, false, queue, pendingState);
              try {
                var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
                  var thenableForFinishedState = chainThenableValue(
                    returnValue,
                    finishedState
                  );
                  dispatchSetStateInternal(
                    fiber,
                    queue,
                    thenableForFinishedState,
                    requestUpdateLane(fiber)
                  );
                } else
                  dispatchSetStateInternal(
                    fiber,
                    queue,
                    finishedState,
                    requestUpdateLane(fiber)
                  );
              } catch (error) {
                dispatchSetStateInternal(
                  fiber,
                  queue,
                  { then: function() {
                  }, status: "rejected", reason: error },
                  requestUpdateLane()
                );
              } finally {
                ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
              }
            }
            function noop$2() {
            }
            function startHostTransition(formFiber, pendingState, action, formData) {
              if (5 !== formFiber.tag)
                throw Error(formatProdErrorMessage(476));
              var queue = ensureFormComponentIsStateful(formFiber).queue;
              startTransition(
                formFiber,
                queue,
                pendingState,
                sharedNotPendingObject,
                null === action ? noop$2 : function() {
                  requestFormReset$1(formFiber);
                  return action(formData);
                }
              );
            }
            function ensureFormComponentIsStateful(formFiber) {
              var existingStateHook = formFiber.memoizedState;
              if (null !== existingStateHook)
                return existingStateHook;
              existingStateHook = {
                memoizedState: sharedNotPendingObject,
                baseState: sharedNotPendingObject,
                baseQueue: null,
                queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: basicStateReducer,
                  lastRenderedState: sharedNotPendingObject
                },
                next: null
              };
              var initialResetState = {};
              existingStateHook.next = {
                memoizedState: initialResetState,
                baseState: initialResetState,
                baseQueue: null,
                queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: basicStateReducer,
                  lastRenderedState: initialResetState
                },
                next: null
              };
              formFiber.memoizedState = existingStateHook;
              formFiber = formFiber.alternate;
              null !== formFiber && (formFiber.memoizedState = existingStateHook);
              return existingStateHook;
            }
            function requestFormReset$1(formFiber) {
              var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
              dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
            }
            function useHostTransitionStatus() {
              return readContext(HostTransitionContext);
            }
            function updateId() {
              return updateWorkInProgressHook().memoizedState;
            }
            function updateRefresh() {
              return updateWorkInProgressHook().memoizedState;
            }
            function refreshCache(fiber) {
              for (var provider = fiber.return; null !== provider; ) {
                switch (provider.tag) {
                  case 24:
                  case 3:
                    var lane = requestUpdateLane();
                    fiber = createUpdate(lane);
                    var root$63 = enqueueUpdate(provider, fiber, lane);
                    null !== root$63 && (scheduleUpdateOnFiber(root$63, provider, lane), entangleTransitions(root$63, provider, lane));
                    provider = { cache: createCache() };
                    fiber.payload = provider;
                    return;
                }
                provider = provider.return;
              }
            }
            function dispatchReducerAction(fiber, queue, action) {
              var lane = requestUpdateLane();
              action = {
                lane,
                revertLane: 0,
                action,
                hasEagerState: false,
                eagerState: null,
                next: null
              };
              isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
            }
            function dispatchSetState(fiber, queue, action) {
              var lane = requestUpdateLane();
              dispatchSetStateInternal(fiber, queue, action, lane);
            }
            function dispatchSetStateInternal(fiber, queue, action, lane) {
              var update = {
                lane,
                revertLane: 0,
                action,
                hasEagerState: false,
                eagerState: null,
                next: null
              };
              if (isRenderPhaseUpdate(fiber))
                enqueueRenderPhaseUpdate(queue, update);
              else {
                var alternate = fiber.alternate;
                if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
                  try {
                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState))
                      return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
                  } catch (error) {
                  } finally {
                  }
                action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (null !== action)
                  return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
              }
              return false;
            }
            function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
              action = {
                lane: 2,
                revertLane: requestTransitionLane(),
                action,
                hasEagerState: false,
                eagerState: null,
                next: null
              };
              if (isRenderPhaseUpdate(fiber)) {
                if (throwIfDuringRender)
                  throw Error(formatProdErrorMessage(479));
              } else
                throwIfDuringRender = enqueueConcurrentHookUpdate(
                  fiber,
                  queue,
                  action,
                  2
                ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
            }
            function isRenderPhaseUpdate(fiber) {
              var alternate = fiber.alternate;
              return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
            }
            function enqueueRenderPhaseUpdate(queue, update) {
              didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            function entangleTransitionUpdate(root2, queue, lane) {
              if (0 !== (lane & 4194176)) {
                var queueLanes = queue.lanes;
                queueLanes &= root2.pendingLanes;
                lane |= queueLanes;
                queue.lanes = lane;
                markRootEntangled(root2, lane);
              }
            }
            var ContextOnlyDispatcher = {
              readContext,
              use,
              useCallback: throwInvalidHookError,
              useContext: throwInvalidHookError,
              useEffect: throwInvalidHookError,
              useImperativeHandle: throwInvalidHookError,
              useLayoutEffect: throwInvalidHookError,
              useInsertionEffect: throwInvalidHookError,
              useMemo: throwInvalidHookError,
              useReducer: throwInvalidHookError,
              useRef: throwInvalidHookError,
              useState: throwInvalidHookError,
              useDebugValue: throwInvalidHookError,
              useDeferredValue: throwInvalidHookError,
              useTransition: throwInvalidHookError,
              useSyncExternalStore: throwInvalidHookError,
              useId: throwInvalidHookError
            };
            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
            ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
            ContextOnlyDispatcher.useFormState = throwInvalidHookError;
            ContextOnlyDispatcher.useActionState = throwInvalidHookError;
            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
            var HooksDispatcherOnMount = {
              readContext,
              use,
              useCallback: function(callback, deps) {
                mountWorkInProgressHook().memoizedState = [
                  callback,
                  void 0 === deps ? null : deps
                ];
                return callback;
              },
              useContext: readContext,
              useEffect: mountEffect,
              useImperativeHandle: function(ref, create, deps) {
                deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
                mountEffectImpl(
                  4194308,
                  4,
                  imperativeHandleEffect.bind(null, create, ref),
                  deps
                );
              },
              useLayoutEffect: function(create, deps) {
                return mountEffectImpl(4194308, 4, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                mountEffectImpl(4, 2, create, deps);
              },
              useMemo: function(nextCreate, deps) {
                var hook = mountWorkInProgressHook();
                deps = void 0 === deps ? null : deps;
                var nextValue = nextCreate();
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                  setIsStrictModeForDevtools(true);
                  try {
                    nextCreate();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                hook.memoizedState = [nextValue, deps];
                return nextValue;
              },
              useReducer: function(reducer, initialArg, init) {
                var hook = mountWorkInProgressHook();
                if (void 0 !== init) {
                  var initialState = init(initialArg);
                  if (shouldDoubleInvokeUserFnsInHooksDEV) {
                    setIsStrictModeForDevtools(true);
                    try {
                      init(initialArg);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                } else
                  initialState = initialArg;
                hook.memoizedState = hook.baseState = initialState;
                reducer = {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: reducer,
                  lastRenderedState: initialState
                };
                hook.queue = reducer;
                reducer = reducer.dispatch = dispatchReducerAction.bind(
                  null,
                  currentlyRenderingFiber$1,
                  reducer
                );
                return [hook.memoizedState, reducer];
              },
              useRef: function(initialValue) {
                var hook = mountWorkInProgressHook();
                initialValue = { current: initialValue };
                return hook.memoizedState = initialValue;
              },
              useState: function(initialState) {
                initialState = mountStateImpl(initialState);
                var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
                queue.dispatch = dispatch;
                return [initialState.memoizedState, dispatch];
              },
              useDebugValue: mountDebugValue,
              useDeferredValue: function(value, initialValue) {
                var hook = mountWorkInProgressHook();
                return mountDeferredValueImpl(hook, value, initialValue);
              },
              useTransition: function() {
                var stateHook = mountStateImpl(false);
                stateHook = startTransition.bind(
                  null,
                  currentlyRenderingFiber$1,
                  stateHook.queue,
                  true,
                  false
                );
                mountWorkInProgressHook().memoizedState = stateHook;
                return [false, stateHook];
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();
                if (isHydrating) {
                  if (void 0 === getServerSnapshot)
                    throw Error(formatProdErrorMessage(407));
                  getServerSnapshot = getServerSnapshot();
                } else {
                  getServerSnapshot = getSnapshot();
                  if (null === workInProgressRoot)
                    throw Error(formatProdErrorMessage(349));
                  0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
                }
                hook.memoizedState = getServerSnapshot;
                var inst = { value: getServerSnapshot, getSnapshot };
                hook.queue = inst;
                mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                  subscribe
                ]);
                fiber.flags |= 2048;
                pushEffect(
                  9,
                  updateStoreInstance.bind(
                    null,
                    fiber,
                    inst,
                    getServerSnapshot,
                    getSnapshot
                  ),
                  { destroy: void 0 },
                  null
                );
                return getServerSnapshot;
              },
              useId: function() {
                var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
                if (isHydrating) {
                  var JSCompiler_inline_result = treeContextOverflow;
                  var idWithLeadingBit = treeContextId;
                  JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
                  identifierPrefix = ":" + identifierPrefix + "R" + JSCompiler_inline_result;
                  JSCompiler_inline_result = localIdCounter++;
                  0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
                  identifierPrefix += ":";
                } else
                  JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + ":";
                return hook.memoizedState = identifierPrefix;
              },
              useCacheRefresh: function() {
                return mountWorkInProgressHook().memoizedState = refreshCache.bind(
                  null,
                  currentlyRenderingFiber$1
                );
              }
            };
            HooksDispatcherOnMount.useMemoCache = useMemoCache;
            HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
            HooksDispatcherOnMount.useFormState = mountActionState;
            HooksDispatcherOnMount.useActionState = mountActionState;
            HooksDispatcherOnMount.useOptimistic = function(passthrough) {
              var hook = mountWorkInProgressHook();
              hook.memoizedState = hook.baseState = passthrough;
              var queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
              };
              hook.queue = queue;
              hook = dispatchOptimisticSetState.bind(
                null,
                currentlyRenderingFiber$1,
                true,
                queue
              );
              queue.dispatch = hook;
              return [passthrough, hook];
            };
            var HooksDispatcherOnUpdate = {
              readContext,
              use,
              useCallback: updateCallback,
              useContext: readContext,
              useEffect: updateEffect,
              useImperativeHandle: updateImperativeHandle,
              useInsertionEffect: updateInsertionEffect,
              useLayoutEffect: updateLayoutEffect,
              useMemo: updateMemo,
              useReducer: updateReducer,
              useRef: updateRef,
              useState: function() {
                return updateReducer(basicStateReducer);
              },
              useDebugValue: mountDebugValue,
              useDeferredValue: function(value, initialValue) {
                var hook = updateWorkInProgressHook();
                return updateDeferredValueImpl(
                  hook,
                  currentHook.memoizedState,
                  value,
                  initialValue
                );
              },
              useTransition: function() {
                var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
                return [
                  "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
                  start
                ];
              },
              useSyncExternalStore: updateSyncExternalStore,
              useId: updateId
            };
            HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
            HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
            HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
            HooksDispatcherOnUpdate.useFormState = updateActionState;
            HooksDispatcherOnUpdate.useActionState = updateActionState;
            HooksDispatcherOnUpdate.useOptimistic = function(passthrough, reducer) {
              var hook = updateWorkInProgressHook();
              return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
            };
            var HooksDispatcherOnRerender = {
              readContext,
              use,
              useCallback: updateCallback,
              useContext: readContext,
              useEffect: updateEffect,
              useImperativeHandle: updateImperativeHandle,
              useInsertionEffect: updateInsertionEffect,
              useLayoutEffect: updateLayoutEffect,
              useMemo: updateMemo,
              useReducer: rerenderReducer,
              useRef: updateRef,
              useState: function() {
                return rerenderReducer(basicStateReducer);
              },
              useDebugValue: mountDebugValue,
              useDeferredValue: function(value, initialValue) {
                var hook = updateWorkInProgressHook();
                return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
                  hook,
                  currentHook.memoizedState,
                  value,
                  initialValue
                );
              },
              useTransition: function() {
                var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
                return [
                  "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
                  start
                ];
              },
              useSyncExternalStore: updateSyncExternalStore,
              useId: updateId
            };
            HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
            HooksDispatcherOnRerender.useMemoCache = useMemoCache;
            HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
            HooksDispatcherOnRerender.useFormState = rerenderActionState;
            HooksDispatcherOnRerender.useActionState = rerenderActionState;
            HooksDispatcherOnRerender.useOptimistic = function(passthrough, reducer) {
              var hook = updateWorkInProgressHook();
              if (null !== currentHook)
                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
              hook.baseState = passthrough;
              return [passthrough, hook.queue.dispatch];
            };
            function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
              ctor = workInProgress2.memoizedState;
              getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
              getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
              workInProgress2.memoizedState = getDerivedStateFromProps;
              0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
            }
            var classComponentUpdater = {
              isMounted: function(component) {
                return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : false;
              },
              enqueueSetState: function(inst, payload, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.payload = payload;
                void 0 !== callback && null !== callback && (update.callback = callback);
                payload = enqueueUpdate(inst, update, lane);
                null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
              },
              enqueueReplaceState: function(inst, payload, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.tag = 1;
                update.payload = payload;
                void 0 !== callback && null !== callback && (update.callback = callback);
                payload = enqueueUpdate(inst, update, lane);
                null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
              },
              enqueueForceUpdate: function(inst, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.tag = 2;
                void 0 !== callback && null !== callback && (update.callback = callback);
                callback = enqueueUpdate(inst, update, lane);
                null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
              }
            };
            function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
              workInProgress2 = workInProgress2.stateNode;
              return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
            }
            function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
              workInProgress2 = instance.state;
              "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
              "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
              instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
            function resolveClassComponentProps(Component, baseProps) {
              var newProps = baseProps;
              if ("ref" in baseProps) {
                newProps = {};
                for (var propName in baseProps)
                  "ref" !== propName && (newProps[propName] = baseProps[propName]);
              }
              if (Component = Component.defaultProps) {
                newProps === baseProps && (newProps = assign({}, newProps));
                for (var propName$67 in Component)
                  void 0 === newProps[propName$67] && (newProps[propName$67] = Component[propName$67]);
              }
              return newProps;
            }
            var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
              if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent("error", {
                  bubbles: true,
                  cancelable: true,
                  message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                  error
                });
                if (!window.dispatchEvent(event))
                  return;
              } else if ("object" === typeof process && "function" === typeof process.emit) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            };
            function defaultOnUncaughtError(error) {
              reportGlobalError(error);
            }
            function defaultOnCaughtError(error) {
              console.error(error);
            }
            function defaultOnRecoverableError(error) {
              reportGlobalError(error);
            }
            function logUncaughtError(root2, errorInfo) {
              try {
                var onUncaughtError = root2.onUncaughtError;
                onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
              } catch (e$68) {
                setTimeout(function() {
                  throw e$68;
                });
              }
            }
            function logCaughtError(root2, boundary, errorInfo) {
              try {
                var onCaughtError = root2.onCaughtError;
                onCaughtError(errorInfo.value, {
                  componentStack: errorInfo.stack,
                  errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
                });
              } catch (e$69) {
                setTimeout(function() {
                  throw e$69;
                });
              }
            }
            function createRootErrorUpdate(root2, errorInfo, lane) {
              lane = createUpdate(lane);
              lane.tag = 3;
              lane.payload = { element: null };
              lane.callback = function() {
                logUncaughtError(root2, errorInfo);
              };
              return lane;
            }
            function createClassErrorUpdate(lane) {
              lane = createUpdate(lane);
              lane.tag = 3;
              return lane;
            }
            function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
              var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
              if ("function" === typeof getDerivedStateFromError) {
                var error = errorInfo.value;
                update.payload = function() {
                  return getDerivedStateFromError(error);
                };
                update.callback = function() {
                  logCaughtError(root2, fiber, errorInfo);
                };
              }
              var inst = fiber.stateNode;
              null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
                logCaughtError(root2, fiber, errorInfo);
                "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
                var stack = errorInfo.stack;
                this.componentDidCatch(errorInfo.value, {
                  componentStack: null !== stack ? stack : ""
                });
              });
            }
            function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
              sourceFiber.flags |= 32768;
              if (null !== value && "object" === typeof value && "function" === typeof value.then) {
                returnFiber = sourceFiber.alternate;
                null !== returnFiber && propagateParentContextChanges(
                  returnFiber,
                  sourceFiber,
                  rootRenderLanes,
                  true
                );
                sourceFiber = suspenseHandlerStackCursor.current;
                if (null !== sourceFiber) {
                  switch (sourceFiber.tag) {
                    case 13:
                      return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                    case 22:
                      return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: /* @__PURE__ */ new Set([value])
                      }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
                  }
                  throw Error(formatProdErrorMessage(435, sourceFiber.tag));
                }
                attachPingListener(root2, value, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return false;
              }
              if (isHydrating)
                return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
                  cause: value
                }), queueHydrationError(
                  createCapturedValueAtFiber(returnFiber, sourceFiber)
                )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
                  root2.stateNode,
                  value,
                  rootRenderLanes
                ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
              var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
              wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
              null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
              4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
              if (null === returnFiber)
                return true;
              value = createCapturedValueAtFiber(value, sourceFiber);
              sourceFiber = returnFiber;
              do {
                switch (sourceFiber.tag) {
                  case 3:
                    return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
                  case 1:
                    if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                      return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                        rootRenderLanes,
                        root2,
                        sourceFiber,
                        value
                      ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
                }
                sourceFiber = sourceFiber.return;
              } while (null !== sourceFiber);
              return false;
            }
            var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
            function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
              workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
                workInProgress2,
                current.child,
                nextChildren,
                renderLanes2
              );
            }
            function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
              Component = Component.render;
              var ref = workInProgress2.ref;
              if ("ref" in nextProps) {
                var propsWithoutRef = {};
                for (var key in nextProps)
                  "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
              } else
                propsWithoutRef = nextProps;
              prepareToReadContext(workInProgress2);
              nextProps = renderWithHooks(
                current,
                workInProgress2,
                Component,
                propsWithoutRef,
                ref,
                renderLanes2
              );
              key = checkDidRenderIdHook();
              if (null !== current && !didReceiveUpdate)
                return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
              isHydrating && key && pushMaterializedTreeId(workInProgress2);
              workInProgress2.flags |= 1;
              reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
              return workInProgress2.child;
            }
            function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
              if (null === current) {
                var type = Component.type;
                if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
                  return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
                    current,
                    workInProgress2,
                    type,
                    nextProps,
                    renderLanes2
                  );
                current = createFiberFromTypeAndProps(
                  Component.type,
                  null,
                  nextProps,
                  workInProgress2,
                  workInProgress2.mode,
                  renderLanes2
                );
                current.ref = workInProgress2.ref;
                current.return = workInProgress2;
                return workInProgress2.child = current;
              }
              type = current.child;
              if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
                var prevProps = type.memoizedProps;
                Component = Component.compare;
                Component = null !== Component ? Component : shallowEqual;
                if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
                  return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
              }
              workInProgress2.flags |= 1;
              current = createWorkInProgress(type, nextProps);
              current.ref = workInProgress2.ref;
              current.return = workInProgress2;
              return workInProgress2.child = current;
            }
            function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
              if (null !== current) {
                var prevProps = current.memoizedProps;
                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
                  if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
                    0 !== (current.flags & 131072) && (didReceiveUpdate = true);
                  else
                    return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
              }
              return updateFunctionComponent(
                current,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            }
            function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
              var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress2.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;
              markRef(current, workInProgress2);
              if ("hidden" === nextProps.mode || nextIsDetached) {
                if (0 !== (workInProgress2.flags & 128)) {
                  nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
                  if (null !== current) {
                    nextChildren = workInProgress2.child = current.child;
                    for (nextIsDetached = 0; null !== nextChildren; )
                      nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                    workInProgress2.childLanes = nextIsDetached & ~nextProps;
                  } else
                    workInProgress2.childLanes = 0, workInProgress2.child = null;
                  return deferHiddenOffscreenComponent(
                    current,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                }
                if (0 !== (renderLanes2 & 536870912))
                  workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
                    workInProgress2,
                    null !== prevState ? prevState.cachePool : null
                  ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
                else
                  return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                    current,
                    workInProgress2,
                    null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                    renderLanes2
                  );
              } else
                null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
              reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
              return workInProgress2.child;
            }
            function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
              var JSCompiler_inline_result = peekCacheFromPool();
              JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
              workInProgress2.memoizedState = {
                baseLanes: nextBaseLanes,
                cachePool: JSCompiler_inline_result
              };
              null !== current && pushTransition(workInProgress2, null);
              reuseHiddenContextOnStack();
              pushOffscreenSuspenseHandler(workInProgress2);
              null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
              return null;
            }
            function markRef(current, workInProgress2) {
              var ref = workInProgress2.ref;
              if (null === ref)
                null !== current && null !== current.ref && (workInProgress2.flags |= 2097664);
              else {
                if ("function" !== typeof ref && "object" !== typeof ref)
                  throw Error(formatProdErrorMessage(284));
                if (null === current || current.ref !== ref)
                  workInProgress2.flags |= 2097664;
              }
            }
            function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
              prepareToReadContext(workInProgress2);
              Component = renderWithHooks(
                current,
                workInProgress2,
                Component,
                nextProps,
                void 0,
                renderLanes2
              );
              nextProps = checkDidRenderIdHook();
              if (null !== current && !didReceiveUpdate)
                return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
              isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
              workInProgress2.flags |= 1;
              reconcileChildren(current, workInProgress2, Component, renderLanes2);
              return workInProgress2.child;
            }
            function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
              prepareToReadContext(workInProgress2);
              workInProgress2.updateQueue = null;
              nextProps = renderWithHooksAgain(
                workInProgress2,
                Component,
                nextProps,
                secondArg
              );
              finishRenderingHooks(current);
              Component = checkDidRenderIdHook();
              if (null !== current && !didReceiveUpdate)
                return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
              isHydrating && Component && pushMaterializedTreeId(workInProgress2);
              workInProgress2.flags |= 1;
              reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
              return workInProgress2.child;
            }
            function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
              prepareToReadContext(workInProgress2);
              if (null === workInProgress2.stateNode) {
                var context = emptyContextObject, contextType = Component.contextType;
                "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
                context = new Component(nextProps, context);
                workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
                context.updater = classComponentUpdater;
                workInProgress2.stateNode = context;
                context._reactInternals = workInProgress2;
                context = workInProgress2.stateNode;
                context.props = nextProps;
                context.state = workInProgress2.memoizedState;
                context.refs = {};
                initializeUpdateQueue(workInProgress2);
                contextType = Component.contextType;
                context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
                context.state = workInProgress2.memoizedState;
                contextType = Component.getDerivedStateFromProps;
                "function" === typeof contextType && (applyDerivedStateFromProps(
                  workInProgress2,
                  Component,
                  contextType,
                  nextProps
                ), context.state = workInProgress2.memoizedState);
                "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
                "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
                nextProps = true;
              } else if (null === current) {
                context = workInProgress2.stateNode;
                var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
                context.props = oldProps;
                var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
                contextType = emptyContextObject;
                "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
                var getDerivedStateFromProps = Component.getDerivedStateFromProps;
                contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
                unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
                contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
                  workInProgress2,
                  context,
                  nextProps,
                  contextType
                );
                hasForceUpdate = false;
                var oldState = workInProgress2.memoizedState;
                context.state = oldState;
                processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
                suspendIfUpdateReadFromEntangledAsyncAction();
                oldContext = workInProgress2.memoizedState;
                unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
                  workInProgress2,
                  Component,
                  getDerivedStateFromProps,
                  nextProps
                ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
                  workInProgress2,
                  Component,
                  oldProps,
                  nextProps,
                  oldState,
                  oldContext,
                  contextType
                )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
              } else {
                context = workInProgress2.stateNode;
                cloneUpdateQueue(current, workInProgress2);
                contextType = workInProgress2.memoizedProps;
                contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
                context.props = contextType$jscomp$0;
                getDerivedStateFromProps = workInProgress2.pendingProps;
                oldState = context.context;
                oldContext = Component.contextType;
                oldProps = emptyContextObject;
                "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
                unresolvedOldProps = Component.getDerivedStateFromProps;
                (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
                  workInProgress2,
                  context,
                  nextProps,
                  oldProps
                );
                hasForceUpdate = false;
                oldState = workInProgress2.memoizedState;
                context.state = oldState;
                processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
                suspendIfUpdateReadFromEntangledAsyncAction();
                var newState = workInProgress2.memoizedState;
                contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
                  workInProgress2,
                  Component,
                  unresolvedOldProps,
                  nextProps
                ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
                  workInProgress2,
                  Component,
                  contextType$jscomp$0,
                  nextProps,
                  oldState,
                  newState,
                  oldProps
                ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
              }
              context = nextProps;
              markRef(current, workInProgress2);
              nextProps = 0 !== (workInProgress2.flags & 128);
              context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                current.child,
                null,
                renderLanes2
              ), workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                Component,
                renderLanes2
              )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return current;
            }
            function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
              resetHydrationState();
              workInProgress2.flags |= 256;
              reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
              return workInProgress2.child;
            }
            var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
            function mountSuspenseOffscreenState(renderLanes2) {
              return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
            }
            function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
              current = null !== current ? current.childLanes & ~renderLanes2 : 0;
              primaryTreeDidDefer && (current |= workInProgressDeferredLane);
              return current;
            }
            function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
              var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
              (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
              JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
              JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
              workInProgress2.flags &= -33;
              if (null === current) {
                if (isHydrating) {
                  showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
                  if (isHydrating) {
                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
                    if (JSCompiler_temp$jscomp$0 = nextInstance) {
                      c: {
                        JSCompiler_temp$jscomp$0 = nextInstance;
                        for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                          if (!nextInstance) {
                            nextInstance = null;
                            break c;
                          }
                          JSCompiler_temp$jscomp$0 = getNextHydratable(
                            JSCompiler_temp$jscomp$0.nextSibling
                          );
                          if (null === JSCompiler_temp$jscomp$0) {
                            nextInstance = null;
                            break c;
                          }
                        }
                        nextInstance = JSCompiler_temp$jscomp$0;
                      }
                      null !== nextInstance ? (workInProgress2.memoizedState = {
                        dehydrated: nextInstance,
                        treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                        retryLane: 536870912
                      }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                        18,
                        null,
                        null,
                        0
                      ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
                    }
                    JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
                  }
                  nextInstance = workInProgress2.memoizedState;
                  if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
                    return "$!" === nextInstance.data ? workInProgress2.lanes = 16 : workInProgress2.lanes = 536870912, null;
                  popSuspenseHandler(workInProgress2);
                }
                nextInstance = nextProps.children;
                nextProps = nextProps.fallback;
                if (showFallback)
                  return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
                    { mode: "hidden", children: nextInstance },
                    showFallback
                  ), nextProps = createFiberFromFragment(
                    nextProps,
                    showFallback,
                    renderLanes2,
                    null
                  ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
                    current,
                    JSCompiler_temp,
                    renderLanes2
                  ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
              }
              JSCompiler_temp$jscomp$0 = current.memoizedState;
              if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
                if (didSuspend)
                  workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                    current,
                    workInProgress2,
                    renderLanes2
                  )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
                    { mode: "visible", children: nextProps.children },
                    nextInstance
                  ), showFallback = createFiberFromFragment(
                    showFallback,
                    nextInstance,
                    renderLanes2,
                    null
                  ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
                    workInProgress2,
                    current.child,
                    null,
                    renderLanes2
                  ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
                    current,
                    JSCompiler_temp,
                    renderLanes2
                  ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
                else if (pushPrimaryTreeSuspenseHandler(workInProgress2), "$!" === nextInstance.data) {
                  JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
                  if (JSCompiler_temp)
                    var digest = JSCompiler_temp.dgst;
                  JSCompiler_temp = digest;
                  nextProps = Error(formatProdErrorMessage(419));
                  nextProps.stack = "";
                  nextProps.digest = JSCompiler_temp;
                  queueHydrationError({ value: nextProps, source: null, stack: null });
                  workInProgress2 = retrySuspenseComponentWithoutHydrating(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
                  JSCompiler_temp = workInProgressRoot;
                  if (null !== JSCompiler_temp) {
                    nextProps = renderLanes2 & -renderLanes2;
                    if (0 !== (nextProps & 42))
                      nextProps = 1;
                    else
                      switch (nextProps) {
                        case 2:
                          nextProps = 1;
                          break;
                        case 8:
                          nextProps = 4;
                          break;
                        case 32:
                          nextProps = 16;
                          break;
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                          nextProps = 64;
                          break;
                        case 268435456:
                          nextProps = 134217728;
                          break;
                        default:
                          nextProps = 0;
                      }
                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps;
                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
                      throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
                  }
                  "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
                  workInProgress2 = retrySuspenseComponentWithoutHydrating(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                } else
                  "$?" === nextInstance.data ? (workInProgress2.flags |= 128, workInProgress2.child = current.child, workInProgress2 = retryDehydratedSuspenseBoundary.bind(
                    null,
                    current
                  ), nextInstance._reactRetry = workInProgress2, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
                    nextInstance.nextSibling
                  ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                    workInProgress2,
                    nextProps.children
                  ), workInProgress2.flags |= 4096);
                return workInProgress2;
              }
              if (showFallback)
                return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
                  mode: "hidden",
                  children: nextProps.children
                }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
                  showFallback,
                  nextInstance,
                  renderLanes2,
                  null
                ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
                  baseLanes: nextInstance.baseLanes | renderLanes2,
                  cachePool: JSCompiler_temp$jscomp$0
                }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
                  current,
                  JSCompiler_temp,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              renderLanes2 = current.child;
              current = renderLanes2.sibling;
              renderLanes2 = createWorkInProgress(renderLanes2, {
                mode: "visible",
                children: nextProps.children
              });
              renderLanes2.return = workInProgress2;
              renderLanes2.sibling = null;
              null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
              workInProgress2.child = renderLanes2;
              workInProgress2.memoizedState = null;
              return renderLanes2;
            }
            function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
              primaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "visible", children: primaryChildren },
                workInProgress2.mode
              );
              primaryChildren.return = workInProgress2;
              return workInProgress2.child = primaryChildren;
            }
            function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
              return createFiberFromOffscreen(offscreenProps, mode, 0, null);
            }
            function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
              reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
              current = mountSuspensePrimaryChildren(
                workInProgress2,
                workInProgress2.pendingProps.children
              );
              current.flags |= 2;
              workInProgress2.memoizedState = null;
              return current;
            }
            function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
              fiber.lanes |= renderLanes2;
              var alternate = fiber.alternate;
              null !== alternate && (alternate.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
            }
            function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
              var renderState = workInProgress2.memoizedState;
              null === renderState ? workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
            }
            function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
              var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
              reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
              nextProps = suspenseStackCursor.current;
              if (0 !== (nextProps & 2))
                nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
              else {
                if (null !== current && 0 !== (current.flags & 128))
                  a:
                    for (current = workInProgress2.child; null !== current; ) {
                      if (13 === current.tag)
                        null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
                      else if (19 === current.tag)
                        scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
                      else if (null !== current.child) {
                        current.child.return = current;
                        current = current.child;
                        continue;
                      }
                      if (current === workInProgress2)
                        break a;
                      for (; null === current.sibling; ) {
                        if (null === current.return || current.return === workInProgress2)
                          break a;
                        current = current.return;
                      }
                      current.sibling.return = current.return;
                      current = current.sibling;
                    }
                nextProps &= 1;
              }
              push(suspenseStackCursor, nextProps);
              switch (revealOrder) {
                case "forwards":
                  renderLanes2 = workInProgress2.child;
                  for (revealOrder = null; null !== renderLanes2; )
                    current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
                  renderLanes2 = revealOrder;
                  null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    revealOrder,
                    renderLanes2,
                    tailMode
                  );
                  break;
                case "backwards":
                  renderLanes2 = null;
                  revealOrder = workInProgress2.child;
                  for (workInProgress2.child = null; null !== revealOrder; ) {
                    current = revealOrder.alternate;
                    if (null !== current && null === findFirstSuspended(current)) {
                      workInProgress2.child = revealOrder;
                      break;
                    }
                    current = revealOrder.sibling;
                    revealOrder.sibling = renderLanes2;
                    renderLanes2 = revealOrder;
                    revealOrder = current;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    renderLanes2,
                    null,
                    tailMode
                  );
                  break;
                case "together":
                  initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
                  break;
                default:
                  workInProgress2.memoizedState = null;
              }
              return workInProgress2.child;
            }
            function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
              null !== current && (workInProgress2.dependencies = current.dependencies);
              workInProgressRootSkippedLanes |= workInProgress2.lanes;
              if (0 === (renderLanes2 & workInProgress2.childLanes))
                if (null !== current) {
                  if (propagateParentContextChanges(
                    current,
                    workInProgress2,
                    renderLanes2,
                    false
                  ), 0 === (renderLanes2 & workInProgress2.childLanes))
                    return null;
                } else
                  return null;
              if (null !== current && workInProgress2.child !== current.child)
                throw Error(formatProdErrorMessage(153));
              if (null !== workInProgress2.child) {
                current = workInProgress2.child;
                renderLanes2 = createWorkInProgress(current, current.pendingProps);
                workInProgress2.child = renderLanes2;
                for (renderLanes2.return = workInProgress2; null !== current.sibling; )
                  current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
                renderLanes2.sibling = null;
              }
              return workInProgress2.child;
            }
            function checkScheduledUpdateOrContext(current, renderLanes2) {
              if (0 !== (current.lanes & renderLanes2))
                return true;
              current = current.dependencies;
              return null !== current && checkIfContextChanged(current) ? true : false;
            }
            function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
              switch (workInProgress2.tag) {
                case 3:
                  pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                  pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
                  resetHydrationState();
                  break;
                case 27:
                case 5:
                  pushHostContext(workInProgress2);
                  break;
                case 4:
                  pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                  break;
                case 10:
                  pushProvider(
                    workInProgress2,
                    workInProgress2.type,
                    workInProgress2.memoizedProps.value
                  );
                  break;
                case 13:
                  var state = workInProgress2.memoizedState;
                  if (null !== state) {
                    if (null !== state.dehydrated)
                      return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                    if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                      return updateSuspenseComponent(current, workInProgress2, renderLanes2);
                    pushPrimaryTreeSuspenseHandler(workInProgress2);
                    current = bailoutOnAlreadyFinishedWork(
                      current,
                      workInProgress2,
                      renderLanes2
                    );
                    return null !== current ? current.sibling : null;
                  }
                  pushPrimaryTreeSuspenseHandler(workInProgress2);
                  break;
                case 19:
                  var didSuspendBefore = 0 !== (current.flags & 128);
                  state = 0 !== (renderLanes2 & workInProgress2.childLanes);
                  state || (propagateParentContextChanges(
                    current,
                    workInProgress2,
                    renderLanes2,
                    false
                  ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
                  if (didSuspendBefore) {
                    if (state)
                      return updateSuspenseListComponent(
                        current,
                        workInProgress2,
                        renderLanes2
                      );
                    workInProgress2.flags |= 128;
                  }
                  didSuspendBefore = workInProgress2.memoizedState;
                  null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
                  push(suspenseStackCursor, suspenseStackCursor.current);
                  if (state)
                    break;
                  else
                    return null;
                case 22:
                case 23:
                  return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
                case 24:
                  pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
              }
              return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
            }
            function beginWork(current, workInProgress2, renderLanes2) {
              if (null !== current)
                if (current.memoizedProps !== workInProgress2.pendingProps)
                  didReceiveUpdate = true;
                else {
                  if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
                    return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                      current,
                      workInProgress2,
                      renderLanes2
                    );
                  didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
                }
              else
                didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
              workInProgress2.lanes = 0;
              switch (workInProgress2.tag) {
                case 16:
                  a: {
                    current = workInProgress2.pendingProps;
                    var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
                    lazyComponent = init(lazyComponent._payload);
                    workInProgress2.type = lazyComponent;
                    if ("function" === typeof lazyComponent)
                      shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                        null,
                        workInProgress2,
                        lazyComponent,
                        current,
                        renderLanes2
                      )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                        null,
                        workInProgress2,
                        lazyComponent,
                        current,
                        renderLanes2
                      ));
                    else {
                      if (void 0 !== lazyComponent && null !== lazyComponent) {
                        if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                          workInProgress2.tag = 11;
                          workInProgress2 = updateForwardRef(
                            null,
                            workInProgress2,
                            lazyComponent,
                            current,
                            renderLanes2
                          );
                          break a;
                        } else if (init === REACT_MEMO_TYPE) {
                          workInProgress2.tag = 14;
                          workInProgress2 = updateMemoComponent(
                            null,
                            workInProgress2,
                            lazyComponent,
                            current,
                            renderLanes2
                          );
                          break a;
                        }
                      }
                      workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                      throw Error(formatProdErrorMessage(306, workInProgress2, ""));
                    }
                  }
                  return workInProgress2;
                case 0:
                  return updateFunctionComponent(
                    current,
                    workInProgress2,
                    workInProgress2.type,
                    workInProgress2.pendingProps,
                    renderLanes2
                  );
                case 1:
                  return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
                    lazyComponent,
                    workInProgress2.pendingProps
                  ), updateClassComponent(
                    current,
                    workInProgress2,
                    lazyComponent,
                    init,
                    renderLanes2
                  );
                case 3:
                  a: {
                    pushHostContainer(
                      workInProgress2,
                      workInProgress2.stateNode.containerInfo
                    );
                    if (null === current)
                      throw Error(formatProdErrorMessage(387));
                    var nextProps = workInProgress2.pendingProps;
                    init = workInProgress2.memoizedState;
                    lazyComponent = init.element;
                    cloneUpdateQueue(current, workInProgress2);
                    processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
                    var nextState = workInProgress2.memoizedState;
                    nextProps = nextState.cache;
                    pushProvider(workInProgress2, CacheContext, nextProps);
                    nextProps !== init.cache && propagateContextChanges(
                      workInProgress2,
                      [CacheContext],
                      renderLanes2,
                      true
                    );
                    suspendIfUpdateReadFromEntangledAsyncAction();
                    nextProps = nextState.element;
                    if (init.isDehydrated)
                      if (init = {
                        element: nextProps,
                        isDehydrated: false,
                        cache: nextState.cache
                      }, workInProgress2.updateQueue.baseState = init, workInProgress2.memoizedState = init, workInProgress2.flags & 256) {
                        workInProgress2 = mountHostRootWithoutHydrating(
                          current,
                          workInProgress2,
                          nextProps,
                          renderLanes2
                        );
                        break a;
                      } else if (nextProps !== lazyComponent) {
                        lazyComponent = createCapturedValueAtFiber(
                          Error(formatProdErrorMessage(424)),
                          workInProgress2
                        );
                        queueHydrationError(lazyComponent);
                        workInProgress2 = mountHostRootWithoutHydrating(
                          current,
                          workInProgress2,
                          nextProps,
                          renderLanes2
                        );
                        break a;
                      } else
                        for (nextHydratableInstance = getNextHydratable(
                          workInProgress2.stateNode.containerInfo.firstChild
                        ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = true, renderLanes2 = mountChildFibers(
                          workInProgress2,
                          null,
                          nextProps,
                          renderLanes2
                        ), workInProgress2.child = renderLanes2; renderLanes2; )
                          renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                    else {
                      resetHydrationState();
                      if (nextProps === lazyComponent) {
                        workInProgress2 = bailoutOnAlreadyFinishedWork(
                          current,
                          workInProgress2,
                          renderLanes2
                        );
                        break a;
                      }
                      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
                    }
                    workInProgress2 = workInProgress2.child;
                  }
                  return workInProgress2;
                case 26:
                  return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
                    workInProgress2.type,
                    null,
                    workInProgress2.pendingProps,
                    null
                  )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
                    rootInstanceStackCursor.current
                  ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
                    workInProgress2.type,
                    current.memoizedProps,
                    workInProgress2.pendingProps,
                    current.memoizedState
                  ), null;
                case 27:
                  return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
                    workInProgress2.type,
                    workInProgress2.pendingProps,
                    rootInstanceStackCursor.current
                  ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getNextHydratable(
                    lazyComponent.firstChild
                  )), lazyComponent = workInProgress2.pendingProps.children, null !== current || isHydrating ? reconcileChildren(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  ) : workInProgress2.child = reconcileChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  ), markRef(current, workInProgress2), workInProgress2.child;
                case 5:
                  if (null === current && isHydrating) {
                    if (init = lazyComponent = nextHydratableInstance)
                      lazyComponent = canHydrateInstance(
                        lazyComponent,
                        workInProgress2.type,
                        workInProgress2.pendingProps,
                        rootOrSingletonContext
                      ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                        lazyComponent.firstChild
                      ), rootOrSingletonContext = false, init = true) : init = false;
                    init || throwOnHydrationMismatch(workInProgress2);
                  }
                  pushHostContext(workInProgress2);
                  init = workInProgress2.type;
                  nextProps = workInProgress2.pendingProps;
                  nextState = null !== current ? current.memoizedProps : null;
                  lazyComponent = nextProps.children;
                  shouldSetTextContent(init, nextProps) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
                  null !== workInProgress2.memoizedState && (init = renderWithHooks(
                    current,
                    workInProgress2,
                    TransitionAwareHostComponent,
                    null,
                    null,
                    renderLanes2
                  ), HostTransitionContext._currentValue = init);
                  markRef(current, workInProgress2);
                  reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
                  return workInProgress2.child;
                case 6:
                  if (null === current && isHydrating) {
                    if (current = renderLanes2 = nextHydratableInstance)
                      renderLanes2 = canHydrateTextInstance(
                        renderLanes2,
                        workInProgress2.pendingProps,
                        rootOrSingletonContext
                      ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
                    current || throwOnHydrationMismatch(workInProgress2);
                  }
                  return null;
                case 13:
                  return updateSuspenseComponent(current, workInProgress2, renderLanes2);
                case 4:
                  return pushHostContainer(
                    workInProgress2,
                    workInProgress2.stateNode.containerInfo
                  ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  ) : reconcileChildren(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  ), workInProgress2.child;
                case 11:
                  return updateForwardRef(
                    current,
                    workInProgress2,
                    workInProgress2.type,
                    workInProgress2.pendingProps,
                    renderLanes2
                  );
                case 7:
                  return reconcileChildren(
                    current,
                    workInProgress2,
                    workInProgress2.pendingProps,
                    renderLanes2
                  ), workInProgress2.child;
                case 8:
                  return reconcileChildren(
                    current,
                    workInProgress2,
                    workInProgress2.pendingProps.children,
                    renderLanes2
                  ), workInProgress2.child;
                case 12:
                  return reconcileChildren(
                    current,
                    workInProgress2,
                    workInProgress2.pendingProps.children,
                    renderLanes2
                  ), workInProgress2.child;
                case 10:
                  return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
                    current,
                    workInProgress2,
                    lazyComponent.children,
                    renderLanes2
                  ), workInProgress2.child;
                case 9:
                  return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
                case 14:
                  return updateMemoComponent(
                    current,
                    workInProgress2,
                    workInProgress2.type,
                    workInProgress2.pendingProps,
                    renderLanes2
                  );
                case 15:
                  return updateSimpleMemoComponent(
                    current,
                    workInProgress2,
                    workInProgress2.type,
                    workInProgress2.pendingProps,
                    renderLanes2
                  );
                case 19:
                  return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
                case 22:
                  return updateOffscreenComponent(current, workInProgress2, renderLanes2);
                case 24:
                  return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, nextProps = createCache(), init.pooledCache = nextProps, nextProps.refCount++, null !== nextProps && (init.pooledCacheLanes |= renderLanes2), init = nextProps), workInProgress2.memoizedState = {
                    parent: lazyComponent,
                    cache: init
                  }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, nextProps = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = nextProps.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
                    workInProgress2,
                    [CacheContext],
                    renderLanes2,
                    true
                  ))), reconcileChildren(
                    current,
                    workInProgress2,
                    workInProgress2.pendingProps.children,
                    renderLanes2
                  ), workInProgress2.child;
                case 29:
                  throw workInProgress2.pendingProps;
              }
              throw Error(formatProdErrorMessage(156, workInProgress2.tag));
            }
            var valueCursor = createCursor(null), currentlyRenderingFiber = null, lastContextDependency = null;
            function pushProvider(providerFiber, context, nextValue) {
              push(valueCursor, context._currentValue);
              context._currentValue = nextValue;
            }
            function popProvider(context) {
              context._currentValue = valueCursor.current;
              pop(valueCursor);
            }
            function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
              for (; null !== parent; ) {
                var alternate = parent.alternate;
                (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
                if (parent === propagationRoot)
                  break;
                parent = parent.return;
              }
            }
            function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
              var fiber = workInProgress2.child;
              null !== fiber && (fiber.return = workInProgress2);
              for (; null !== fiber; ) {
                var list = fiber.dependencies;
                if (null !== list) {
                  var nextFiber = fiber.child;
                  list = list.firstContext;
                  a:
                    for (; null !== list; ) {
                      var dependency = list;
                      list = fiber;
                      for (var i = 0; i < contexts.length; i++)
                        if (dependency.context === contexts[i]) {
                          list.lanes |= renderLanes2;
                          dependency = list.alternate;
                          null !== dependency && (dependency.lanes |= renderLanes2);
                          scheduleContextWorkOnParentPath(
                            list.return,
                            renderLanes2,
                            workInProgress2
                          );
                          forcePropagateEntireTree || (nextFiber = null);
                          break a;
                        }
                      list = dependency.next;
                    }
                } else if (18 === fiber.tag) {
                  nextFiber = fiber.return;
                  if (null === nextFiber)
                    throw Error(formatProdErrorMessage(341));
                  nextFiber.lanes |= renderLanes2;
                  list = nextFiber.alternate;
                  null !== list && (list.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
                  nextFiber = null;
                } else
                  nextFiber = fiber.child;
                if (null !== nextFiber)
                  nextFiber.return = fiber;
                else
                  for (nextFiber = fiber; null !== nextFiber; ) {
                    if (nextFiber === workInProgress2) {
                      nextFiber = null;
                      break;
                    }
                    fiber = nextFiber.sibling;
                    if (null !== fiber) {
                      fiber.return = nextFiber.return;
                      nextFiber = fiber;
                      break;
                    }
                    nextFiber = nextFiber.return;
                  }
                fiber = nextFiber;
              }
            }
            function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
              current = null;
              for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
                if (!isInsidePropagationBailout) {
                  if (0 !== (parent.flags & 524288))
                    isInsidePropagationBailout = true;
                  else if (0 !== (parent.flags & 262144))
                    break;
                }
                if (10 === parent.tag) {
                  var currentParent = parent.alternate;
                  if (null === currentParent)
                    throw Error(formatProdErrorMessage(387));
                  currentParent = currentParent.memoizedProps;
                  if (null !== currentParent) {
                    var context = parent.type;
                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
                  }
                } else if (parent === hostTransitionProviderCursor.current) {
                  currentParent = parent.alternate;
                  if (null === currentParent)
                    throw Error(formatProdErrorMessage(387));
                  currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
                }
                parent = parent.return;
              }
              null !== current && propagateContextChanges(
                workInProgress2,
                current,
                renderLanes2,
                forcePropagateEntireTree
              );
              workInProgress2.flags |= 262144;
            }
            function checkIfContextChanged(currentDependencies) {
              for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
                if (!objectIs(
                  currentDependencies.context._currentValue,
                  currentDependencies.memoizedValue
                ))
                  return true;
                currentDependencies = currentDependencies.next;
              }
              return false;
            }
            function prepareToReadContext(workInProgress2) {
              currentlyRenderingFiber = workInProgress2;
              lastContextDependency = null;
              workInProgress2 = workInProgress2.dependencies;
              null !== workInProgress2 && (workInProgress2.firstContext = null);
            }
            function readContext(context) {
              return readContextForConsumer(currentlyRenderingFiber, context);
            }
            function readContextDuringReconciliation(consumer, context) {
              null === currentlyRenderingFiber && prepareToReadContext(consumer);
              return readContextForConsumer(consumer, context);
            }
            function readContextForConsumer(consumer, context) {
              var value = context._currentValue;
              context = { context, memoizedValue: value, next: null };
              if (null === lastContextDependency) {
                if (null === consumer)
                  throw Error(formatProdErrorMessage(308));
                lastContextDependency = context;
                consumer.dependencies = { lanes: 0, firstContext: context };
                consumer.flags |= 524288;
              } else
                lastContextDependency = lastContextDependency.next = context;
              return value;
            }
            var hasForceUpdate = false;
            function initializeUpdateQueue(fiber) {
              fiber.updateQueue = {
                baseState: fiber.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: { pending: null, lanes: 0, hiddenCallbacks: null },
                callbacks: null
              };
            }
            function cloneUpdateQueue(current, workInProgress2) {
              current = current.updateQueue;
              workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
                baseState: current.baseState,
                firstBaseUpdate: current.firstBaseUpdate,
                lastBaseUpdate: current.lastBaseUpdate,
                shared: current.shared,
                callbacks: null
              });
            }
            function createUpdate(lane) {
              return { lane, tag: 0, payload: null, callback: null, next: null };
            }
            function enqueueUpdate(fiber, update, lane) {
              var updateQueue = fiber.updateQueue;
              if (null === updateQueue)
                return null;
              updateQueue = updateQueue.shared;
              if (0 !== (executionContext & 2)) {
                var pending = updateQueue.pending;
                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
                updateQueue.pending = update;
                update = getRootForUpdatedFiber(fiber);
                markUpdateLaneFromFiberToRoot(fiber, null, lane);
                return update;
              }
              enqueueUpdate$1(fiber, updateQueue, update, lane);
              return getRootForUpdatedFiber(fiber);
            }
            function entangleTransitions(root2, fiber, lane) {
              fiber = fiber.updateQueue;
              if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
                var queueLanes = fiber.lanes;
                queueLanes &= root2.pendingLanes;
                lane |= queueLanes;
                fiber.lanes = lane;
                markRootEntangled(root2, lane);
              }
            }
            function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
              var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
              if (null !== current && (current = current.updateQueue, queue === current)) {
                var newFirst = null, newLast = null;
                queue = queue.firstBaseUpdate;
                if (null !== queue) {
                  do {
                    var clone = {
                      lane: queue.lane,
                      tag: queue.tag,
                      payload: queue.payload,
                      callback: null,
                      next: null
                    };
                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                    queue = queue.next;
                  } while (null !== queue);
                  null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
                } else
                  newFirst = newLast = capturedUpdate;
                queue = {
                  baseState: current.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: current.shared,
                  callbacks: current.callbacks
                };
                workInProgress2.updateQueue = queue;
                return;
              }
              workInProgress2 = queue.lastBaseUpdate;
              null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
              queue.lastBaseUpdate = capturedUpdate;
            }
            var didReadFromEntangledAsyncAction = false;
            function suspendIfUpdateReadFromEntangledAsyncAction() {
              if (didReadFromEntangledAsyncAction) {
                var entangledActionThenable = currentEntangledActionThenable;
                if (null !== entangledActionThenable)
                  throw entangledActionThenable;
              }
            }
            function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
              didReadFromEntangledAsyncAction = false;
              var queue = workInProgress$jscomp$0.updateQueue;
              hasForceUpdate = false;
              var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
              if (null !== pendingQueue) {
                queue.shared.pending = null;
                var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = null;
                null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
                lastBaseUpdate = lastPendingUpdate;
                var current = workInProgress$jscomp$0.alternate;
                null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
              }
              if (null !== firstBaseUpdate) {
                var newState = queue.baseState;
                lastBaseUpdate = 0;
                current = firstPendingUpdate = lastPendingUpdate = null;
                pendingQueue = firstBaseUpdate;
                do {
                  var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
                  if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                    null !== current && (current = current.next = {
                      lane: 0,
                      tag: pendingQueue.tag,
                      payload: pendingQueue.payload,
                      callback: null,
                      next: null
                    });
                    a: {
                      var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                      updateLane = props;
                      var instance = instance$jscomp$0;
                      switch (update.tag) {
                        case 1:
                          workInProgress2 = update.payload;
                          if ("function" === typeof workInProgress2) {
                            newState = workInProgress2.call(instance, newState, updateLane);
                            break a;
                          }
                          newState = workInProgress2;
                          break a;
                        case 3:
                          workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                        case 0:
                          workInProgress2 = update.payload;
                          updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                          if (null === updateLane || void 0 === updateLane)
                            break a;
                          newState = assign({}, newState, updateLane);
                          break a;
                        case 2:
                          hasForceUpdate = true;
                      }
                    }
                    updateLane = pendingQueue.callback;
                    null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
                  } else
                    isHiddenUpdate = {
                      lane: updateLane,
                      tag: pendingQueue.tag,
                      payload: pendingQueue.payload,
                      callback: pendingQueue.callback,
                      next: null
                    }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
                  pendingQueue = pendingQueue.next;
                  if (null === pendingQueue)
                    if (pendingQueue = queue.shared.pending, null === pendingQueue)
                      break;
                    else
                      isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
                } while (1);
                null === current && (lastPendingUpdate = newState);
                queue.baseState = lastPendingUpdate;
                queue.firstBaseUpdate = firstPendingUpdate;
                queue.lastBaseUpdate = current;
                null === firstBaseUpdate && (queue.shared.lanes = 0);
                workInProgressRootSkippedLanes |= lastBaseUpdate;
                workInProgress$jscomp$0.lanes = lastBaseUpdate;
                workInProgress$jscomp$0.memoizedState = newState;
              }
            }
            function callCallback(callback, context) {
              if ("function" !== typeof callback)
                throw Error(formatProdErrorMessage(191, callback));
              callback.call(context);
            }
            function commitCallbacks(updateQueue, context) {
              var callbacks = updateQueue.callbacks;
              if (null !== callbacks)
                for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
                  callCallback(callbacks[updateQueue], context);
            }
            function commitHookEffectListMount(flags, finishedWork) {
              try {
                var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
                if (null !== lastEffect) {
                  var firstEffect = lastEffect.next;
                  updateQueue = firstEffect;
                  do {
                    if ((updateQueue.tag & flags) === flags) {
                      lastEffect = void 0;
                      var create = updateQueue.create, inst = updateQueue.inst;
                      lastEffect = create();
                      inst.destroy = lastEffect;
                    }
                    updateQueue = updateQueue.next;
                  } while (updateQueue !== firstEffect);
                }
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
              try {
                var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
                if (null !== lastEffect) {
                  var firstEffect = lastEffect.next;
                  updateQueue = firstEffect;
                  do {
                    if ((updateQueue.tag & flags) === flags) {
                      var inst = updateQueue.inst, destroy = inst.destroy;
                      if (void 0 !== destroy) {
                        inst.destroy = void 0;
                        lastEffect = finishedWork;
                        var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
                        try {
                          destroy();
                        } catch (error) {
                          captureCommitPhaseError(
                            lastEffect,
                            nearestMountedAncestor,
                            error
                          );
                        }
                      }
                    }
                    updateQueue = updateQueue.next;
                  } while (updateQueue !== firstEffect);
                }
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            function commitClassCallbacks(finishedWork) {
              var updateQueue = finishedWork.updateQueue;
              if (null !== updateQueue) {
                var instance = finishedWork.stateNode;
                try {
                  commitCallbacks(updateQueue, instance);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
            }
            function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
              instance.props = resolveClassComponentProps(
                current.type,
                current.memoizedProps
              );
              instance.state = current.memoizedState;
              try {
                instance.componentWillUnmount();
              } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
              }
            }
            function safelyAttachRef(current, nearestMountedAncestor) {
              try {
                var ref = current.ref;
                if (null !== ref) {
                  var instance = current.stateNode;
                  switch (current.tag) {
                    case 26:
                    case 27:
                    case 5:
                      var instanceToUse = instance;
                      break;
                    default:
                      instanceToUse = instance;
                  }
                  "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
                }
              } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
              }
            }
            function safelyDetachRef(current, nearestMountedAncestor) {
              var ref = current.ref, refCleanup = current.refCleanup;
              if (null !== ref)
                if ("function" === typeof refCleanup)
                  try {
                    refCleanup();
                  } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                  } finally {
                    current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
                  }
                else if ("function" === typeof ref)
                  try {
                    ref(null);
                  } catch (error$112) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error$112);
                  }
                else
                  ref.current = null;
            }
            function commitHostMount(finishedWork) {
              var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
              try {
                a:
                  switch (type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      props.autoFocus && instance.focus();
                      break a;
                    case "img":
                      props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
                  }
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            function commitHostUpdate(finishedWork, newProps, oldProps) {
              try {
                var domElement = finishedWork.stateNode;
                updateProperties(domElement, finishedWork.type, oldProps, newProps);
                domElement[internalPropsKey] = newProps;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            function isHostParent(fiber) {
              return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
            }
            function getHostSibling(fiber) {
              a:
                for (; ; ) {
                  for (; null === fiber.sibling; ) {
                    if (null === fiber.return || isHostParent(fiber.return))
                      return null;
                    fiber = fiber.return;
                  }
                  fiber.sibling.return = fiber.return;
                  for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag; ) {
                    if (fiber.flags & 2)
                      continue a;
                    if (null === fiber.child || 4 === fiber.tag)
                      continue a;
                    else
                      fiber.child.return = fiber, fiber = fiber.child;
                  }
                  if (!(fiber.flags & 2))
                    return fiber.stateNode;
                }
            }
            function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
              var tag = node.tag;
              if (5 === tag || 6 === tag)
                node = node.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node, before) : parent.insertBefore(node, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node, parent)) : (before = parent, before.appendChild(node)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
              else if (4 !== tag && 27 !== tag && (node = node.child, null !== node))
                for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
                  insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
            }
            function insertOrAppendPlacementNode(node, before, parent) {
              var tag = node.tag;
              if (5 === tag || 6 === tag)
                node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
              else if (4 !== tag && 27 !== tag && (node = node.child, null !== node))
                for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
                  insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
            }
            var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, shouldFireAfterActiveInstanceBlur = false;
            function commitBeforeMutationEffects(root2, firstChild) {
              root2 = root2.containerInfo;
              eventsEnabled = _enabled;
              root2 = getActiveElementDeep(root2);
              if (hasSelectionCapabilities(root2)) {
                if ("selectionStart" in root2)
                  var JSCompiler_temp = {
                    start: root2.selectionStart,
                    end: root2.selectionEnd
                  };
                else
                  a: {
                    JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                    var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                    if (selection && 0 !== selection.rangeCount) {
                      JSCompiler_temp = selection.anchorNode;
                      var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                      selection = selection.focusOffset;
                      try {
                        JSCompiler_temp.nodeType, focusNode.nodeType;
                      } catch (e$20) {
                        JSCompiler_temp = null;
                        break a;
                      }
                      var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                      b:
                        for (; ; ) {
                          for (var next; ; ) {
                            node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                            node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                            3 === node.nodeType && (length += node.nodeValue.length);
                            if (null === (next = node.firstChild))
                              break;
                            parentNode = node;
                            node = next;
                          }
                          for (; ; ) {
                            if (node === root2)
                              break b;
                            parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                            parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                            if (null !== (next = node.nextSibling))
                              break;
                            node = parentNode;
                            parentNode = node.parentNode;
                          }
                          node = next;
                        }
                      JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                    } else
                      JSCompiler_temp = null;
                  }
                JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
              } else
                JSCompiler_temp = null;
              selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
              _enabled = false;
              for (nextEffect = firstChild; null !== nextEffect; )
                if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
                  root2.return = firstChild, nextEffect = root2;
                else
                  for (; null !== nextEffect; ) {
                    firstChild = nextEffect;
                    focusNode = firstChild.alternate;
                    root2 = firstChild.flags;
                    switch (firstChild.tag) {
                      case 0:
                        break;
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (0 !== (root2 & 1024) && null !== focusNode) {
                          root2 = void 0;
                          JSCompiler_temp = firstChild;
                          anchorOffset = focusNode.memoizedProps;
                          focusNode = focusNode.memoizedState;
                          selection = JSCompiler_temp.stateNode;
                          try {
                            var resolvedPrevProps = resolveClassComponentProps(
                              JSCompiler_temp.type,
                              anchorOffset,
                              JSCompiler_temp.elementType === JSCompiler_temp.type
                            );
                            root2 = selection.getSnapshotBeforeUpdate(
                              resolvedPrevProps,
                              focusNode
                            );
                            selection.__reactInternalSnapshotBeforeUpdate = root2;
                          } catch (error) {
                            captureCommitPhaseError(
                              JSCompiler_temp,
                              JSCompiler_temp.return,
                              error
                            );
                          }
                        }
                        break;
                      case 3:
                        if (0 !== (root2 & 1024)) {
                          if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                            clearContainerSparingly(root2);
                          else if (1 === JSCompiler_temp)
                            switch (root2.nodeName) {
                              case "HEAD":
                              case "HTML":
                              case "BODY":
                                clearContainerSparingly(root2);
                                break;
                              default:
                                root2.textContent = "";
                            }
                        }
                        break;
                      case 5:
                      case 26:
                      case 27:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        if (0 !== (root2 & 1024))
                          throw Error(formatProdErrorMessage(163));
                    }
                    root2 = firstChild.sibling;
                    if (null !== root2) {
                      root2.return = firstChild.return;
                      nextEffect = root2;
                      break;
                    }
                    nextEffect = firstChild.return;
                  }
              resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
              shouldFireAfterActiveInstanceBlur = false;
              return resolvedPrevProps;
            }
            function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
              var flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 0:
                case 11:
                case 15:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  flags & 4 && commitHookEffectListMount(5, finishedWork);
                  break;
                case 1:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  if (flags & 4)
                    if (finishedRoot = finishedWork.stateNode, null === current)
                      try {
                        finishedRoot.componentDidMount();
                      } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                      }
                    else {
                      var prevProps = resolveClassComponentProps(
                        finishedWork.type,
                        current.memoizedProps
                      );
                      current = current.memoizedState;
                      try {
                        finishedRoot.componentDidUpdate(
                          prevProps,
                          current,
                          finishedRoot.__reactInternalSnapshotBeforeUpdate
                        );
                      } catch (error$111) {
                        captureCommitPhaseError(
                          finishedWork,
                          finishedWork.return,
                          error$111
                        );
                      }
                    }
                  flags & 64 && commitClassCallbacks(finishedWork);
                  flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                  break;
                case 3:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                    finishedRoot = null;
                    if (null !== finishedWork.child)
                      switch (finishedWork.child.tag) {
                        case 27:
                        case 5:
                          finishedRoot = finishedWork.child.stateNode;
                          break;
                        case 1:
                          finishedRoot = finishedWork.child.stateNode;
                      }
                    try {
                      commitCallbacks(flags, finishedRoot);
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  }
                  break;
                case 26:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                  break;
                case 27:
                case 5:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  null === current && flags & 4 && commitHostMount(finishedWork);
                  flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                  break;
                case 12:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  break;
                case 13:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                case 22:
                  prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
                  if (!prevProps) {
                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                    offscreenSubtreeIsHidden = prevProps;
                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      0 !== (finishedWork.subtreeFlags & 8772)
                    ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  }
                  flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
                  break;
                default:
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              }
            }
            function detachFiberAfterEffects(fiber) {
              var alternate = fiber.alternate;
              null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
              fiber.stateNode = null;
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
            var hostParent = null, hostParentIsContainer = false;
            function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
              for (parent = parent.child; null !== parent; )
                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
            }
            function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
              if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
                try {
                  injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
                } catch (err) {
                }
              switch (deletedFiber.tag) {
                case 26:
                  offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
                  break;
                case 27:
                  offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode;
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  deletedFiber = deletedFiber.stateNode;
                  for (nearestMountedAncestor = deletedFiber.attributes; nearestMountedAncestor.length; )
                    deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
                  detachDeletedInstance(deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  break;
                case 5:
                  offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                case 6:
                  prevHostParentIsContainer = hostParent;
                  var prevHostParentIsContainer$119 = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  hostParent = prevHostParentIsContainer;
                  hostParentIsContainer = prevHostParentIsContainer$119;
                  if (null !== hostParent)
                    if (hostParentIsContainer)
                      try {
                        finishedRoot = hostParent, prevHostParent = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? finishedRoot.parentNode.removeChild(prevHostParent) : finishedRoot.removeChild(prevHostParent);
                      } catch (error) {
                        captureCommitPhaseError(
                          deletedFiber,
                          nearestMountedAncestor,
                          error
                        );
                      }
                    else
                      try {
                        hostParent.removeChild(deletedFiber.stateNode);
                      } catch (error) {
                        captureCommitPhaseError(
                          deletedFiber,
                          nearestMountedAncestor,
                          error
                        );
                      }
                  break;
                case 18:
                  null !== hostParent && (hostParentIsContainer ? (nearestMountedAncestor = hostParent, deletedFiber = deletedFiber.stateNode, 8 === nearestMountedAncestor.nodeType ? clearSuspenseBoundary(
                    nearestMountedAncestor.parentNode,
                    deletedFiber
                  ) : 1 === nearestMountedAncestor.nodeType && clearSuspenseBoundary(nearestMountedAncestor, deletedFiber), retryIfBlockedOn(nearestMountedAncestor)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
                  break;
                case 4:
                  prevHostParent = hostParent;
                  prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  break;
                case 0:
                case 11:
                case 14:
                case 15:
                  offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
                  offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  break;
                case 1:
                  offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                    deletedFiber,
                    nearestMountedAncestor,
                    prevHostParent
                  ));
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  break;
                case 21:
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  break;
                case 22:
                  offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
                  offscreenSubtreeWasHidden = prevHostParent;
                  break;
                default:
                  recursivelyTraverseDeletionEffects(
                    finishedRoot,
                    nearestMountedAncestor,
                    deletedFiber
                  );
              }
            }
            function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
              if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
                try {
                  retryIfBlockedOn(finishedRoot);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
            }
            function getRetryCache(finishedWork) {
              switch (finishedWork.tag) {
                case 13:
                case 19:
                  var retryCache = finishedWork.stateNode;
                  null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
                  return retryCache;
                case 22:
                  return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
                default:
                  throw Error(formatProdErrorMessage(435, finishedWork.tag));
              }
            }
            function attachSuspenseRetryListeners(finishedWork, wakeables) {
              var retryCache = getRetryCache(finishedWork);
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
              });
            }
            function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
              var deletions = parentFiber.deletions;
              if (null !== deletions)
                for (var i = 0; i < deletions.length; i++) {
                  var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
                  a:
                    for (; null !== parent; ) {
                      switch (parent.tag) {
                        case 27:
                        case 5:
                          hostParent = parent.stateNode;
                          hostParentIsContainer = false;
                          break a;
                        case 3:
                          hostParent = parent.stateNode.containerInfo;
                          hostParentIsContainer = true;
                          break a;
                        case 4:
                          hostParent = parent.stateNode.containerInfo;
                          hostParentIsContainer = true;
                          break a;
                      }
                      parent = parent.return;
                    }
                  if (null === hostParent)
                    throw Error(formatProdErrorMessage(160));
                  commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
                  hostParent = null;
                  hostParentIsContainer = false;
                  root2 = childToDelete.alternate;
                  null !== root2 && (root2.return = null);
                  childToDelete.return = null;
                }
              if (parentFiber.subtreeFlags & 13878)
                for (parentFiber = parentFiber.child; null !== parentFiber; )
                  commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
            }
            var currentHoistableRoot = null;
            function commitMutationEffectsOnFiber(finishedWork, root2) {
              var current = finishedWork.alternate, flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
                  break;
                case 1:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                  flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
                  break;
                case 26:
                  var hoistableRoot = currentHoistableRoot;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                  if (flags & 4) {
                    var currentResource = null !== current ? current.memoizedState : null;
                    flags = finishedWork.memoizedState;
                    if (null === current)
                      if (null === flags)
                        if (null === finishedWork.stateNode) {
                          a: {
                            flags = finishedWork.type;
                            current = finishedWork.memoizedProps;
                            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                            b:
                              switch (flags) {
                                case "title":
                                  currentResource = hoistableRoot.getElementsByTagName("title")[0];
                                  if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                                    currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                                      currentResource,
                                      hoistableRoot.querySelector("head > title")
                                    );
                                  setInitialProperties(currentResource, flags, current);
                                  currentResource[internalInstanceKey] = finishedWork;
                                  markNodeAsHoistable(currentResource);
                                  flags = currentResource;
                                  break a;
                                case "link":
                                  var maybeNodes = getHydratableHoistableCache(
                                    "link",
                                    "href",
                                    hoistableRoot
                                  ).get(flags + (current.href || ""));
                                  if (maybeNodes) {
                                    for (var i = 0; i < maybeNodes.length; i++)
                                      if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                        maybeNodes.splice(i, 1);
                                        break b;
                                      }
                                  }
                                  currentResource = hoistableRoot.createElement(flags);
                                  setInitialProperties(currentResource, flags, current);
                                  hoistableRoot.head.appendChild(currentResource);
                                  break;
                                case "meta":
                                  if (maybeNodes = getHydratableHoistableCache(
                                    "meta",
                                    "content",
                                    hoistableRoot
                                  ).get(flags + (current.content || ""))) {
                                    for (i = 0; i < maybeNodes.length; i++)
                                      if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                        maybeNodes.splice(i, 1);
                                        break b;
                                      }
                                  }
                                  currentResource = hoistableRoot.createElement(flags);
                                  setInitialProperties(currentResource, flags, current);
                                  hoistableRoot.head.appendChild(currentResource);
                                  break;
                                default:
                                  throw Error(formatProdErrorMessage(468, flags));
                              }
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                          }
                          finishedWork.stateNode = flags;
                        } else
                          mountHoistable(
                            hoistableRoot,
                            finishedWork.type,
                            finishedWork.stateNode
                          );
                      else
                        finishedWork.stateNode = acquireResource(
                          hoistableRoot,
                          flags,
                          finishedWork.memoizedProps
                        );
                    else
                      currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      ) : acquireResource(
                        hoistableRoot,
                        flags,
                        finishedWork.memoizedProps
                      )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                        finishedWork,
                        finishedWork.memoizedProps,
                        current.memoizedProps
                      );
                  }
                  break;
                case 27:
                  if (flags & 4 && null === finishedWork.alternate) {
                    hoistableRoot = finishedWork.stateNode;
                    currentResource = finishedWork.memoizedProps;
                    try {
                      for (var node = hoistableRoot.firstChild; node; ) {
                        var nextNode = node.nextSibling, nodeName = node.nodeName;
                        node[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node.rel.toLowerCase() || hoistableRoot.removeChild(node);
                        node = nextNode;
                      }
                      for (var type = finishedWork.type, attributes = hoistableRoot.attributes; attributes.length; )
                        hoistableRoot.removeAttributeNode(attributes[0]);
                      setInitialProperties(hoistableRoot, type, currentResource);
                      hoistableRoot[internalInstanceKey] = finishedWork;
                      hoistableRoot[internalPropsKey] = currentResource;
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  }
                case 5:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                  if (finishedWork.flags & 32) {
                    hoistableRoot = finishedWork.stateNode;
                    try {
                      setTextContent(hoistableRoot, "");
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  }
                  flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
                    finishedWork,
                    hoistableRoot,
                    null !== current ? current.memoizedProps : hoistableRoot
                  ));
                  flags & 1024 && (needsFormReset = true);
                  break;
                case 6:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  if (flags & 4) {
                    if (null === finishedWork.stateNode)
                      throw Error(formatProdErrorMessage(162));
                    flags = finishedWork.memoizedProps;
                    current = finishedWork.stateNode;
                    try {
                      current.nodeValue = flags;
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  }
                  break;
                case 3:
                  tagCaches = null;
                  hoistableRoot = currentHoistableRoot;
                  currentHoistableRoot = getHoistableRoot(root2.containerInfo);
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  currentHoistableRoot = hoistableRoot;
                  commitReconciliationEffects(finishedWork);
                  if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
                    try {
                      retryIfBlockedOn(root2.containerInfo);
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
                  break;
                case 4:
                  flags = currentHoistableRoot;
                  currentHoistableRoot = getHoistableRoot(
                    finishedWork.stateNode.containerInfo
                  );
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  currentHoistableRoot = flags;
                  break;
                case 12:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  break;
                case 13:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
                  flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                  break;
                case 22:
                  flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                  node = null !== finishedWork.memoizedState;
                  nextNode = null !== current && null !== current.memoizedState;
                  nodeName = offscreenSubtreeIsHidden;
                  type = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = nodeName || node;
                  offscreenSubtreeWasHidden = type || nextNode;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  offscreenSubtreeWasHidden = type;
                  offscreenSubtreeIsHidden = nodeName;
                  commitReconciliationEffects(finishedWork);
                  root2 = finishedWork.stateNode;
                  root2._current = finishedWork;
                  root2._visibility &= -3;
                  root2._visibility |= root2._pendingVisibility & 2;
                  if (flags & 8192 && (root2._visibility = node ? root2._visibility & -2 : root2._visibility | 1, node && (root2 = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root2 || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode))
                    a:
                      for (current = null, root2 = finishedWork; ; ) {
                        if (5 === root2.tag || 26 === root2.tag || 27 === root2.tag) {
                          if (null === current) {
                            nextNode = current = root2;
                            try {
                              if (hoistableRoot = nextNode.stateNode, node)
                                currentResource = hoistableRoot.style, "function" === typeof currentResource.setProperty ? currentResource.setProperty(
                                  "display",
                                  "none",
                                  "important"
                                ) : currentResource.display = "none";
                              else {
                                maybeNodes = nextNode.stateNode;
                                i = nextNode.memoizedProps.style;
                                var display = void 0 !== i && null !== i && i.hasOwnProperty("display") ? i.display : null;
                                maybeNodes.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                              }
                            } catch (error) {
                              captureCommitPhaseError(nextNode, nextNode.return, error);
                            }
                          }
                        } else if (6 === root2.tag) {
                          if (null === current) {
                            nextNode = root2;
                            try {
                              nextNode.stateNode.nodeValue = node ? "" : nextNode.memoizedProps;
                            } catch (error) {
                              captureCommitPhaseError(nextNode, nextNode.return, error);
                            }
                          }
                        } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                          root2.child.return = root2;
                          root2 = root2.child;
                          continue;
                        }
                        if (root2 === finishedWork)
                          break a;
                        for (; null === root2.sibling; ) {
                          if (null === root2.return || root2.return === finishedWork)
                            break a;
                          current === root2 && (current = null);
                          root2 = root2.return;
                        }
                        current === root2 && (current = null);
                        root2.sibling.return = root2.return;
                        root2 = root2.sibling;
                      }
                  flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
                  break;
                case 19:
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  commitReconciliationEffects(finishedWork);
                  flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                  break;
                case 21:
                  break;
                default:
                  recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
              }
            }
            function commitReconciliationEffects(finishedWork) {
              var flags = finishedWork.flags;
              if (flags & 2) {
                try {
                  if (27 !== finishedWork.tag) {
                    a: {
                      for (var parent = finishedWork.return; null !== parent; ) {
                        if (isHostParent(parent)) {
                          var JSCompiler_inline_result = parent;
                          break a;
                        }
                        parent = parent.return;
                      }
                      throw Error(formatProdErrorMessage(160));
                    }
                    switch (JSCompiler_inline_result.tag) {
                      case 27:
                        var parent$jscomp$0 = JSCompiler_inline_result.stateNode, before = getHostSibling(finishedWork);
                        insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
                        break;
                      case 5:
                        var parent$113 = JSCompiler_inline_result.stateNode;
                        JSCompiler_inline_result.flags & 32 && (setTextContent(parent$113, ""), JSCompiler_inline_result.flags &= -33);
                        var before$114 = getHostSibling(finishedWork);
                        insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
                        break;
                      case 3:
                      case 4:
                        var parent$115 = JSCompiler_inline_result.stateNode.containerInfo, before$116 = getHostSibling(finishedWork);
                        insertOrAppendPlacementNodeIntoContainer(
                          finishedWork,
                          before$116,
                          parent$115
                        );
                        break;
                      default:
                        throw Error(formatProdErrorMessage(161));
                    }
                  }
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
                finishedWork.flags &= -3;
              }
              flags & 4096 && (finishedWork.flags &= -4097);
            }
            function recursivelyResetForms(parentFiber) {
              if (parentFiber.subtreeFlags & 1024)
                for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                  var fiber = parentFiber;
                  recursivelyResetForms(fiber);
                  5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
                  parentFiber = parentFiber.sibling;
                }
            }
            function recursivelyTraverseLayoutEffects(root2, parentFiber) {
              if (parentFiber.subtreeFlags & 8772)
                for (parentFiber = parentFiber.child; null !== parentFiber; )
                  commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
            }
            function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var finishedWork = parentFiber;
                switch (finishedWork.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
                    recursivelyTraverseDisappearLayoutEffects(finishedWork);
                    break;
                  case 1:
                    safelyDetachRef(finishedWork, finishedWork.return);
                    var instance = finishedWork.stateNode;
                    "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                      finishedWork,
                      finishedWork.return,
                      instance
                    );
                    recursivelyTraverseDisappearLayoutEffects(finishedWork);
                    break;
                  case 26:
                  case 27:
                  case 5:
                    safelyDetachRef(finishedWork, finishedWork.return);
                    recursivelyTraverseDisappearLayoutEffects(finishedWork);
                    break;
                  case 22:
                    safelyDetachRef(finishedWork, finishedWork.return);
                    null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
                    break;
                  default:
                    recursivelyTraverseDisappearLayoutEffects(finishedWork);
                }
                parentFiber = parentFiber.sibling;
              }
            }
            function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
              includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
                switch (finishedWork.tag) {
                  case 0:
                  case 11:
                  case 15:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    commitHookEffectListMount(4, finishedWork);
                    break;
                  case 1:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    current = finishedWork;
                    finishedRoot = current.stateNode;
                    if ("function" === typeof finishedRoot.componentDidMount)
                      try {
                        finishedRoot.componentDidMount();
                      } catch (error) {
                        captureCommitPhaseError(current, current.return, error);
                      }
                    current = finishedWork;
                    finishedRoot = current.updateQueue;
                    if (null !== finishedRoot) {
                      var instance = current.stateNode;
                      try {
                        var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                        if (null !== hiddenCallbacks)
                          for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                            callCallback(hiddenCallbacks[finishedRoot], instance);
                      } catch (error) {
                        captureCommitPhaseError(current, current.return, error);
                      }
                    }
                    includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
                    safelyAttachRef(finishedWork, finishedWork.return);
                    break;
                  case 26:
                  case 27:
                  case 5:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
                    safelyAttachRef(finishedWork, finishedWork.return);
                    break;
                  case 12:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    break;
                  case 13:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                    break;
                  case 22:
                    null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                    safelyAttachRef(finishedWork, finishedWork.return);
                    break;
                  default:
                    recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      includeWorkInProgressEffects
                    );
                }
                parentFiber = parentFiber.sibling;
              }
            }
            function commitOffscreenPassiveMountEffects(current, finishedWork) {
              var previousCache = null;
              null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
              current = null;
              null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
              current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
            }
            function commitCachePassiveMountEffect(current, finishedWork) {
              current = null;
              null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
              finishedWork = finishedWork.memoizedState.cache;
              finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
            }
            function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
              if (parentFiber.subtreeFlags & 10256)
                for (parentFiber = parentFiber.child; null !== parentFiber; )
                  commitPassiveMountOnFiber(
                    root2,
                    parentFiber,
                    committedLanes,
                    committedTransitions
                  ), parentFiber = parentFiber.sibling;
            }
            function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
              var flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 0:
                case 11:
                case 15:
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
                  flags & 2048 && commitHookEffectListMount(9, finishedWork);
                  break;
                case 3:
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
                  flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
                  break;
                case 12:
                  if (flags & 2048) {
                    recursivelyTraversePassiveMountEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions
                    );
                    finishedRoot = finishedWork.stateNode;
                    try {
                      var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                      "function" === typeof onPostCommit && onPostCommit(
                        id,
                        null === finishedWork.alternate ? "mount" : "update",
                        finishedRoot.passiveEffectDuration,
                        -0
                      );
                    } catch (error) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                  } else
                    recursivelyTraversePassiveMountEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions
                    );
                  break;
                case 23:
                  break;
                case 22:
                  _finishedWork$memoize2 = finishedWork.stateNode;
                  null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  ) : (_finishedWork$memoize2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions,
                    0 !== (finishedWork.subtreeFlags & 10256)
                  ));
                  flags & 2048 && commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                case 24:
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
                  flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                  break;
                default:
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
              }
            }
            function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
              includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
                switch (finishedWork.tag) {
                  case 0:
                  case 11:
                  case 15:
                    recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    );
                    commitHookEffectListMount(8, finishedWork);
                    break;
                  case 23:
                    break;
                  case 22:
                    var instance = finishedWork.stateNode;
                    null !== finishedWork.memoizedState ? instance._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    ) : recursivelyTraverseAtomicPassiveEffects(
                      finishedRoot,
                      finishedWork
                    ) : (instance._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    ));
                    includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                      finishedWork.alternate,
                      finishedWork
                    );
                    break;
                  case 24:
                    recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    );
                    includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                    break;
                  default:
                    recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    );
                }
                parentFiber = parentFiber.sibling;
              }
            }
            function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
              if (parentFiber.subtreeFlags & 10256)
                for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                  var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
                  switch (finishedWork.tag) {
                    case 22:
                      recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                      flags & 2048 && commitOffscreenPassiveMountEffects(
                        finishedWork.alternate,
                        finishedWork
                      );
                      break;
                    case 24:
                      recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                      flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                      break;
                    default:
                      recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                  }
                  parentFiber = parentFiber.sibling;
                }
            }
            var suspenseyCommitFlag = 8192;
            function recursivelyAccumulateSuspenseyCommit(parentFiber) {
              if (parentFiber.subtreeFlags & suspenseyCommitFlag)
                for (parentFiber = parentFiber.child; null !== parentFiber; )
                  accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
            }
            function accumulateSuspenseyCommitOnFiber(fiber) {
              switch (fiber.tag) {
                case 26:
                  recursivelyAccumulateSuspenseyCommit(fiber);
                  fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                    currentHoistableRoot,
                    fiber.memoizedState,
                    fiber.memoizedProps
                  );
                  break;
                case 5:
                  recursivelyAccumulateSuspenseyCommit(fiber);
                  break;
                case 3:
                case 4:
                  var previousHoistableRoot = currentHoistableRoot;
                  currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
                  recursivelyAccumulateSuspenseyCommit(fiber);
                  currentHoistableRoot = previousHoistableRoot;
                  break;
                case 22:
                  null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
                  break;
                default:
                  recursivelyAccumulateSuspenseyCommit(fiber);
              }
            }
            function detachAlternateSiblings(parentFiber) {
              var previousFiber = parentFiber.alternate;
              if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
                previousFiber.child = null;
                do
                  previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
                while (null !== parentFiber);
              }
            }
            function recursivelyTraversePassiveUnmountEffects(parentFiber) {
              var deletions = parentFiber.deletions;
              if (0 !== (parentFiber.flags & 16)) {
                if (null !== deletions)
                  for (var i = 0; i < deletions.length; i++) {
                    var childToDelete = deletions[i];
                    nextEffect = childToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                      childToDelete,
                      parentFiber
                    );
                  }
                detachAlternateSiblings(parentFiber);
              }
              if (parentFiber.subtreeFlags & 10256)
                for (parentFiber = parentFiber.child; null !== parentFiber; )
                  commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
            }
            function commitPassiveUnmountOnFiber(finishedWork) {
              switch (finishedWork.tag) {
                case 0:
                case 11:
                case 15:
                  recursivelyTraversePassiveUnmountEffects(finishedWork);
                  finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
                  break;
                case 3:
                  recursivelyTraversePassiveUnmountEffects(finishedWork);
                  break;
                case 12:
                  recursivelyTraversePassiveUnmountEffects(finishedWork);
                  break;
                case 22:
                  var instance = finishedWork.stateNode;
                  null !== finishedWork.memoizedState && instance._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
                  break;
                default:
                  recursivelyTraversePassiveUnmountEffects(finishedWork);
              }
            }
            function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
              var deletions = parentFiber.deletions;
              if (0 !== (parentFiber.flags & 16)) {
                if (null !== deletions)
                  for (var i = 0; i < deletions.length; i++) {
                    var childToDelete = deletions[i];
                    nextEffect = childToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                      childToDelete,
                      parentFiber
                    );
                  }
                detachAlternateSiblings(parentFiber);
              }
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                deletions = parentFiber;
                switch (deletions.tag) {
                  case 0:
                  case 11:
                  case 15:
                    commitHookEffectListUnmount(8, deletions, deletions.return);
                    recursivelyTraverseDisconnectPassiveEffects(deletions);
                    break;
                  case 22:
                    i = deletions.stateNode;
                    i._visibility & 4 && (i._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(deletions));
                    break;
                  default:
                    recursivelyTraverseDisconnectPassiveEffects(deletions);
                }
                parentFiber = parentFiber.sibling;
              }
            }
            function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
              for (; null !== nextEffect; ) {
                var fiber = nextEffect;
                switch (fiber.tag) {
                  case 0:
                  case 11:
                  case 15:
                    commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
                    break;
                  case 23:
                  case 22:
                    if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                      var cache = fiber.memoizedState.cachePool.pool;
                      null != cache && cache.refCount++;
                    }
                    break;
                  case 24:
                    releaseCache(fiber.memoizedState.cache);
                }
                cache = fiber.child;
                if (null !== cache)
                  cache.return = fiber, nextEffect = cache;
                else
                  a:
                    for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                      cache = nextEffect;
                      var sibling = cache.sibling, returnFiber = cache.return;
                      detachFiberAfterEffects(cache);
                      if (cache === fiber) {
                        nextEffect = null;
                        break a;
                      }
                      if (null !== sibling) {
                        sibling.return = returnFiber;
                        nextEffect = sibling;
                        break a;
                      }
                      nextEffect = returnFiber;
                    }
              }
            }
            function FiberNode(tag, pendingProps, key, mode) {
              this.tag = tag;
              this.key = key;
              this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
              this.index = 0;
              this.refCleanup = this.ref = null;
              this.pendingProps = pendingProps;
              this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
              this.mode = mode;
              this.subtreeFlags = this.flags = 0;
              this.deletions = null;
              this.childLanes = this.lanes = 0;
              this.alternate = null;
            }
            function createFiberImplClass(tag, pendingProps, key, mode) {
              return new FiberNode(tag, pendingProps, key, mode);
            }
            function shouldConstruct(Component) {
              Component = Component.prototype;
              return !(!Component || !Component.isReactComponent);
            }
            function createWorkInProgress(current, pendingProps) {
              var workInProgress2 = current.alternate;
              null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
                current.tag,
                pendingProps,
                current.key,
                current.mode
              ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
              workInProgress2.flags = current.flags & 31457280;
              workInProgress2.childLanes = current.childLanes;
              workInProgress2.lanes = current.lanes;
              workInProgress2.child = current.child;
              workInProgress2.memoizedProps = current.memoizedProps;
              workInProgress2.memoizedState = current.memoizedState;
              workInProgress2.updateQueue = current.updateQueue;
              pendingProps = current.dependencies;
              workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
              workInProgress2.sibling = current.sibling;
              workInProgress2.index = current.index;
              workInProgress2.ref = current.ref;
              workInProgress2.refCleanup = current.refCleanup;
              return workInProgress2;
            }
            function resetWorkInProgress(workInProgress2, renderLanes2) {
              workInProgress2.flags &= 31457282;
              var current = workInProgress2.alternate;
              null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
                lanes: renderLanes2.lanes,
                firstContext: renderLanes2.firstContext
              });
              return workInProgress2;
            }
            function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
              var fiberTag = 0;
              owner = type;
              if ("function" === typeof type)
                shouldConstruct(type) && (fiberTag = 1);
              else if ("string" === typeof type)
                fiberTag = isHostHoistableType(
                  type,
                  pendingProps,
                  contextStackCursor.current
                ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
              else
                a:
                  switch (type) {
                    case REACT_FRAGMENT_TYPE:
                      return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                    case REACT_STRICT_MODE_TYPE:
                      fiberTag = 8;
                      mode |= 24;
                      break;
                    case REACT_PROFILER_TYPE:
                      return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
                    case REACT_SUSPENSE_TYPE:
                      return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
                    case REACT_SUSPENSE_LIST_TYPE:
                      return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
                    case REACT_OFFSCREEN_TYPE:
                      return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                    default:
                      if ("object" === typeof type && null !== type)
                        switch (type.$$typeof) {
                          case REACT_PROVIDER_TYPE:
                          case REACT_CONTEXT_TYPE:
                            fiberTag = 10;
                            break a;
                          case REACT_CONSUMER_TYPE:
                            fiberTag = 9;
                            break a;
                          case REACT_FORWARD_REF_TYPE:
                            fiberTag = 11;
                            break a;
                          case REACT_MEMO_TYPE:
                            fiberTag = 14;
                            break a;
                          case REACT_LAZY_TYPE:
                            fiberTag = 16;
                            owner = null;
                            break a;
                        }
                      fiberTag = 29;
                      pendingProps = Error(
                        formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
                      );
                      owner = null;
                  }
              key = createFiberImplClass(fiberTag, pendingProps, key, mode);
              key.elementType = type;
              key.type = owner;
              key.lanes = lanes;
              return key;
            }
            function createFiberFromFragment(elements, mode, lanes, key) {
              elements = createFiberImplClass(7, elements, key, mode);
              elements.lanes = lanes;
              return elements;
            }
            function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
              pendingProps = createFiberImplClass(22, pendingProps, key, mode);
              pendingProps.elementType = REACT_OFFSCREEN_TYPE;
              pendingProps.lanes = lanes;
              var primaryChildInstance = {
                _visibility: 1,
                _pendingVisibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null,
                _current: null,
                detach: function() {
                  var fiber = primaryChildInstance._current;
                  if (null === fiber)
                    throw Error(formatProdErrorMessage(456));
                  if (0 === (primaryChildInstance._pendingVisibility & 2)) {
                    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
                    null !== root2 && (primaryChildInstance._pendingVisibility |= 2, scheduleUpdateOnFiber(root2, fiber, 2));
                  }
                },
                attach: function() {
                  var fiber = primaryChildInstance._current;
                  if (null === fiber)
                    throw Error(formatProdErrorMessage(456));
                  if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
                    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
                    null !== root2 && (primaryChildInstance._pendingVisibility &= -3, scheduleUpdateOnFiber(root2, fiber, 2));
                  }
                }
              };
              pendingProps.stateNode = primaryChildInstance;
              return pendingProps;
            }
            function createFiberFromText(content, mode, lanes) {
              content = createFiberImplClass(6, content, null, mode);
              content.lanes = lanes;
              return content;
            }
            function createFiberFromPortal(portal, mode, lanes) {
              mode = createFiberImplClass(
                4,
                null !== portal.children ? portal.children : [],
                portal.key,
                mode
              );
              mode.lanes = lanes;
              mode.stateNode = {
                containerInfo: portal.containerInfo,
                pendingChildren: null,
                implementation: portal.implementation
              };
              return mode;
            }
            function markUpdate(workInProgress2) {
              workInProgress2.flags |= 4;
            }
            function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
              if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
                workInProgress2.flags &= -16777217;
              else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
                resource = suspenseHandlerStackCursor.current;
                if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
                  throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
                workInProgress2.flags |= 8192;
              }
            }
            function scheduleRetryEffect(workInProgress2, retryQueue) {
              null !== retryQueue && (workInProgress2.flags |= 4);
              workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
            }
            function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
              if (!isHydrating)
                switch (renderState.tailMode) {
                  case "hidden":
                    hasRenderedATailFallback = renderState.tail;
                    for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                      null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                    null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                    break;
                  case "collapsed":
                    lastTailNode = renderState.tail;
                    for (var lastTailNode$131 = null; null !== lastTailNode; )
                      null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode), lastTailNode = lastTailNode.sibling;
                    null === lastTailNode$131 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$131.sibling = null;
                }
            }
            function bubbleProperties(completedWork) {
              var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
              if (didBailout)
                for (var child$132 = completedWork.child; null !== child$132; )
                  newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags & 31457280, subtreeFlags |= child$132.flags & 31457280, child$132.return = completedWork, child$132 = child$132.sibling;
              else
                for (child$132 = completedWork.child; null !== child$132; )
                  newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags, subtreeFlags |= child$132.flags, child$132.return = completedWork, child$132 = child$132.sibling;
              completedWork.subtreeFlags |= subtreeFlags;
              completedWork.childLanes = newChildLanes;
              return didBailout;
            }
            function completeWork(current, workInProgress2, renderLanes2) {
              var newProps = workInProgress2.pendingProps;
              popTreeContext(workInProgress2);
              switch (workInProgress2.tag) {
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                  return bubbleProperties(workInProgress2), null;
                case 1:
                  return bubbleProperties(workInProgress2), null;
                case 3:
                  renderLanes2 = workInProgress2.stateNode;
                  newProps = null;
                  null !== current && (newProps = current.memoizedState.cache);
                  workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
                  popProvider(CacheContext);
                  popHostContainer();
                  renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
                  if (null === current || null === current.child)
                    popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
                  bubbleProperties(workInProgress2);
                  return null;
                case 26:
                  return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
                case 27:
                  popHostContext(workInProgress2);
                  renderLanes2 = rootInstanceStackCursor.current;
                  var type = workInProgress2.type;
                  if (null !== current && null != workInProgress2.stateNode)
                    current.memoizedProps !== newProps && markUpdate(workInProgress2);
                  else {
                    if (!newProps) {
                      if (null === workInProgress2.stateNode)
                        throw Error(formatProdErrorMessage(166));
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                    current = contextStackCursor.current;
                    popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                case 5:
                  popHostContext(workInProgress2);
                  renderLanes2 = workInProgress2.type;
                  if (null !== current && null != workInProgress2.stateNode)
                    current.memoizedProps !== newProps && markUpdate(workInProgress2);
                  else {
                    if (!newProps) {
                      if (null === workInProgress2.stateNode)
                        throw Error(formatProdErrorMessage(166));
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                    current = contextStackCursor.current;
                    if (popHydrationState(workInProgress2))
                      prepareToHydrateHostInstance(workInProgress2, current);
                    else {
                      type = getOwnerDocumentFromRootContainer(
                        rootInstanceStackCursor.current
                      );
                      switch (current) {
                        case 1:
                          current = type.createElementNS(
                            "http://www.w3.org/2000/svg",
                            renderLanes2
                          );
                          break;
                        case 2:
                          current = type.createElementNS(
                            "http://www.w3.org/1998/Math/MathML",
                            renderLanes2
                          );
                          break;
                        default:
                          switch (renderLanes2) {
                            case "svg":
                              current = type.createElementNS(
                                "http://www.w3.org/2000/svg",
                                renderLanes2
                              );
                              break;
                            case "math":
                              current = type.createElementNS(
                                "http://www.w3.org/1998/Math/MathML",
                                renderLanes2
                              );
                              break;
                            case "script":
                              current = type.createElement("div");
                              current.innerHTML = "<script><\/script>";
                              current = current.removeChild(current.firstChild);
                              break;
                            case "select":
                              current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                              newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                              break;
                            default:
                              current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                          }
                      }
                      current[internalInstanceKey] = workInProgress2;
                      current[internalPropsKey] = newProps;
                      a:
                        for (type = workInProgress2.child; null !== type; ) {
                          if (5 === type.tag || 6 === type.tag)
                            current.appendChild(type.stateNode);
                          else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                            type.child.return = type;
                            type = type.child;
                            continue;
                          }
                          if (type === workInProgress2)
                            break a;
                          for (; null === type.sibling; ) {
                            if (null === type.return || type.return === workInProgress2)
                              break a;
                            type = type.return;
                          }
                          type.sibling.return = type.return;
                          type = type.sibling;
                        }
                      workInProgress2.stateNode = current;
                      a:
                        switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                            current = !!newProps.autoFocus;
                            break a;
                          case "img":
                            current = true;
                            break a;
                          default:
                            current = false;
                        }
                      current && markUpdate(workInProgress2);
                    }
                  }
                  bubbleProperties(workInProgress2);
                  workInProgress2.flags &= -16777217;
                  return null;
                case 6:
                  if (current && null != workInProgress2.stateNode)
                    current.memoizedProps !== newProps && markUpdate(workInProgress2);
                  else {
                    if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                      throw Error(formatProdErrorMessage(166));
                    current = rootInstanceStackCursor.current;
                    if (popHydrationState(workInProgress2)) {
                      current = workInProgress2.stateNode;
                      renderLanes2 = workInProgress2.memoizedProps;
                      newProps = null;
                      type = hydrationParentFiber;
                      if (null !== type)
                        switch (type.tag) {
                          case 27:
                          case 5:
                            newProps = type.memoizedProps;
                        }
                      current[internalInstanceKey] = workInProgress2;
                      current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                      current || throwOnHydrationMismatch(workInProgress2);
                    } else
                      current = getOwnerDocumentFromRootContainer(current).createTextNode(
                        newProps
                      ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                case 13:
                  newProps = workInProgress2.memoizedState;
                  if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
                    type = popHydrationState(workInProgress2);
                    if (null !== newProps && null !== newProps.dehydrated) {
                      if (null === current) {
                        if (!type)
                          throw Error(formatProdErrorMessage(318));
                        type = workInProgress2.memoizedState;
                        type = null !== type ? type.dehydrated : null;
                        if (!type)
                          throw Error(formatProdErrorMessage(317));
                        type[internalInstanceKey] = workInProgress2;
                      } else
                        resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                      bubbleProperties(workInProgress2);
                      type = false;
                    } else
                      null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), type = true;
                    if (!type) {
                      if (workInProgress2.flags & 256)
                        return popSuspenseHandler(workInProgress2), workInProgress2;
                      popSuspenseHandler(workInProgress2);
                      return null;
                    }
                  }
                  popSuspenseHandler(workInProgress2);
                  if (0 !== (workInProgress2.flags & 128))
                    return workInProgress2.lanes = renderLanes2, workInProgress2;
                  renderLanes2 = null !== newProps;
                  current = null !== current && null !== current.memoizedState;
                  if (renderLanes2) {
                    newProps = workInProgress2.child;
                    type = null;
                    null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
                    var cache$144 = null;
                    null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$144 = newProps.memoizedState.cachePool.pool);
                    cache$144 !== type && (newProps.flags |= 2048);
                  }
                  renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
                  scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
                  bubbleProperties(workInProgress2);
                  return null;
                case 4:
                  return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
                case 10:
                  return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
                case 19:
                  pop(suspenseStackCursor);
                  type = workInProgress2.memoizedState;
                  if (null === type)
                    return bubbleProperties(workInProgress2), null;
                  newProps = 0 !== (workInProgress2.flags & 128);
                  cache$144 = type.rendering;
                  if (null === cache$144)
                    if (newProps)
                      cutOffTailIfNeeded(type, false);
                    else {
                      if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                        for (current = workInProgress2.child; null !== current; ) {
                          cache$144 = findFirstSuspended(current);
                          if (null !== cache$144) {
                            workInProgress2.flags |= 128;
                            cutOffTailIfNeeded(type, false);
                            current = cache$144.updateQueue;
                            workInProgress2.updateQueue = current;
                            scheduleRetryEffect(workInProgress2, current);
                            workInProgress2.subtreeFlags = 0;
                            current = renderLanes2;
                            for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                              resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                            push(
                              suspenseStackCursor,
                              suspenseStackCursor.current & 1 | 2
                            );
                            return workInProgress2.child;
                          }
                          current = current.sibling;
                        }
                      null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
                    }
                  else {
                    if (!newProps)
                      if (current = findFirstSuspended(cache$144), null !== current) {
                        if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$144.alternate && !isHydrating)
                          return bubbleProperties(workInProgress2), null;
                      } else
                        2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
                    type.isBackwards ? (cache$144.sibling = workInProgress2.child, workInProgress2.child = cache$144) : (current = type.last, null !== current ? current.sibling = cache$144 : workInProgress2.child = cache$144, type.last = cache$144);
                  }
                  if (null !== type.tail)
                    return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
                  bubbleProperties(workInProgress2);
                  return null;
                case 22:
                case 23:
                  return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
                case 24:
                  return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
                case 25:
                  return null;
              }
              throw Error(formatProdErrorMessage(156, workInProgress2.tag));
            }
            function unwindWork(current, workInProgress2) {
              popTreeContext(workInProgress2);
              switch (workInProgress2.tag) {
                case 1:
                  return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
                case 3:
                  return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
                case 26:
                case 27:
                case 5:
                  return popHostContext(workInProgress2), null;
                case 13:
                  popSuspenseHandler(workInProgress2);
                  current = workInProgress2.memoizedState;
                  if (null !== current && null !== current.dehydrated) {
                    if (null === workInProgress2.alternate)
                      throw Error(formatProdErrorMessage(340));
                    resetHydrationState();
                  }
                  current = workInProgress2.flags;
                  return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
                case 19:
                  return pop(suspenseStackCursor), null;
                case 4:
                  return popHostContainer(), null;
                case 10:
                  return popProvider(workInProgress2.type), null;
                case 22:
                case 23:
                  return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
                case 24:
                  return popProvider(CacheContext), null;
                case 25:
                  return null;
                default:
                  return null;
              }
            }
            function unwindInterruptedWork(current, interruptedWork) {
              popTreeContext(interruptedWork);
              switch (interruptedWork.tag) {
                case 3:
                  popProvider(CacheContext);
                  popHostContainer();
                  break;
                case 26:
                case 27:
                case 5:
                  popHostContext(interruptedWork);
                  break;
                case 4:
                  popHostContainer();
                  break;
                case 13:
                  popSuspenseHandler(interruptedWork);
                  break;
                case 19:
                  pop(suspenseStackCursor);
                  break;
                case 10:
                  popProvider(interruptedWork.type);
                  break;
                case 22:
                case 23:
                  popSuspenseHandler(interruptedWork);
                  popHiddenContext();
                  null !== current && pop(resumedCache);
                  break;
                case 24:
                  popProvider(CacheContext);
              }
            }
            var DefaultAsyncDispatcher = {
              getCacheForType: function(resourceType) {
                var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
                void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
                return cacheForType;
              }
            }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
            function requestUpdateLane() {
              if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
                return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
              if (null !== ReactSharedInternals.T) {
                var actionScopeLane = currentEntangledLane;
                return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
              }
              return resolveUpdatePriority();
            }
            function requestDeferredLane() {
              0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
              var suspenseHandler = suspenseHandlerStackCursor.current;
              null !== suspenseHandler && (suspenseHandler.flags |= 32);
              return workInProgressDeferredLane;
            }
            function scheduleUpdateOnFiber(root2, fiber, lane) {
              if (root2 === workInProgressRoot && 2 === workInProgressSuspendedReason || null !== root2.cancelPendingCommit)
                prepareFreshStack(root2, 0), markRootSuspended(
                  root2,
                  workInProgressRootRenderLanes,
                  workInProgressDeferredLane,
                  false
                );
              markRootUpdated$1(root2, lane);
              if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
                root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
                  root2,
                  workInProgressRootRenderLanes,
                  workInProgressDeferredLane,
                  false
                )), ensureRootIsScheduled(root2);
            }
            function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
              if (0 !== (executionContext & 6))
                throw Error(formatProdErrorMessage(327));
              var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
              do {
                if (0 === exitStatus) {
                  workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
                  break;
                } else if (6 === exitStatus)
                  markRootSuspended(
                    root$jscomp$0,
                    lanes,
                    0,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                else {
                  forceSync = root$jscomp$0.current.alternate;
                  if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                    exitStatus = renderRootSync(root$jscomp$0, lanes, false);
                    renderWasConcurrent = false;
                    continue;
                  }
                  if (2 === exitStatus) {
                    renderWasConcurrent = lanes;
                    if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                      var JSCompiler_inline_result = 0;
                    else
                      JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
                    if (0 !== JSCompiler_inline_result) {
                      lanes = JSCompiler_inline_result;
                      a: {
                        var root2 = root$jscomp$0;
                        exitStatus = workInProgressRootConcurrentErrors;
                        var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                        wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                        JSCompiler_inline_result = renderRootSync(
                          root2,
                          JSCompiler_inline_result,
                          false
                        );
                        if (2 !== JSCompiler_inline_result) {
                          if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                            root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                            workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                            exitStatus = 4;
                            break a;
                          }
                          renderWasConcurrent = workInProgressRootRecoverableErrors;
                          workInProgressRootRecoverableErrors = exitStatus;
                          null !== renderWasConcurrent && queueRecoverableErrors(renderWasConcurrent);
                        }
                        exitStatus = JSCompiler_inline_result;
                      }
                      renderWasConcurrent = false;
                      if (2 !== exitStatus)
                        continue;
                    }
                  }
                  if (1 === exitStatus) {
                    prepareFreshStack(root$jscomp$0, 0);
                    markRootSuspended(root$jscomp$0, lanes, 0, true);
                    break;
                  }
                  a: {
                    shouldTimeSlice = root$jscomp$0;
                    switch (exitStatus) {
                      case 0:
                      case 1:
                        throw Error(formatProdErrorMessage(345));
                      case 4:
                        if ((lanes & 4194176) === lanes) {
                          markRootSuspended(
                            shouldTimeSlice,
                            lanes,
                            workInProgressDeferredLane,
                            !workInProgressRootDidSkipSuspendedSiblings
                          );
                          break a;
                        }
                        break;
                      case 2:
                        workInProgressRootRecoverableErrors = null;
                        break;
                      case 3:
                      case 5:
                        break;
                      default:
                        throw Error(formatProdErrorMessage(329));
                    }
                    shouldTimeSlice.finishedWork = forceSync;
                    shouldTimeSlice.finishedLanes = lanes;
                    if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + 300 - now(), 10 < renderWasConcurrent)) {
                      markRootSuspended(
                        shouldTimeSlice,
                        lanes,
                        workInProgressDeferredLane,
                        !workInProgressRootDidSkipSuspendedSiblings
                      );
                      if (0 !== getNextLanes(shouldTimeSlice, 0))
                        break a;
                      shouldTimeSlice.timeoutHandle = scheduleTimeout(
                        commitRootWhenReady.bind(
                          null,
                          shouldTimeSlice,
                          forceSync,
                          workInProgressRootRecoverableErrors,
                          workInProgressTransitions,
                          workInProgressRootDidIncludeRecursiveRenderUpdate,
                          lanes,
                          workInProgressDeferredLane,
                          workInProgressRootInterleavedUpdatedLanes,
                          workInProgressSuspendedRetryLanes,
                          workInProgressRootDidSkipSuspendedSiblings,
                          2,
                          -0,
                          0
                        ),
                        renderWasConcurrent
                      );
                      break a;
                    }
                    commitRootWhenReady(
                      shouldTimeSlice,
                      forceSync,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      lanes,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes,
                      workInProgressRootDidSkipSuspendedSiblings,
                      0,
                      -0,
                      0
                    );
                  }
                }
                break;
              } while (1);
              ensureRootIsScheduled(root$jscomp$0);
            }
            function queueRecoverableErrors(errors) {
              null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(
                workInProgressRootRecoverableErrors,
                errors
              );
            }
            function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
              var subtreeFlags = finishedWork.subtreeFlags;
              if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
                if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
                  root2.cancelPendingCommit = finishedWork(
                    commitRoot.bind(
                      null,
                      root2,
                      recoverableErrors,
                      transitions,
                      didIncludeRenderPhaseUpdate,
                      spawnedLane,
                      updatedLanes,
                      suspendedRetryLanes,
                      1,
                      completedRenderStartTime,
                      completedRenderEndTime
                    )
                  );
                  markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
                  return;
                }
              }
              commitRoot(
                root2,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                suspendedCommitReason,
                completedRenderStartTime,
                completedRenderEndTime
              );
            }
            function isRenderConsistentWithExternalStores(finishedWork) {
              for (var node = finishedWork; ; ) {
                var tag = node.tag;
                if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
                  for (var i = 0; i < tag.length; i++) {
                    var check = tag[i], getSnapshot = check.getSnapshot;
                    check = check.value;
                    try {
                      if (!objectIs(getSnapshot(), check))
                        return false;
                    } catch (error) {
                      return false;
                    }
                  }
                tag = node.child;
                if (node.subtreeFlags & 16384 && null !== tag)
                  tag.return = node, node = tag;
                else {
                  if (node === finishedWork)
                    break;
                  for (; null === node.sibling; ) {
                    if (null === node.return || node.return === finishedWork)
                      return true;
                    node = node.return;
                  }
                  node.sibling.return = node.return;
                  node = node.sibling;
                }
              }
              return true;
            }
            function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
              suspendedLanes &= ~workInProgressRootPingedLanes;
              suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
              root2.suspendedLanes |= suspendedLanes;
              root2.pingedLanes &= ~suspendedLanes;
              didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
              didAttemptEntireTree = root2.expirationTimes;
              for (var lanes = suspendedLanes; 0 < lanes; ) {
                var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
                didAttemptEntireTree[index$6] = -1;
                lanes &= ~lane;
              }
              0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
            }
            function flushSyncWork$1() {
              return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
            }
            function resetWorkInProgressStack() {
              if (null !== workInProgress) {
                if (0 === workInProgressSuspendedReason)
                  var interruptedWork = workInProgress.return;
                else
                  interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
                for (; null !== interruptedWork; )
                  unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
                workInProgress = null;
              }
            }
            function prepareFreshStack(root2, lanes) {
              root2.finishedWork = null;
              root2.finishedLanes = 0;
              var timeoutHandle = root2.timeoutHandle;
              -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
              timeoutHandle = root2.cancelPendingCommit;
              null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
              resetWorkInProgressStack();
              workInProgressRoot = root2;
              workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
              workInProgressRootRenderLanes = lanes;
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              workInProgressRootDidSkipSuspendedSiblings = false;
              workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
              workInProgressRootDidAttachPingListener = false;
              workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
              workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
              workInProgressRootDidIncludeRecursiveRenderUpdate = false;
              0 !== (lanes & 8) && (lanes |= lanes & 32);
              var allEntangledLanes = root2.entangledLanes;
              if (0 !== allEntangledLanes)
                for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
                  var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
                  lanes |= root2[index$4];
                  allEntangledLanes &= ~lane;
                }
              entangledRenderLanes = lanes;
              finishQueueingConcurrentUpdates();
              return timeoutHandle;
            }
            function handleThrow(root2, thrownValue) {
              currentlyRenderingFiber$1 = null;
              ReactSharedInternals.H = ContextOnlyDispatcher;
              thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
              workInProgressThrownValue = thrownValue;
              null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              ));
            }
            function pushDispatcher() {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = ContextOnlyDispatcher;
              return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
            }
            function pushAsyncDispatcher() {
              var prevAsyncDispatcher = ReactSharedInternals.A;
              ReactSharedInternals.A = DefaultAsyncDispatcher;
              return prevAsyncDispatcher;
            }
            function renderDidSuspendDelayIfPossible() {
              workInProgressRootExitStatus = 4;
              workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
              0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
                workInProgressRoot,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                false
              );
            }
            function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
              var prevExecutionContext = executionContext;
              executionContext |= 2;
              var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
              if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
                workInProgressTransitions = null, prepareFreshStack(root2, lanes);
              lanes = false;
              var exitStatus = workInProgressRootExitStatus;
              a:
                do
                  try {
                    if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                      var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                      switch (workInProgressSuspendedReason) {
                        case 8:
                          resetWorkInProgressStack();
                          exitStatus = 6;
                          break a;
                        case 3:
                        case 2:
                        case 6:
                          null === suspenseHandlerStackCursor.current && (lanes = true);
                          var reason = workInProgressSuspendedReason;
                          workInProgressSuspendedReason = 0;
                          workInProgressThrownValue = null;
                          throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                          if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                            exitStatus = 0;
                            break a;
                          }
                          break;
                        default:
                          reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                      }
                    }
                    workLoopSync();
                    exitStatus = workInProgressRootExitStatus;
                    break;
                  } catch (thrownValue$164) {
                    handleThrow(root2, thrownValue$164);
                  }
                while (1);
              lanes && root2.shellSuspendCounter++;
              lastContextDependency = currentlyRenderingFiber = null;
              executionContext = prevExecutionContext;
              ReactSharedInternals.H = prevDispatcher;
              ReactSharedInternals.A = prevAsyncDispatcher;
              null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
              return exitStatus;
            }
            function workLoopSync() {
              for (; null !== workInProgress; )
                performUnitOfWork(workInProgress);
            }
            function renderRootConcurrent(root2, lanes) {
              var prevExecutionContext = executionContext;
              executionContext |= 2;
              var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
              workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
                root2,
                lanes
              );
              a:
                do
                  try {
                    if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                      lanes = workInProgress;
                      var thrownValue = workInProgressThrownValue;
                      b:
                        switch (workInProgressSuspendedReason) {
                          case 1:
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                            break;
                          case 2:
                            if (isThenableResolved(thrownValue)) {
                              workInProgressSuspendedReason = 0;
                              workInProgressThrownValue = null;
                              replaySuspendedUnitOfWork(lanes);
                              break;
                            }
                            lanes = function() {
                              2 === workInProgressSuspendedReason && workInProgressRoot === root2 && (workInProgressSuspendedReason = 7);
                              ensureRootIsScheduled(root2);
                            };
                            thrownValue.then(lanes, lanes);
                            break a;
                          case 3:
                            workInProgressSuspendedReason = 7;
                            break a;
                          case 4:
                            workInProgressSuspendedReason = 5;
                            break a;
                          case 7:
                            isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                            break;
                          case 5:
                            var resource = null;
                            switch (workInProgress.tag) {
                              case 26:
                                resource = workInProgress.memoizedState;
                              case 5:
                              case 27:
                                var hostFiber = workInProgress;
                                if (resource ? preloadResource(resource) : 1) {
                                  workInProgressSuspendedReason = 0;
                                  workInProgressThrownValue = null;
                                  var sibling = hostFiber.sibling;
                                  if (null !== sibling)
                                    workInProgress = sibling;
                                  else {
                                    var returnFiber = hostFiber.return;
                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                                  }
                                  break b;
                                }
                            }
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                            break;
                          case 6:
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                            break;
                          case 8:
                            resetWorkInProgressStack();
                            workInProgressRootExitStatus = 6;
                            break a;
                          default:
                            throw Error(formatProdErrorMessage(462));
                        }
                    }
                    workLoopConcurrent();
                    break;
                  } catch (thrownValue$166) {
                    handleThrow(root2, thrownValue$166);
                  }
                while (1);
              lastContextDependency = currentlyRenderingFiber = null;
              ReactSharedInternals.H = prevDispatcher;
              ReactSharedInternals.A = prevAsyncDispatcher;
              executionContext = prevExecutionContext;
              if (null !== workInProgress)
                return 0;
              workInProgressRoot = null;
              workInProgressRootRenderLanes = 0;
              finishQueueingConcurrentUpdates();
              return workInProgressRootExitStatus;
            }
            function workLoopConcurrent() {
              for (; null !== workInProgress && !shouldYield(); )
                performUnitOfWork(workInProgress);
            }
            function performUnitOfWork(unitOfWork) {
              var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
              unitOfWork.memoizedProps = unitOfWork.pendingProps;
              null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
            }
            function replaySuspendedUnitOfWork(unitOfWork) {
              var next = unitOfWork;
              var current = next.alternate;
              switch (next.tag) {
                case 15:
                case 0:
                  next = replayFunctionComponent(
                    current,
                    next,
                    next.pendingProps,
                    next.type,
                    void 0,
                    workInProgressRootRenderLanes
                  );
                  break;
                case 11:
                  next = replayFunctionComponent(
                    current,
                    next,
                    next.pendingProps,
                    next.type.render,
                    next.ref,
                    workInProgressRootRenderLanes
                  );
                  break;
                case 5:
                  resetHooksOnUnwind(next);
                default:
                  unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
              }
              unitOfWork.memoizedProps = unitOfWork.pendingProps;
              null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
            }
            function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
              lastContextDependency = currentlyRenderingFiber = null;
              resetHooksOnUnwind(unitOfWork);
              thenableState$1 = null;
              thenableIndexCounter$1 = 0;
              var returnFiber = unitOfWork.return;
              try {
                if (throwException(
                  root2,
                  returnFiber,
                  unitOfWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                )) {
                  workInProgressRootExitStatus = 1;
                  logUncaughtError(
                    root2,
                    createCapturedValueAtFiber(thrownValue, root2.current)
                  );
                  workInProgress = null;
                  return;
                }
              } catch (error) {
                if (null !== returnFiber)
                  throw workInProgress = returnFiber, error;
                workInProgressRootExitStatus = 1;
                logUncaughtError(
                  root2,
                  createCapturedValueAtFiber(thrownValue, root2.current)
                );
                workInProgress = null;
                return;
              }
              if (unitOfWork.flags & 32768) {
                if (isHydrating || 1 === suspendedReason)
                  root2 = true;
                else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
                  root2 = false;
                else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
                  suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
                unwindUnitOfWork(unitOfWork, root2);
              } else
                completeUnitOfWork(unitOfWork);
            }
            function completeUnitOfWork(unitOfWork) {
              var completedWork = unitOfWork;
              do {
                if (0 !== (completedWork.flags & 32768)) {
                  unwindUnitOfWork(
                    completedWork,
                    workInProgressRootDidSkipSuspendedSiblings
                  );
                  return;
                }
                unitOfWork = completedWork.return;
                var next = completeWork(
                  completedWork.alternate,
                  completedWork,
                  entangledRenderLanes
                );
                if (null !== next) {
                  workInProgress = next;
                  return;
                }
                completedWork = completedWork.sibling;
                if (null !== completedWork) {
                  workInProgress = completedWork;
                  return;
                }
                workInProgress = completedWork = unitOfWork;
              } while (null !== completedWork);
              0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
            }
            function unwindUnitOfWork(unitOfWork, skipSiblings) {
              do {
                var next = unwindWork(unitOfWork.alternate, unitOfWork);
                if (null !== next) {
                  next.flags &= 32767;
                  workInProgress = next;
                  return;
                }
                next = unitOfWork.return;
                null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
                if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
                  workInProgress = unitOfWork;
                  return;
                }
                workInProgress = unitOfWork = next;
              } while (null !== unitOfWork);
              workInProgressRootExitStatus = 6;
              workInProgress = null;
            }
            function commitRoot(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
              var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = ReactDOMSharedInternals.p;
              try {
                ReactDOMSharedInternals.p = 2, ReactSharedInternals.T = null, commitRootImpl(
                  root2,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  previousUpdateLanePriority,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  suspendedCommitReason,
                  completedRenderStartTime,
                  completedRenderEndTime
                );
              } finally {
                ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
              }
            }
            function commitRootImpl(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
              do
                flushPassiveEffects();
              while (null !== rootWithPendingPassiveEffects);
              if (0 !== (executionContext & 6))
                throw Error(formatProdErrorMessage(327));
              var finishedWork = root2.finishedWork;
              didIncludeRenderPhaseUpdate = root2.finishedLanes;
              if (null === finishedWork)
                return null;
              root2.finishedWork = null;
              root2.finishedLanes = 0;
              if (finishedWork === root2.current)
                throw Error(formatProdErrorMessage(177));
              root2.callbackNode = null;
              root2.callbackPriority = 0;
              root2.cancelPendingCommit = null;
              var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
              remainingLanes |= concurrentlyUpdatedLanes;
              markRootFinished(
                root2,
                didIncludeRenderPhaseUpdate,
                remainingLanes,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes
              );
              root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
              0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = true, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function() {
                flushPassiveEffects(true);
                return null;
              }));
              transitions = 0 !== (finishedWork.flags & 15990);
              0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = 2, updatedLanes = executionContext, executionContext |= 4, commitBeforeMutationEffects(root2, finishedWork), commitMutationEffectsOnFiber(finishedWork, root2), restoreSelection(selectionInformation, root2.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root2.current = finishedWork, commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root2.current = finishedWork;
              rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = root2, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : releaseRootPooledCache(root2, remainingLanes);
              remainingLanes = root2.pendingLanes;
              0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
              onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
              ensureRootIsScheduled(root2);
              if (null !== recoverableErrors)
                for (renderPriorityLevel = root2.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)
                  remainingLanes = recoverableErrors[finishedWork], renderPriorityLevel(remainingLanes.value, {
                    componentStack: remainingLanes.stack
                  });
              0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
              remainingLanes = root2.pendingLanes;
              0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
              flushSyncWorkAcrossRoots_impl(0, false);
              return null;
            }
            function releaseRootPooledCache(root2, remainingLanes) {
              0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
            }
            function flushPassiveEffects() {
              if (null !== rootWithPendingPassiveEffects) {
                var root$170 = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;
                pendingPassiveEffectsRemainingLanes = 0;
                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
                try {
                  ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
                  ReactSharedInternals.T = null;
                  if (null === rootWithPendingPassiveEffects)
                    var JSCompiler_inline_result = false;
                  else {
                    renderPriority = pendingPassiveTransitions;
                    pendingPassiveTransitions = null;
                    var root2 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
                    rootWithPendingPassiveEffects = null;
                    pendingPassiveEffectsLanes = 0;
                    if (0 !== (executionContext & 6))
                      throw Error(formatProdErrorMessage(331));
                    var prevExecutionContext = executionContext;
                    executionContext |= 4;
                    commitPassiveUnmountOnFiber(root2.current);
                    commitPassiveMountOnFiber(root2, root2.current, lanes, renderPriority);
                    executionContext = prevExecutionContext;
                    flushSyncWorkAcrossRoots_impl(0, false);
                    if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
                      try {
                        injectedHook.onPostCommitFiberRoot(rendererID, root2);
                      } catch (err) {
                      }
                    JSCompiler_inline_result = true;
                  }
                  return JSCompiler_inline_result;
                } finally {
                  ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root$170, remainingLanes);
                }
              }
              return false;
            }
            function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
              rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
              null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
            }
            function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
              if (3 === sourceFiber.tag)
                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
              else
                for (; null !== nearestMountedAncestor; ) {
                  if (3 === nearestMountedAncestor.tag) {
                    captureCommitPhaseErrorOnRoot(
                      nearestMountedAncestor,
                      sourceFiber,
                      error
                    );
                    break;
                  } else if (1 === nearestMountedAncestor.tag) {
                    var instance = nearestMountedAncestor.stateNode;
                    if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                      error = createClassErrorUpdate(2);
                      instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                      null !== instance && (initializeClassErrorUpdate(
                        error,
                        instance,
                        nearestMountedAncestor,
                        sourceFiber
                      ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                      break;
                    }
                  }
                  nearestMountedAncestor = nearestMountedAncestor.return;
                }
            }
            function attachPingListener(root2, wakeable, lanes) {
              var pingCache = root2.pingCache;
              if (null === pingCache) {
                pingCache = root2.pingCache = new PossiblyWeakMap();
                var threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              } else
                threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
              threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
            }
            function pingSuspendedRoot(root2, wakeable, pingedLanes) {
              var pingCache = root2.pingCache;
              null !== pingCache && pingCache.delete(wakeable);
              root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
              root2.warmLanes &= ~pingedLanes;
              workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
              ensureRootIsScheduled(root2);
            }
            function retryTimedOutBoundary(boundaryFiber, retryLane) {
              0 === retryLane && (retryLane = claimNextRetryLane());
              boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
              null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
            }
            function retryDehydratedSuspenseBoundary(boundaryFiber) {
              var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              retryTimedOutBoundary(boundaryFiber, retryLane);
            }
            function resolveRetryWakeable(boundaryFiber, wakeable) {
              var retryLane = 0;
              switch (boundaryFiber.tag) {
                case 13:
                  var retryCache = boundaryFiber.stateNode;
                  var suspenseState = boundaryFiber.memoizedState;
                  null !== suspenseState && (retryLane = suspenseState.retryLane);
                  break;
                case 19:
                  retryCache = boundaryFiber.stateNode;
                  break;
                case 22:
                  retryCache = boundaryFiber.stateNode._retryCache;
                  break;
                default:
                  throw Error(formatProdErrorMessage(314));
              }
              null !== retryCache && retryCache.delete(wakeable);
              retryTimedOutBoundary(boundaryFiber, retryLane);
            }
            function scheduleCallback$1(priorityLevel, callback) {
              return scheduleCallback$3(priorityLevel, callback);
            }
            var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
            function ensureRootIsScheduled(root2) {
              root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
              mightHavePendingSyncWork = true;
              didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateTask(processRootScheduleInMicrotask));
            }
            function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
              if (!isFlushingWork && mightHavePendingSyncWork) {
                isFlushingWork = true;
                do {
                  var didPerformSomeWork = false;
                  for (var root$172 = firstScheduledRoot; null !== root$172; ) {
                    if (!onlyLegacy)
                      if (0 !== syncTransitionLanes) {
                        var pendingLanes = root$172.pendingLanes;
                        if (0 === pendingLanes)
                          var JSCompiler_inline_result = 0;
                        else {
                          var suspendedLanes = root$172.suspendedLanes, pingedLanes = root$172.pingedLanes;
                          JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                          JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                          JSCompiler_inline_result = JSCompiler_inline_result & 201326677 ? JSCompiler_inline_result & 201326677 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                        }
                        0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
                      } else
                        JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                          root$172,
                          root$172 === workInProgressRoot ? JSCompiler_inline_result : 0
                        ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
                    root$172 = root$172.next;
                  }
                } while (didPerformSomeWork);
                isFlushingWork = false;
              }
            }
            function processRootScheduleInMicrotask() {
              mightHavePendingSyncWork = didScheduleMicrotask = false;
              var syncTransitionLanes = 0;
              0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
              for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
                var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
                if (0 === nextLanes)
                  root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
                else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
                  mightHavePendingSyncWork = true;
                root2 = next;
              }
              flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
            }
            function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
              for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
                var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
                if (-1 === expirationTime) {
                  if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                    expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
                } else
                  expirationTime <= currentTime && (root2.expiredLanes |= lane);
                lanes &= ~lane;
              }
              currentTime = workInProgressRoot;
              suspendedLanes = workInProgressRootRenderLanes;
              suspendedLanes = getNextLanes(
                root2,
                root2 === currentTime ? suspendedLanes : 0
              );
              pingedLanes = root2.callbackNode;
              if (0 === suspendedLanes || root2 === currentTime && 2 === workInProgressSuspendedReason || null !== root2.cancelPendingCommit)
                return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
              if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
                currentTime = suspendedLanes & -suspendedLanes;
                if (currentTime === root2.callbackPriority)
                  return currentTime;
                null !== pingedLanes && cancelCallback$1(pingedLanes);
                switch (lanesToEventPriority(suspendedLanes)) {
                  case 2:
                  case 8:
                    suspendedLanes = UserBlockingPriority;
                    break;
                  case 32:
                    suspendedLanes = NormalPriority$1;
                    break;
                  case 268435456:
                    suspendedLanes = IdlePriority;
                    break;
                  default:
                    suspendedLanes = NormalPriority$1;
                }
                pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
                suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
                root2.callbackPriority = currentTime;
                root2.callbackNode = suspendedLanes;
                return currentTime;
              }
              null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
              root2.callbackPriority = 2;
              root2.callbackNode = null;
              return 2;
            }
            function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
              var originalCallbackNode = root2.callbackNode;
              if (flushPassiveEffects() && root2.callbackNode !== originalCallbackNode)
                return null;
              var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
              workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
                root2,
                root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
              );
              if (0 === workInProgressRootRenderLanes$jscomp$0)
                return null;
              performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
              scheduleTaskForRootDuringMicrotask(root2, now());
              return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
            }
            function performSyncWorkOnRoot(root2, lanes) {
              if (flushPassiveEffects())
                return null;
              performWorkOnRoot(root2, lanes, true);
            }
            function scheduleImmediateTask(cb) {
              scheduleMicrotask(function() {
                0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, cb) : cb();
              });
            }
            function requestTransitionLane() {
              0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
              return currentEventTransitionLane;
            }
            function coerceFormActionProp(actionProp) {
              return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
            }
            function createFormDataWithSubmitter(form, submitter) {
              var temp = submitter.ownerDocument.createElement("input");
              temp.name = submitter.name;
              temp.value = submitter.value;
              form.id && temp.setAttribute("form", form.id);
              submitter.parentNode.insertBefore(temp, submitter);
              form = new FormData(form);
              temp.parentNode.removeChild(temp);
              return form;
            }
            function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
              if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
                var action = coerceFormActionProp(
                  (nativeEventTarget[internalPropsKey] || null).action
                ), submitter = nativeEvent.submitter;
                submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
                var event = new SyntheticEvent(
                  "action",
                  "action",
                  null,
                  nativeEvent,
                  nativeEventTarget
                );
                dispatchQueue.push({
                  event,
                  listeners: [
                    {
                      instance: null,
                      listener: function() {
                        if (nativeEvent.defaultPrevented) {
                          if (0 !== currentEventTransitionLane) {
                            var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                            startHostTransition(
                              maybeTargetInst,
                              {
                                pending: true,
                                data: formData,
                                method: nativeEventTarget.method,
                                action
                              },
                              null,
                              formData
                            );
                          }
                        } else
                          "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                            maybeTargetInst,
                            {
                              pending: true,
                              data: formData,
                              method: nativeEventTarget.method,
                              action
                            },
                            action,
                            formData
                          ));
                      },
                      currentTarget: nativeEventTarget
                    }
                  ]
                });
              }
            }
            for (var i$jscomp$inline_1439 = 0; i$jscomp$inline_1439 < simpleEventPluginEvents.length; i$jscomp$inline_1439++) {
              var eventName$jscomp$inline_1440 = simpleEventPluginEvents[i$jscomp$inline_1439], domEventName$jscomp$inline_1441 = eventName$jscomp$inline_1440.toLowerCase(), capitalizedEvent$jscomp$inline_1442 = eventName$jscomp$inline_1440[0].toUpperCase() + eventName$jscomp$inline_1440.slice(1);
              registerSimpleEvent(
                domEventName$jscomp$inline_1441,
                "on" + capitalizedEvent$jscomp$inline_1442
              );
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
            registerSimpleEvent(TRANSITION_START, "onTransitionStart");
            registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
            registerTwoPhaseEvent(
              "onChange",
              "change click focusin focusout input keydown keyup selectionchange".split(" ")
            );
            registerTwoPhaseEvent(
              "onSelect",
              "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
                " "
              )
            );
            registerTwoPhaseEvent("onBeforeInput", [
              "compositionend",
              "keypress",
              "textInput",
              "paste"
            ]);
            registerTwoPhaseEvent(
              "onCompositionEnd",
              "compositionend focusout keydown keypress keyup mousedown".split(" ")
            );
            registerTwoPhaseEvent(
              "onCompositionStart",
              "compositionstart focusout keydown keypress keyup mousedown".split(" ")
            );
            registerTwoPhaseEvent(
              "onCompositionUpdate",
              "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
            );
            var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
              " "
            ), nonDelegatedEvents = new Set(
              "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
            );
            function processDispatchQueue(dispatchQueue, eventSystemFlags) {
              eventSystemFlags = 0 !== (eventSystemFlags & 4);
              for (var i = 0; i < dispatchQueue.length; i++) {
                var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
                _dispatchQueue$i = _dispatchQueue$i.listeners;
                a: {
                  var previousInstance = void 0;
                  if (eventSystemFlags)
                    for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                      var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                      _dispatchListeners$i = _dispatchListeners$i.listener;
                      if (instance !== previousInstance && event.isPropagationStopped())
                        break a;
                      previousInstance = _dispatchListeners$i;
                      event.currentTarget = currentTarget;
                      try {
                        previousInstance(event);
                      } catch (error) {
                        reportGlobalError(error);
                      }
                      event.currentTarget = null;
                      previousInstance = instance;
                    }
                  else
                    for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                      _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                      instance = _dispatchListeners$i.instance;
                      currentTarget = _dispatchListeners$i.currentTarget;
                      _dispatchListeners$i = _dispatchListeners$i.listener;
                      if (instance !== previousInstance && event.isPropagationStopped())
                        break a;
                      previousInstance = _dispatchListeners$i;
                      event.currentTarget = currentTarget;
                      try {
                        previousInstance(event);
                      } catch (error) {
                        reportGlobalError(error);
                      }
                      event.currentTarget = null;
                      previousInstance = instance;
                    }
                }
              }
            }
            function listenToNonDelegatedEvent(domEventName, targetElement) {
              var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
              void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
              var listenerSetKey = domEventName + "__bubble";
              JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
            }
            function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
              var eventSystemFlags = 0;
              isCapturePhaseListener && (eventSystemFlags |= 4);
              addTrappedEventListener(
                target,
                domEventName,
                eventSystemFlags,
                isCapturePhaseListener
              );
            }
            var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
            function listenToAllSupportedEvents(rootContainerElement) {
              if (!rootContainerElement[listeningMarker]) {
                rootContainerElement[listeningMarker] = true;
                allNativeEvents.forEach(function(domEventName) {
                  "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
                });
                var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
                null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
              }
            }
            function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
              switch (getEventPriority(domEventName)) {
                case 2:
                  var listenerWrapper = dispatchDiscreteEvent;
                  break;
                case 8:
                  listenerWrapper = dispatchContinuousEvent;
                  break;
                default:
                  listenerWrapper = dispatchEvent;
              }
              eventSystemFlags = listenerWrapper.bind(
                null,
                domEventName,
                eventSystemFlags,
                targetContainer
              );
              listenerWrapper = void 0;
              !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
              isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                capture: true,
                passive: listenerWrapper
              }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                passive: listenerWrapper
              }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
            }
            function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
              var ancestorInst = targetInst$jscomp$0;
              if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
                a:
                  for (; ; ) {
                    if (null === targetInst$jscomp$0)
                      return;
                    var nodeTag = targetInst$jscomp$0.tag;
                    if (3 === nodeTag || 4 === nodeTag) {
                      var container = targetInst$jscomp$0.stateNode.containerInfo;
                      if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer)
                        break;
                      if (4 === nodeTag)
                        for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                          var grandTag = nodeTag.tag;
                          if (3 === grandTag || 4 === grandTag) {
                            if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer)
                              return;
                          }
                          nodeTag = nodeTag.return;
                        }
                      for (; null !== container; ) {
                        nodeTag = getClosestInstanceFromNode(container);
                        if (null === nodeTag)
                          return;
                        grandTag = nodeTag.tag;
                        if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                          targetInst$jscomp$0 = ancestorInst = nodeTag;
                          continue a;
                        }
                        container = container.parentNode;
                      }
                    }
                    targetInst$jscomp$0 = targetInst$jscomp$0.return;
                  }
              batchedUpdates$1(function() {
                var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
                a: {
                  var reactName = topLevelEventsToReactNames.get(domEventName);
                  if (void 0 !== reactName) {
                    var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                    switch (domEventName) {
                      case "keypress":
                        if (0 === getEventCharCode(nativeEvent))
                          break a;
                      case "keydown":
                      case "keyup":
                        SyntheticEventCtor = SyntheticKeyboardEvent;
                        break;
                      case "focusin":
                        reactEventType = "focus";
                        SyntheticEventCtor = SyntheticFocusEvent;
                        break;
                      case "focusout":
                        reactEventType = "blur";
                        SyntheticEventCtor = SyntheticFocusEvent;
                        break;
                      case "beforeblur":
                      case "afterblur":
                        SyntheticEventCtor = SyntheticFocusEvent;
                        break;
                      case "click":
                        if (2 === nativeEvent.button)
                          break a;
                      case "auxclick":
                      case "dblclick":
                      case "mousedown":
                      case "mousemove":
                      case "mouseup":
                      case "mouseout":
                      case "mouseover":
                      case "contextmenu":
                        SyntheticEventCtor = SyntheticMouseEvent;
                        break;
                      case "drag":
                      case "dragend":
                      case "dragenter":
                      case "dragexit":
                      case "dragleave":
                      case "dragover":
                      case "dragstart":
                      case "drop":
                        SyntheticEventCtor = SyntheticDragEvent;
                        break;
                      case "touchcancel":
                      case "touchend":
                      case "touchmove":
                      case "touchstart":
                        SyntheticEventCtor = SyntheticTouchEvent;
                        break;
                      case ANIMATION_END:
                      case ANIMATION_ITERATION:
                      case ANIMATION_START:
                        SyntheticEventCtor = SyntheticAnimationEvent;
                        break;
                      case TRANSITION_END:
                        SyntheticEventCtor = SyntheticTransitionEvent;
                        break;
                      case "scroll":
                      case "scrollend":
                        SyntheticEventCtor = SyntheticUIEvent;
                        break;
                      case "wheel":
                        SyntheticEventCtor = SyntheticWheelEvent;
                        break;
                      case "copy":
                      case "cut":
                      case "paste":
                        SyntheticEventCtor = SyntheticClipboardEvent;
                        break;
                      case "gotpointercapture":
                      case "lostpointercapture":
                      case "pointercancel":
                      case "pointerdown":
                      case "pointermove":
                      case "pointerout":
                      case "pointerover":
                      case "pointerup":
                        SyntheticEventCtor = SyntheticPointerEvent;
                        break;
                      case "toggle":
                      case "beforetoggle":
                        SyntheticEventCtor = SyntheticToggleEvent;
                    }
                    var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                    inCapturePhase = [];
                    for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                      var _instance = instance;
                      lastHostComponent = _instance.stateNode;
                      _instance = _instance.tag;
                      5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                        createDispatchListener(instance, _instance, lastHostComponent)
                      ));
                      if (accumulateTargetOnly)
                        break;
                      instance = instance.return;
                    }
                    0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                      reactName,
                      reactEventType,
                      null,
                      nativeEvent,
                      nativeEventTarget
                    ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
                  }
                }
                if (0 === (eventSystemFlags & 7)) {
                  a: {
                    reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                    SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                    if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                      break a;
                    if (SyntheticEventCtor || reactName) {
                      reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                      if (SyntheticEventCtor) {
                        if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                          reactEventType = null;
                      } else
                        SyntheticEventCtor = null, reactEventType = targetInst;
                      if (SyntheticEventCtor !== reactEventType) {
                        inCapturePhase = SyntheticMouseEvent;
                        _instance = "onMouseLeave";
                        reactEventName = "onMouseEnter";
                        instance = "mouse";
                        if ("pointerout" === domEventName || "pointerover" === domEventName)
                          inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                        accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                        lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                        reactName = new inCapturePhase(
                          _instance,
                          instance + "leave",
                          SyntheticEventCtor,
                          nativeEvent,
                          nativeEventTarget
                        );
                        reactName.target = accumulateTargetOnly;
                        reactName.relatedTarget = lastHostComponent;
                        _instance = null;
                        getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                          reactEventName,
                          instance + "enter",
                          reactEventType,
                          nativeEvent,
                          nativeEventTarget
                        ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                        accumulateTargetOnly = _instance;
                        if (SyntheticEventCtor && reactEventType)
                          b: {
                            inCapturePhase = SyntheticEventCtor;
                            reactEventName = reactEventType;
                            instance = 0;
                            for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                              instance++;
                            lastHostComponent = 0;
                            for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                              lastHostComponent++;
                            for (; 0 < instance - lastHostComponent; )
                              inCapturePhase = getParent(inCapturePhase), instance--;
                            for (; 0 < lastHostComponent - instance; )
                              reactEventName = getParent(reactEventName), lastHostComponent--;
                            for (; instance--; ) {
                              if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                                break b;
                              inCapturePhase = getParent(inCapturePhase);
                              reactEventName = getParent(reactEventName);
                            }
                            inCapturePhase = null;
                          }
                        else
                          inCapturePhase = null;
                        null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                          dispatchQueue,
                          reactName,
                          SyntheticEventCtor,
                          inCapturePhase,
                          false
                        );
                        null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                          dispatchQueue,
                          accumulateTargetOnly,
                          reactEventType,
                          inCapturePhase,
                          true
                        );
                      }
                    }
                  }
                  a: {
                    reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                    SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                    if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                      var getTargetInstFunc = getTargetInstForChangeEvent;
                    else if (isTextInputElement(reactName))
                      if (isInputEventSupported)
                        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                      else {
                        getTargetInstFunc = getTargetInstForInputEventPolyfill;
                        var handleEventFunc = handleEventsForInputEventPolyfill;
                      }
                    else
                      SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                    if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                      createAndAccumulateChangeEvent(
                        dispatchQueue,
                        getTargetInstFunc,
                        nativeEvent,
                        nativeEventTarget
                      );
                      break a;
                    }
                    handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                    "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
                  }
                  handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
                  switch (domEventName) {
                    case "focusin":
                      if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                        activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                      break;
                    case "focusout":
                      lastSelection = activeElementInst = activeElement = null;
                      break;
                    case "mousedown":
                      mouseDown = true;
                      break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                      mouseDown = false;
                      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                      break;
                    case "selectionchange":
                      if (skipSelectionChangeEvent)
                        break;
                    case "keydown":
                    case "keyup":
                      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                  }
                  var fallbackData;
                  if (canUseCompositionEvent)
                    b: {
                      switch (domEventName) {
                        case "compositionstart":
                          var eventType = "onCompositionStart";
                          break b;
                        case "compositionend":
                          eventType = "onCompositionEnd";
                          break b;
                        case "compositionupdate":
                          eventType = "onCompositionUpdate";
                          break b;
                      }
                      eventType = void 0;
                    }
                  else
                    isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
                  eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                    eventType,
                    domEventName,
                    null,
                    nativeEvent,
                    nativeEventTarget
                  ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
                  if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                    eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                      "onBeforeInput",
                      "beforeinput",
                      null,
                      nativeEvent,
                      nativeEventTarget
                    ), dispatchQueue.push({
                      event: handleEventFunc,
                      listeners: eventType
                    }), handleEventFunc.data = fallbackData);
                  extractEvents$1(
                    dispatchQueue,
                    domEventName,
                    targetInst,
                    nativeEvent,
                    nativeEventTarget
                  );
                }
                processDispatchQueue(dispatchQueue, eventSystemFlags);
              });
            }
            function createDispatchListener(instance, listener, currentTarget) {
              return {
                instance,
                listener,
                currentTarget
              };
            }
            function accumulateTwoPhaseListeners(targetFiber, reactName) {
              for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
                var _instance2 = targetFiber, stateNode = _instance2.stateNode;
                _instance2 = _instance2.tag;
                5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
                  createDispatchListener(targetFiber, _instance2, stateNode)
                ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
                  createDispatchListener(targetFiber, _instance2, stateNode)
                ));
                targetFiber = targetFiber.return;
              }
              return listeners;
            }
            function getParent(inst) {
              if (null === inst)
                return null;
              do
                inst = inst.return;
              while (inst && 5 !== inst.tag && 27 !== inst.tag);
              return inst ? inst : null;
            }
            function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
              for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
                var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
                _instance3 = _instance3.tag;
                if (null !== alternate && alternate === common)
                  break;
                5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
                  createDispatchListener(target, stateNode, alternate)
                )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
                  createDispatchListener(target, stateNode, alternate)
                )));
                target = target.return;
              }
              0 !== listeners.length && dispatchQueue.push({ event, listeners });
            }
            var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
            function normalizeMarkupForTextOrAttribute(markup) {
              return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
            }
            function checkForUnmatchedText(serverText, clientText) {
              clientText = normalizeMarkupForTextOrAttribute(clientText);
              return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
            }
            function noop$1() {
            }
            function setProp(domElement, tag, key, value, props, prevValue) {
              switch (key) {
                case "children":
                  "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
                  break;
                case "className":
                  setValueForKnownAttribute(domElement, "class", value);
                  break;
                case "tabIndex":
                  setValueForKnownAttribute(domElement, "tabindex", value);
                  break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                  setValueForKnownAttribute(domElement, key, value);
                  break;
                case "style":
                  setValueForStyles(domElement, value, prevValue);
                  break;
                case "data":
                  if ("object" !== tag) {
                    setValueForKnownAttribute(domElement, "data", value);
                    break;
                  }
                case "src":
                case "href":
                  if ("" === value && ("a" !== tag || "href" !== key)) {
                    domElement.removeAttribute(key);
                    break;
                  }
                  if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                    domElement.removeAttribute(key);
                    break;
                  }
                  value = sanitizeURL("" + value);
                  domElement.setAttribute(key, value);
                  break;
                case "action":
                case "formAction":
                  if ("function" === typeof value) {
                    domElement.setAttribute(
                      key,
                      "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                    );
                    break;
                  } else
                    "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                      domElement,
                      tag,
                      "formEncType",
                      props.formEncType,
                      props,
                      null
                    ), setProp(
                      domElement,
                      tag,
                      "formMethod",
                      props.formMethod,
                      props,
                      null
                    ), setProp(
                      domElement,
                      tag,
                      "formTarget",
                      props.formTarget,
                      props,
                      null
                    )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
                  if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                    domElement.removeAttribute(key);
                    break;
                  }
                  value = sanitizeURL("" + value);
                  domElement.setAttribute(key, value);
                  break;
                case "onClick":
                  null != value && (domElement.onclick = noop$1);
                  break;
                case "onScroll":
                  null != value && listenToNonDelegatedEvent("scroll", domElement);
                  break;
                case "onScrollEnd":
                  null != value && listenToNonDelegatedEvent("scrollend", domElement);
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != value) {
                    if ("object" !== typeof value || !("__html" in value))
                      throw Error(formatProdErrorMessage(61));
                    key = value.__html;
                    if (null != key) {
                      if (null != props.children)
                        throw Error(formatProdErrorMessage(60));
                      domElement.innerHTML = key;
                    }
                  }
                  break;
                case "multiple":
                  domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
                  break;
                case "muted":
                  domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  break;
                case "autoFocus":
                  break;
                case "xlinkHref":
                  if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                    domElement.removeAttribute("xlink:href");
                    break;
                  }
                  key = sanitizeURL("" + value);
                  domElement.setAttributeNS(
                    "http://www.w3.org/1999/xlink",
                    "xlink:href",
                    key
                  );
                  break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
                  break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
                  break;
                case "capture":
                case "download":
                  true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
                  break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
                  break;
                case "rowSpan":
                case "start":
                  null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
                  break;
                case "popover":
                  listenToNonDelegatedEvent("beforetoggle", domElement);
                  listenToNonDelegatedEvent("toggle", domElement);
                  setValueForAttribute(domElement, "popover", value);
                  break;
                case "xlinkActuate":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:actuate",
                    value
                  );
                  break;
                case "xlinkArcrole":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:arcrole",
                    value
                  );
                  break;
                case "xlinkRole":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:role",
                    value
                  );
                  break;
                case "xlinkShow":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:show",
                    value
                  );
                  break;
                case "xlinkTitle":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:title",
                    value
                  );
                  break;
                case "xlinkType":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/1999/xlink",
                    "xlink:type",
                    value
                  );
                  break;
                case "xmlBase":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:base",
                    value
                  );
                  break;
                case "xmlLang":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:lang",
                    value
                  );
                  break;
                case "xmlSpace":
                  setValueForNamespacedAttribute(
                    domElement,
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    value
                  );
                  break;
                case "is":
                  setValueForAttribute(domElement, "is", value);
                  break;
                case "innerText":
                case "textContent":
                  break;
                default:
                  if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
                    key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
              }
            }
            function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
              switch (key) {
                case "style":
                  setValueForStyles(domElement, value, prevValue);
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != value) {
                    if ("object" !== typeof value || !("__html" in value))
                      throw Error(formatProdErrorMessage(61));
                    key = value.__html;
                    if (null != key) {
                      if (null != props.children)
                        throw Error(formatProdErrorMessage(60));
                      domElement.innerHTML = key;
                    }
                  }
                  break;
                case "children":
                  "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
                  break;
                case "onScroll":
                  null != value && listenToNonDelegatedEvent("scroll", domElement);
                  break;
                case "onScrollEnd":
                  null != value && listenToNonDelegatedEvent("scrollend", domElement);
                  break;
                case "onClick":
                  null != value && (domElement.onclick = noop$1);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                  break;
                case "innerText":
                case "textContent":
                  break;
                default:
                  if (!registrationNameDependencies.hasOwnProperty(key))
                    a: {
                      if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                        "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                        domElement.addEventListener(tag, value, props);
                        break a;
                      }
                      key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                    }
              }
            }
            function setInitialProperties(domElement, tag, props) {
              switch (tag) {
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                  break;
                case "img":
                  listenToNonDelegatedEvent("error", domElement);
                  listenToNonDelegatedEvent("load", domElement);
                  var hasSrc = false, hasSrcSet = false, propKey;
                  for (propKey in props)
                    if (props.hasOwnProperty(propKey)) {
                      var propValue = props[propKey];
                      if (null != propValue)
                        switch (propKey) {
                          case "src":
                            hasSrc = true;
                            break;
                          case "srcSet":
                            hasSrcSet = true;
                            break;
                          case "children":
                          case "dangerouslySetInnerHTML":
                            throw Error(formatProdErrorMessage(137, tag));
                          default:
                            setProp(domElement, tag, propKey, propValue, props, null);
                        }
                    }
                  hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
                  hasSrc && setProp(domElement, tag, "src", props.src, props, null);
                  return;
                case "input":
                  listenToNonDelegatedEvent("invalid", domElement);
                  var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
                  for (hasSrc in props)
                    if (props.hasOwnProperty(hasSrc)) {
                      var propValue$186 = props[hasSrc];
                      if (null != propValue$186)
                        switch (hasSrc) {
                          case "name":
                            hasSrcSet = propValue$186;
                            break;
                          case "type":
                            propValue = propValue$186;
                            break;
                          case "checked":
                            checked = propValue$186;
                            break;
                          case "defaultChecked":
                            defaultChecked = propValue$186;
                            break;
                          case "value":
                            propKey = propValue$186;
                            break;
                          case "defaultValue":
                            defaultValue = propValue$186;
                            break;
                          case "children":
                          case "dangerouslySetInnerHTML":
                            if (null != propValue$186)
                              throw Error(formatProdErrorMessage(137, tag));
                            break;
                          default:
                            setProp(domElement, tag, hasSrc, propValue$186, props, null);
                        }
                    }
                  initInput(
                    domElement,
                    propKey,
                    defaultValue,
                    checked,
                    defaultChecked,
                    propValue,
                    hasSrcSet,
                    false
                  );
                  track(domElement);
                  return;
                case "select":
                  listenToNonDelegatedEvent("invalid", domElement);
                  hasSrc = propValue = propKey = null;
                  for (hasSrcSet in props)
                    if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                      switch (hasSrcSet) {
                        case "value":
                          propKey = defaultValue;
                          break;
                        case "defaultValue":
                          propValue = defaultValue;
                          break;
                        case "multiple":
                          hasSrc = defaultValue;
                        default:
                          setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                      }
                  tag = propKey;
                  props = propValue;
                  domElement.multiple = !!hasSrc;
                  null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
                  return;
                case "textarea":
                  listenToNonDelegatedEvent("invalid", domElement);
                  propKey = hasSrcSet = hasSrc = null;
                  for (propValue in props)
                    if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                      switch (propValue) {
                        case "value":
                          hasSrc = defaultValue;
                          break;
                        case "defaultValue":
                          hasSrcSet = defaultValue;
                          break;
                        case "children":
                          propKey = defaultValue;
                          break;
                        case "dangerouslySetInnerHTML":
                          if (null != defaultValue)
                            throw Error(formatProdErrorMessage(91));
                          break;
                        default:
                          setProp(domElement, tag, propValue, defaultValue, props, null);
                      }
                  initTextarea(domElement, hasSrc, hasSrcSet, propKey);
                  track(domElement);
                  return;
                case "option":
                  for (checked in props)
                    if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                      switch (checked) {
                        case "selected":
                          domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                          break;
                        default:
                          setProp(domElement, tag, checked, hasSrc, props, null);
                      }
                  return;
                case "dialog":
                  listenToNonDelegatedEvent("cancel", domElement);
                  listenToNonDelegatedEvent("close", domElement);
                  break;
                case "iframe":
                case "object":
                  listenToNonDelegatedEvent("load", domElement);
                  break;
                case "video":
                case "audio":
                  for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                    listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
                  break;
                case "image":
                  listenToNonDelegatedEvent("error", domElement);
                  listenToNonDelegatedEvent("load", domElement);
                  break;
                case "details":
                  listenToNonDelegatedEvent("toggle", domElement);
                  break;
                case "embed":
                case "source":
                case "link":
                  listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                  for (defaultChecked in props)
                    if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                      switch (defaultChecked) {
                        case "children":
                        case "dangerouslySetInnerHTML":
                          throw Error(formatProdErrorMessage(137, tag));
                        default:
                          setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                      }
                  return;
                default:
                  if (isCustomElement(tag)) {
                    for (propValue$186 in props)
                      props.hasOwnProperty(propValue$186) && (hasSrc = props[propValue$186], void 0 !== hasSrc && setPropOnCustomElement(
                        domElement,
                        tag,
                        propValue$186,
                        hasSrc,
                        props,
                        void 0
                      ));
                    return;
                  }
              }
              for (defaultValue in props)
                props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
            }
            function updateProperties(domElement, tag, lastProps, nextProps) {
              switch (tag) {
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                  break;
                case "input":
                  var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
                  for (propKey in lastProps) {
                    var lastProp = lastProps[propKey];
                    if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                      switch (propKey) {
                        case "checked":
                          break;
                        case "value":
                          break;
                        case "defaultValue":
                          lastDefaultValue = lastProp;
                        default:
                          nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                      }
                  }
                  for (var propKey$203 in nextProps) {
                    var propKey = nextProps[propKey$203];
                    lastProp = lastProps[propKey$203];
                    if (nextProps.hasOwnProperty(propKey$203) && (null != propKey || null != lastProp))
                      switch (propKey$203) {
                        case "type":
                          type = propKey;
                          break;
                        case "name":
                          name = propKey;
                          break;
                        case "checked":
                          checked = propKey;
                          break;
                        case "defaultChecked":
                          defaultChecked = propKey;
                          break;
                        case "value":
                          value = propKey;
                          break;
                        case "defaultValue":
                          defaultValue = propKey;
                          break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                          if (null != propKey)
                            throw Error(formatProdErrorMessage(137, tag));
                          break;
                        default:
                          propKey !== lastProp && setProp(
                            domElement,
                            tag,
                            propKey$203,
                            propKey,
                            nextProps,
                            lastProp
                          );
                      }
                  }
                  updateInput(
                    domElement,
                    value,
                    defaultValue,
                    lastDefaultValue,
                    checked,
                    defaultChecked,
                    type,
                    name
                  );
                  return;
                case "select":
                  propKey = value = defaultValue = propKey$203 = null;
                  for (type in lastProps)
                    if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                      switch (type) {
                        case "value":
                          break;
                        case "multiple":
                          propKey = lastDefaultValue;
                        default:
                          nextProps.hasOwnProperty(type) || setProp(
                            domElement,
                            tag,
                            type,
                            null,
                            nextProps,
                            lastDefaultValue
                          );
                      }
                  for (name in nextProps)
                    if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                      switch (name) {
                        case "value":
                          propKey$203 = type;
                          break;
                        case "defaultValue":
                          defaultValue = type;
                          break;
                        case "multiple":
                          value = type;
                        default:
                          type !== lastDefaultValue && setProp(
                            domElement,
                            tag,
                            name,
                            type,
                            nextProps,
                            lastDefaultValue
                          );
                      }
                  tag = defaultValue;
                  lastProps = value;
                  nextProps = propKey;
                  null != propKey$203 ? updateOptions(domElement, !!lastProps, propKey$203, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
                  return;
                case "textarea":
                  propKey = propKey$203 = null;
                  for (defaultValue in lastProps)
                    if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                      switch (defaultValue) {
                        case "value":
                          break;
                        case "children":
                          break;
                        default:
                          setProp(domElement, tag, defaultValue, null, nextProps, name);
                      }
                  for (value in nextProps)
                    if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                      switch (value) {
                        case "value":
                          propKey$203 = name;
                          break;
                        case "defaultValue":
                          propKey = name;
                          break;
                        case "children":
                          break;
                        case "dangerouslySetInnerHTML":
                          if (null != name)
                            throw Error(formatProdErrorMessage(91));
                          break;
                        default:
                          name !== type && setProp(domElement, tag, value, name, nextProps, type);
                      }
                  updateTextarea(domElement, propKey$203, propKey);
                  return;
                case "option":
                  for (var propKey$219 in lastProps)
                    if (propKey$203 = lastProps[propKey$219], lastProps.hasOwnProperty(propKey$219) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$219))
                      switch (propKey$219) {
                        case "selected":
                          domElement.selected = false;
                          break;
                        default:
                          setProp(
                            domElement,
                            tag,
                            propKey$219,
                            null,
                            nextProps,
                            propKey$203
                          );
                      }
                  for (lastDefaultValue in nextProps)
                    if (propKey$203 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$203 !== propKey && (null != propKey$203 || null != propKey))
                      switch (lastDefaultValue) {
                        case "selected":
                          domElement.selected = propKey$203 && "function" !== typeof propKey$203 && "symbol" !== typeof propKey$203;
                          break;
                        default:
                          setProp(
                            domElement,
                            tag,
                            lastDefaultValue,
                            propKey$203,
                            nextProps,
                            propKey
                          );
                      }
                  return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                  for (var propKey$224 in lastProps)
                    propKey$203 = lastProps[propKey$224], lastProps.hasOwnProperty(propKey$224) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$224) && setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);
                  for (checked in nextProps)
                    if (propKey$203 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$203 !== propKey && (null != propKey$203 || null != propKey))
                      switch (checked) {
                        case "children":
                        case "dangerouslySetInnerHTML":
                          if (null != propKey$203)
                            throw Error(formatProdErrorMessage(137, tag));
                          break;
                        default:
                          setProp(
                            domElement,
                            tag,
                            checked,
                            propKey$203,
                            nextProps,
                            propKey
                          );
                      }
                  return;
                default:
                  if (isCustomElement(tag)) {
                    for (var propKey$229 in lastProps)
                      propKey$203 = lastProps[propKey$229], lastProps.hasOwnProperty(propKey$229) && void 0 !== propKey$203 && !nextProps.hasOwnProperty(propKey$229) && setPropOnCustomElement(
                        domElement,
                        tag,
                        propKey$229,
                        void 0,
                        nextProps,
                        propKey$203
                      );
                    for (defaultChecked in nextProps)
                      propKey$203 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$203 === propKey || void 0 === propKey$203 && void 0 === propKey || setPropOnCustomElement(
                        domElement,
                        tag,
                        defaultChecked,
                        propKey$203,
                        nextProps,
                        propKey
                      );
                    return;
                  }
              }
              for (var propKey$234 in lastProps)
                propKey$203 = lastProps[propKey$234], lastProps.hasOwnProperty(propKey$234) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$234) && setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);
              for (lastProp in nextProps)
                propKey$203 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$203 === propKey || null == propKey$203 && null == propKey || setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);
            }
            var eventsEnabled = null, selectionInformation = null;
            function getOwnerDocumentFromRootContainer(rootContainerElement) {
              return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            }
            function getOwnHostContext(namespaceURI) {
              switch (namespaceURI) {
                case "http://www.w3.org/2000/svg":
                  return 1;
                case "http://www.w3.org/1998/Math/MathML":
                  return 2;
                default:
                  return 0;
              }
            }
            function getChildHostContextProd(parentNamespace, type) {
              if (0 === parentNamespace)
                switch (type) {
                  case "svg":
                    return 1;
                  case "math":
                    return 2;
                  default:
                    return 0;
                }
              return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
            }
            function shouldSetTextContent(type, props) {
              return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
            }
            var currentPopstateTransitionEvent = null;
            function shouldAttemptEagerTransition() {
              var event = window.event;
              if (event && "popstate" === event.type) {
                if (event === currentPopstateTransitionEvent)
                  return false;
                currentPopstateTransitionEvent = event;
                return true;
              }
              currentPopstateTransitionEvent = null;
              return false;
            }
            var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
              return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
            } : scheduleTimeout;
            function handleErrorInNextTick(error) {
              setTimeout(function() {
                throw error;
              });
            }
            function clearSuspenseBoundary(parentInstance, suspenseInstance) {
              var node = suspenseInstance, depth = 0;
              do {
                var nextNode = node.nextSibling;
                parentInstance.removeChild(node);
                if (nextNode && 8 === nextNode.nodeType)
                  if (node = nextNode.data, "/$" === node) {
                    if (0 === depth) {
                      parentInstance.removeChild(nextNode);
                      retryIfBlockedOn(suspenseInstance);
                      return;
                    }
                    depth--;
                  } else
                    "$" !== node && "$?" !== node && "$!" !== node || depth++;
                node = nextNode;
              } while (node);
              retryIfBlockedOn(suspenseInstance);
            }
            function clearContainerSparingly(container) {
              var nextNode = container.firstChild;
              nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
              for (; nextNode; ) {
                var node = nextNode;
                nextNode = nextNode.nextSibling;
                switch (node.nodeName) {
                  case "HTML":
                  case "HEAD":
                  case "BODY":
                    clearContainerSparingly(node);
                    detachDeletedInstance(node);
                    continue;
                  case "SCRIPT":
                  case "STYLE":
                    continue;
                  case "LINK":
                    if ("stylesheet" === node.rel.toLowerCase())
                      continue;
                }
                container.removeChild(node);
              }
            }
            function canHydrateInstance(instance, type, props, inRootOrSingleton) {
              for (; 1 === instance.nodeType; ) {
                var anyProps = props;
                if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
                  if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                    break;
                } else if (!inRootOrSingleton)
                  if ("input" === type && "hidden" === instance.type) {
                    var name = null == anyProps.name ? null : "" + anyProps.name;
                    if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                      return instance;
                  } else
                    return instance;
                else if (!instance[internalHoistableMarker])
                  switch (type) {
                    case "meta":
                      if (!instance.hasAttribute("itemprop"))
                        break;
                      return instance;
                    case "link":
                      name = instance.getAttribute("rel");
                      if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                        break;
                      else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                        break;
                      return instance;
                    case "style":
                      if (instance.hasAttribute("data-precedence"))
                        break;
                      return instance;
                    case "script":
                      name = instance.getAttribute("src");
                      if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                        break;
                      return instance;
                    default:
                      return instance;
                  }
                instance = getNextHydratable(instance.nextSibling);
                if (null === instance)
                  break;
              }
              return null;
            }
            function canHydrateTextInstance(instance, text, inRootOrSingleton) {
              if ("" === text)
                return null;
              for (; 3 !== instance.nodeType; ) {
                if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
                  return null;
                instance = getNextHydratable(instance.nextSibling);
                if (null === instance)
                  return null;
              }
              return instance;
            }
            function getNextHydratable(node) {
              for (; null != node; node = node.nextSibling) {
                var nodeType = node.nodeType;
                if (1 === nodeType || 3 === nodeType)
                  break;
                if (8 === nodeType) {
                  nodeType = node.data;
                  if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
                    break;
                  if ("/$" === nodeType)
                    return null;
                }
              }
              return node;
            }
            function getParentSuspenseInstance(targetInstance) {
              targetInstance = targetInstance.previousSibling;
              for (var depth = 0; targetInstance; ) {
                if (8 === targetInstance.nodeType) {
                  var data = targetInstance.data;
                  if ("$" === data || "$!" === data || "$?" === data) {
                    if (0 === depth)
                      return targetInstance;
                    depth--;
                  } else
                    "/$" === data && depth++;
                }
                targetInstance = targetInstance.previousSibling;
              }
              return null;
            }
            function resolveSingletonInstance(type, props, rootContainerInstance) {
              props = getOwnerDocumentFromRootContainer(rootContainerInstance);
              switch (type) {
                case "html":
                  type = props.documentElement;
                  if (!type)
                    throw Error(formatProdErrorMessage(452));
                  return type;
                case "head":
                  type = props.head;
                  if (!type)
                    throw Error(formatProdErrorMessage(453));
                  return type;
                case "body":
                  type = props.body;
                  if (!type)
                    throw Error(formatProdErrorMessage(454));
                  return type;
                default:
                  throw Error(formatProdErrorMessage(451));
              }
            }
            var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
            function getHoistableRoot(container) {
              return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
            }
            var previousDispatcher = ReactDOMSharedInternals.d;
            ReactDOMSharedInternals.d = {
              f: flushSyncWork,
              r: requestFormReset,
              D: prefetchDNS,
              C: preconnect,
              L: preload,
              m: preloadModule,
              X: preinitScript,
              S: preinitStyle,
              M: preinitModuleScript
            };
            function flushSyncWork() {
              var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
              return previousWasRendering || wasRendering;
            }
            function requestFormReset(form) {
              var formInst = getInstanceFromNode(form);
              null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
            }
            var globalDocument = "undefined" === typeof document ? null : document;
            function preconnectAs(rel, href, crossOrigin) {
              var ownerDocument = globalDocument;
              if (ownerDocument && "string" === typeof href && href) {
                var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
                limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
                "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
                preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
              }
            }
            function prefetchDNS(href) {
              previousDispatcher.D(href);
              preconnectAs("dns-prefetch", href, null);
            }
            function preconnect(href, crossOrigin) {
              previousDispatcher.C(href, crossOrigin);
              preconnectAs("preconnect", href, crossOrigin);
            }
            function preload(href, as, options2) {
              previousDispatcher.L(href, as, options2);
              var ownerDocument = globalDocument;
              if (ownerDocument && href && as) {
                var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
                "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  options2.imageSrcSet
                ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  options2.imageSizes
                ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
                var key = preloadSelector;
                switch (as) {
                  case "style":
                    key = getStyleKey(href);
                    break;
                  case "script":
                    key = getScriptKey(href);
                }
                preloadPropsMap.has(key) || (href = assign(
                  {
                    rel: "preload",
                    href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
                    as
                  },
                  options2
                ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
              }
            }
            function preloadModule(href, options2) {
              previousDispatcher.m(href, options2);
              var ownerDocument = globalDocument;
              if (ownerDocument && href) {
                var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    key = getScriptKey(href);
                }
                if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                  switch (as) {
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                      if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                        return;
                  }
                  as = ownerDocument.createElement("link");
                  setInitialProperties(as, "link", href);
                  markNodeAsHoistable(as);
                  ownerDocument.head.appendChild(as);
                }
              }
            }
            function preinitStyle(href, precedence, options2) {
              previousDispatcher.S(href, precedence, options2);
              var ownerDocument = globalDocument;
              if (ownerDocument && href) {
                var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
                precedence = precedence || "default";
                var resource = styles.get(key);
                if (!resource) {
                  var state = { loading: 0, preload: null };
                  if (resource = ownerDocument.querySelector(
                    getStylesheetSelectorFromKey(key)
                  ))
                    state.loading = 5;
                  else {
                    href = assign(
                      { rel: "stylesheet", href, "data-precedence": precedence },
                      options2
                    );
                    (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
                    var link = resource = ownerDocument.createElement("link");
                    markNodeAsHoistable(link);
                    setInitialProperties(link, "link", href);
                    link._p = new Promise(function(resolve, reject) {
                      link.onload = resolve;
                      link.onerror = reject;
                    });
                    link.addEventListener("load", function() {
                      state.loading |= 1;
                    });
                    link.addEventListener("error", function() {
                      state.loading |= 2;
                    });
                    state.loading |= 4;
                    insertStylesheet(resource, precedence, ownerDocument);
                  }
                  resource = {
                    type: "stylesheet",
                    instance: resource,
                    count: 1,
                    state
                  };
                  styles.set(key, resource);
                }
              }
            }
            function preinitScript(src, options2) {
              previousDispatcher.X(src, options2);
              var ownerDocument = globalDocument;
              if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                  type: "script",
                  instance: resource,
                  count: 1,
                  state: null
                }, scripts.set(key, resource));
              }
            }
            function preinitModuleScript(src, options2) {
              previousDispatcher.M(src, options2);
              var ownerDocument = globalDocument;
              if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                  type: "script",
                  instance: resource,
                  count: 1,
                  state: null
                }, scripts.set(key, resource));
              }
            }
            function getResource(type, currentProps, pendingProps, currentResource) {
              var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
              if (!JSCompiler_inline_result)
                throw Error(formatProdErrorMessage(446));
              switch (type) {
                case "meta":
                case "title":
                  return null;
                case "style":
                  return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
                    JSCompiler_inline_result
                  ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
                    type: "style",
                    instance: null,
                    count: 0,
                    state: null
                  }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
                case "link":
                  if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                    type = getStyleKey(pendingProps.href);
                    var styles$242 = getResourcesFromRoot(
                      JSCompiler_inline_result
                    ).hoistableStyles, resource$243 = styles$242.get(type);
                    resource$243 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$243 = {
                      type: "stylesheet",
                      instance: null,
                      count: 0,
                      state: { loading: 0, preload: null }
                    }, styles$242.set(type, resource$243), (styles$242 = JSCompiler_inline_result.querySelector(
                      getStylesheetSelectorFromKey(type)
                    )) && !styles$242._p && (resource$243.instance = styles$242, resource$243.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                      rel: "preload",
                      as: "style",
                      href: pendingProps.href,
                      crossOrigin: pendingProps.crossOrigin,
                      integrity: pendingProps.integrity,
                      media: pendingProps.media,
                      hrefLang: pendingProps.hrefLang,
                      referrerPolicy: pendingProps.referrerPolicy
                    }, preloadPropsMap.set(type, pendingProps), styles$242 || preloadStylesheet(
                      JSCompiler_inline_result,
                      type,
                      pendingProps,
                      resource$243.state
                    )));
                    if (currentProps && null === currentResource)
                      throw Error(formatProdErrorMessage(528, ""));
                    return resource$243;
                  }
                  if (currentProps && null !== currentResource)
                    throw Error(formatProdErrorMessage(529, ""));
                  return null;
                case "script":
                  return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
                    JSCompiler_inline_result
                  ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null
                  }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
                default:
                  throw Error(formatProdErrorMessage(444, type));
              }
            }
            function getStyleKey(href) {
              return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
            }
            function getStylesheetSelectorFromKey(key) {
              return 'link[rel="stylesheet"][' + key + "]";
            }
            function stylesheetPropsFromRawProps(rawProps) {
              return assign({}, rawProps, {
                "data-precedence": rawProps.precedence,
                precedence: null
              });
            }
            function preloadStylesheet(ownerDocument, key, preloadProps, state) {
              ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
                return state.loading |= 1;
              }), key.addEventListener("error", function() {
                return state.loading |= 2;
              }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
            }
            function getScriptKey(src) {
              return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
            }
            function getScriptSelectorFromKey(key) {
              return "script[async]" + key;
            }
            function acquireResource(hoistableRoot, resource, props) {
              resource.count++;
              if (null === resource.instance)
                switch (resource.type) {
                  case "style":
                    var instance = hoistableRoot.querySelector(
                      'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                    );
                    if (instance)
                      return resource.instance = instance, markNodeAsHoistable(instance), instance;
                    var styleProps = assign({}, props, {
                      "data-href": props.href,
                      "data-precedence": props.precedence,
                      href: null,
                      precedence: null
                    });
                    instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                      "style"
                    );
                    markNodeAsHoistable(instance);
                    setInitialProperties(instance, "style", styleProps);
                    insertStylesheet(instance, props.precedence, hoistableRoot);
                    return resource.instance = instance;
                  case "stylesheet":
                    styleProps = getStyleKey(props.href);
                    var instance$248 = hoistableRoot.querySelector(
                      getStylesheetSelectorFromKey(styleProps)
                    );
                    if (instance$248)
                      return resource.state.loading |= 4, resource.instance = instance$248, markNodeAsHoistable(instance$248), instance$248;
                    instance = stylesheetPropsFromRawProps(props);
                    (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                    instance$248 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                    markNodeAsHoistable(instance$248);
                    var linkInstance = instance$248;
                    linkInstance._p = new Promise(function(resolve, reject) {
                      linkInstance.onload = resolve;
                      linkInstance.onerror = reject;
                    });
                    setInitialProperties(instance$248, "link", instance);
                    resource.state.loading |= 4;
                    insertStylesheet(instance$248, props.precedence, hoistableRoot);
                    return resource.instance = instance$248;
                  case "script":
                    instance$248 = getScriptKey(props.src);
                    if (styleProps = hoistableRoot.querySelector(
                      getScriptSelectorFromKey(instance$248)
                    ))
                      return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                    instance = props;
                    if (styleProps = preloadPropsMap.get(instance$248))
                      instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    styleProps = hoistableRoot.createElement("script");
                    markNodeAsHoistable(styleProps);
                    setInitialProperties(styleProps, "link", instance);
                    hoistableRoot.head.appendChild(styleProps);
                    return resource.instance = styleProps;
                  case "void":
                    return null;
                  default:
                    throw Error(formatProdErrorMessage(443, resource.type));
                }
              else
                "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
              return resource.instance;
            }
            function insertStylesheet(instance, precedence, root2) {
              for (var nodes = root2.querySelectorAll(
                'link[rel="stylesheet"][data-precedence],style[data-precedence]'
              ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (node.dataset.precedence === precedence)
                  prior = node;
                else if (prior !== last)
                  break;
              }
              prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
            }
            function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
              null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
              null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
              null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
            }
            function adoptPreloadPropsForScript(scriptProps, preloadProps) {
              null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
              null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
              null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
            }
            var tagCaches = null;
            function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
              if (null === tagCaches) {
                var cache = /* @__PURE__ */ new Map();
                var caches = tagCaches = /* @__PURE__ */ new Map();
                caches.set(ownerDocument, cache);
              } else
                caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
              if (cache.has(type))
                return cache;
              cache.set(type, null);
              ownerDocument = ownerDocument.getElementsByTagName(type);
              for (caches = 0; caches < ownerDocument.length; caches++) {
                var node = ownerDocument[caches];
                if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
                  var nodeKey = node.getAttribute(keyAttribute) || "";
                  nodeKey = type + nodeKey;
                  var existing = cache.get(nodeKey);
                  existing ? existing.push(node) : cache.set(nodeKey, [node]);
                }
              }
              return cache;
            }
            function mountHoistable(hoistableRoot, type, instance) {
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              hoistableRoot.head.insertBefore(
                instance,
                "title" === type ? hoistableRoot.querySelector("head > title") : null
              );
            }
            function isHostHoistableType(type, props, hostContext) {
              if (1 === hostContext || null != props.itemProp)
                return false;
              switch (type) {
                case "meta":
                case "title":
                  return true;
                case "style":
                  if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
                    break;
                  return true;
                case "link":
                  if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
                    break;
                  switch (props.rel) {
                    case "stylesheet":
                      return type = props.disabled, "string" === typeof props.precedence && null == type;
                    default:
                      return true;
                  }
                case "script":
                  if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
                    return true;
              }
              return false;
            }
            function preloadResource(resource) {
              return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
            }
            var suspendedState = null;
            function noop() {
            }
            function suspendResource(hoistableRoot, resource, props) {
              if (null === suspendedState)
                throw Error(formatProdErrorMessage(475));
              var state = suspendedState;
              if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
                if (null === resource.instance) {
                  var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                    getStylesheetSelectorFromKey(key)
                  );
                  if (instance) {
                    hoistableRoot = instance._p;
                    null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                    resource.state.loading |= 4;
                    resource.instance = instance;
                    markNodeAsHoistable(instance);
                    return;
                  }
                  instance = hoistableRoot.ownerDocument || hoistableRoot;
                  props = stylesheetPropsFromRawProps(props);
                  (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
                  instance = instance.createElement("link");
                  markNodeAsHoistable(instance);
                  var linkInstance = instance;
                  linkInstance._p = new Promise(function(resolve, reject) {
                    linkInstance.onload = resolve;
                    linkInstance.onerror = reject;
                  });
                  setInitialProperties(instance, "link", props);
                  resource.instance = instance;
                }
                null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
                state.stylesheets.set(resource, hoistableRoot);
                (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
              }
            }
            function waitForCommitToBeReady() {
              if (null === suspendedState)
                throw Error(formatProdErrorMessage(475));
              var state = suspendedState;
              state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
              return 0 < state.count ? function(commit) {
                var stylesheetTimer = setTimeout(function() {
                  state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
                  if (state.unsuspend) {
                    var unsuspend = state.unsuspend;
                    state.unsuspend = null;
                    unsuspend();
                  }
                }, 6e4);
                state.unsuspend = commit;
                return function() {
                  state.unsuspend = null;
                  clearTimeout(stylesheetTimer);
                };
              } : null;
            }
            function onUnsuspend() {
              this.count--;
              if (0 === this.count) {
                if (this.stylesheets)
                  insertSuspendedStylesheets(this, this.stylesheets);
                else if (this.unsuspend) {
                  var unsuspend = this.unsuspend;
                  this.unsuspend = null;
                  unsuspend();
                }
              }
            }
            var precedencesByRoot = null;
            function insertSuspendedStylesheets(state, resources) {
              state.stylesheets = null;
              null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
            }
            function insertStylesheetIntoRoot(root2, resource) {
              if (!(resource.state.loading & 4)) {
                var precedences = precedencesByRoot.get(root2);
                if (precedences)
                  var last = precedences.get(null);
                else {
                  precedences = /* @__PURE__ */ new Map();
                  precedencesByRoot.set(root2, precedences);
                  for (var nodes = root2.querySelectorAll(
                    "link[data-precedence],style[data-precedence]"
                  ), i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                      precedences.set(node.dataset.precedence, node), last = node;
                  }
                  last && precedences.set(null, last);
                }
                nodes = resource.instance;
                node = nodes.getAttribute("data-precedence");
                i = precedences.get(node) || last;
                i === last && precedences.set(null, nodes);
                precedences.set(node, nodes);
                this.count++;
                last = onUnsuspend.bind(this);
                nodes.addEventListener("load", last);
                nodes.addEventListener("error", last);
                i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
                resource.state.loading |= 4;
              }
            }
            var HostTransitionContext = {
              $$typeof: REACT_CONTEXT_TYPE,
              Provider: null,
              Consumer: null,
              _currentValue: sharedNotPendingObject,
              _currentValue2: sharedNotPendingObject,
              _threadCount: 0
            };
            function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
              this.tag = 1;
              this.containerInfo = containerInfo;
              this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
              this.timeoutHandle = -1;
              this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
              this.callbackPriority = 0;
              this.expirationTimes = createLaneMap(-1);
              this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
              this.entanglements = createLaneMap(0);
              this.hiddenUpdates = createLaneMap(null);
              this.identifierPrefix = identifierPrefix;
              this.onUncaughtError = onUncaughtError;
              this.onCaughtError = onCaughtError;
              this.onRecoverableError = onRecoverableError;
              this.pooledCache = null;
              this.pooledCacheLanes = 0;
              this.formState = formState;
              this.incompleteTransitions = /* @__PURE__ */ new Map();
            }
            function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
              containerInfo = new FiberRootNode(
                containerInfo,
                tag,
                hydrate,
                identifierPrefix,
                onUncaughtError,
                onCaughtError,
                onRecoverableError,
                formState
              );
              tag = 1;
              true === isStrictMode && (tag |= 24);
              isStrictMode = createFiberImplClass(3, null, null, tag);
              containerInfo.current = isStrictMode;
              isStrictMode.stateNode = containerInfo;
              tag = createCache();
              tag.refCount++;
              containerInfo.pooledCache = tag;
              tag.refCount++;
              isStrictMode.memoizedState = {
                element: initialChildren,
                isDehydrated: hydrate,
                cache: tag
              };
              initializeUpdateQueue(isStrictMode);
              return containerInfo;
            }
            function getContextForSubtree(parentComponent) {
              if (!parentComponent)
                return emptyContextObject;
              parentComponent = emptyContextObject;
              return parentComponent;
            }
            function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
              parentComponent = getContextForSubtree(parentComponent);
              null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
              container = createUpdate(lane);
              container.payload = { element };
              callback = void 0 === callback ? null : callback;
              null !== callback && (container.callback = callback);
              element = enqueueUpdate(rootFiber, container, lane);
              null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
            }
            function markRetryLaneImpl(fiber, retryLane) {
              fiber = fiber.memoizedState;
              if (null !== fiber && null !== fiber.dehydrated) {
                var a = fiber.retryLane;
                fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
              }
            }
            function markRetryLaneIfNotHydrated(fiber, retryLane) {
              markRetryLaneImpl(fiber, retryLane);
              (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
            }
            function attemptContinuousHydration(fiber) {
              if (13 === fiber.tag) {
                var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
                null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
                markRetryLaneIfNotHydrated(fiber, 67108864);
              }
            }
            var _enabled = true;
            function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
              var prevTransition = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              try {
                ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
              } finally {
                ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
              }
            }
            function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
              var prevTransition = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              try {
                ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
              } finally {
                ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
              }
            }
            function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
              if (_enabled) {
                var blockedOn = findInstanceBlockingEvent(nativeEvent);
                if (null === blockedOn)
                  dispatchEventForPluginEventSystem(
                    domEventName,
                    eventSystemFlags,
                    nativeEvent,
                    return_targetInst,
                    targetContainer
                  ), clearIfContinuousEvent(domEventName, nativeEvent);
                else if (queueIfContinuousEvent(
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                ))
                  nativeEvent.stopPropagation();
                else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
                  for (; null !== blockedOn; ) {
                    var fiber = getInstanceFromNode(blockedOn);
                    if (null !== fiber)
                      switch (fiber.tag) {
                        case 3:
                          fiber = fiber.stateNode;
                          if (fiber.current.memoizedState.isDehydrated) {
                            var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                            if (0 !== lanes) {
                              var root2 = fiber;
                              root2.pendingLanes |= 2;
                              for (root2.entangledLanes |= 2; lanes; ) {
                                var lane = 1 << 31 - clz32(lanes);
                                root2.entanglements[1] |= lane;
                                lanes &= ~lane;
                              }
                              ensureRootIsScheduled(fiber);
                              0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                            }
                          }
                          break;
                        case 13:
                          root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                      }
                    fiber = findInstanceBlockingEvent(nativeEvent);
                    null === fiber && dispatchEventForPluginEventSystem(
                      domEventName,
                      eventSystemFlags,
                      nativeEvent,
                      return_targetInst,
                      targetContainer
                    );
                    if (fiber === blockedOn)
                      break;
                    blockedOn = fiber;
                  }
                  null !== blockedOn && nativeEvent.stopPropagation();
                } else
                  dispatchEventForPluginEventSystem(
                    domEventName,
                    eventSystemFlags,
                    nativeEvent,
                    null,
                    targetContainer
                  );
              }
            }
            function findInstanceBlockingEvent(nativeEvent) {
              nativeEvent = getEventTarget(nativeEvent);
              return findInstanceBlockingTarget(nativeEvent);
            }
            var return_targetInst = null;
            function findInstanceBlockingTarget(targetNode) {
              return_targetInst = null;
              targetNode = getClosestInstanceFromNode(targetNode);
              if (null !== targetNode) {
                var nearestMounted = getNearestMountedFiber(targetNode);
                if (null === nearestMounted)
                  targetNode = null;
                else {
                  var tag = nearestMounted.tag;
                  if (13 === tag) {
                    targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                    if (null !== targetNode)
                      return targetNode;
                    targetNode = null;
                  } else if (3 === tag) {
                    if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                      return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                    targetNode = null;
                  } else
                    nearestMounted !== targetNode && (targetNode = null);
                }
              }
              return_targetInst = targetNode;
              return null;
            }
            function getEventPriority(domEventName) {
              switch (domEventName) {
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                  return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                  return 8;
                case "message":
                  switch (getCurrentPriorityLevel()) {
                    case ImmediatePriority:
                      return 2;
                    case UserBlockingPriority:
                      return 8;
                    case NormalPriority$1:
                    case LowPriority:
                      return 32;
                    case IdlePriority:
                      return 268435456;
                    default:
                      return 32;
                  }
                default:
                  return 32;
              }
            }
            var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
              " "
            );
            function clearIfContinuousEvent(domEventName, nativeEvent) {
              switch (domEventName) {
                case "focusin":
                case "focusout":
                  queuedFocus = null;
                  break;
                case "dragenter":
                case "dragleave":
                  queuedDrag = null;
                  break;
                case "mouseover":
                case "mouseout":
                  queuedMouse = null;
                  break;
                case "pointerover":
                case "pointerout":
                  queuedPointers.delete(nativeEvent.pointerId);
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                  queuedPointerCaptures.delete(nativeEvent.pointerId);
              }
            }
            function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
              if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
                return existingQueuedEvent = {
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  targetContainers: [targetContainer]
                }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
              existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
              blockedOn = existingQueuedEvent.targetContainers;
              null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
              return existingQueuedEvent;
            }
            function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
              switch (domEventName) {
                case "focusin":
                  return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedFocus,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent
                  ), true;
                case "dragenter":
                  return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedDrag,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent
                  ), true;
                case "mouseover":
                  return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedMouse,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent
                  ), true;
                case "pointerover":
                  var pointerId = nativeEvent.pointerId;
                  queuedPointers.set(
                    pointerId,
                    accumulateOrCreateContinuousQueuedReplayableEvent(
                      queuedPointers.get(pointerId) || null,
                      blockedOn,
                      domEventName,
                      eventSystemFlags,
                      targetContainer,
                      nativeEvent
                    )
                  );
                  return true;
                case "gotpointercapture":
                  return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                    pointerId,
                    accumulateOrCreateContinuousQueuedReplayableEvent(
                      queuedPointerCaptures.get(pointerId) || null,
                      blockedOn,
                      domEventName,
                      eventSystemFlags,
                      targetContainer,
                      nativeEvent
                    )
                  ), true;
              }
              return false;
            }
            function attemptExplicitHydrationTarget(queuedTarget) {
              var targetInst = getClosestInstanceFromNode(queuedTarget.target);
              if (null !== targetInst) {
                var nearestMounted = getNearestMountedFiber(targetInst);
                if (null !== nearestMounted) {
                  if (targetInst = nearestMounted.tag, 13 === targetInst) {
                    if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                      queuedTarget.blockedOn = targetInst;
                      runWithPriority(queuedTarget.priority, function() {
                        if (13 === nearestMounted.tag) {
                          var lane = requestUpdateLane(), root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                          null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                          markRetryLaneIfNotHydrated(nearestMounted, lane);
                        }
                      });
                      return;
                    }
                  } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                    queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                    return;
                  }
                }
              }
              queuedTarget.blockedOn = null;
            }
            function attemptReplayContinuousQueuedEvent(queuedEvent) {
              if (null !== queuedEvent.blockedOn)
                return false;
              for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
                var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
                if (null === nextBlockedOn) {
                  nextBlockedOn = queuedEvent.nativeEvent;
                  var nativeEventClone = new nextBlockedOn.constructor(
                    nextBlockedOn.type,
                    nextBlockedOn
                  );
                  currentReplayingEvent = nativeEventClone;
                  nextBlockedOn.target.dispatchEvent(nativeEventClone);
                  currentReplayingEvent = null;
                } else
                  return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
                targetContainers.shift();
              }
              return true;
            }
            function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
              attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
            }
            function replayUnblockedEvents() {
              hasScheduledReplayAttempt = false;
              null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
              null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
              null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
              queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
              queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
            }
            function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
              queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
                Scheduler.unstable_NormalPriority,
                replayUnblockedEvents
              )));
            }
            var lastScheduledReplayQueue = null;
            function scheduleReplayQueueIfNeeded(formReplayingQueue) {
              lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
                Scheduler.unstable_NormalPriority,
                function() {
                  lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
                  for (var i = 0; i < formReplayingQueue.length; i += 3) {
                    var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                    if ("function" !== typeof submitterOrAction)
                      if (null === findInstanceBlockingTarget(submitterOrAction || form))
                        continue;
                      else
                        break;
                    var formInst = getInstanceFromNode(form);
                    null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                      formInst,
                      {
                        pending: true,
                        data: formData,
                        method: form.method,
                        action: submitterOrAction
                      },
                      submitterOrAction,
                      formData
                    ));
                  }
                }
              ));
            }
            function retryIfBlockedOn(unblocked) {
              function unblock(queuedEvent) {
                return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
              }
              null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
              null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
              null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
              queuedPointers.forEach(unblock);
              queuedPointerCaptures.forEach(unblock);
              for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
                var queuedTarget = queuedExplicitHydrationTargets[i];
                queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
              }
              for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
                attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
              i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
              if (null != i)
                for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
                  var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
                  if ("function" === typeof submitterOrAction)
                    formProps || scheduleReplayQueueIfNeeded(i);
                  else if (formProps) {
                    var action = null;
                    if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                      if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                        action = formProps.formAction;
                      else {
                        if (null !== findInstanceBlockingTarget(form))
                          continue;
                      }
                    else
                      action = formProps.action;
                    "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                    scheduleReplayQueueIfNeeded(i);
                  }
                }
            }
            function ReactDOMRoot(internalRoot) {
              this._internalRoot = internalRoot;
            }
            ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
              var root2 = this._internalRoot;
              if (null === root2)
                throw Error(formatProdErrorMessage(409));
              var current = root2.current, lane = requestUpdateLane();
              updateContainerImpl(current, lane, children, root2, null, null);
            };
            ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
              var root2 = this._internalRoot;
              if (null !== root2) {
                this._internalRoot = null;
                var container = root2.containerInfo;
                0 === root2.tag && flushPassiveEffects();
                updateContainerImpl(root2.current, 2, null, root2, null, null);
                flushSyncWork$1();
                container[internalContainerInstanceKey] = null;
              }
            };
            function ReactDOMHydrationRoot(internalRoot) {
              this._internalRoot = internalRoot;
            }
            ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
              if (target) {
                var updatePriority = resolveUpdatePriority();
                target = { blockedOn: null, target, priority: updatePriority };
                for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++)
                  ;
                queuedExplicitHydrationTargets.splice(i, 0, target);
                0 === i && attemptExplicitHydrationTarget(target);
              }
            };
            var isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;
            if ("19.0.0" !== isomorphicReactPackageVersion$jscomp$inline_1686)
              throw Error(
                formatProdErrorMessage(
                  527,
                  isomorphicReactPackageVersion$jscomp$inline_1686,
                  "19.0.0"
                )
              );
            ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
              var fiber = componentOrElement._reactInternals;
              if (void 0 === fiber) {
                if ("function" === typeof componentOrElement.render)
                  throw Error(formatProdErrorMessage(188));
                componentOrElement = Object.keys(componentOrElement).join(",");
                throw Error(formatProdErrorMessage(268, componentOrElement));
              }
              componentOrElement = findCurrentFiberUsingSlowPath(fiber);
              componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
              componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
              return componentOrElement;
            };
            var internals$jscomp$inline_2165 = {
              bundleType: 0,
              version: "19.0.0",
              rendererPackageName: "react-dom",
              currentDispatcherRef: ReactSharedInternals,
              findFiberByHostInstance: getClosestInstanceFromNode,
              reconcilerVersion: "19.0.0"
            };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
              var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (!hook$jscomp$inline_2166.isDisabled && hook$jscomp$inline_2166.supportsFiber)
                try {
                  rendererID = hook$jscomp$inline_2166.inject(
                    internals$jscomp$inline_2165
                  ), injectedHook = hook$jscomp$inline_2166;
                } catch (err) {
                }
            }
            exports2.createRoot = function(container, options2) {
              if (!isValidContainer(container))
                throw Error(formatProdErrorMessage(299));
              var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
              null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
              options2 = createFiberRoot(
                container,
                1,
                false,
                null,
                null,
                isStrictMode,
                identifierPrefix,
                onUncaughtError,
                onCaughtError,
                onRecoverableError,
                transitionCallbacks,
                null
              );
              container[internalContainerInstanceKey] = options2.current;
              listenToAllSupportedEvents(
                8 === container.nodeType ? container.parentNode : container
              );
              return new ReactDOMRoot(options2);
            };
            __webpack_unused_export__ = function(container, initialChildren, options2) {
              if (!isValidContainer(container))
                throw Error(formatProdErrorMessage(299));
              var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
              null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
              initialChildren = createFiberRoot(
                container,
                1,
                true,
                initialChildren,
                null != options2 ? options2 : null,
                isStrictMode,
                identifierPrefix,
                onUncaughtError,
                onCaughtError,
                onRecoverableError,
                transitionCallbacks,
                formState
              );
              initialChildren.context = getContextForSubtree(null);
              options2 = initialChildren.current;
              isStrictMode = requestUpdateLane();
              identifierPrefix = createUpdate(isStrictMode);
              identifierPrefix.callback = null;
              enqueueUpdate(options2, identifierPrefix, isStrictMode);
              initialChildren.current.lanes = isStrictMode;
              markRootUpdated$1(initialChildren, isStrictMode);
              ensureRootIsScheduled(initialChildren);
              container[internalContainerInstanceKey] = initialChildren.current;
              listenToAllSupportedEvents(container);
              return new ReactDOMHydrationRoot(initialChildren);
            };
            __webpack_unused_export__ = "19.0.0";
          }
        ),
        /***/
        929: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            /**
             * @license React
             * react-dom.production.js
             *
             * Copyright (c) Meta Platforms, Inc. and affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var React = __webpack_require__2(41);
            function formatProdErrorMessage(code) {
              var url = "https://react.dev/errors/" + code;
              if (1 < arguments.length) {
                url += "?args[]=" + encodeURIComponent(arguments[1]);
                for (var i = 2; i < arguments.length; i++)
                  url += "&args[]=" + encodeURIComponent(arguments[i]);
              }
              return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
            }
            function noop() {
            }
            var Internals = {
              d: {
                f: noop,
                r: function() {
                  throw Error(formatProdErrorMessage(522));
                },
                D: noop,
                C: noop,
                L: noop,
                m: noop,
                X: noop,
                S: noop,
                M: noop
              },
              p: 0,
              findDOMNode: null
            }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
            function createPortal$1(children, containerInfo, implementation) {
              var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
              return {
                $$typeof: REACT_PORTAL_TYPE,
                key: null == key ? null : "" + key,
                children,
                containerInfo,
                implementation
              };
            }
            var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
            function getCrossOriginStringAs(as, input) {
              if ("font" === as)
                return "";
              if ("string" === typeof input)
                return "use-credentials" === input ? input : "";
            }
            exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
            exports2.createPortal = function(children, container) {
              var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
              if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
                throw Error(formatProdErrorMessage(299));
              return createPortal$1(children, container, null, key);
            };
            exports2.flushSync = function(fn) {
              var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
              try {
                if (ReactSharedInternals.T = null, Internals.p = 2, fn)
                  return fn();
              } finally {
                ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
              }
            };
            exports2.preconnect = function(href, options) {
              "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
            };
            exports2.prefetchDNS = function(href) {
              "string" === typeof href && Internals.d.D(href);
            };
            exports2.preinit = function(href, options) {
              if ("string" === typeof href && options && "string" === typeof options.as) {
                var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
                "style" === as ? Internals.d.S(
                  href,
                  "string" === typeof options.precedence ? options.precedence : void 0,
                  {
                    crossOrigin,
                    integrity,
                    fetchPriority
                  }
                ) : "script" === as && Internals.d.X(href, {
                  crossOrigin,
                  integrity,
                  fetchPriority,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
              }
            };
            exports2.preinitModule = function(href, options) {
              if ("string" === typeof href)
                if ("object" === typeof options && null !== options) {
                  if (null == options.as || "script" === options.as) {
                    var crossOrigin = getCrossOriginStringAs(
                      options.as,
                      options.crossOrigin
                    );
                    Internals.d.M(href, {
                      crossOrigin,
                      integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                      nonce: "string" === typeof options.nonce ? options.nonce : void 0
                    });
                  }
                } else
                  null == options && Internals.d.M(href);
            };
            exports2.preload = function(href, options) {
              if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
                var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
                Internals.d.L(href, as, {
                  crossOrigin,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0,
                  type: "string" === typeof options.type ? options.type : void 0,
                  fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
                  referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
                  imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
                  imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
                  media: "string" === typeof options.media ? options.media : void 0
                });
              }
            };
            exports2.preloadModule = function(href, options) {
              if ("string" === typeof href)
                if (options) {
                  var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
                  Internals.d.m(href, {
                    as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
                    crossOrigin,
                    integrity: "string" === typeof options.integrity ? options.integrity : void 0
                  });
                } else
                  Internals.d.m(href);
            };
            exports2.requestFormReset = function(form) {
              Internals.d.r(form);
            };
            exports2.unstable_batchedUpdates = function(fn, a) {
              return fn(a);
            };
            exports2.useFormState = function(action, initialState, permalink) {
              return ReactSharedInternals.H.useFormState(action, initialState, permalink);
            };
            exports2.useFormStatus = function() {
              return ReactSharedInternals.H.useHostTransitionStatus();
            };
            exports2.version = "19.0.0";
          }
        ),
        /***/
        873: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            function checkDCE() {
              if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                return;
              }
              if (false) {}
              try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
              } catch (err) {
                console.error(err);
              }
            }
            if (true) {
              checkDCE();
              module2.exports = __webpack_require__2(974);
            } else {}
          }
        ),
        /***/
        144: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            function checkDCE() {
              if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                return;
              }
              if (false) {}
              try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
              } catch (err) {
                console.error(err);
              }
            }
            if (true) {
              checkDCE();
              module2.exports = __webpack_require__2(929);
            } else {}
          }
        ),
        /***/
        62: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            /**
             * @license React
             * react.production.js
             *
             * Copyright (c) Meta Platforms, Inc. and affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
            function getIteratorFn(maybeIterable) {
              if (null === maybeIterable || "object" !== typeof maybeIterable)
                return null;
              maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
              return "function" === typeof maybeIterable ? maybeIterable : null;
            }
            var ReactNoopUpdateQueue = {
              isMounted: function() {
                return false;
              },
              enqueueForceUpdate: function() {
              },
              enqueueReplaceState: function() {
              },
              enqueueSetState: function() {
              }
            }, assign = Object.assign, emptyObject = {};
            function Component(props, context, updater) {
              this.props = props;
              this.context = context;
              this.refs = emptyObject;
              this.updater = updater || ReactNoopUpdateQueue;
            }
            Component.prototype.isReactComponent = {};
            Component.prototype.setState = function(partialState, callback) {
              if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
                throw Error(
                  "takes an object of state variables to update or a function which returns an object of state variables."
                );
              this.updater.enqueueSetState(this, partialState, callback, "setState");
            };
            Component.prototype.forceUpdate = function(callback) {
              this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
            };
            function ComponentDummy() {
            }
            ComponentDummy.prototype = Component.prototype;
            function PureComponent(props, context, updater) {
              this.props = props;
              this.context = context;
              this.refs = emptyObject;
              this.updater = updater || ReactNoopUpdateQueue;
            }
            var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
            pureComponentPrototype.constructor = PureComponent;
            assign(pureComponentPrototype, Component.prototype);
            pureComponentPrototype.isPureReactComponent = true;
            var isArrayImpl = Array.isArray, ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
            function ReactElement(type, key, self2, source, owner, props) {
              self2 = props.ref;
              return {
                $$typeof: REACT_ELEMENT_TYPE,
                type,
                key,
                ref: void 0 !== self2 ? self2 : null,
                props
              };
            }
            function cloneAndReplaceKey(oldElement, newKey) {
              return ReactElement(
                oldElement.type,
                newKey,
                void 0,
                void 0,
                void 0,
                oldElement.props
              );
            }
            function isValidElement(object) {
              return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
            }
            function escape(key) {
              var escaperLookup = { "=": "=0", ":": "=2" };
              return "$" + key.replace(/[=:]/g, function(match) {
                return escaperLookup[match];
              });
            }
            var userProvidedKeyEscapeRegex = /\/+/g;
            function getElementKey(element, index) {
              return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
            }
            function noop$1() {
            }
            function resolveThenable(thenable) {
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
                default:
                  switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                    function(fulfilledValue) {
                      "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                    },
                    function(error) {
                      "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                    }
                  )), thenable.status) {
                    case "fulfilled":
                      return thenable.value;
                    case "rejected":
                      throw thenable.reason;
                  }
              }
              throw thenable;
            }
            function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
              var type = typeof children;
              if ("undefined" === type || "boolean" === type)
                children = null;
              var invokeCallback = false;
              if (null === children)
                invokeCallback = true;
              else
                switch (type) {
                  case "bigint":
                  case "string":
                  case "number":
                    invokeCallback = true;
                    break;
                  case "object":
                    switch (children.$$typeof) {
                      case REACT_ELEMENT_TYPE:
                      case REACT_PORTAL_TYPE:
                        invokeCallback = true;
                        break;
                      case REACT_LAZY_TYPE:
                        return invokeCallback = children._init, mapIntoArray(
                          invokeCallback(children._payload),
                          array,
                          escapedPrefix,
                          nameSoFar,
                          callback
                        );
                    }
                }
              if (invokeCallback)
                return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                  return c;
                })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
                  callback,
                  escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
                    userProvidedKeyEscapeRegex,
                    "$&/"
                  ) + "/") + invokeCallback
                )), array.push(callback)), 1;
              invokeCallback = 0;
              var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
              if (isArrayImpl(children))
                for (var i = 0; i < children.length; i++)
                  nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                    nameSoFar,
                    array,
                    escapedPrefix,
                    type,
                    callback
                  );
              else if (i = getIteratorFn(children), "function" === typeof i)
                for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
                  nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                    nameSoFar,
                    array,
                    escapedPrefix,
                    type,
                    callback
                  );
              else if ("object" === type) {
                if ("function" === typeof children.then)
                  return mapIntoArray(
                    resolveThenable(children),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
                array = String(children);
                throw Error(
                  "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
                );
              }
              return invokeCallback;
            }
            function mapChildren(children, func, context) {
              if (null == children)
                return children;
              var result = [], count = 0;
              mapIntoArray(children, result, "", "", function(child) {
                return func.call(context, child, count++);
              });
              return result;
            }
            function lazyInitializer(payload) {
              if (-1 === payload._status) {
                var ctor = payload._result;
                ctor = ctor();
                ctor.then(
                  function(moduleObject) {
                    if (0 === payload._status || -1 === payload._status)
                      payload._status = 1, payload._result = moduleObject;
                  },
                  function(error) {
                    if (0 === payload._status || -1 === payload._status)
                      payload._status = 2, payload._result = error;
                  }
                );
                -1 === payload._status && (payload._status = 0, payload._result = ctor);
              }
              if (1 === payload._status)
                return payload._result.default;
              throw payload._result;
            }
            var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
              if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent("error", {
                  bubbles: true,
                  cancelable: true,
                  message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                  error
                });
                if (!window.dispatchEvent(event))
                  return;
              } else if ("object" === typeof process && "function" === typeof process.emit) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            };
            function noop() {
            }
            exports2.Children = {
              map: mapChildren,
              forEach: function(children, forEachFunc, forEachContext) {
                mapChildren(
                  children,
                  function() {
                    forEachFunc.apply(this, arguments);
                  },
                  forEachContext
                );
              },
              count: function(children) {
                var n = 0;
                mapChildren(children, function() {
                  n++;
                });
                return n;
              },
              toArray: function(children) {
                return mapChildren(children, function(child) {
                  return child;
                }) || [];
              },
              only: function(children) {
                if (!isValidElement(children))
                  throw Error(
                    "React.Children.only expected to receive a single React element child."
                  );
                return children;
              }
            };
            exports2.Component = Component;
            exports2.Fragment = REACT_FRAGMENT_TYPE;
            exports2.Profiler = REACT_PROFILER_TYPE;
            exports2.PureComponent = PureComponent;
            exports2.StrictMode = REACT_STRICT_MODE_TYPE;
            exports2.Suspense = REACT_SUSPENSE_TYPE;
            exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
            exports2.act = function() {
              throw Error("act(...) is not supported in production builds of React.");
            };
            exports2.cache = function(fn) {
              return function() {
                return fn.apply(null, arguments);
              };
            };
            exports2.cloneElement = function(element, config, children) {
              if (null === element || void 0 === element)
                throw Error(
                  "The argument must be a React element, but you passed " + element + "."
                );
              var props = assign({}, element.props), key = element.key, owner = void 0;
              if (null != config)
                for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
                  !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
              var propName = arguments.length - 2;
              if (1 === propName)
                props.children = children;
              else if (1 < propName) {
                for (var childArray = Array(propName), i = 0; i < propName; i++)
                  childArray[i] = arguments[i + 2];
                props.children = childArray;
              }
              return ReactElement(element.type, key, void 0, void 0, owner, props);
            };
            exports2.createContext = function(defaultValue) {
              defaultValue = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null
              };
              defaultValue.Provider = defaultValue;
              defaultValue.Consumer = {
                $$typeof: REACT_CONSUMER_TYPE,
                _context: defaultValue
              };
              return defaultValue;
            };
            exports2.createElement = function(type, config, children) {
              var propName, props = {}, key = null;
              if (null != config)
                for (propName in void 0 !== config.key && (key = "" + config.key), config)
                  hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
              var childrenLength = arguments.length - 2;
              if (1 === childrenLength)
                props.children = children;
              else if (1 < childrenLength) {
                for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
                  childArray[i] = arguments[i + 2];
                props.children = childArray;
              }
              if (type && type.defaultProps)
                for (propName in childrenLength = type.defaultProps, childrenLength)
                  void 0 === props[propName] && (props[propName] = childrenLength[propName]);
              return ReactElement(type, key, void 0, void 0, null, props);
            };
            exports2.createRef = function() {
              return { current: null };
            };
            exports2.forwardRef = function(render) {
              return { $$typeof: REACT_FORWARD_REF_TYPE, render };
            };
            exports2.isValidElement = isValidElement;
            exports2.lazy = function(ctor) {
              return {
                $$typeof: REACT_LAZY_TYPE,
                _payload: { _status: -1, _result: ctor },
                _init: lazyInitializer
              };
            };
            exports2.memo = function(type, compare) {
              return {
                $$typeof: REACT_MEMO_TYPE,
                type,
                compare: void 0 === compare ? null : compare
              };
            };
            exports2.startTransition = function(scope) {
              var prevTransition = ReactSharedInternals.T, currentTransition = {};
              ReactSharedInternals.T = currentTransition;
              try {
                var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
              } catch (error) {
                reportGlobalError(error);
              } finally {
                ReactSharedInternals.T = prevTransition;
              }
            };
            exports2.unstable_useCacheRefresh = function() {
              return ReactSharedInternals.H.useCacheRefresh();
            };
            exports2.use = function(usable) {
              return ReactSharedInternals.H.use(usable);
            };
            exports2.useActionState = function(action, initialState, permalink) {
              return ReactSharedInternals.H.useActionState(action, initialState, permalink);
            };
            exports2.useCallback = function(callback, deps) {
              return ReactSharedInternals.H.useCallback(callback, deps);
            };
            exports2.useContext = function(Context) {
              return ReactSharedInternals.H.useContext(Context);
            };
            exports2.useDebugValue = function() {
            };
            exports2.useDeferredValue = function(value, initialValue) {
              return ReactSharedInternals.H.useDeferredValue(value, initialValue);
            };
            exports2.useEffect = function(create, deps) {
              return ReactSharedInternals.H.useEffect(create, deps);
            };
            exports2.useId = function() {
              return ReactSharedInternals.H.useId();
            };
            exports2.useImperativeHandle = function(ref, create, deps) {
              return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
            };
            exports2.useInsertionEffect = function(create, deps) {
              return ReactSharedInternals.H.useInsertionEffect(create, deps);
            };
            exports2.useLayoutEffect = function(create, deps) {
              return ReactSharedInternals.H.useLayoutEffect(create, deps);
            };
            exports2.useMemo = function(create, deps) {
              return ReactSharedInternals.H.useMemo(create, deps);
            };
            exports2.useOptimistic = function(passthrough, reducer) {
              return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
            };
            exports2.useReducer = function(reducer, initialArg, init) {
              return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
            };
            exports2.useRef = function(initialValue) {
              return ReactSharedInternals.H.useRef(initialValue);
            };
            exports2.useState = function(initialState) {
              return ReactSharedInternals.H.useState(initialState);
            };
            exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
              return ReactSharedInternals.H.useSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            };
            exports2.useTransition = function() {
              return ReactSharedInternals.H.useTransition();
            };
            exports2.version = "19.0.0";
          }
        ),
        /***/
        41: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(62);
            } else {}
          }
        ),
        /***/
        310: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            /**
             * @license React
             * scheduler.production.js
             *
             * Copyright (c) Meta Platforms, Inc. and affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            function push(heap, node) {
              var index = heap.length;
              heap.push(node);
              a:
                for (; 0 < index; ) {
                  var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
                  if (0 < compare(parent, node))
                    heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
                  else
                    break a;
                }
            }
            function peek(heap) {
              return 0 === heap.length ? null : heap[0];
            }
            function pop(heap) {
              if (0 === heap.length)
                return null;
              var first = heap[0], last = heap.pop();
              if (last !== first) {
                heap[0] = last;
                a:
                  for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
                    var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                    if (0 > compare(left, last))
                      rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                    else if (rightIndex < length && 0 > compare(right, last))
                      heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                    else
                      break a;
                  }
              }
              return first;
            }
            function compare(a, b) {
              var diff = a.sortIndex - b.sortIndex;
              return 0 !== diff ? diff : a.id - b.id;
            }
            exports2.unstable_now = void 0;
            if ("object" === typeof performance && "function" === typeof performance.now) {
              var localPerformance = performance;
              exports2.unstable_now = function() {
                return localPerformance.now();
              };
            } else {
              var localDate = Date, initialTime = localDate.now();
              exports2.unstable_now = function() {
                return localDate.now() - initialTime;
              };
            }
            var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
            function advanceTimers(currentTime) {
              for (var timer = peek(timerQueue); null !== timer; ) {
                if (null === timer.callback)
                  pop(timerQueue);
                else if (timer.startTime <= currentTime)
                  pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
                else
                  break;
                timer = peek(timerQueue);
              }
            }
            function handleTimeout(currentTime) {
              isHostTimeoutScheduled = false;
              advanceTimers(currentTime);
              if (!isHostCallbackScheduled)
                if (null !== peek(taskQueue))
                  isHostCallbackScheduled = true, requestHostCallback();
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
            }
            var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
            function shouldYieldToHost() {
              return exports2.unstable_now() - startTime < frameInterval ? false : true;
            }
            function performWorkUntilDeadline() {
              if (isMessageLoopRunning) {
                var currentTime = exports2.unstable_now();
                startTime = currentTime;
                var hasMoreWork = true;
                try {
                  a: {
                    isHostCallbackScheduled = false;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = true;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                      b: {
                        advanceTimers(currentTime);
                        for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                          var callback = currentTask.callback;
                          if ("function" === typeof callback) {
                            currentTask.callback = null;
                            currentPriorityLevel = currentTask.priorityLevel;
                            var continuationCallback = callback(
                              currentTask.expirationTime <= currentTime
                            );
                            currentTime = exports2.unstable_now();
                            if ("function" === typeof continuationCallback) {
                              currentTask.callback = continuationCallback;
                              advanceTimers(currentTime);
                              hasMoreWork = true;
                              break b;
                            }
                            currentTask === peek(taskQueue) && pop(taskQueue);
                            advanceTimers(currentTime);
                          } else
                            pop(taskQueue);
                          currentTask = peek(taskQueue);
                        }
                        if (null !== currentTask)
                          hasMoreWork = true;
                        else {
                          var firstTimer = peek(timerQueue);
                          null !== firstTimer && requestHostTimeout(
                            handleTimeout,
                            firstTimer.startTime - currentTime
                          );
                          hasMoreWork = false;
                        }
                      }
                      break a;
                    } finally {
                      currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                    }
                    hasMoreWork = void 0;
                  }
                } finally {
                  hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
                }
              }
            }
            var schedulePerformWorkUntilDeadline;
            if ("function" === typeof localSetImmediate)
              schedulePerformWorkUntilDeadline = function() {
                localSetImmediate(performWorkUntilDeadline);
              };
            else if ("undefined" !== typeof MessageChannel) {
              var channel = new MessageChannel(), port = channel.port2;
              channel.port1.onmessage = performWorkUntilDeadline;
              schedulePerformWorkUntilDeadline = function() {
                port.postMessage(null);
              };
            } else
              schedulePerformWorkUntilDeadline = function() {
                localSetTimeout(performWorkUntilDeadline, 0);
              };
            function requestHostCallback() {
              isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            }
            function requestHostTimeout(callback, ms) {
              taskTimeoutID = localSetTimeout(function() {
                callback(exports2.unstable_now());
              }, ms);
            }
            exports2.unstable_IdlePriority = 5;
            exports2.unstable_ImmediatePriority = 1;
            exports2.unstable_LowPriority = 4;
            exports2.unstable_NormalPriority = 3;
            exports2.unstable_Profiling = null;
            exports2.unstable_UserBlockingPriority = 2;
            exports2.unstable_cancelCallback = function(task) {
              task.callback = null;
            };
            exports2.unstable_continueExecution = function() {
              isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
            };
            exports2.unstable_forceFrameRate = function(fps) {
              0 > fps || 125 < fps ? console.error(
                "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
              ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
            };
            exports2.unstable_getCurrentPriorityLevel = function() {
              return currentPriorityLevel;
            };
            exports2.unstable_getFirstCallbackNode = function() {
              return peek(taskQueue);
            };
            exports2.unstable_next = function(eventHandler) {
              switch (currentPriorityLevel) {
                case 1:
                case 2:
                case 3:
                  var priorityLevel = 3;
                  break;
                default:
                  priorityLevel = currentPriorityLevel;
              }
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = priorityLevel;
              try {
                return eventHandler();
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
            exports2.unstable_pauseExecution = function() {
            };
            exports2.unstable_requestPaint = function() {
            };
            exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
              switch (priorityLevel) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  break;
                default:
                  priorityLevel = 3;
              }
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = priorityLevel;
              try {
                return eventHandler();
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
            exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
              var currentTime = exports2.unstable_now();
              "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
              switch (priorityLevel) {
                case 1:
                  var timeout = -1;
                  break;
                case 2:
                  timeout = 250;
                  break;
                case 5:
                  timeout = 1073741823;
                  break;
                case 4:
                  timeout = 1e4;
                  break;
                default:
                  timeout = 5e3;
              }
              timeout = options + timeout;
              priorityLevel = {
                id: taskIdCounter++,
                callback,
                priorityLevel,
                startTime: options,
                expirationTime: timeout,
                sortIndex: -1
              };
              options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
              return priorityLevel;
            };
            exports2.unstable_shouldYield = shouldYieldToHost;
            exports2.unstable_wrapCallback = function(callback) {
              var parentPriorityLevel = currentPriorityLevel;
              return function() {
                var previousPriorityLevel = currentPriorityLevel;
                currentPriorityLevel = parentPriorityLevel;
                try {
                  return callback.apply(this, arguments);
                } finally {
                  currentPriorityLevel = previousPriorityLevel;
                }
              };
            };
          }
        ),
        /***/
        967: (
          /***/
          (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(310);
            } else {}
          }
        ),
        /***/
        444: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__444__;
          }
        ),
        /***/
        910: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__910__;
          }
        ),
        /***/
        254: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__254__;
          }
        ),
        /***/
        685: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__685__;
          }
        ),
        /***/
        292: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__292__;
          }
        ),
        /***/
        736: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__736__;
          }
        ),
        /***/
        517: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__517__;
          }
        ),
        /***/
        540: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__540__;
          }
        ),
        /***/
        863: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__863__;
          }
        ),
        /***/
        387: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__387__;
          }
        ),
        /***/
        493: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__493__;
          }
        ),
        /***/
        748: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__748__;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __nested_webpack_require_1478812__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __nested_webpack_require_1478812__);
        return module2.exports;
      }
      (() => {
        __nested_webpack_require_1478812__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__nested_webpack_require_1478812__.o(definition, key) && !__nested_webpack_require_1478812__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __nested_webpack_require_1478812__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __nested_webpack_require_1478812__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __nested_webpack_exports__ = {};
      (() => {
        "use strict";
        __nested_webpack_require_1478812__.r(__nested_webpack_exports__);
        __nested_webpack_require_1478812__.d(__nested_webpack_exports__, {
          AceTree: () => (
            /* reexport */
            AceTree
          ),
          Box: () => (
            /* reexport */
            Box
          ),
          Button: () => (
            /* reexport */
            Button
          )
        });
        var react = __nested_webpack_require_1478812__(41);
        var client = __nested_webpack_require_1478812__(873);
        var bundle_index = __nested_webpack_require_1478812__(465);
        ;
        var __getOwnPropSymbols = Object.getOwnPropertySymbols;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __propIsEnum = Object.prototype.propertyIsEnumerable;
        var __objRest = (source, exclude) => {
          var target = {};
          for (var prop in source)
            if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
              target[prop] = source[prop];
          if (source != null && __getOwnPropSymbols)
            for (var prop of __getOwnPropSymbols(source)) {
              if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
                target[prop] = source[prop];
            }
          return target;
        };
        const BoxContext = (0, react.createContext)({
          parentBox: null,
          childIndexRef: { current: 0 }
        });
        const Box = (0, react.forwardRef)((props, ref) => {
          const _a = props, {
            buttons = [],
            children
          } = _a, boxOptions = __objRest(_a, [
            "buttons",
            "children"
          ]);
          const boxRef = (0, react.useRef)(
            new bundle_index.Box(boxOptions)
          );
          const boxElement = (0, react.useRef)(null);
          const { parentBox, childIndexRef } = (0, react.useContext)(BoxContext);
          function render() {
            boxRef.current.element = boxElement.current;
            boxRef.current.render();
          }
          function setButtons() {
            boxRef.current.setButtons(buttons.map((button) => {
              const buttonDomNode = document.createElement("div");
              const root = (0, client.createRoot)(buttonDomNode);
              root.render(button);
              return buttonDomNode;
            }));
          }
          function addToParent() {
            const i = childIndexRef.current;
            childIndexRef.current = i + 1;
            parentBox.addChildBox(i, boxRef.current);
          }
          (0, react.useLayoutEffect)(() => {
            render();
            setButtons();
            parentBox && addToParent();
            return () => {
              boxRef.current.remove();
            };
          }, [parentBox]);
          (0, react.useEffect)(() => {
          }, [props]);
          const myContextValue = (0, react.useMemo)(() => {
            return {
              parentBox: boxRef.current,
              childIndexRef: { current: 0 }
            };
          }, []);
          (0, react.useImperativeHandle)(ref, () => ({
            boxInstance: boxRef.current
          }));
          return /* @__PURE__ */ react.createElement(BoxContext.Provider, { value: myContextValue }, /* @__PURE__ */ react.createElement("div", { ref: boxElement, className: "box" }, children));
        });
        ;
        var Button_getOwnPropSymbols = Object.getOwnPropertySymbols;
        var Button_hasOwnProp = Object.prototype.hasOwnProperty;
        var Button_propIsEnum = Object.prototype.propertyIsEnumerable;
        var Button_objRest = (source, exclude) => {
          var target = {};
          for (var prop in source)
            if (Button_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
              target[prop] = source[prop];
          if (source != null && Button_getOwnPropSymbols)
            for (var prop of Button_getOwnPropSymbols(source)) {
              if (exclude.indexOf(prop) < 0 && Button_propIsEnum.call(source, prop))
                target[prop] = source[prop];
            }
          return target;
        };
        const Button = (props) => {
          const _a = props, { children } = _a, buttonOptions = Button_objRest(_a, ["children"]);
          const buttonRef = (0, react.useRef)(new bundle_index.Button(buttonOptions));
          const buttonElementRef = (0, react.useRef)(null);
          (0, react.useLayoutEffect)(() => {
            buttonRef.current.element = buttonElementRef.current;
            buttonRef.current.render();
            return () => {
              buttonRef.current.remove();
            };
          }, []);
          return /* @__PURE__ */ react.createElement("div", { ref: buttonElementRef }, children);
        };
        ;
        const AceTree = (0, react.forwardRef)(
          (props, ref) => {
            const { children } = props;
            const treeRef = (0, react.useRef)(new bundle_index.AceTreeWrapper());
            const treeElementRef = (0, react.useRef)(null);
            (0, react.useLayoutEffect)(() => {
              treeRef.current.element = treeElementRef.current;
              treeRef.current.render();
              return () => {
                treeRef.current.remove();
              };
            }, []);
            (0, react.useImperativeHandle)(ref, () => ({
              aceTreeInstance: treeRef.current
            }));
            return /* @__PURE__ */ react.createElement("div", { ref: treeElementRef }, children);
          }
        );
        ;
      })();
      return __nested_webpack_exports__;
    })()
  );
});


/***/ }),

/***/ 31247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

var Scheduler = __webpack_require__(69982),
  React = __webpack_require__(96540),
  ReactDOM = __webpack_require__(40961);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function isValidContainer(node) {
  return !(
    !node ||
    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
  );
}
var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE
      ? null
      : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PORTAL_TYPE:
      return "Portal";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type ||
          ((type = innerType.displayName || innerType.name || ""),
          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
        return type;
      case REACT_MEMO_TYPE:
        return (
          (innerType = type.displayName || null),
          null !== innerType
            ? innerType
            : getComponentNameFromType(type.type) || "Memo"
        );
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
  return null;
}
var ReactSharedInternals =
    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  assign = Object.assign,
  prefix,
  suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = (match && match[1]) || "";
      suffix =
        -1 < x.stack.indexOf("\n    at")
          ? " (<anonymous>)"
          : -1 < x.stack.indexOf("@")
            ? "@unknown:0:0"
            : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$0) {
                control = x$0;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$1) {
              control = x$1;
            }
            (Fake = fn()) &&
              "function" === typeof Fake.catch &&
              Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName =
      "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor &&
      namePropDescriptor.configurable &&
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (
        namePropDescriptor = RunInRootFrame = 0;
        RunInRootFrame < sampleLines.length &&
        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

      )
        RunInRootFrame++;
      for (
        ;
        namePropDescriptor < controlLines.length &&
        !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        );

      )
        namePropDescriptor++;
      if (
        RunInRootFrame === sampleLines.length ||
        namePropDescriptor === controlLines.length
      )
        for (
          RunInRootFrame = sampleLines.length - 1,
            namePropDescriptor = controlLines.length - 1;
          1 <= RunInRootFrame &&
          0 <= namePropDescriptor &&
          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

        )
          namePropDescriptor--;
      for (
        ;
        1 <= RunInRootFrame && 0 <= namePropDescriptor;
        RunInRootFrame--, namePropDescriptor--
      )
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (
                (RunInRootFrame--,
                namePropDescriptor--,
                0 > namePropDescriptor ||
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor])
              ) {
                var frame =
                  "\n" +
                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName &&
                  frame.includes("<anonymous>") &&
                  (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
    : "";
}
function describeFiber(fiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return (fiber = describeNativeComponentFrame(fiber.type, !1)), fiber;
    case 11:
      return (
        (fiber = describeNativeComponentFrame(fiber.type.render, !1)), fiber
      );
    case 1:
      return (fiber = describeNativeComponentFrame(fiber.type, !0)), fiber;
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "";
    do
      (info += describeFiber(workInProgress)),
        (workInProgress = workInProgress.return);
    while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      (node = fiber),
        0 !== (node.flags & 4098) && (nearestMounted = node.return),
        (fiber = node.return);
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState &&
      ((fiber = fiber.alternate),
      null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) (a = parentA), (b = parentB);
    else {
      for (var didFindChild = !1, child$2 = parentA.child; child$2; ) {
        if (child$2 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$2 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$2 = child$2.sibling;
      }
      if (!didFindChild) {
        for (child$2 = parentB.child; child$2; ) {
          if (child$2 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$2 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$2 = child$2.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactDOMSharedInternals =
    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index ||
    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  fiber = nextRootInstance.nodeType;
  switch (fiber) {
    case 9:
    case 11:
      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)
        ? (nextRootInstance = nextRootInstance.namespaceURI)
          ? getOwnHostContext(nextRootInstance)
          : 0
        : 0;
      break;
    default:
      if (
        ((fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance),
        (nextRootInstance = fiber.tagName),
        (fiber = fiber.namespaceURI))
      )
        (fiber = getOwnHostContext(fiber)),
          (nextRootInstance = getChildHostContextProd(fiber, nextRootInstance));
      else
        switch (nextRootInstance) {
          case "svg":
            nextRootInstance = 1;
            break;
          case "math":
            nextRootInstance = 2;
            break;
          default:
            nextRootInstance = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, nextRootInstance);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result &&
    (push(contextFiberStackCursor, fiber),
    push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber &&
    (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber &&
    (pop(hostTransitionProviderCursor),
    (HostTransitionContext._currentValue = sharedNotPendingObject));
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function onCommitRoot(root) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
    try {
      injectedHook.onCommitFiberRoot(
        rendererID,
        root,
        void 0,
        128 === (root.current.flags & 128)
      );
    } catch (err) {}
}
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
}
var nextTransitionLane = 128,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 4194176;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes,
    warmLanes = root.warmLanes;
  root = 0 !== root.finishedLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes
    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
      0 !== pendingLanes
        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
        : ((pingedLanes &= nonIdlePendingLanes),
          0 !== pingedLanes
            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
            : root ||
              ((warmLanes = nonIdlePendingLanes & ~warmLanes),
              0 !== warmLanes &&
                (nextLanes = getHighestPriorityLanes(warmLanes)))))
    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
      0 !== nonIdlePendingLanes
        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : 0 !== pingedLanes
          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
          : root ||
            ((warmLanes = pendingLanes & ~warmLanes),
            0 !== warmLanes &&
              (nextLanes = getHighestPriorityLanes(warmLanes))));
  return 0 === nextLanes
    ? 0
    : 0 !== wipLanes &&
        wipLanes !== nextLanes &&
        0 === (wipLanes & suspendedLanes) &&
        ((suspendedLanes = nextLanes & -nextLanes),
        (warmLanes = wipLanes & -wipLanes),
        suspendedLanes >= warmLanes ||
          (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))
      ? wipLanes
      : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (
    0 ===
    (root.pendingLanes &
      ~(root.suspendedLanes & ~root.pingedLanes) &
      renderLanes)
  );
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
      return currentTime + 250;
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextTransitionLane() {
  var lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
  return lane;
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane &&
    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
}
function markRootFinished(
  root,
  finishedLanes,
  remainingLanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (
    remainingLanes = previouslyPendingLanes & ~remainingLanes;
    0 < remainingLanes;

  ) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane)
      for (
        hiddenUpdates[index$7] = null, index$7 = 0;
        index$7 < hiddenUpdatesForLane.length;
        index$7++
      ) {
        var update = hiddenUpdatesForLane[index$7];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes &&
    0 === updatedLanes &&
    0 !== root.tag &&
    (root.suspendedLanes |=
      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] =
    root.entanglements[spawnedLaneIndex] |
    1073741824 |
    (entangledLanes & 4194218);
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
  for (root = root.entanglements; rootEntangledLanes; ) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
      (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes
    ? 8 < lanes
      ? 0 !== (lanes & 134217727)
        ? 32
        : 268435456
      : 8
    : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return (ReactDOMSharedInternals.p = priority), fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (
      (targetInst =
        parentNode[internalContainerInstanceKey] ||
        parentNode[internalInstanceKey])
    ) {
      parentNode = targetInst.alternate;
      if (
        null !== targetInst.child ||
        (null !== parentNode && null !== parentNode.child)
      )
        for (
          targetNode = getParentSuspenseInstance(targetNode);
          null !== targetNode;

        ) {
          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (
    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
  ) {
    var tag = node.tag;
    if (
      5 === tag ||
      6 === tag ||
      13 === tag ||
      26 === tag ||
      27 === tag ||
      3 === tag
    )
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources ||
    (resources = root[internalRootNodeResourcesKey] =
      { hoistableStyles: new Map(), hoistableScripts: new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (
    registrationName = 0;
    registrationName < dependencies.length;
    registrationName++
  )
    allNativeEvents.add(dependencies[registrationName]);
}
var canUseDOM = !(
    "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
  ),
  VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return (validatedAttributeNameCache[attributeName] = !0);
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$10 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (
    (elem = elem.nodeName) &&
    "input" === elem.toLowerCase() &&
    ("checkbox" === type || "radio" === type)
  );
}
function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? "checked" : "value",
    descriptor = Object.getOwnPropertyDescriptor(
      node.constructor.prototype,
      valueField
    ),
    currentValue = "" + node[valueField];
  if (
    !node.hasOwnProperty(valueField) &&
    "undefined" !== typeof descriptor &&
    "function" === typeof descriptor.get &&
    "function" === typeof descriptor.set
  ) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node &&
    (value = isCheckable(node)
      ? node.checked
        ? "true"
        : "false"
      : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(
  element,
  value,
  defaultValue,
  lastDefaultValue,
  checked,
  defaultChecked,
  type,
  name
) {
  element.name = "";
  null != type &&
  "function" !== typeof type &&
  "symbol" !== typeof type &&
  "boolean" !== typeof type
    ? (element.type = type)
    : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if ((0 === value && "" === element.value) || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) &&
        (element.value = "" + getToStringValue(value));
  else
    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
  null != value
    ? setDefaultValue(element, type, getToStringValue(value))
    : null != defaultValue
      ? setDefaultValue(element, type, getToStringValue(defaultValue))
      : null != lastDefaultValue && element.removeAttribute("value");
  null == checked &&
    null != defaultChecked &&
    (element.defaultChecked = !!defaultChecked);
  null != checked &&
    (element.checked =
      checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name &&
  "function" !== typeof name &&
  "symbol" !== typeof name &&
  "boolean" !== typeof name
    ? (element.name = "" + getToStringValue(name))
    : element.removeAttribute("name");
}
function initInput(
  element,
  value,
  defaultValue,
  checked,
  defaultChecked,
  type,
  name,
  isHydrating
) {
  null != type &&
    "function" !== typeof type &&
    "symbol" !== typeof type &&
    "boolean" !== typeof type &&
    (element.type = type);
  if (null != value || null != defaultValue) {
    if (
      !(
        ("submit" !== type && "reset" !== type) ||
        (void 0 !== value && null !== value)
      )
    )
      return;
    defaultValue =
      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked =
    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name &&
    "function" !== typeof name &&
    "symbol" !== typeof name &&
    "boolean" !== typeof name &&
    (element.name = name);
}
function setDefaultValue(node, type, value) {
  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
    node.defaultValue === "" + value ||
    (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++)
      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
        node[propValue].selected !== i && (node[propValue].selected = i),
        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (
    null != value &&
    ((value = "" + getToStringValue(value)),
    value !== element.value && (element.value = value),
    null == defaultValue)
  ) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue =
    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue &&
    "" !== children &&
    null !== children &&
    (element.value = children);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (
      firstChild &&
      firstChild === node.lastChild &&
      3 === firstChild.nodeType
    ) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value
    ? isCustomProperty
      ? style.setProperty(styleName, "")
      : "float" === styleName
        ? (style.cssFloat = "")
        : (style[styleName] = "")
    : isCustomProperty
      ? style.setProperty(styleName, value)
      : "number" !== typeof value ||
          0 === value ||
          unitlessNumbers.has(styleName)
        ? "float" === styleName
          ? (style.cssFloat = value)
          : (style[styleName] = ("" + value).trim())
        : (style[styleName] = value + "px");
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) ||
        (null != styles && styles.hasOwnProperty(styleName)) ||
        (0 === styleName.indexOf("--")
          ? node.setProperty(styleName, "")
          : "float" === styleName
            ? (node.cssFloat = "")
            : (node[styleName] = ""));
    for (var styleName$16 in styles)
      (styleName = styles[styleName$16]),
        styles.hasOwnProperty(styleName$16) &&
          prevStyles[styleName$16] !== styleName &&
          setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) &&
        setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]),
  isJavaScriptProtocol =
    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url)
    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
    : url;
}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement &&
    (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) +
              '"][type="radio"]'
          );
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          ) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          )
            (otherNode = props[internalInstance]),
              otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        (internalInstance = props.value),
          null != internalInstance &&
            updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (
      ((isInsideEventHandler = !1),
      null !== restoreTarget || null !== restoreQueue)
    )
      if (
        (flushSyncWork$1(),
        restoreTarget &&
          ((a = restoreTarget),
          (fn = restoreQueue),
          (restoreQueue = restoreTarget = null),
          restoreStateOfTarget(a),
          fn))
      )
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) ||
        ((inst = inst.type),
        (props = !(
          "button" === inst ||
          "input" === inst ||
          "select" === inst ||
          "textarea" === inst
        )));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var passiveBrowserEventsSupported = !1;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (
    start = 0;
    start < startLength && startValue[start] === endValue[start];
    start++
  );
  var minEnd = startLength - start;
  for (
    end = 1;
    end <= minEnd &&
    startValue[startLength - end] === endValue[endLength - end];
    end++
  );
  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent
    ? ((nativeEvent = nativeEvent.charCode),
      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
    : (nativeEvent = keyCode);
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(
    reactName,
    reactEventType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) &&
        ((reactName = Interface[propName]),
        (this[propName] = reactName
          ? reactName(nativeEvent)
          : nativeEvent[propName]));
    this.isDefaultPrevented = (
      null != nativeEvent.defaultPrevented
        ? nativeEvent.defaultPrevented
        : !1 === nativeEvent.returnValue
    )
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget
        ? event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement
        : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent &&
        (lastMouseEvent && "mousemove" === event.type
          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
            (lastMovementY = event.screenY - lastMouseEvent.screenY))
          : (lastMovementY = lastMovementX = 0),
        (lastMouseEvent = event));
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState
    ? nativeEvent.getModifierState(keyArg)
    : (keyArg = modifierKeyToProp[keyArg])
      ? !!nativeEvent[keyArg]
      : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function (event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM &&
  "documentMode" in document &&
  (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData =
    canUseDOM &&
    (!canUseCompositionEvent ||
      (documentMode && 8 < documentMode && 11 >= documentMode)),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent
    ? nativeEvent.data
    : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return (
        (domEventName = nativeEvent.data),
        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
      );
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName ||
      (!canUseCompositionEvent &&
        isFallbackCompositionEnd(domEventName, nativeEvent))
      ? ((domEventName = getData()),
        (fallbackText = startText = root = null),
        (isComposing = !1),
        domEventName)
      : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
        (nativeEvent.ctrlKey && nativeEvent.altKey)
      ) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale
        ? null
        : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName
    ? !!supportedInputTypes[elem.type]
    : "textarea" === nodeName
      ? !0
      : !1;
}
function createAndAccumulateChangeEvent(
  dispatchQueue,
  inst,
  nativeEvent,
  target
) {
  restoreTarget
    ? restoreQueue
      ? restoreQueue.push(target)
      : (restoreQueue = [target])
    : (restoreTarget = target);
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length &&
    ((nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    )),
    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$283;
  if (canUseDOM) {
    var isSupported$jscomp$inline_418 = "oninput" in document;
    if (!isSupported$jscomp$inline_418) {
      var element$jscomp$inline_419 = document.createElement("div");
      element$jscomp$inline_419.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_418 =
        "function" === typeof element$jscomp$inline_419.oninput;
    }
    JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;
  } else JSCompiler_inline_result$jscomp$283 = !1;
  isInputEventSupported =
    JSCompiler_inline_result$jscomp$283 &&
    (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 &&
    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    (activeElementInst$1 = activeElement$1 = null));
}
function handlePropertyChange(nativeEvent) {
  if (
    "value" === nativeEvent.propertyName &&
    getInstIfValueChanged(activeElementInst$1)
  ) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName
    ? (stopWatchingForValueChange(),
      (activeElement$1 = target),
      (activeElementInst$1 = targetInst),
      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
    : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (
    "selectionchange" === domEventName ||
    "keyup" === domEventName ||
    "keydown" === domEventName
  )
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if (
    "object" !== typeof objA ||
    null === objA ||
    "object" !== typeof objB ||
    null === objB
  )
    return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    )
      return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset)
        return { node: node, offset: offset - root };
      root = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode
    ? outerNode === innerNode
      ? !0
      : outerNode && 3 === outerNode.nodeType
        ? !1
        : innerNode && 3 === innerNode.nodeType
          ? containsNode(outerNode, innerNode.parentNode)
          : "contains" in outerNode
            ? outerNode.contains(innerNode)
            : outerNode.compareDocumentPosition
              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
              : !1
    : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo =
    null != containerInfo &&
    null != containerInfo.ownerDocument &&
    null != containerInfo.ownerDocument.defaultView
      ? containerInfo.ownerDocument.defaultView
      : window;
  for (
    var element = getActiveElement(containerInfo.document);
    element instanceof containerInfo.HTMLIFrameElement;

  ) {
    try {
      var JSCompiler_inline_result =
        "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName &&
    (("input" === nodeName &&
      ("text" === elem.type ||
        "search" === elem.type ||
        "tel" === elem.type ||
        "url" === elem.type ||
        "password" === elem.type)) ||
      "textarea" === nodeName ||
      "true" === elem.contentEditable)
  );
}
function restoreSelection(priorSelectionInformation, containerInfo) {
  var curFocusedElem = getActiveElementDeep(containerInfo);
  containerInfo = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (
    curFocusedElem !== containerInfo &&
    containerInfo &&
    containerInfo.ownerDocument &&
    containsNode(containerInfo.ownerDocument.documentElement, containerInfo)
  ) {
    if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo))
      if (
        ((priorSelectionInformation = priorSelectionRange.start),
        (curFocusedElem = priorSelectionRange.end),
        void 0 === curFocusedElem &&
          (curFocusedElem = priorSelectionInformation),
        "selectionStart" in containerInfo)
      )
        (containerInfo.selectionStart = priorSelectionInformation),
          (containerInfo.selectionEnd = Math.min(
            curFocusedElem,
            containerInfo.value.length
          ));
      else if (
        ((curFocusedElem =
          ((priorSelectionInformation =
            containerInfo.ownerDocument || document) &&
            priorSelectionInformation.defaultView) ||
          window),
        curFocusedElem.getSelection)
      ) {
        curFocusedElem = curFocusedElem.getSelection();
        var length = containerInfo.textContent.length,
          start = Math.min(priorSelectionRange.start, length);
        priorSelectionRange =
          void 0 === priorSelectionRange.end
            ? start
            : Math.min(priorSelectionRange.end, length);
        !curFocusedElem.extend &&
          start > priorSelectionRange &&
          ((length = priorSelectionRange),
          (priorSelectionRange = start),
          (start = length));
        length = getNodeForCharacterOffset(containerInfo, start);
        var endMarker = getNodeForCharacterOffset(
          containerInfo,
          priorSelectionRange
        );
        length &&
          endMarker &&
          (1 !== curFocusedElem.rangeCount ||
            curFocusedElem.anchorNode !== length.node ||
            curFocusedElem.anchorOffset !== length.offset ||
            curFocusedElem.focusNode !== endMarker.node ||
            curFocusedElem.focusOffset !== endMarker.offset) &&
          ((priorSelectionInformation =
            priorSelectionInformation.createRange()),
          priorSelectionInformation.setStart(length.node, length.offset),
          curFocusedElem.removeAllRanges(),
          start > priorSelectionRange
            ? (curFocusedElem.addRange(priorSelectionInformation),
              curFocusedElem.extend(endMarker.node, endMarker.offset))
            : (priorSelectionInformation.setEnd(
                endMarker.node,
                endMarker.offset
              ),
              curFocusedElem.addRange(priorSelectionInformation)));
      }
    priorSelectionInformation = [];
    for (
      curFocusedElem = containerInfo;
      (curFocusedElem = curFocusedElem.parentNode);

    )
      1 === curFocusedElem.nodeType &&
        priorSelectionInformation.push({
          element: curFocusedElem,
          left: curFocusedElem.scrollLeft,
          top: curFocusedElem.scrollTop
        });
    "function" === typeof containerInfo.focus && containerInfo.focus();
    for (
      containerInfo = 0;
      containerInfo < priorSelectionInformation.length;
      containerInfo++
    )
      (curFocusedElem = priorSelectionInformation[containerInfo]),
        (curFocusedElem.element.scrollLeft = curFocusedElem.left),
        (curFocusedElem.element.scrollTop = curFocusedElem.top);
  }
}
var skipSelectionChangeEvent =
    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc =
    nativeEventTarget.window === nativeEventTarget
      ? nativeEventTarget.document
      : 9 === nativeEventTarget.nodeType
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument;
  mouseDown ||
    null == activeElement ||
    activeElement !== getActiveElement(doc) ||
    ((doc = activeElement),
    "selectionStart" in doc && hasSelectionCapabilities(doc)
      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
      : ((doc = (
          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        })),
    (lastSelection && shallowEqual(lastSelection, doc)) ||
      ((lastSelection = doc),
      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
      0 < doc.length &&
        ((nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
        (nativeEvent.target = activeElement))));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM &&
  ((style = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete vendorPrefixes.animationend.animation,
    delete vendorPrefixes.animationiteration.animation,
    delete vendorPrefixes.animationstart.animation),
  "TransitionEvent" in window ||
    delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents =
    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
      " "
    );
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (
    var endIndex = concurrentQueuesIndex,
      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
    i < endIndex;

  ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
    (parent.childLanes |= lane),
      (alternate = parent.alternate),
      null !== alternate && (alternate.childLanes |= lane),
      22 === parent.tag &&
        ((sourceFiber = parent.stateNode),
        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
      (sourceFiber = parent),
      (parent = parent.return);
  isHidden &&
    null !== update &&
    3 === sourceFiber.tag &&
    ((parent = sourceFiber.stateNode),
    (isHidden = 31 - clz32(lane)),
    (parent = parent.hiddenUpdates),
    (sourceFiber = parent[isHidden]),
    null === sourceFiber
      ? (parent[isHidden] = [update])
      : sourceFiber.push(update),
    (update.lane = lane | 536870912));
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw (
      ((nestedUpdateCount = 0),
      (rootWithNestedUpdates = null),
      Error(formatProdErrorMessage(185)))
    );
  for (var parent = sourceFiber.return; null !== parent; )
    (sourceFiber = parent), (parent = sourceFiber.return);
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {},
  CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - (baseLength % 5);
    length = (
      baseIdWithLeadingBit &
      ((1 << numberOfOverflowBits) - 1)
    ).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId =
      (1 << (32 - clz32(totalChildren) + baseLength)) |
      (index << baseLength) |
      baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    (treeContextId =
      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
      (treeContextOverflow = workInProgress);
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return &&
    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider; )
    (treeForkProvider = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null),
      (treeForkCount = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null);
  for (; workInProgress === treeContextProvider; )
    (treeContextProvider = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextOverflow = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextId = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null);
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(formatProdErrorMessage(418, ""));
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        !0
      );
      track(instance);
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance),
        initTextarea(instance, props.value, props.defaultValue, props.children),
        track(instance);
  }
  type = props.children;
  ("string" !== typeof type &&
    "number" !== typeof type &&
    "bigint" !== typeof type) ||
  instance.textContent === "" + type ||
  !0 === props.suppressHydrationWarning ||
  checkForUnmatchedText(instance.textContent, type)
    ? (null != props.popover &&
        (listenToNonDelegatedEvent("beforetoggle", instance),
        listenToNonDelegatedEvent("toggle", instance)),
      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
      null != props.onScrollEnd &&
        listenToNonDelegatedEvent("scrollend", instance),
      null != props.onClick && (instance.onclick = noop$1),
      (instance = !0))
    : (instance = !1);
  instance || throwOnHydrationMismatch(fiber);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 3:
      case 27:
        rootOrSingletonContext = !0;
        return;
      case 5:
      case 13:
        rootOrSingletonContext = !1;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
  var shouldClear = !1,
    JSCompiler_temp;
  if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {
    if ((JSCompiler_temp = 5 === fiber.tag))
      (JSCompiler_temp = fiber.type),
        (JSCompiler_temp =
          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
          shouldSetTextContent(fiber.type, fiber.memoizedProps));
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && (shouldClear = !0);
  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === fiber.tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    a: {
      fiber = fiber.nextSibling;
      for (shouldClear = 0; fiber; ) {
        if (8 === fiber.nodeType)
          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
            if (0 === shouldClear) {
              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
              break a;
            }
            shouldClear--;
          } else
            ("$" !== JSCompiler_temp &&
              "$!" !== JSCompiler_temp &&
              "$?" !== JSCompiler_temp) ||
              shouldClear++;
        fiber = fiber.nextSibling;
      }
      nextHydratableInstance = null;
    }
  } else
    nextHydratableInstance = hydrationParentFiber
      ? getNextHydratable(fiber.stateNode.nextSibling)
      : null;
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function queueHydrationError(error) {
  null === hydrationErrors
    ? (hydrationErrors = [error])
    : hydrationErrors.push(error);
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  noopSuspenseyCommitThenable = { then: function () {} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function noop$3() {}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index
    ? thenableState.push(thenable)
    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      thenableState = thenable.reason;
      if (thenableState === SuspenseException)
        throw Error(formatProdErrorMessage(483));
      throw thenableState;
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
      else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(
          function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          thenableState = thenable.reason;
          if (thenableState === SuspenseException)
            throw Error(formatProdErrorMessage(483));
          throw thenableState;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber
        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
        : returnFiber
    )
  );
}
function resolveLazy(lazyType) {
  var init = lazyType._init;
  return init(lazyType._payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions
        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
        : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key
        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
        : existingChildren.set(currentFirstChild.index, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return (newFiber.flags |= 1048576), lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return (
        (newIndex = newIndex.index),
        newIndex < lastPlacedIndex
          ? ((newFiber.flags |= 33554434), lastPlacedIndex)
          : newIndex
      );
    newFiber.flags |= 33554434;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects &&
      null === newFiber.alternate &&
      (newFiber.flags |= 33554434);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return (
        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (
      null !== current &&
      (current.elementType === elementType ||
        ("object" === typeof elementType &&
          null !== elementType &&
          elementType.$$typeof === REACT_LAZY_TYPE &&
          resolveLazy(elementType) === current.type))
    )
      return (
        (current = useFiber(current, element.props)),
        coerceRef(current, element),
        (current.return = returnFiber),
        current
      );
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (
      null === current ||
      4 !== current.tag ||
      current.stateNode.containerInfo !== portal.containerInfo ||
      current.stateNode.implementation !== portal.implementation
    )
      return (
        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return (
        (current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        )),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        )),
        (newChild.return = returnFiber),
        newChild
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            )),
            coerceRef(lanes, newChild),
            (lanes.return = returnFiber),
            lanes
          );
        case REACT_PORTAL_TYPE:
          return (
            (newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            newChild
          );
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return createChild(returnFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return null !== key
        ? null
        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key
            ? updateElement(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key
            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_LAZY_TYPE:
          return (
            (key = newChild._init),
            (newChild = key(newChild._payload)),
            updateSlot(returnFiber, oldFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key
          ? null
          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChild,
    lanes
  ) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (existingChildren = existingChildren.get(newIdx) || null),
        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updateElement(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_PORTAL_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updatePortal(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            newChild,
            lanes
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
        );
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null;
      null !== oldFiber && newIdx < newChildren.length;
      newIdx++
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
          null !== oldFiber &&
            ((currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = oldFiber)
              : (previousNewFiber.sibling = oldFiber),
            (previousNewFiber = oldFiber));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      newIdx < newChildren.length;
      newIdx++
    )
      (nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      )),
        null !== nextOldFiber &&
          (shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
          (currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          )),
          null === previousNewFiber
            ? (resultingFirstChild = nextOldFiber)
            : (previousNewFiber.sibling = nextOldFiber),
          (previousNewFiber = nextOldFiber));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null,
        step = newChildren.next();
      null !== oldFiber && !step.done;
      newIdx++, step = newChildren.next()
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        (step = createChild(returnFiber, step.value, lanes)),
          null !== step &&
            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (resultingFirstChild = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      !step.done;
      newIdx++, step = newChildren.next()
    )
      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
        null !== step &&
          (shouldTrackSideEffects &&
            null !== step.alternate &&
            oldFiber.delete(null === step.key ? newIdx : step.key),
          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
          null === previousNewFiber
            ? (resultingFirstChild = step)
            : (previousNewFiber.sibling = step),
          (previousNewFiber = step));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes
  ) {
    "object" === typeof newChild &&
      null !== newChild &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      null === newChild.key &&
      (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (
                  currentFirstChild.elementType === key ||
                  ("object" === typeof key &&
                    null !== key &&
                    key.$$typeof === REACT_LAZY_TYPE &&
                    resolveLazy(key) === currentFirstChild.type)
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE
              ? ((lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : ((lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = lanes));
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (
                  4 === currentFirstChild.tag &&
                  currentFirstChild.stateNode.containerInfo ===
                    newChild.containerInfo &&
                  currentFirstChild.stateNode.implementation ===
                    newChild.implementation
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return (
            (key = newChild._init),
            (newChild = key(newChild._payload)),
            reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
      ? ((newChild = "" + newChild),
        null !== currentFirstChild && 6 === currentFirstChild.tag
          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
            (lanes = useFiber(currentFirstChild, newChild)),
            (lanes.return = returnFiber),
            (returnFiber = lanes))
          : (deleteRemainingChildren(returnFiber, currentFirstChild),
            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
            (lanes.return = returnFiber),
            (returnFiber = lanes)),
        placeSingleChild(returnFiber))
      : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary &&
    (null === current || null !== currentTreeHiddenStackCursor.current
      ? (shellBoundary = handler)
      : null !== current.memoizedState && (shellBoundary = handler));
}
function pushOffscreenSuspenseHandler(fiber) {
  if (22 === fiber.tag) {
    if (
      (push(suspenseStackCursor, suspenseStackCursor.current),
      push(suspenseHandlerStackCursor, fiber),
      null === shellBoundary)
    ) {
      var current = fiber.alternate;
      null !== current &&
        null !== current.memoizedState &&
        (shellBoundary = fiber);
    }
  } else reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (
        null !== state &&
        ((state = state.dehydrated),
        null === state || "$?" === state.data || "$!" === state.data)
      )
        return node;
    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var AbortControllerLocal =
    "undefined" !== typeof AbortController
      ? AbortController
      : function () {
          var listeners = [],
            signal = (this.signal = {
              aborted: !1,
              addEventListener: function (type, listener) {
                listeners.push(listener);
              }
            });
          this.abort = function () {
            signal.aborted = !0;
            listeners.forEach(function (listener) {
              return listener();
            });
          };
        },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount &&
    scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = (currentEntangledListeners = []);
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (
    0 === --currentEntangledPendingCount &&
    null !== currentEntangledListeners
  ) {
    null !== currentEntangledActionThenable &&
      (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(
    function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  "object" === typeof returnValue &&
    null !== returnValue &&
    "function" === typeof returnValue.then &&
    entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish &&
    prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender
    ? cacheResumedFromPreviousRender
    : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool
    ? push(resumedCache, resumedCache.current)
    : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool
    ? null
    : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var renderLanes = 0,
  currentlyRenderingFiber$1 = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H =
    null === current || null === current.memoizedState
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass &&
    (nextRenderLanes = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current ||
    didReceiveUpdate ||
    ((current = current.dependencies),
    null !== current &&
      checkIfContextChanged(current) &&
      (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber$1 = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable =
    "function" === typeof maybeThenable.then
      ? useThenable(maybeThenable)
      : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
    (currentlyRenderingFiber$1.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (
      workInProgress = workInProgress.memoizedState;
      null !== workInProgress;

    ) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook
    ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook);
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber$1.alternate;
    nextCurrentHook =
      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook =
    null === workInProgressHook
      ? currentlyRenderingFiber$1.memoizedState
      : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    (workInProgressHook = nextWorkInProgressHook),
      (currentHook = nextCurrentHook);
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber$1.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook
      ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =
          nextCurrentHook)
      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
  }
  return workInProgressHook;
}
var createFunctionComponentUpdateQueue;
createFunctionComponentUpdateQueue = function () {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
};
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber$1;
  null ===
    (null === workInProgressHook
      ? index.memoizedState
      : workInProgressHook.next) &&
    ((index = index.alternate),
    (ReactSharedInternals.H =
      null === index || null === index.memoizedState
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate));
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber$1.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber$1.alternate;
    null !== current &&
      ((current = current.updateQueue),
      null !== current &&
        ((current = current.memoCache),
        null != current &&
          (memoCache = {
            data: current.data.map(function (array) {
              return array.slice();
            }),
            index: 0
          })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue &&
    ((updateQueue = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber$1.updateQueue = updateQueue));
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (
      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
      current < size;
      current++
    )
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = (baseFirst = null),
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$54 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (
        updateLane !== update.lane
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast &&
            (newBaseQueueLast = newBaseQueueLast.next =
              {
                lane: 0,
                revertLane: 0,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
            updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction$54 = !0);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane &&
            (didReadFromEntangledAsyncAction$54 = !0);
          continue;
        } else
          (updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }),
            null === newBaseQueueLast
              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                (baseFirst = pendingQueue))
              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
            (currentlyRenderingFiber$1.lanes |= revertLane),
            (workInProgressRootSkippedLanes |= revertLane);
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV &&
          reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState
          ? update.eagerState
          : reducer(pendingQueue, updateLane);
      } else
        (revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }),
          null === newBaseQueueLast
            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
              (baseFirst = pendingQueue))
            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
          (currentlyRenderingFiber$1.lanes |= updateLane),
          (workInProgressRootSkippedLanes |= updateLane);
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast
      ? (baseFirst = pendingQueue)
      : (newBaseQueueLast.next = newBaseQueueFirst);
    if (
      !objectIs(pendingQueue, hook.memoizedState) &&
      ((didReceiveUpdate = !0),
      didReadFromEntangledAsyncAction$54 &&
        ((reducer = currentEntangledActionThenable), null !== reducer))
    )
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
    do (newState = reducer(newState, update.action)), (update = update.next);
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber$1,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged &&
    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
    subscribe
  ]);
  if (
    hook.getSnapshot !== getSnapshot ||
    snapshotChanged ||
    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
  ) {
    fiber.flags |= 2048;
    pushEffect(
      9,
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      { destroy: void 0 },
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 ||
      0 !== (renderLanes & 60) ||
      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber$1.updateQueue;
  null === getSnapshot
    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber$1.updateQueue = getSnapshot),
      (getSnapshot.stores = [fiber]))
    : ((renderedSnapshot = getSnapshot.stores),
      null === renderedSnapshot
        ? (getSnapshot.stores = [fiber])
        : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(
  fiber,
  actionQueue,
  setPendingState,
  setState,
  payload
) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T
      ? setPendingState(!0)
      : (actionNode.isTransition = !1);
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState
      ? ((actionNode.next = actionQueue.pending = actionNode),
        runActionStateAction(actionQueue, actionNode))
      : ((actionNode.next = setPendingState.next),
        (actionQueue.pending = setPendingState.next = actionNode));
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish &&
        onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      ReactSharedInternals.T = prevTransition;
    }
  } else
    try {
      (prevTransition = action(prevState, payload)),
        handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$60) {
      onActionError(actionQueue, node, error$60);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue &&
  "object" === typeof returnValue &&
  "function" === typeof returnValue.then
    ? returnValue.then(
        function (nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function (error) {
          return onActionError(actionQueue, node, error);
        }
      )
    : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode &&
    ((nextState = actionNode.next),
    nextState === actionNode
      ? (actionQueue.pending = null)
      : ((nextState = nextState.next),
        (actionNode.next = nextState),
        runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      (actionNode.status = "rejected"),
        (actionNode.reason = error),
        notifyActionListeners(actionNode),
        (actionNode = actionNode.next);
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber$1;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (
                var inRootOrSingleton = rootOrSingletonContext;
                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

              ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 =
                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                  ? JSCompiler_inline_result$jscomp$0
                  : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result =
                "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber$1,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber$1,
    !1,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber$1,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  currentStateHook =
    "object" === typeof currentStateHook &&
    null !== currentStateHook &&
    "function" === typeof currentStateHook.then
      ? useThenable(currentStateHook)
      : currentStateHook;
  var actionQueueHook = updateWorkInProgressHook(),
    actionQueue = actionQueueHook.queue,
    dispatch = actionQueue.dispatch;
  action !== actionQueueHook.memoizedState &&
    ((currentlyRenderingFiber$1.flags |= 2048),
    pushEffect(
      9,
      actionStateActionEffect.bind(null, actionQueue, action),
      { destroy: void 0 },
      null
    ));
  return [currentStateHook, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushEffect(tag, create, inst, deps) {
  tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };
  create = currentlyRenderingFiber$1.updateQueue;
  null === create &&
    ((create = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber$1.updateQueue = create));
  inst = create.lastEffect;
  null === inst
    ? (create.lastEffect = tag.next = tag)
    : ((deps = inst.next),
      (inst.next = tag),
      (tag.next = deps),
      (create.lastEffect = tag));
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    1 | hookFlags,
    create,
    { destroy: void 0 },
    void 0 === deps ? null : deps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook &&
  null !== deps &&
  areHookInputsEqual(deps, currentHook.memoizedState.deps)
    ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))
    : ((currentlyRenderingFiber$1.flags |= fiberFlags),
      (hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps)));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return (
      (create = create()),
      (ref.current = create),
      function () {
        ref.current = null;
      }
    );
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
    return (hook.memoizedState = value);
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return (
      (hook = mountDeferredValueImpl(hook, value, initialValue)),
      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
      hook
    );
  if (0 === (renderLanes & 42))
    return (didReceiveUpdate = !0), (hook.memoizedState = value);
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p =
    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    if (
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
    ) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function () {}, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function noop$2() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action
      ? noop$2
      : function () {
          requestFormReset$1(formFiber);
          return action(formData);
        }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$63 = enqueueUpdate(provider, fiber, lane);
        null !== root$63 &&
          (scheduleUpdateOnFiber(root$63, provider, lane),
          entangleTransitions(root$63, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber)
    ? enqueueRenderPhaseUpdate(queue, action)
    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
      null !== action &&
        (scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (
      0 === fiber.lanes &&
      (null === alternate || 0 === alternate.lanes) &&
      ((alternate = queue.lastRenderedReducer), null !== alternate)
    )
      try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = !0;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return (
            enqueueUpdate$1(fiber, queue, update, 0),
            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
            !1
          );
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return (
        scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane),
        !0
      );
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    (throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    )),
      null !== throwIfDuringRender &&
        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return (
    fiber === currentlyRenderingFiber$1 ||
    (null !== alternate && alternate === currentlyRenderingFiber$1)
  );
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
    !0;
  var pending = queue.pending;
  null === pending
    ? (update.next = update)
    : ((update.next = pending.next), (pending.next = update));
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194176)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError
};
ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
ContextOnlyDispatcher.useFormState = throwInvalidHookError;
ContextOnlyDispatcher.useActionState = throwInvalidHookError;
ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
var HooksDispatcherOnMount = {
  readContext: readContext,
  use: use,
  useCallback: function (callback, deps) {
    mountWorkInProgressHook().memoizedState = [
      callback,
      void 0 === deps ? null : deps
    ];
    return callback;
  },
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: function (ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    mountEffectImpl(
      4194308,
      4,
      imperativeHandleEffect.bind(null, create, ref),
      deps
    );
  },
  useLayoutEffect: function (create, deps) {
    return mountEffectImpl(4194308, 4, create, deps);
  },
  useInsertionEffect: function (create, deps) {
    mountEffectImpl(4, 2, create, deps);
  },
  useMemo: function (nextCreate, deps) {
    var hook = mountWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var nextValue = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    hook.memoizedState = [nextValue, deps];
    return nextValue;
  },
  useReducer: function (reducer, initialArg, init) {
    var hook = mountWorkInProgressHook();
    if (void 0 !== init) {
      var initialState = init(initialArg);
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          init(initialArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
    } else initialState = initialArg;
    hook.memoizedState = hook.baseState = initialState;
    reducer = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: reducer,
      lastRenderedState: initialState
    };
    hook.queue = reducer;
    reducer = reducer.dispatch = dispatchReducerAction.bind(
      null,
      currentlyRenderingFiber$1,
      reducer
    );
    return [hook.memoizedState, reducer];
  },
  useRef: function (initialValue) {
    var hook = mountWorkInProgressHook();
    initialValue = { current: initialValue };
    return (hook.memoizedState = initialValue);
  },
  useState: function (initialState) {
    initialState = mountStateImpl(initialState);
    var queue = initialState.queue,
      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
    queue.dispatch = dispatch;
    return [initialState.memoizedState, dispatch];
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = mountWorkInProgressHook();
    return mountDeferredValueImpl(hook, value, initialValue);
  },
  useTransition: function () {
    var stateHook = mountStateImpl(!1);
    stateHook = startTransition.bind(
      null,
      currentlyRenderingFiber$1,
      stateHook.queue,
      !0,
      !1
    );
    mountWorkInProgressHook().memoizedState = stateHook;
    return [!1, stateHook];
  },
  useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber$1,
      hook = mountWorkInProgressHook();
    if (isHydrating) {
      if (void 0 === getServerSnapshot)
        throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else {
      getServerSnapshot = getSnapshot();
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      0 !== (workInProgressRootRenderLanes & 60) ||
        pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    hook.memoizedState = getServerSnapshot;
    var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
    hook.queue = inst;
    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
      subscribe
    ]);
    fiber.flags |= 2048;
    pushEffect(
      9,
      updateStoreInstance.bind(
        null,
        fiber,
        inst,
        getServerSnapshot,
        getSnapshot
      ),
      { destroy: void 0 },
      null
    );
    return getServerSnapshot;
  },
  useId: function () {
    var hook = mountWorkInProgressHook(),
      identifierPrefix = workInProgressRoot.identifierPrefix;
    if (isHydrating) {
      var JSCompiler_inline_result = treeContextOverflow;
      var idWithLeadingBit = treeContextId;
      JSCompiler_inline_result =
        (
          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
        ).toString(32) + JSCompiler_inline_result;
      identifierPrefix =
        ":" + identifierPrefix + "R" + JSCompiler_inline_result;
      JSCompiler_inline_result = localIdCounter++;
      0 < JSCompiler_inline_result &&
        (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
      identifierPrefix += ":";
    } else
      (JSCompiler_inline_result = globalClientIdCounter++),
        (identifierPrefix =
          ":" +
          identifierPrefix +
          "r" +
          JSCompiler_inline_result.toString(32) +
          ":");
    return (hook.memoizedState = identifierPrefix);
  },
  useCacheRefresh: function () {
    return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
      null,
      currentlyRenderingFiber$1
    ));
  }
};
HooksDispatcherOnMount.useMemoCache = useMemoCache;
HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnMount.useFormState = mountActionState;
HooksDispatcherOnMount.useActionState = mountActionState;
HooksDispatcherOnMount.useOptimistic = function (passthrough) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = hook.baseState = passthrough;
  var queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: null,
    lastRenderedState: null
  };
  hook.queue = queue;
  hook = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber$1,
    !0,
    queue
  );
  queue.dispatch = hook;
  return [passthrough, hook];
};
var HooksDispatcherOnUpdate = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: function () {
    return updateReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return updateDeferredValueImpl(
      hook,
      currentHook.memoizedState,
      value,
      initialValue
    );
  },
  useTransition: function () {
    var booleanOrThenable = updateReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnUpdate.useFormState = updateActionState;
HooksDispatcherOnUpdate.useActionState = updateActionState;
HooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
};
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook
      ? mountDeferredValueImpl(hook, value, initialValue)
      : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
HooksDispatcherOnRerender.useMemoCache = useMemoCache;
HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnRerender.useFormState = rerenderActionState;
HooksDispatcherOnRerender.useActionState = rerenderActionState;
HooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  if (null !== currentHook)
    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
  hook.baseState = passthrough;
  return [passthrough, hook.queue.dispatch];
};
function applyDerivedStateFromProps(
  workInProgress,
  ctor,
  getDerivedStateFromProps,
  nextProps
) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps =
    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
      ? ctor
      : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes &&
    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  isMounted: function (component) {
    return (component = component._reactInternals)
      ? getNearestMountedFiber(component) === component
      : !1;
  },
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback &&
      (scheduleUpdateOnFiber(callback, inst, lane),
      entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate
    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
    : ctor.prototype && ctor.prototype.isPureReactComponent
      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
      : !0;
}
function callComponentWillReceiveProps(
  workInProgress,
  instance,
  newProps,
  nextContext
) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps &&
    instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress &&
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if ((Component = Component.defaultProps)) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$67 in Component)
      void 0 === newProps[propName$67] &&
        (newProps[propName$67] = Component[propName$67]);
  }
  return newProps;
}
var reportGlobalError =
  "function" === typeof reportError
    ? reportError
    : function (error) {
        if (
          "object" === typeof window &&
          "function" === typeof window.ErrorEvent
        ) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message:
              "object" === typeof error &&
              null !== error &&
              "string" === typeof error.message
                ? String(error.message)
                : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if (
          "object" === typeof process &&
          "function" === typeof process.emit
        ) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$68) {
    setTimeout(function () {
      throw e$68;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$69) {
    setTimeout(function () {
      throw e$69;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst &&
    "function" === typeof inst.componentDidCatch &&
    (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError &&
        (null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
}
function throwException(
  root,
  returnFiber,
  sourceFiber,
  value,
  rootRenderLanes
) {
  sourceFiber.flags |= 32768;
  if (
    null !== value &&
    "object" === typeof value &&
    "function" === typeof value.then
  ) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber &&
      propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        !0
      );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 13:
          return (
            null === shellBoundary
              ? renderDidSuspendDelayIfPossible()
              : null === sourceFiber.alternate &&
                0 === workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 3),
            (sourceFiber.flags &= -257),
            (sourceFiber.flags |= 65536),
            (sourceFiber.lanes = rootRenderLanes),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? (sourceFiber.updateQueue = new Set([value]))
                  : returnFiber.add(value),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
        case 22:
          return (
            (sourceFiber.flags |= 65536),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? ((returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: new Set([value])
                    }),
                    (sourceFiber.updateQueue = returnFiber))
                  : ((sourceFiber = returnFiber.retryQueue),
                    null === sourceFiber
                      ? (returnFiber.retryQueue = new Set([value]))
                      : sourceFiber.add(value)),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating)
    return (
      (returnFiber = suspenseHandlerStackCursor.current),
      null !== returnFiber
        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
          (returnFiber.flags |= 65536),
          (returnFiber.lanes = rootRenderLanes),
          value !== HydrationMismatchException &&
            ((root = Error(formatProdErrorMessage(422), { cause: value })),
            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
        : (value !== HydrationMismatchException &&
            ((returnFiber = Error(formatProdErrorMessage(423), {
              cause: value
            })),
            queueHydrationError(
              createCapturedValueAtFiber(returnFiber, sourceFiber)
            )),
          (root = root.current.alternate),
          (root.flags |= 65536),
          (rootRenderLanes &= -rootRenderLanes),
          (root.lanes |= rootRenderLanes),
          (value = createCapturedValueAtFiber(value, sourceFiber)),
          (rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          )),
          enqueueCapturedUpdate(root, rootRenderLanes),
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2)),
      !1
    );
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors
    ? (workInProgressRootConcurrentErrors = [wrapperError])
    : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return (
          (sourceFiber.flags |= 65536),
          (root = rootRenderLanes & -rootRenderLanes),
          (sourceFiber.lanes |= root),
          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
          enqueueCapturedUpdate(sourceFiber, root),
          !1
        );
      case 1:
        if (
          ((returnFiber = sourceFiber.type),
          (wrapperError = sourceFiber.stateNode),
          0 === (sourceFiber.flags & 128) &&
            ("function" === typeof returnFiber.getDerivedStateFromError ||
              (null !== wrapperError &&
                "function" === typeof wrapperError.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
        )
          return (
            (sourceFiber.flags |= 65536),
            (rootRenderLanes &= -rootRenderLanes),
            (sourceFiber.lanes |= rootRenderLanes),
            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
            initializeClassErrorUpdate(
              rootRenderLanes,
              root,
              sourceFiber,
              value
            ),
            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
            !1
          );
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child =
    null === current
      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
      : reconcileChildFibers(
          workInProgress,
          current.child,
          nextChildren,
          renderLanes
        );
}
function updateForwardRef(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(
    current,
    workInProgress,
    Component,
    propsWithoutRef,
    ref,
    renderLanes
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null === current) {
    var type = Component.type;
    if (
      "function" === typeof type &&
      !shouldConstruct(type) &&
      void 0 === type.defaultProps &&
      null === Component.compare
    )
      return (
        (workInProgress.tag = 15),
        (workInProgress.type = type),
        updateSimpleMemoComponent(
          current,
          workInProgress,
          type,
          nextProps,
          renderLanes
        )
      );
    current = createFiberFromTypeAndProps(
      Component.type,
      null,
      nextProps,
      workInProgress,
      workInProgress.mode,
      renderLanes
    );
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return (workInProgress.child = current);
}
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    )
      if (
        ((didReceiveUpdate = !1),
        (workInProgress.pendingProps = nextProps = prevProps),
        checkScheduledUpdateOrContext(current, renderLanes))
      )
        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
      else
        return (
          (workInProgress.lanes = current.lanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
  }
  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    nextChildren = nextProps.children,
    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
    prevState = null !== current ? current.memoizedState : null;
  markRef(current, workInProgress);
  if ("hidden" === nextProps.mode || nextIsDetached) {
    if (0 !== (workInProgress.flags & 128)) {
      nextProps =
        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextChildren = workInProgress.child = current.child;
        for (nextIsDetached = 0; null !== nextChildren; )
          (nextIsDetached =
            nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
            (nextChildren = nextChildren.sibling);
        workInProgress.childLanes = nextIsDetached & ~nextProps;
      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
      return deferHiddenOffscreenComponent(
        current,
        workInProgress,
        nextProps,
        renderLanes
      );
    }
    if (0 !== (renderLanes & 536870912))
      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
        null !== current &&
          pushTransition(
            workInProgress,
            null !== prevState ? prevState.cachePool : null
          ),
        null !== prevState
          ? pushHiddenContext(workInProgress, prevState)
          : reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress);
    else
      return (
        (workInProgress.lanes = workInProgress.childLanes = 536870912),
        deferHiddenOffscreenComponent(
          current,
          workInProgress,
          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
          renderLanes
        )
      );
  } else
    null !== prevState
      ? (pushTransition(workInProgress, prevState.cachePool),
        pushHiddenContext(workInProgress, prevState),
        reuseSuspenseHandlerOnStack(workInProgress),
        (workInProgress.memoizedState = null))
      : (null !== current && pushTransition(workInProgress, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function deferHiddenOffscreenComponent(
  current,
  workInProgress,
  nextBaseLanes,
  renderLanes
) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result =
    null === JSCompiler_inline_result
      ? null
      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current &&
    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  return null;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref)
    null !== current &&
      null !== current.ref &&
      (workInProgress.flags |= 2097664);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress.flags |= 2097664;
  }
}
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    void 0,
    renderLanes
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(
  current,
  workInProgress,
  nextProps,
  Component,
  secondArg,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress,
    Component,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType &&
      null !== contextType &&
      (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState =
      null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context =
      "object" === typeof contextType && null !== contextType
        ? readContext(contextType)
        : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(
        workInProgress,
        Component,
        contextType,
        nextProps
      ),
      (context.state = workInProgress.memoizedState));
    "function" === typeof Component.getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate ||
      ("function" !== typeof context.UNSAFE_componentWillMount &&
        "function" !== typeof context.componentWillMount) ||
      ((contextType = context.state),
      "function" === typeof context.componentWillMount &&
        context.componentWillMount(),
      "function" === typeof context.UNSAFE_componentWillMount &&
        context.UNSAFE_componentWillMount(),
      contextType !== context.state &&
        classComponentUpdater.enqueueReplaceState(context, context.state, null),
      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
      suspendIfUpdateReadFromEntangledAsyncAction(),
      (context.state = workInProgress.memoizedState));
    "function" === typeof context.componentDidMount &&
      (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 &&
      null !== contextType$jscomp$0 &&
      (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 =
      "function" === typeof getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((unresolvedOldProps || oldContext !== contextType) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          contextType
        ));
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
      ? ("function" === typeof getDerivedStateFromProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            getDerivedStateFromProps,
            nextProps
          ),
          (oldContext = workInProgress.memoizedState)),
        (oldProps =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          ))
          ? (contextType$jscomp$0 ||
              ("function" !== typeof context.UNSAFE_componentWillMount &&
                "function" !== typeof context.componentWillMount) ||
              ("function" === typeof context.componentWillMount &&
                context.componentWillMount(),
              "function" === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount()),
            "function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = oldContext)),
        (context.props = nextProps),
        (context.state = oldContext),
        (context.context = contextType),
        (nextProps = oldProps))
      : ("function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308),
        (nextProps = !1));
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext &&
      null !== oldContext &&
      (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext =
      "function" === typeof unresolvedOldProps ||
      "function" === typeof context.getSnapshotBeforeUpdate) ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          oldProps
        ));
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps ||
    oldState !== newState ||
    hasForceUpdate ||
    (null !== current &&
      null !== current.dependencies &&
      checkIfContextChanged(current.dependencies))
      ? ("function" === typeof unresolvedOldProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            unresolvedOldProps,
            nextProps
          ),
          (newState = workInProgress.memoizedState)),
        (contextType$jscomp$0 =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies)))
          ? (oldContext ||
              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                "function" !== typeof context.componentWillUpdate) ||
              ("function" === typeof context.componentWillUpdate &&
                context.componentWillUpdate(nextProps, newState, oldProps),
              "function" === typeof context.UNSAFE_componentWillUpdate &&
                context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )),
            "function" === typeof context.componentDidUpdate &&
              (workInProgress.flags |= 4),
            "function" === typeof context.getSnapshotBeforeUpdate &&
              (workInProgress.flags |= 1024))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = newState)),
        (context.props = nextProps),
        (context.state = newState),
        (context.context = oldProps),
        (nextProps = contextType$jscomp$0))
      : ("function" !== typeof context.componentDidUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 4),
        "function" !== typeof context.getSnapshotBeforeUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 1024),
        (nextProps = !1));
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps
    ? ((context = workInProgress.stateNode),
      (Component =
        nextProps && "function" !== typeof Component.getDerivedStateFromError
          ? null
          : context.render()),
      (workInProgress.flags |= 1),
      null !== current && nextProps
        ? ((workInProgress.child = reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes
          )),
          (workInProgress.child = reconcileChildFibers(
            workInProgress,
            null,
            Component,
            renderLanes
          )))
        : reconcileChildren(current, workInProgress, Component, renderLanes),
      (workInProgress.memoizedState = context.state),
      (current = workInProgress.child))
    : (current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes
      ));
  return current;
}
function mountHostRootWithoutHydrating(
  current,
  workInProgress,
  nextChildren,
  renderLanes
) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
function mountSuspenseOffscreenState(renderLanes) {
  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(
  current,
  primaryTreeDidDefer,
  renderLanes
) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) ||
    (JSCompiler_temp =
      null !== current && null === current.memoizedState
        ? !1
        : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback
        ? pushPrimaryTreeSuspenseHandler(workInProgress)
        : reuseSuspenseHandlerOnStack(workInProgress);
      if (isHydrating) {
        var nextInstance = nextHydratableInstance,
          JSCompiler_temp$jscomp$0;
        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
          c: {
            JSCompiler_temp$jscomp$0 = nextInstance;
            for (
              nextInstance = rootOrSingletonContext;
              8 !== JSCompiler_temp$jscomp$0.nodeType;

            ) {
              if (!nextInstance) {
                nextInstance = null;
                break c;
              }
              JSCompiler_temp$jscomp$0 = getNextHydratable(
                JSCompiler_temp$jscomp$0.nextSibling
              );
              if (null === JSCompiler_temp$jscomp$0) {
                nextInstance = null;
                break c;
              }
            }
            nextInstance = JSCompiler_temp$jscomp$0;
          }
          null !== nextInstance
            ? ((workInProgress.memoizedState = {
                dehydrated: nextInstance,
                treeContext:
                  null !== treeContextProvider
                    ? { id: treeContextId, overflow: treeContextOverflow }
                    : null,
                retryLane: 536870912
              }),
              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
                18,
                null,
                null,
                0
              )),
              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
              (JSCompiler_temp$jscomp$0.return = workInProgress),
              (workInProgress.child = JSCompiler_temp$jscomp$0),
              (hydrationParentFiber = workInProgress),
              (nextHydratableInstance = null),
              (JSCompiler_temp$jscomp$0 = !0))
            : (JSCompiler_temp$jscomp$0 = !1);
        }
        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
      }
      nextInstance = workInProgress.memoizedState;
      if (
        null !== nextInstance &&
        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
      )
        return (
          "$!" === nextInstance.data
            ? (workInProgress.lanes = 16)
            : (workInProgress.lanes = 536870912),
          null
        );
      popSuspenseHandler(workInProgress);
    }
    nextInstance = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return (
        reuseSuspenseHandlerOnStack(workInProgress),
        (showFallback = workInProgress.mode),
        (nextInstance = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextInstance },
          showFallback
        )),
        (nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes,
          null
        )),
        (nextInstance.return = workInProgress),
        (nextProps.return = workInProgress),
        (nextInstance.sibling = nextProps),
        (workInProgress.child = nextInstance),
        (showFallback = workInProgress.child),
        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes
        )),
        (workInProgress.memoizedState = SUSPENDED_MARKER),
        nextProps
      );
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
  }
  JSCompiler_temp$jscomp$0 = current.memoizedState;
  if (
    null !== JSCompiler_temp$jscomp$0 &&
    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
    null !== nextInstance)
  ) {
    if (didSuspend)
      workInProgress.flags & 256
        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
          (workInProgress.flags &= -257),
          (workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          )))
        : null !== workInProgress.memoizedState
          ? (reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.child = current.child),
            (workInProgress.flags |= 128),
            (workInProgress = null))
          : (reuseSuspenseHandlerOnStack(workInProgress),
            (showFallback = nextProps.fallback),
            (nextInstance = workInProgress.mode),
            (nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            )),
            (showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes,
              null
            )),
            (showFallback.flags |= 2),
            (nextProps.return = workInProgress),
            (showFallback.return = workInProgress),
            (nextProps.sibling = showFallback),
            (workInProgress.child = nextProps),
            reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            ),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            (workInProgress = showFallback));
    else if (
      (pushPrimaryTreeSuspenseHandler(workInProgress),
      "$!" === nextInstance.data)
    ) {
      JSCompiler_temp =
        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || JSCompiler_temp)
    ) {
      JSCompiler_temp = workInProgressRoot;
      if (null !== JSCompiler_temp) {
        nextProps = renderLanes & -renderLanes;
        if (0 !== (nextProps & 42)) nextProps = 1;
        else
          switch (nextProps) {
            case 2:
              nextProps = 1;
              break;
            case 8:
              nextProps = 4;
              break;
            case 32:
              nextProps = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              nextProps = 64;
              break;
            case 268435456:
              nextProps = 134217728;
              break;
            default:
              nextProps = 0;
          }
        nextProps =
          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
            ? 0
            : nextProps;
        if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
          throw (
            ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
            enqueueConcurrentRenderForLane(current, nextProps),
            scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
            SelectiveHydrationException)
          );
      }
      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      "$?" === nextInstance.data
        ? ((workInProgress.flags |= 128),
          (workInProgress.child = current.child),
          (workInProgress = retryDehydratedSuspenseBoundary.bind(
            null,
            current
          )),
          (nextInstance._reactRetry = workInProgress),
          (workInProgress = null))
        : ((current = JSCompiler_temp$jscomp$0.treeContext),
          (nextHydratableInstance = getNextHydratable(
            nextInstance.nextSibling
          )),
          (hydrationParentFiber = workInProgress),
          (isHydrating = !0),
          (hydrationErrors = null),
          (rootOrSingletonContext = !1),
          null !== current &&
            ((idStack[idStackIndex++] = treeContextId),
            (idStack[idStackIndex++] = treeContextOverflow),
            (idStack[idStackIndex++] = treeContextProvider),
            (treeContextId = current.id),
            (treeContextOverflow = current.overflow),
            (treeContextProvider = workInProgress)),
          (workInProgress = mountSuspensePrimaryChildren(
            workInProgress,
            nextProps.children
          )),
          (workInProgress.flags |= 4096));
    return workInProgress;
  }
  if (showFallback)
    return (
      reuseSuspenseHandlerOnStack(workInProgress),
      (showFallback = nextProps.fallback),
      (nextInstance = workInProgress.mode),
      (JSCompiler_temp$jscomp$0 = current.child),
      (digest = JSCompiler_temp$jscomp$0.sibling),
      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
        mode: "hidden",
        children: nextProps.children
      })),
      (nextProps.subtreeFlags =
        JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),
      null !== digest
        ? (showFallback = createWorkInProgress(digest, showFallback))
        : ((showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes,
            null
          )),
          (showFallback.flags |= 2)),
      (showFallback.return = workInProgress),
      (nextProps.return = workInProgress),
      (nextProps.sibling = showFallback),
      (workInProgress.child = nextProps),
      (nextProps = showFallback),
      (showFallback = workInProgress.child),
      (nextInstance = current.child.memoizedState),
      null === nextInstance
        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
          null !== JSCompiler_temp$jscomp$0
            ? ((digest = CacheContext._currentValue),
              (JSCompiler_temp$jscomp$0 =
                JSCompiler_temp$jscomp$0.parent !== digest
                  ? { parent: digest, pool: digest }
                  : JSCompiler_temp$jscomp$0))
            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
          (nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes,
            cachePool: JSCompiler_temp$jscomp$0
          })),
      (showFallback.memoizedState = nextInstance),
      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes
      )),
      (workInProgress.memoizedState = SUSPENDED_MARKER),
      nextProps
    );
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current &&
    ((JSCompiler_temp = workInProgress.deletions),
    null === JSCompiler_temp
      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
      : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress.mode
  );
  primaryChildren.return = workInProgress;
  return (workInProgress.child = primaryChildren);
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  return createFiberFromOffscreen(offscreenProps, mode, 0, null);
}
function retrySuspenseComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(
    workInProgress,
    workInProgress.pendingProps.children
  );
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(
  workInProgress,
  isBackwards,
  tail,
  lastContentRow,
  tailMode
) {
  var renderState = workInProgress.memoizedState;
  null === renderState
    ? (workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode
      })
    : ((renderState.isBackwards = isBackwards),
      (renderState.rendering = null),
      (renderState.renderingStartTime = 0),
      (renderState.last = lastContentRow),
      (renderState.tail = tail),
      (renderState.tailMode = tailMode));
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
  nextProps = suspenseStackCursor.current;
  if (0 !== (nextProps & 2))
    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
  else {
    if (null !== current && 0 !== (current.flags & 128))
      a: for (current = workInProgress.child; null !== current; ) {
        if (13 === current.tag)
          null !== current.memoizedState &&
            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
        else if (19 === current.tag)
          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
        else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;
        for (; null === current.sibling; ) {
          if (null === current.return || current.return === workInProgress)
            break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
    nextProps &= 1;
  }
  push(suspenseStackCursor, nextProps);
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes; )
        (current = renderLanes.alternate),
          null !== current &&
            null === findFirstSuspended(current) &&
            (revealOrder = renderLanes),
          (renderLanes = renderLanes.sibling);
      renderLanes = revealOrder;
      null === renderLanes
        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
      initSuspenseListRenderState(
        workInProgress,
        !1,
        revealOrder,
        renderLanes,
        tailMode
      );
      break;
    case "backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress,
        !0,
        renderLanes,
        null,
        tailMode
      );
      break;
    case "together":
      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes))
    if (null !== current) {
      if (
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        0 === (renderLanes & workInProgress.childLanes))
      )
        return null;
    } else return null;
  if (null !== current && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling; )
      (current = current.sibling),
        (renderLanes = renderLanes.sibling =
          createWorkInProgress(current, current.pendingProps)),
        (renderLanes.return = workInProgress);
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(
  current,
  workInProgress,
  renderLanes
) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress,
        workInProgress.type,
        workInProgress.memoizedProps.value
      );
      break;
    case 13:
      var state = workInProgress.memoizedState;
      if (null !== state) {
        if (null !== state.dehydrated)
          return (
            pushPrimaryTreeSuspenseHandler(workInProgress),
            (workInProgress.flags |= 128),
            null
          );
        if (0 !== (renderLanes & workInProgress.child.childLanes))
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state = 0 !== (renderLanes & workInProgress.childLanes);
      state ||
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        (state = 0 !== (renderLanes & workInProgress.childLanes)));
      if (didSuspendBefore) {
        if (state)
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore &&
        ((didSuspendBefore.rendering = null),
        (didSuspendBefore.tail = null),
        (didSuspendBefore.lastEffect = null));
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state) break;
      else return null;
    case 22:
    case 23:
      return (
        (workInProgress.lanes = 0),
        updateOffscreenComponent(current, workInProgress, renderLanes)
      );
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = !0;
    else {
      if (
        !checkScheduledUpdateOrContext(current, renderLanes) &&
        0 === (workInProgress.flags & 128)
      )
        return (
          (didReceiveUpdate = !1),
          attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress,
            renderLanes
          )
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  else
    (didReceiveUpdate = !1),
      isHydrating &&
        0 !== (workInProgress.flags & 1048576) &&
        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        current = workInProgress.pendingProps;
        var lazyComponent = workInProgress.elementType,
          init = lazyComponent._init;
        lazyComponent = init(lazyComponent._payload);
        workInProgress.type = lazyComponent;
        if ("function" === typeof lazyComponent)
          shouldConstruct(lazyComponent)
            ? ((current = resolveClassComponentProps(lazyComponent, current)),
              (workInProgress.tag = 1),
              (workInProgress = updateClassComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              )))
            : ((workInProgress.tag = 0),
              (workInProgress = updateFunctionComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              )));
        else {
          if (void 0 !== lazyComponent && null !== lazyComponent)
            if (
              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
            ) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              );
              break a;
            } else if (init === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              );
              break a;
            }
          workInProgress =
            getComponentNameFromType(lazyComponent) || lazyComponent;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 1:
      return (
        (lazyComponent = workInProgress.type),
        (init = resolveClassComponentProps(
          lazyComponent,
          workInProgress.pendingProps
        )),
        updateClassComponent(
          current,
          workInProgress,
          lazyComponent,
          init,
          renderLanes
        )
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        var nextProps = workInProgress.pendingProps;
        init = workInProgress.memoizedState;
        lazyComponent = init.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextProps, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        nextProps = nextState.cache;
        pushProvider(workInProgress, CacheContext, nextProps);
        nextProps !== init.cache &&
          propagateContextChanges(
            workInProgress,
            [CacheContext],
            renderLanes,
            !0
          );
        suspendIfUpdateReadFromEntangledAsyncAction();
        nextProps = nextState.element;
        if (init.isDehydrated)
          if (
            ((init = {
              element: nextProps,
              isDehydrated: !1,
              cache: nextState.cache
            }),
            (workInProgress.updateQueue.baseState = init),
            (workInProgress.memoizedState = init),
            workInProgress.flags & 256)
          ) {
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              nextProps,
              renderLanes
            );
            break a;
          } else if (nextProps !== lazyComponent) {
            lazyComponent = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress
            );
            queueHydrationError(lazyComponent);
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              nextProps,
              renderLanes
            );
            break a;
          } else
            for (
              nextHydratableInstance = getNextHydratable(
                workInProgress.stateNode.containerInfo.firstChild
              ),
                hydrationParentFiber = workInProgress,
                isHydrating = !0,
                hydrationErrors = null,
                rootOrSingletonContext = !0,
                renderLanes = mountChildFibers(
                  workInProgress,
                  null,
                  nextProps,
                  renderLanes
                ),
                workInProgress.child = renderLanes;
              renderLanes;

            )
              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                (renderLanes = renderLanes.sibling);
        else {
          resetHydrationState();
          if (nextProps === lazyComponent) {
            workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            break a;
          }
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return (
        markRef(current, workInProgress),
        null === current
          ? (renderLanes = getResource(
              workInProgress.type,
              null,
              workInProgress.pendingProps,
              null
            ))
            ? (workInProgress.memoizedState = renderLanes)
            : isHydrating ||
              ((renderLanes = workInProgress.type),
              (current = workInProgress.pendingProps),
              (lazyComponent = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              ).createElement(renderLanes)),
              (lazyComponent[internalInstanceKey] = workInProgress),
              (lazyComponent[internalPropsKey] = current),
              setInitialProperties(lazyComponent, renderLanes, current),
              markNodeAsHoistable(lazyComponent),
              (workInProgress.stateNode = lazyComponent))
          : (workInProgress.memoizedState = getResource(
              workInProgress.type,
              current.memoizedProps,
              workInProgress.pendingProps,
              current.memoizedState
            )),
        null
      );
    case 27:
      return (
        pushHostContext(workInProgress),
        null === current &&
          isHydrating &&
          ((lazyComponent = workInProgress.stateNode =
            resolveSingletonInstance(
              workInProgress.type,
              workInProgress.pendingProps,
              rootInstanceStackCursor.current
            )),
          (hydrationParentFiber = workInProgress),
          (rootOrSingletonContext = !0),
          (nextHydratableInstance = getNextHydratable(
            lazyComponent.firstChild
          ))),
        (lazyComponent = workInProgress.pendingProps.children),
        null !== current || isHydrating
          ? reconcileChildren(
              current,
              workInProgress,
              lazyComponent,
              renderLanes
            )
          : (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              lazyComponent,
              renderLanes
            )),
        markRef(current, workInProgress),
        workInProgress.child
      );
    case 5:
      if (null === current && isHydrating) {
        if ((init = lazyComponent = nextHydratableInstance))
          (lazyComponent = canHydrateInstance(
            lazyComponent,
            workInProgress.type,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== lazyComponent
              ? ((workInProgress.stateNode = lazyComponent),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                )),
                (rootOrSingletonContext = !1),
                (init = !0))
              : (init = !1);
        init || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      init = workInProgress.type;
      nextProps = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      lazyComponent = nextProps.children;
      shouldSetTextContent(init, nextProps)
        ? (lazyComponent = null)
        : null !== nextState &&
          shouldSetTextContent(init, nextState) &&
          (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState &&
        ((init = renderWithHooks(
          current,
          workInProgress,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes
        )),
        (HostTransitionContext._currentValue = init));
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if ((current = renderLanes = nextHydratableInstance))
          (renderLanes = canHydrateTextInstance(
            renderLanes,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== renderLanes
              ? ((workInProgress.stateNode = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null),
                (current = !0))
              : (current = !1);
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return (
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        ),
        (lazyComponent = workInProgress.pendingProps),
        null === current
          ? (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              lazyComponent,
              renderLanes
            ))
          : reconcileChildren(
              current,
              workInProgress,
              lazyComponent,
              renderLanes
            ),
        workInProgress.child
      );
    case 11:
      return updateForwardRef(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 7:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps,
          renderLanes
        ),
        workInProgress.child
      );
    case 8:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 12:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 10:
      return (
        (lazyComponent = workInProgress.pendingProps),
        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
        reconcileChildren(
          current,
          workInProgress,
          lazyComponent.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 9:
      return (
        (init = workInProgress.type._context),
        (lazyComponent = workInProgress.pendingProps.children),
        prepareToReadContext(workInProgress),
        (init = readContext(init)),
        (lazyComponent = lazyComponent(init)),
        (workInProgress.flags |= 1),
        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
        workInProgress.child
      );
    case 14:
      return updateMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    case 24:
      return (
        prepareToReadContext(workInProgress),
        (lazyComponent = readContext(CacheContext)),
        null === current
          ? ((init = peekCacheFromPool()),
            null === init &&
              ((init = workInProgressRoot),
              (nextProps = createCache()),
              (init.pooledCache = nextProps),
              nextProps.refCount++,
              null !== nextProps && (init.pooledCacheLanes |= renderLanes),
              (init = nextProps)),
            (workInProgress.memoizedState = {
              parent: lazyComponent,
              cache: init
            }),
            initializeUpdateQueue(workInProgress),
            pushProvider(workInProgress, CacheContext, init))
          : (0 !== (current.lanes & renderLanes) &&
              (cloneUpdateQueue(current, workInProgress),
              processUpdateQueue(workInProgress, null, null, renderLanes),
              suspendIfUpdateReadFromEntangledAsyncAction()),
            (init = current.memoizedState),
            (nextProps = workInProgress.memoizedState),
            init.parent !== lazyComponent
              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
                (workInProgress.memoizedState = init),
                0 === workInProgress.lanes &&
                  (workInProgress.memoizedState =
                    workInProgress.updateQueue.baseState =
                      init),
                pushProvider(workInProgress, CacheContext, lazyComponent))
              : ((lazyComponent = nextProps.cache),
                pushProvider(workInProgress, CacheContext, lazyComponent),
                lazyComponent !== init.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0
                  ))),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes
      ? ((parent.childLanes |= renderLanes),
        null !== alternate && (alternate.childLanes |= renderLanes))
      : null !== alternate &&
        (alternate.childLanes & renderLanes) !== renderLanes &&
        (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(
  workInProgress,
  contexts,
  renderLanes,
  forcePropagateEntireTree
) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber; ) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list; ) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(
              list.return,
              renderLanes,
              workInProgress
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(
  current,
  workInProgress,
  renderLanes,
  forcePropagateEntireTree
) {
  current = null;
  for (
    var parent = workInProgress, isInsidePropagationBailout = !1;
    null !== parent;

  ) {
    if (!isInsidePropagationBailout)
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
      else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) ||
          (null !== current ? current.push(context) : (current = [context]));
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !==
        parent.memoizedState.memoizedState &&
        (null !== current
          ? current.push(HostTransitionContext)
          : (current = [HostTransitionContext]));
    }
    parent = parent.return;
  }
  null !== current &&
    propagateContextChanges(
      workInProgress,
      current,
      renderLanes,
      forcePropagateEntireTree
    );
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (
    currentDependencies = currentDependencies.firstContext;
    null !== currentDependencies;

  ) {
    if (
      !objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      )
    )
      return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context: context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current &&
    (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
}
function createUpdate(lane) {
  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending
      ? (update.next = update)
      : ((update.next = pending.next), (pending.next = update));
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (
    null !== current &&
    ((current = current.updateQueue), queue === current)
  ) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast
          ? (newFirst = newLast = clone)
          : (newLast = newLast.next = clone);
        queue = queue.next;
      } while (null !== queue);
      null === newLast
        ? (newFirst = newLast = capturedUpdate)
        : (newLast = newLast.next = capturedUpdate);
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress
    ? (queue.firstBaseUpdate = capturedUpdate)
    : (workInProgress.next = capturedUpdate);
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(
  workInProgress$jscomp$0,
  props,
  instance$jscomp$0,
  renderLanes
) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate
      ? (firstBaseUpdate = firstPendingUpdate)
      : (lastBaseUpdate.next = firstPendingUpdate);
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current &&
      ((current = current.updateQueue),
      (pendingQueue = current.lastBaseUpdate),
      pendingQueue !== lastBaseUpdate &&
        (null === pendingQueue
          ? (current.firstBaseUpdate = firstPendingUpdate)
          : (pendingQueue.next = firstPendingUpdate),
        (current.lastBaseUpdate = lastPendingUpdate)));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (
        isHiddenUpdate
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        0 !== updateLane &&
          updateLane === currentEntangledLane &&
          (didReadFromEntangledAsyncAction = !0);
        null !== current &&
          (current = current.next =
            {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = (workInProgress.flags & -65537) | 128;
            case 0:
              workInProgress = update.payload;
              updateLane =
                "function" === typeof workInProgress
                  ? workInProgress.call(instance, newState, updateLane)
                  : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane &&
          ((workInProgress$jscomp$0.flags |= 64),
          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
          (isHiddenUpdate = queue.callbacks),
          null === isHiddenUpdate
            ? (queue.callbacks = [updateLane])
            : isHiddenUpdate.push(updateLane));
      } else
        (isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }),
          null === current
            ? ((firstPendingUpdate = current = isHiddenUpdate),
              (lastPendingUpdate = newState))
            : (current = current.next = isHiddenUpdate),
          (lastBaseUpdate |= updateLane);
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
          break;
        else
          (isHiddenUpdate = pendingQueue),
            (pendingQueue = isHiddenUpdate.next),
            (isHiddenUpdate.next = null),
            (queue.lastBaseUpdate = isHiddenUpdate),
            (queue.shared.pending = null);
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (
      updateQueue.callbacks = null, updateQueue = 0;
      updateQueue < callbacks.length;
      updateQueue++
    )
      callCallback(callbacks[updateQueue], context);
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(
  flags,
  finishedWork,
  nearestMountedAncestor$jscomp$0
) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(
  current,
  nearestMountedAncestor,
  instance
) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      var instance = current.stateNode;
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = instance;
          break;
        default:
          instanceToUse = instance;
      }
      "function" === typeof ref
        ? (current.refCleanup = ref(instanceToUse))
        : (ref.current = instanceToUse);
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        (current.refCleanup = null),
          (current = current.alternate),
          null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$112) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$112);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src
          ? (instance.src = props.src)
          : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return (
    5 === fiber.tag ||
    3 === fiber.tag ||
    26 === fiber.tag ||
    27 === fiber.tag ||
    4 === fiber.tag
  );
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (
      fiber = fiber.sibling;
      5 !== fiber.tag &&
      6 !== fiber.tag &&
      27 !== fiber.tag &&
      18 !== fiber.tag;

    ) {
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else (fiber.child.return = fiber), (fiber = fiber.child);
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before
        ? 8 === parent.nodeType
          ? parent.parentNode.insertBefore(node, before)
          : parent.insertBefore(node, before)
        : (8 === parent.nodeType
            ? ((before = parent.parentNode), before.insertBefore(node, parent))
            : ((before = parent), before.appendChild(node)),
          (parent = parent._reactRootContainer),
          (null !== parent && void 0 !== parent) ||
            null !== before.onclick ||
            (before.onclick = noop$1));
  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
    for (
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        (node = node.sibling);
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
    for (
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null,
  shouldFireAfterActiveInstanceBlur = !1;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root)
      var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };
    else
      a: {
        JSCompiler_temp =
          ((JSCompiler_temp = root.ownerDocument) &&
            JSCompiler_temp.defaultView) ||
          window;
        var selection =
          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next; ; ) {
              node !== JSCompiler_temp ||
                (0 !== anchorOffset && 3 !== node.nodeType) ||
                (start = length + anchorOffset);
              node !== focusNode ||
                (0 !== selection && 3 !== node.nodeType) ||
                (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp &&
                ++indexWithinAnchor === anchorOffset &&
                (start = length);
              parentNode === focusNode &&
                ++indexWithinFocus === selection &&
                (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp =
            -1 === start || -1 === end ? null : { start: start, end: end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (
      ((firstChild = nextEffect),
      (root = firstChild.child),
      0 !== (firstChild.subtreeFlags & 1028) && null !== root)
    )
      (root.return = firstChild), (nextEffect = root);
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root & 1024) && null !== focusNode) {
              root = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset,
                  JSCompiler_temp.elementType === JSCompiler_temp.type
                );
                root = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root & 1024))
              if (
                ((root = firstChild.stateNode.containerInfo),
                (JSCompiler_temp = root.nodeType),
                9 === JSCompiler_temp)
              )
                clearContainerSparingly(root);
              else if (1 === JSCompiler_temp)
                switch (root.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root);
                    break;
                  default:
                    root.textContent = "";
                }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
  resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
  shouldFireAfterActiveInstanceBlur = !1;
  return resolvedPrevProps;
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (((finishedRoot = finishedWork.stateNode), null === current))
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$111) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$111
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
        finishedRoot = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              finishedRoot = finishedWork.child.stateNode;
              break;
            case 1:
              finishedRoot = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(flags, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 26:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 27:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 22:
      prevProps =
        null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!prevProps) {
        current =
          (null !== current && null !== current.memoizedState) ||
          offscreenSubtreeWasHidden;
        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevProps;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
          ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            )
          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      flags & 512 &&
        ("manual" === finishedWork.memoizedProps.mode
          ? safelyAttachRef(finishedWork, finishedWork.return)
          : safelyDetachRef(finishedWork, finishedWork.return));
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate &&
    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag &&
    ((alternate = fiber.stateNode),
    null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(
  finishedRoot,
  nearestMountedAncestor,
  parent
) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
      (parent = parent.sibling);
}
function commitDeletionEffectsOnFiber(
  finishedRoot,
  nearestMountedAncestor,
  deletedFiber
) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState
        ? deletedFiber.memoizedState.count--
        : deletedFiber.stateNode &&
          ((deletedFiber = deletedFiber.stateNode),
          deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber = deletedFiber.stateNode;
      for (
        nearestMountedAncestor = deletedFiber.attributes;
        nearestMountedAncestor.length;

      )
        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
      detachDeletedInstance(deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParentIsContainer = hostParent;
      var prevHostParentIsContainer$119 = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParentIsContainer;
      hostParentIsContainer = prevHostParentIsContainer$119;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (finishedRoot = hostParent),
              (prevHostParent = deletedFiber.stateNode),
              8 === finishedRoot.nodeType
                ? finishedRoot.parentNode.removeChild(prevHostParent)
                : finishedRoot.removeChild(prevHostParent);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent &&
        (hostParentIsContainer
          ? ((nearestMountedAncestor = hostParent),
            (deletedFiber = deletedFiber.stateNode),
            8 === nearestMountedAncestor.nodeType
              ? clearSuspenseBoundary(
                  nearestMountedAncestor.parentNode,
                  deletedFiber
                )
              : 1 === nearestMountedAncestor.nodeType &&
                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),
            retryIfBlockedOn(nearestMountedAncestor))
          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden ||
        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
        (prevHostParent = deletedFiber.stateNode),
        "function" === typeof prevHostParent.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden =
        (prevHostParent = offscreenSubtreeWasHidden) ||
        null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState),
      null !== finishedRoot &&
        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
  )
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return (
        (finishedWork = finishedWork.stateNode),
        (retryCache = finishedWork._retryCache),
        null === retryCache &&
          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
        retryCache
      );
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    retryCache.has(wakeable) ||
      (retryCache.add(wakeable), wakeable.then(retry, retry));
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = !1;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13878)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
        (parentFiber = parentFiber.sibling);
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
        commitHookEffectListMount(3, finishedWork),
        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      flags & 64 &&
        offscreenSubtreeIsHidden &&
        ((finishedWork = finishedWork.updateQueue),
        null !== finishedWork &&
          ((flags = finishedWork.callbacks),
          null !== flags &&
            ((current = finishedWork.shared.hiddenCallbacks),
            (finishedWork.shared.hiddenCallbacks =
              null === current ? flags : current.concat(flags)))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource =
                      hoistableRoot.getElementsByTagName("title")[0];
                    if (
                      !currentResource ||
                      currentResource[internalHoistableMarker] ||
                      currentResource[internalInstanceKey] ||
                      "http://www.w3.org/2000/svg" ===
                        currentResource.namespaceURI ||
                      currentResource.hasAttribute("itemprop")
                    )
                      (currentResource = hoistableRoot.createElement(flags)),
                        hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes)
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("href") ===
                            (null == current.href ? null : current.href) &&
                            currentResource.getAttribute("rel") ===
                              (null == current.rel ? null : current.rel) &&
                            currentResource.getAttribute("title") ===
                              (null == current.title ? null : current.title) &&
                            currentResource.getAttribute("crossorigin") ===
                              (null == current.crossOrigin
                                ? null
                                : current.crossOrigin))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (
                      (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || "")))
                    )
                      for (i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("content") ===
                            (null == current.content
                              ? null
                              : "" + current.content) &&
                            currentResource.getAttribute("name") ===
                              (null == current.name ? null : current.name) &&
                            currentResource.getAttribute("property") ===
                              (null == current.property
                                ? null
                                : current.property) &&
                            currentResource.getAttribute("http-equiv") ===
                              (null == current.httpEquiv
                                ? null
                                : current.httpEquiv) &&
                            currentResource.getAttribute("charset") ===
                              (null == current.charSet
                                ? null
                                : current.charSet))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags
            ? (null === currentResource
                ? null !== current.stateNode &&
                  ((current = current.stateNode),
                  current.parentNode.removeChild(current))
                : currentResource.count--,
              null === flags
                ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  )
                : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  ))
            : null === flags &&
              null !== finishedWork.stateNode &&
              commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
      }
      break;
    case 27:
      if (flags & 4 && null === finishedWork.alternate) {
        hoistableRoot = finishedWork.stateNode;
        currentResource = finishedWork.memoizedProps;
        try {
          for (var node = hoistableRoot.firstChild; node; ) {
            var nextNode = node.nextSibling,
              nodeName = node.nodeName;
            node[internalHoistableMarker] ||
              "HEAD" === nodeName ||
              "BODY" === nodeName ||
              "SCRIPT" === nodeName ||
              "STYLE" === nodeName ||
              ("LINK" === nodeName &&
                "stylesheet" === node.rel.toLowerCase()) ||
              hoistableRoot.removeChild(node);
            node = nextNode;
          }
          for (
            var type = finishedWork.type, attributes = hoistableRoot.attributes;
            attributes.length;

          )
            hoistableRoot.removeAttributeNode(attributes[0]);
          setInitialProperties(hoistableRoot, type, currentResource);
          hoistableRoot[internalInstanceKey] = finishedWork;
          hoistableRoot[internalPropsKey] = currentResource;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 &&
        null != finishedWork.stateNode &&
        ((hoistableRoot = finishedWork.memoizedProps),
        commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset &&
        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 &&
        (null !== finishedWork.memoizedState) !==
          (null !== current && null !== current.memoizedState) &&
        (globalMostRecentFallbackTime = now());
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      node = null !== finishedWork.memoizedState;
      nextNode = null !== current && null !== current.memoizedState;
      nodeName = offscreenSubtreeIsHidden;
      type = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = nodeName || node;
      offscreenSubtreeWasHidden = type || nextNode;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = type;
      offscreenSubtreeIsHidden = nodeName;
      commitReconciliationEffects(finishedWork);
      root = finishedWork.stateNode;
      root._current = finishedWork;
      root._visibility &= -3;
      root._visibility |= root._pendingVisibility & 2;
      if (
        flags & 8192 &&
        ((root._visibility = node
          ? root._visibility & -2
          : root._visibility | 1),
        node &&
          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
          null === current ||
            nextNode ||
            root ||
            recursivelyTraverseDisappearLayoutEffects(finishedWork)),
        null === finishedWork.memoizedProps ||
          "manual" !== finishedWork.memoizedProps.mode)
      )
        a: for (current = null, root = finishedWork; ; ) {
          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
            if (null === current) {
              nextNode = current = root;
              try {
                if (((hoistableRoot = nextNode.stateNode), node))
                  (currentResource = hoistableRoot.style),
                    "function" === typeof currentResource.setProperty
                      ? currentResource.setProperty(
                          "display",
                          "none",
                          "important"
                        )
                      : (currentResource.display = "none");
                else {
                  maybeNodes = nextNode.stateNode;
                  i = nextNode.memoizedProps.style;
                  var display =
                    void 0 !== i && null !== i && i.hasOwnProperty("display")
                      ? i.display
                      : null;
                  maybeNodes.style.display =
                    null == display || "boolean" === typeof display
                      ? ""
                      : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              nextNode = root;
              try {
                nextNode.stateNode.nodeValue = node
                  ? ""
                  : nextNode.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if (
            ((22 !== root.tag && 23 !== root.tag) ||
              null === root.memoizedState ||
              root === finishedWork) &&
            null !== root.child
          ) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling; ) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((current = flags.retryQueue),
          null !== current &&
            ((flags.retryQueue = null),
            attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork),
        commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      if (27 !== finishedWork.tag) {
        a: {
          for (var parent = finishedWork.return; null !== parent; ) {
            if (isHostParent(parent)) {
              var JSCompiler_inline_result = parent;
              break a;
            }
            parent = parent.return;
          }
          throw Error(formatProdErrorMessage(160));
        }
        switch (JSCompiler_inline_result.tag) {
          case 27:
            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
              before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
            break;
          case 5:
            var parent$113 = JSCompiler_inline_result.stateNode;
            JSCompiler_inline_result.flags & 32 &&
              (setTextContent(parent$113, ""),
              (JSCompiler_inline_result.flags &= -33));
            var before$114 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
            break;
          case 3:
          case 4:
            var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,
              before$116 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              before$116,
              parent$115
            );
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
        (parentFiber = parentFiber.sibling);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 26:
      case 27:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        safelyDetachRef(finishedWork, finishedWork.return);
        null === finishedWork.memoizedState &&
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (
                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                finishedRoot < hiddenCallbacks.length;
                finishedRoot++
              )
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects &&
          flags & 64 &&
          commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 26:
      case 27:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          null === current &&
          flags & 4 &&
          commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current &&
    null !== current.memoizedState &&
    null !== current.memoizedState.cachePool &&
    (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState &&
    null !== finishedWork.memoizedState.cachePool &&
    (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache &&
    (null != current && current.refCount++,
    null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate &&
    (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current &&
    (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(
  root,
  parentFiber,
  committedLanes,
  committedTransitions
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveMountOnFiber(
  finishedRoot,
  finishedWork,
  committedLanes,
  committedTransitions
) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        ((finishedRoot = null),
        null !== finishedWork.alternate &&
          (finishedRoot = finishedWork.alternate.memoizedState.cache),
        (finishedWork = finishedWork.memoizedState.cache),
        finishedWork !== finishedRoot &&
          (finishedWork.refCount++,
          null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit &&
            onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      null !== finishedWork.memoizedState
        ? _finishedWork$memoize2._visibility & 4
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
        : _finishedWork$memoize2._visibility & 4
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : ((_finishedWork$memoize2._visibility |= 4),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
      flags & 2048 &&
        commitOffscreenPassiveMountEffects(
          finishedWork.alternate,
          finishedWork
        );
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  committedLanes$jscomp$0,
  committedTransitions$jscomp$0,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState
          ? instance._visibility & 4
            ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              )
            : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              )
          : ((instance._visibility |= 4),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(parentFiber) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function accumulateSuspenseyCommitOnFiber(fiber) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(fiber);
      fiber.flags & suspenseyCommitFlag &&
        null !== fiber.memoizedState &&
        suspendResource(
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(fiber);
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(fiber);
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState &&
        ((previousHoistableRoot = fiber.alternate),
        null !== previousHoistableRoot &&
        null !== previousHoistableRoot.memoizedState
          ? ((previousHoistableRoot = suspenseyCommitFlag),
            (suspenseyCommitFlag = 16777216),
            recursivelyAccumulateSuspenseyCommit(fiber),
            (suspenseyCommitFlag = previousHoistableRoot))
          : recursivelyAccumulateSuspenseyCommit(fiber));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(fiber);
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (
    null !== previousFiber &&
    ((parentFiber = previousFiber.child), null !== parentFiber)
  ) {
    previousFiber.child = null;
    do
      (previousFiber = parentFiber.sibling),
        (parentFiber.sibling = null),
        (parentFiber = previousFiber);
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 &&
        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState &&
      instance._visibility & 4 &&
      (null === finishedWork.return || 13 !== finishedWork.return.tag)
        ? ((instance._visibility &= -5),
          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
        : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 4 &&
          ((i._visibility &= -5),
          recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
  deletedSubtreeRoot,
  nearestMountedAncestor
) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (
          null !== fiber.memoizedState &&
          null !== fiber.memoizedState.cachePool
        ) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling =
    this.child =
    this.return =
    this.stateNode =
    this.type =
    this.elementType =
      null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies =
    this.memoizedState =
    this.updateQueue =
    this.memoizedProps =
      null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress
    ? ((workInProgress = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      )),
      (workInProgress.elementType = current.elementType),
      (workInProgress.type = current.type),
      (workInProgress.stateNode = current.stateNode),
      (workInProgress.alternate = current),
      (current.alternate = workInProgress))
    : ((workInProgress.pendingProps = pendingProps),
      (workInProgress.type = current.type),
      (workInProgress.flags = 0),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null));
  workInProgress.flags = current.flags & 31457280;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies =
    null === pendingProps
      ? null
      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 31457282;
  var current = workInProgress.alternate;
  null === current
    ? ((workInProgress.childLanes = 0),
      (workInProgress.lanes = renderLanes),
      (workInProgress.child = null),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.memoizedProps = null),
      (workInProgress.memoizedState = null),
      (workInProgress.updateQueue = null),
      (workInProgress.dependencies = null),
      (workInProgress.stateNode = null))
    : ((workInProgress.childLanes = current.childLanes),
      (workInProgress.lanes = current.lanes),
      (workInProgress.child = current.child),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null),
      (workInProgress.memoizedProps = current.memoizedProps),
      (workInProgress.memoizedState = current.memoizedState),
      (workInProgress.updateQueue = current.updateQueue),
      (workInProgress.type = current.type),
      (renderLanes = current.dependencies),
      (workInProgress.dependencies =
        null === renderLanes
          ? null
          : {
              lanes: renderLanes.lanes,
              firstContext: renderLanes.firstContext
            }));
  return workInProgress;
}
function createFiberFromTypeAndProps(
  type,
  key,
  pendingProps,
  owner,
  mode,
  lanes
) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    )
      ? 26
      : "html" === type || "head" === type || "body" === type
        ? 27
        : 5;
  else
    a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return (
          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
          (type.elementType = REACT_PROFILER_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_TYPE:
        return (
          (type = createFiberImplClass(13, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_LIST_TYPE:
        return (
          (type = createFiberImplClass(19, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  pendingProps = createFiberImplClass(22, pendingProps, key, mode);
  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
  pendingProps.lanes = lanes;
  var primaryChildInstance = {
    _visibility: 1,
    _pendingVisibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null,
    _current: null,
    detach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 === (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root &&
          ((primaryChildInstance._pendingVisibility |= 2),
          scheduleUpdateOnFiber(root, fiber, 2));
      }
    },
    attach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root &&
          ((primaryChildInstance._pendingVisibility &= -3),
          scheduleUpdateOnFiber(root, fiber, 2));
      }
    }
  };
  pendingProps.stateNode = primaryChildInstance;
  return pendingProps;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress.flags &= -16777217;
  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
    resource = suspenseHandlerStackCursor.current;
    if (
      null !== resource &&
      ((workInProgressRootRenderLanes & 4194176) ===
      workInProgressRootRenderLanes
        ? null !== shellBoundary
        : ((workInProgressRootRenderLanes & 62914560) !==
            workInProgressRootRenderLanes &&
            0 === (workInProgressRootRenderLanes & 536870912)) ||
          resource !== shellBoundary)
    )
      throw (
        ((suspendedThenable = noopSuspenseyCommitThenable),
        SuspenseyCommitException)
      );
    workInProgress.flags |= 8192;
  }
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 &&
    ((retryQueue =
      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
    (workInProgress.lanes |= retryQueue),
    (workInProgressSuspendedRetryLanes |= retryQueue));
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$131 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === lastTailNode$131
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (lastTailNode$131.sibling = null);
    }
}
function bubbleProperties(completedWork) {
  var didBailout =
      null !== completedWork.alternate &&
      completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout)
    for (var child$132 = completedWork.child; null !== child$132; )
      (newChildLanes |= child$132.lanes | child$132.childLanes),
        (subtreeFlags |= child$132.subtreeFlags & 31457280),
        (subtreeFlags |= child$132.flags & 31457280),
        (child$132.return = completedWork),
        (child$132 = child$132.sibling);
  else
    for (child$132 = completedWork.child; null !== child$132; )
      (newChildLanes |= child$132.lanes | child$132.childLanes),
        (subtreeFlags |= child$132.subtreeFlags),
        (subtreeFlags |= child$132.flags),
        (child$132.return = completedWork),
        (child$132 = child$132.sibling);
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps &&
        (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext &&
        ((renderLanes.context = renderLanes.pendingContext),
        (renderLanes.pendingContext = null));
      if (null === current || null === current.child)
        popHydrationState(workInProgress)
          ? markUpdate(workInProgress)
          : null === current ||
            (current.memoizedState.isDehydrated &&
              0 === (workInProgress.flags & 256)) ||
            ((workInProgress.flags |= 1024),
            null !== hydrationErrors &&
              (queueRecoverableErrors(hydrationErrors),
              (hydrationErrors = null)));
      bubbleProperties(workInProgress);
      return null;
    case 26:
      return (
        (renderLanes = workInProgress.memoizedState),
        null === current
          ? (markUpdate(workInProgress),
            null !== renderLanes
              ? (bubbleProperties(workInProgress),
                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
              : (bubbleProperties(workInProgress),
                (workInProgress.flags &= -16777217)))
          : renderLanes
            ? renderLanes !== current.memoizedState
              ? (markUpdate(workInProgress),
                bubbleProperties(workInProgress),
                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
              : (bubbleProperties(workInProgress),
                (workInProgress.flags &= -16777217))
            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
              bubbleProperties(workInProgress),
              (workInProgress.flags &= -16777217)),
        null
      );
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      var type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress)
          ? prepareToHydrateHostInstance(workInProgress, current)
          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
            (workInProgress.stateNode = current),
            markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      renderLanes = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, current);
        else {
          type = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (current) {
            case 1:
              current = type.createElementNS(
                "http://www.w3.org/2000/svg",
                renderLanes
              );
              break;
            case 2:
              current = type.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                renderLanes
              );
              break;
            default:
              switch (renderLanes) {
                case "svg":
                  current = type.createElementNS(
                    "http://www.w3.org/2000/svg",
                    renderLanes
                  );
                  break;
                case "math":
                  current = type.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    renderLanes
                  );
                  break;
                case "script":
                  current = type.createElement("div");
                  current.innerHTML = "<script>\x3c/script>";
                  current = current.removeChild(current.firstChild);
                  break;
                case "select":
                  current =
                    "string" === typeof newProps.is
                      ? type.createElement("select", { is: newProps.is })
                      : type.createElement("select");
                  newProps.multiple
                    ? (current.multiple = !0)
                    : newProps.size && (current.size = newProps.size);
                  break;
                default:
                  current =
                    "string" === typeof newProps.is
                      ? type.createElement(renderLanes, { is: newProps.is })
                      : type.createElement(renderLanes);
              }
          }
          current[internalInstanceKey] = workInProgress;
          current[internalPropsKey] = newProps;
          a: for (type = workInProgress.child; null !== type; ) {
            if (5 === type.tag || 6 === type.tag)
              current.appendChild(type.stateNode);
            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
              type.child.return = type;
              type = type.child;
              continue;
            }
            if (type === workInProgress) break a;
            for (; null === type.sibling; ) {
              if (null === type.return || type.return === workInProgress)
                break a;
              type = type.return;
            }
            type.sibling.return = type.return;
            type = type.sibling;
          }
          workInProgress.stateNode = current;
          a: switch (
            (setInitialProperties(current, renderLanes, newProps), renderLanes)
          ) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              current = !!newProps.autoFocus;
              break a;
            case "img":
              current = !0;
              break a;
            default:
              current = !1;
          }
          current && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      workInProgress.flags &= -16777217;
      return null;
    case 6:
      if (current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current =
            current.nodeValue === renderLanes ||
            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
            checkForUnmatchedText(current.nodeValue, renderLanes)
              ? !0
              : !1;
          current || throwOnHydrationMismatch(workInProgress);
        } else
          (current =
            getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            )),
            (current[internalInstanceKey] = workInProgress),
            (workInProgress.stateNode = current);
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (
        null === current ||
        (null !== current.memoizedState &&
          null !== current.memoizedState.dehydrated)
      ) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          type = !1;
        } else
          null !== hydrationErrors &&
            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
            (type = !0);
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128))
        return (workInProgress.lanes = renderLanes), workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      if (renderLanes) {
        newProps = workInProgress.child;
        type = null;
        null !== newProps.alternate &&
          null !== newProps.alternate.memoizedState &&
          null !== newProps.alternate.memoizedState.cachePool &&
          (type = newProps.alternate.memoizedState.cachePool.pool);
        var cache$144 = null;
        null !== newProps.memoizedState &&
          null !== newProps.memoizedState.cachePool &&
          (cache$144 = newProps.memoizedState.cachePool.pool);
        cache$144 !== type && (newProps.flags |= 2048);
      }
      renderLanes !== current &&
        renderLanes &&
        (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return (
        popHostContainer(),
        null === current &&
          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
        bubbleProperties(workInProgress),
        null
      );
    case 10:
      return (
        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
      );
    case 19:
      pop(suspenseStackCursor);
      type = workInProgress.memoizedState;
      if (null === type) return bubbleProperties(workInProgress), null;
      newProps = 0 !== (workInProgress.flags & 128);
      cache$144 = type.rendering;
      if (null === cache$144)
        if (newProps) cutOffTailIfNeeded(type, !1);
        else {
          if (
            0 !== workInProgressRootExitStatus ||
            (null !== current && 0 !== (current.flags & 128))
          )
            for (current = workInProgress.child; null !== current; ) {
              cache$144 = findFirstSuspended(current);
              if (null !== cache$144) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, !1);
                current = cache$144.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes; )
                  resetWorkInProgress(renderLanes, current),
                    (renderLanes = renderLanes.sibling);
                push(
                  suspenseStackCursor,
                  (suspenseStackCursor.current & 1) | 2
                );
                return workInProgress.child;
              }
              current = current.sibling;
            }
          null !== type.tail &&
            now() > workInProgressRootRenderTargetTime &&
            ((workInProgress.flags |= 128),
            (newProps = !0),
            cutOffTailIfNeeded(type, !1),
            (workInProgress.lanes = 4194304));
        }
      else {
        if (!newProps)
          if (((current = findFirstSuspended(cache$144)), null !== current)) {
            if (
              ((workInProgress.flags |= 128),
              (newProps = !0),
              (current = current.updateQueue),
              (workInProgress.updateQueue = current),
              scheduleRetryEffect(workInProgress, current),
              cutOffTailIfNeeded(type, !0),
              null === type.tail &&
                "hidden" === type.tailMode &&
                !cache$144.alternate &&
                !isHydrating)
            )
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - type.renderingStartTime >
              workInProgressRootRenderTargetTime &&
              536870912 !== renderLanes &&
              ((workInProgress.flags |= 128),
              (newProps = !0),
              cutOffTailIfNeeded(type, !1),
              (workInProgress.lanes = 4194304));
        type.isBackwards
          ? ((cache$144.sibling = workInProgress.child),
            (workInProgress.child = cache$144))
          : ((current = type.last),
            null !== current
              ? (current.sibling = cache$144)
              : (workInProgress.child = cache$144),
            (type.last = cache$144));
      }
      if (null !== type.tail)
        return (
          (workInProgress = type.tail),
          (type.rendering = workInProgress),
          (type.tail = workInProgress.sibling),
          (type.renderingStartTime = now()),
          (workInProgress.sibling = null),
          (current = suspenseStackCursor.current),
          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
          workInProgress
        );
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        (newProps = null !== workInProgress.memoizedState),
        null !== current
          ? (null !== current.memoizedState) !== newProps &&
            (workInProgress.flags |= 8192)
          : newProps && (workInProgress.flags |= 8192),
        newProps
          ? 0 !== (renderLanes & 536870912) &&
            0 === (workInProgress.flags & 128) &&
            (bubbleProperties(workInProgress),
            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
          : bubbleProperties(workInProgress),
        (renderLanes = workInProgress.updateQueue),
        null !== renderLanes &&
          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
        (renderLanes = null),
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (renderLanes = current.memoizedState.cachePool.pool),
        (newProps = null),
        null !== workInProgress.memoizedState &&
          null !== workInProgress.memoizedState.cachePool &&
          (newProps = workInProgress.memoizedState.cachePool.pool),
        newProps !== renderLanes && (workInProgress.flags |= 2048),
        null !== current && pop(resumedCache),
        null
      );
    case 24:
      return (
        (renderLanes = null),
        null !== current && (renderLanes = current.memoizedState.cache),
        workInProgress.memoizedState.cache !== renderLanes &&
          (workInProgress.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(workInProgress),
        null
      );
    case 25:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return (
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 3:
      return (
        popProvider(CacheContext),
        popHostContainer(),
        (current = workInProgress.flags),
        0 !== (current & 65536) && 0 === (current & 128)
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        null !== current && pop(resumedCache),
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType &&
        ((cacheForType = resourceType()),
        cache.data.set(resourceType, cacheForType));
      return cacheForType;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  rootDoesHavePassiveEffects = !1,
  rootWithPendingPassiveEffects = null,
  pendingPassiveEffectsLanes = 0,
  pendingPassiveEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
  if (null !== ReactSharedInternals.T) {
    var actionScopeLane = currentEntangledLane;
    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
  }
  return resolveUpdatePriority();
}
function requestDeferredLane() {
  0 === workInProgressDeferredLane &&
    (workInProgressDeferredLane =
      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
        ? claimNextTransitionLane()
        : 536870912);
  var suspenseHandler = suspenseHandlerStackCursor.current;
  null !== suspenseHandler && (suspenseHandler.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (
    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
    null !== root.cancelPendingCommit
  )
    prepareFreshStack(root, 0),
      markRootSuspended(
        root,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        !1
      );
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot)
    root === workInProgressRoot &&
      (0 === (executionContext & 2) &&
        (workInProgressRootInterleavedUpdatedLanes |= lane),
      4 === workInProgressRootExitStatus &&
        markRootSuspended(
          root,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        )),
      ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice =
      (!forceSync &&
        0 === (lanes & 60) &&
        0 === (lanes & root$jscomp$0.expiredLanes)) ||
      checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice
      ? renderRootConcurrent(root$jscomp$0, lanes)
      : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering &&
        !shouldTimeSlice &&
        markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else if (6 === exitStatus)
      markRootSuspended(
        root$jscomp$0,
        lanes,
        0,
        !workInProgressRootDidSkipSuspendedSiblings
      );
    else {
      forceSync = root$jscomp$0.current.alternate;
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(forceSync)
      ) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
            (JSCompiler_inline_result =
              0 !== JSCompiler_inline_result
                ? JSCompiler_inline_result
                : JSCompiler_inline_result & 536870912
                  ? 536870912
                  : 0);
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated &&
              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root,
              JSCompiler_inline_result,
              !1
            );
            if (2 !== JSCompiler_inline_result) {
              if (
                workInProgressRootDidAttachPingListener &&
                !wasRootDehydrated
              ) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |=
                  renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent &&
                queueRecoverableErrors(renderWasConcurrent);
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        switch (exitStatus) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194176) === lanes) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              break a;
            }
            break;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        shouldTimeSlice.finishedWork = forceSync;
        shouldTimeSlice.finishedLanes = lanes;
        if (
          (lanes & 62914560) === lanes &&
          ((renderWasConcurrent = globalMostRecentFallbackTime + 300 - now()),
          10 < renderWasConcurrent)
        ) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              2,
              -0,
              0
            ),
            renderWasConcurrent
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          0,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function queueRecoverableErrors(errors) {
  null === workInProgressRootRecoverableErrors
    ? (workInProgressRootRecoverableErrors = errors)
    : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        errors
      );
}
function commitRootWhenReady(
  root,
  finishedWork,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  lanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  didSkipSuspendedSiblings,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  var subtreeFlags = finishedWork.subtreeFlags;
  if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
    if (
      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
      accumulateSuspenseyCommitOnFiber(finishedWork),
      (finishedWork = waitForCommitToBeReady()),
      null !== finishedWork)
    ) {
      root.cancelPendingCommit = finishedWork(
        commitRoot.bind(
          null,
          root,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          1,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  commitRoot(
    root,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes,
    suspendedCommitReason,
    completedRenderStartTime,
    completedRenderEndTime
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if (
      (0 === tag || 11 === tag || 15 === tag) &&
      node.flags & 16384 &&
      ((tag = node.updateQueue),
      null !== tag && ((tag = tag.stores), null !== tag))
    )
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      (tag.return = node), (node = tag);
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(
  root,
  suspendedLanes,
  spawnedLane,
  didAttemptEntireTree
) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane &&
    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6)
    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      (interruptedWork = workInProgress),
        (lastContextDependency = currentlyRenderingFiber = null),
        resetHooksOnUnwind(interruptedWork),
        (thenableState$1 = null),
        (thenableIndexCounter$1 = 0),
        (interruptedWork = workInProgress);
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
        (interruptedWork = interruptedWork.return);
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = 0;
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle &&
    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle &&
    ((root.cancelPendingCommit = null), timeoutHandle());
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes =
    workInProgressDeferredLane =
    workInProgressRootPingedLanes =
    workInProgressRootInterleavedUpdatedLanes =
    workInProgressRootSkippedLanes =
    workInProgressRootExitStatus =
      0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
    null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes)
    for (
      root = root.entanglements, allEntangledLanes &= lanes;
      0 < allEntangledLanes;

    ) {
      var index$4 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$4;
      lanes |= root[index$4];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException
    ? ((thrownValue = getSuspendedThenable()),
      (workInProgressSuspendedReason = 3))
    : thrownValue === SuspenseyCommitException
      ? ((thrownValue = getSuspendedThenable()),
        (workInProgressSuspendedReason = 4))
      : (workInProgressSuspendedReason =
          thrownValue === SelectiveHydrationException
            ? 8
            : null !== thrownValue &&
                "object" === typeof thrownValue &&
                "function" === typeof thrownValue.then
              ? 6
              : 1);
  workInProgressThrownValue = thrownValue;
  null === workInProgress &&
    ((workInProgressRootExitStatus = 1),
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    ));
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings ||
    ((workInProgressRootRenderLanes & 4194176) !==
      workInProgressRootRenderLanes &&
      null !== suspenseHandlerStackCursor.current) ||
    (workInProgressRootIsPrerendering = !0);
  (0 === (workInProgressRootSkippedLanes & 134217727) &&
    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
    null === workInProgressRoot ||
    markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      !1
    );
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (
              shouldYieldForPrerendering &&
              workInProgressRootIsPrerendering
            ) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            (reason = workInProgressSuspendedReason),
              (workInProgressSuspendedReason = 0),
              (workInProgressThrownValue = null),
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$164) {
      handleThrow(root, thrownValue$164);
    }
  while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress &&
    ((workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0),
    finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
    ? ((workInProgressTransitions = null),
      (workInProgressRootRenderTargetTime = now() + 500),
      prepareFreshStack(root, lanes))
    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root,
        lanes
      ));
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              2 === workInProgressSuspendedReason &&
                workInProgressRoot === root &&
                (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue)
              ? ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                replaySuspendedUnitOfWork(lanes))
              : ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber
                      ? ((workInProgress = returnFiber),
                        completeUnitOfWork(returnFiber))
                      : (workInProgress = null);
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrent();
      break;
    } catch (thrownValue$166) {
      handleThrow(root, thrownValue$166);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next),
        (next = workInProgress =
          resetWorkInProgress(next, entangledRenderLanes)),
        (next = beginWork(current, next, entangledRenderLanes));
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function throwAndUnwindWorkLoop(
  root,
  unitOfWork,
  thrownValue,
  suspendedReason
) {
  lastContextDependency = currentlyRenderingFiber = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (
      throwException(
        root,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )
    ) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root,
        createCapturedValueAtFiber(thrownValue, root.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;
    else if (
      workInProgressRootIsPrerendering ||
      0 !== (workInProgressRootRenderLanes & 536870912)
    )
      root = !1;
    else if (
      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
      2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
    )
      (suspendedReason = suspenseHandlerStackCursor.current),
        null !== suspendedReason &&
          13 === suspendedReason.tag &&
          (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next &&
      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
    if (
      !skipSiblings &&
      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
    ) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(
  root,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  var prevTransition = ReactSharedInternals.T,
    previousUpdateLanePriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      (ReactSharedInternals.T = null),
      commitRootImpl(
        root,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        previousUpdateLanePriority,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      );
  } finally {
    (ReactSharedInternals.T = prevTransition),
      (ReactDOMSharedInternals.p = previousUpdateLanePriority);
  }
}
function commitRootImpl(
  root,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  renderPriorityLevel,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  do flushPassiveEffects();
  while (null !== rootWithPendingPassiveEffects);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var finishedWork = root.finishedWork;
  didIncludeRenderPhaseUpdate = root.finishedLanes;
  if (null === finishedWork) return null;
  root.finishedWork = null;
  root.finishedLanes = 0;
  if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
  root.callbackNode = null;
  root.callbackPriority = 0;
  root.cancelPendingCommit = null;
  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
  remainingLanes |= concurrentlyUpdatedLanes;
  markRootFinished(
    root,
    didIncludeRenderPhaseUpdate,
    remainingLanes,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
  root === workInProgressRoot &&
    ((workInProgress = workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0));
  (0 === (finishedWork.subtreeFlags & 10256) &&
    0 === (finishedWork.flags & 10256)) ||
    rootDoesHavePassiveEffects ||
    ((rootDoesHavePassiveEffects = !0),
    (pendingPassiveEffectsRemainingLanes = remainingLanes),
    (pendingPassiveTransitions = transitions),
    scheduleCallback$1(NormalPriority$1, function () {
      flushPassiveEffects(!0);
      return null;
    }));
  transitions = 0 !== (finishedWork.flags & 15990);
  0 !== (finishedWork.subtreeFlags & 15990) || transitions
    ? ((transitions = ReactSharedInternals.T),
      (ReactSharedInternals.T = null),
      (spawnedLane = ReactDOMSharedInternals.p),
      (ReactDOMSharedInternals.p = 2),
      (updatedLanes = executionContext),
      (executionContext |= 4),
      commitBeforeMutationEffects(root, finishedWork),
      commitMutationEffectsOnFiber(finishedWork, root),
      restoreSelection(selectionInformation, root.containerInfo),
      (_enabled = !!eventsEnabled),
      (selectionInformation = eventsEnabled = null),
      (root.current = finishedWork),
      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),
      requestPaint(),
      (executionContext = updatedLanes),
      (ReactDOMSharedInternals.p = spawnedLane),
      (ReactSharedInternals.T = transitions))
    : (root.current = finishedWork);
  rootDoesHavePassiveEffects
    ? ((rootDoesHavePassiveEffects = !1),
      (rootWithPendingPassiveEffects = root),
      (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))
    : releaseRootPooledCache(root, remainingLanes);
  remainingLanes = root.pendingLanes;
  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
  ensureRootIsScheduled(root);
  if (null !== recoverableErrors)
    for (
      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
      finishedWork < recoverableErrors.length;
      finishedWork++
    )
      (remainingLanes = recoverableErrors[finishedWork]),
        renderPriorityLevel(remainingLanes.value, {
          componentStack: remainingLanes.stack
        });
  0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
  remainingLanes = root.pendingLanes;
  0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42)
    ? root === rootWithNestedUpdates
      ? nestedUpdateCount++
      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
    : (nestedUpdateCount = 0);
  flushSyncWorkAcrossRoots_impl(0, !1);
  return null;
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) &&
    ((remainingLanes = root.pooledCache),
    null != remainingLanes &&
      ((root.pooledCache = null), releaseCache(remainingLanes)));
}
function flushPassiveEffects() {
  if (null !== rootWithPendingPassiveEffects) {
    var root$170 = rootWithPendingPassiveEffects,
      remainingLanes = pendingPassiveEffectsRemainingLanes;
    pendingPassiveEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
      prevTransition = ReactSharedInternals.T,
      previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      if (null === rootWithPendingPassiveEffects)
        var JSCompiler_inline_result = !1;
      else {
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root = rootWithPendingPassiveEffects,
          lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = 0;
        if (0 !== (executionContext & 6))
          throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root.current);
        commitPassiveMountOnFiber(root, root.current, lanes, renderPriority);
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        if (
          injectedHook &&
          "function" === typeof injectedHook.onPostCommitFiberRoot
        )
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root);
          } catch (err) {}
        JSCompiler_inline_result = !0;
      }
      return JSCompiler_inline_result;
    } finally {
      (ReactDOMSharedInternals.p = previousPriority),
        (ReactSharedInternals.T = prevTransition),
        releaseRootPooledCache(root$170, remainingLanes);
    }
  }
  return !1;
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber &&
    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if (
          "function" ===
            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
          ("function" === typeof instance.componentDidCatch &&
            (null === legacyErrorBoundariesThatAlreadyFailed ||
              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
        ) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance &&
            (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ),
            markRootUpdated$1(instance, 2),
            ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    (threadIDs = pingCache.get(wakeable)),
      void 0 === threadIDs &&
        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) ||
    ((workInProgressRootDidAttachPingListener = !0),
    threadIDs.add(lanes),
    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
    wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root &&
    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
    (4 === workInProgressRootExitStatus ||
    (3 === workInProgressRootExitStatus &&
      (workInProgressRootRenderLanes & 62914560) ===
        workInProgressRootRenderLanes &&
      300 > now() - globalMostRecentFallbackTime)
      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
      : (workInProgressRootPingedLanes |= pingedLanes),
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
      (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber &&
    (markRootUpdated$1(boundaryFiber, retryLane),
    ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot &&
    null === root.next &&
    (null === lastScheduledRoot
      ? (firstScheduledRoot = lastScheduledRoot = root)
      : (lastScheduledRoot = lastScheduledRoot.next = root));
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask ||
    ((didScheduleMicrotask = !0),
    scheduleImmediateTask(processRootScheduleInMicrotask));
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$172 = firstScheduledRoot; null !== root$172; ) {
        if (!onlyLegacy)
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$172.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$172.suspendedLanes,
                pingedLanes = root$172.pingedLanes;
              JSCompiler_inline_result =
                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
              JSCompiler_inline_result &=
                pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result =
                JSCompiler_inline_result & 201326677
                  ? (JSCompiler_inline_result & 201326677) | 1
                  : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0;
            }
            0 !== JSCompiler_inline_result &&
              ((didPerformSomeWork = !0),
              performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
          } else
            (JSCompiler_inline_result = workInProgressRootRenderLanes),
              (JSCompiler_inline_result = getNextLanes(
                root$172,
                root$172 === workInProgressRoot ? JSCompiler_inline_result : 0
              )),
              0 === (JSCompiler_inline_result & 3) ||
                checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) ||
                ((didPerformSomeWork = !0),
                performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
        root$172 = root$172.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane &&
    (shouldAttemptEagerTransition() &&
      (syncTransitionLanes = currentEventTransitionLane),
    (currentEventTransitionLane = 0));
  for (
    var currentTime = now(), prev = null, root = firstScheduledRoot;
    null !== root;

  ) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes)
      (root.next = null),
        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
        null === next && (lastScheduledRoot = prev);
    else if (
      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
    )
      mightHavePendingSyncWork = !0;
    root = next;
  }
  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (
    var suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      expirationTimes = root.expirationTimes,
      lanes = root.pendingLanes & -62914561;
    0 < lanes;

  ) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root,
    root === currentTime ? suspendedLanes : 0
  );
  pingedLanes = root.callbackNode;
  if (
    0 === suspendedLanes ||
    (root === currentTime && 2 === workInProgressSuspendedReason) ||
    null !== root.cancelPendingCommit
  )
    return (
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes),
      (root.callbackNode = null),
      (root.callbackPriority = 0)
    );
  if (
    0 === (suspendedLanes & 3) ||
    checkIfRootIsPrerendering(root, suspendedLanes)
  ) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  var originalCallbackNode = root.callbackNode;
  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode
    ? performWorkOnRootViaSchedulerTask.bind(null, root)
    : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPassiveEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateTask(cb) {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6)
      ? scheduleCallback$3(ImmediatePriority, cb)
      : cb();
  });
}
function requestTransitionLane() {
  0 === currentEventTransitionLane &&
    (currentEventTransitionLane = claimNextTransitionLane());
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp ||
    "symbol" === typeof actionProp ||
    "boolean" === typeof actionProp
    ? null
    : "function" === typeof actionProp
      ? actionProp
      : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(
  dispatchQueue,
  domEventName,
  maybeTargetInst,
  nativeEvent,
  nativeEventTarget
) {
  if (
    "submit" === domEventName &&
    maybeTargetInst &&
    maybeTargetInst.stateNode === nativeEventTarget
  ) {
    var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ),
      submitter = nativeEvent.submitter;
    submitter &&
      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
        ? coerceFormActionProp(domEventName.formAction)
        : submitter.getAttribute("formAction")),
      null !== domEventName && ((action = domEventName), (submitter = null)));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event: event,
      listeners: [
        {
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action &&
                (event.preventDefault(),
                (formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget)),
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  action,
                  formData
                ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (
  var i$jscomp$inline_1439 = 0;
  i$jscomp$inline_1439 < simpleEventPluginEvents.length;
  i$jscomp$inline_1439++
) {
  var eventName$jscomp$inline_1440 =
      simpleEventPluginEvents[i$jscomp$inline_1439],
    domEventName$jscomp$inline_1441 =
      eventName$jscomp$inline_1440.toLowerCase(),
    capitalizedEvent$jscomp$inline_1442 =
      eventName$jscomp$inline_1440[0].toUpperCase() +
      eventName$jscomp$inline_1440.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1441,
    "on" + capitalizedEvent$jscomp$inline_1442
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle"
      .split(" ")
      .concat(mediaEventTypes)
  );
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (
          var i$jscomp$0 = _dispatchQueue$i.length - 1;
          0 <= i$jscomp$0;
          i$jscomp$0--
        ) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < _dispatchQueue$i.length;
          i$jscomp$0++
        ) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result &&
    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
      new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) ||
    (addTrappedEventListener(targetElement, domEventName, 2, !1),
    JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName &&
        (nonDelegatedEvents.has(domEventName) ||
          listenToNativeEvent(domEventName, !1, rootContainerElement),
        listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    null === ownerDocument ||
      ownerDocument[listeningMarker] ||
      ((ownerDocument[listeningMarker] = !0),
      listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported ||
    ("touchstart" !== domEventName &&
      "touchmove" !== domEventName &&
      "wheel" !== domEventName) ||
    (listenerWrapper = !0);
  isCapturePhaseListener
    ? void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: !0,
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
    : void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst$jscomp$0,
  targetContainer
) {
  var ancestorInst = targetInst$jscomp$0;
  if (
    0 === (eventSystemFlags & 1) &&
    0 === (eventSystemFlags & 2) &&
    null !== targetInst$jscomp$0
  )
    a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (
          container === targetContainer ||
          (8 === container.nodeType && container.parentNode === targetContainer)
        )
          break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if (3 === grandTag || 4 === grandTag)
              if (
                ((grandTag = nodeTag.stateNode.containerInfo),
                grandTag === targetContainer ||
                  (8 === grandTag.nodeType &&
                    grandTag.parentNode === targetContainer))
              )
                return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container; ) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (
            5 === grandTag ||
            6 === grandTag ||
            26 === grandTag ||
            27 === grandTag
          ) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly =
            !inCapturePhase &&
            ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase
            ? null !== reactName
              ? reactName + "Capture"
              : null
            : reactName;
        inCapturePhase = [];
        for (
          var instance = targetInst, lastHostComponent;
          null !== instance;

        ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
            null === lastHostComponent ||
            null === reactEventName ||
            ((_instance = getListener(instance, reactEventName)),
            null != _instance &&
              inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length &&
          ((reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName =
          "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor =
          "mouseout" === domEventName || "pointerout" === domEventName;
        if (
          reactName &&
          nativeEvent !== currentReplayingEvent &&
          (reactEventType =
            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
          (getClosestInstanceFromNode(reactEventType) ||
            reactEventType[internalContainerInstanceKey])
        )
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget
              : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window;
          if (SyntheticEventCtor) {
            if (
              ((reactEventType =
                nativeEvent.relatedTarget || nativeEvent.toElement),
              (SyntheticEventCtor = targetInst),
              (reactEventType = reactEventType
                ? getClosestInstanceFromNode(reactEventType)
                : null),
              null !== reactEventType &&
                ((accumulateTargetOnly =
                  getNearestMountedFiber(reactEventType)),
                (inCapturePhase = reactEventType.tag),
                reactEventType !== accumulateTargetOnly ||
                  (5 !== inCapturePhase &&
                    27 !== inCapturePhase &&
                    6 !== inCapturePhase)))
            )
              reactEventType = null;
          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              (inCapturePhase = SyntheticPointerEvent),
                (_instance = "onPointerLeave"),
                (reactEventName = "onPointerEnter"),
                (instance = "pointer");
            accumulateTargetOnly =
              null == SyntheticEventCtor
                ? reactName
                : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent =
              null == reactEventType
                ? reactName
                : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
              ((inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              )),
              (inCapturePhase.target = lastHostComponent),
              (inCapturePhase.relatedTarget = accumulateTargetOnly),
              (_instance = inCapturePhase));
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (
                  lastHostComponent = inCapturePhase;
                  lastHostComponent;
                  lastHostComponent = getParent(lastHostComponent)
                )
                  instance++;
                lastHostComponent = 0;
                for (
                  _instance = reactEventName;
                  _instance;
                  _instance = getParent(_instance)
                )
                  lastHostComponent++;
                for (; 0 < instance - lastHostComponent; )
                  (inCapturePhase = getParent(inCapturePhase)), instance--;
                for (; 0 < lastHostComponent - instance; )
                  (reactEventName = getParent(reactEventName)),
                    lastHostComponent--;
                for (; instance--; ) {
                  if (
                    inCapturePhase === reactEventName ||
                    (null !== reactEventName &&
                      inCapturePhase === reactEventName.alternate)
                  )
                    break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1
              );
            null !== reactEventType &&
              null !== accumulateTargetOnly &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                !0
              );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor =
          reactName.nodeName && reactName.nodeName.toLowerCase();
        if (
          "select" === SyntheticEventCtor ||
          ("input" === SyntheticEventCtor && "file" === reactName.type)
        )
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          (SyntheticEventCtor = reactName.nodeName),
            !SyntheticEventCtor ||
            "input" !== SyntheticEventCtor.toLowerCase() ||
            ("checkbox" !== reactName.type && "radio" !== reactName.type)
              ? targetInst &&
                isCustomElement(targetInst.elementType) &&
                (getTargetInstFunc = getTargetInstForChangeEvent)
              : (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
        ) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName &&
          targetInst &&
          "number" === reactName.type &&
          null != targetInst.memoizedProps.value &&
          setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (
            isTextInputElement(handleEventFunc) ||
            "true" === handleEventFunc.contentEditable
          )
            (activeElement = handleEventFunc),
              (activeElementInst = targetInst),
              (lastSelection = null);
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing
          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
            (eventType = "onCompositionEnd")
          : "keydown" === domEventName &&
            229 === nativeEvent.keyCode &&
            (eventType = "onCompositionStart");
      eventType &&
        (useFallbackCompositionData &&
          "ko" !== nativeEvent.locale &&
          (isComposing || "onCompositionStart" !== eventType
            ? "onCompositionEnd" === eventType &&
              isComposing &&
              (fallbackData = getData())
            : ((root = nativeEventTarget),
              (startText = "value" in root ? root.value : root.textContent),
              (isComposing = !0))),
        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
        0 < handleEventFunc.length &&
          ((eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
          fallbackData
            ? (eventType.data = fallbackData)
            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
              null !== fallbackData && (eventType.data = fallbackData))));
      if (
        (fallbackData = canUseTextInputEvent
          ? getNativeBeforeInputChars(domEventName, nativeEvent)
          : getFallbackBeforeInputChars(domEventName, nativeEvent))
      )
        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
          0 < eventType.length &&
            ((handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }),
            (handleEventFunc.data = fallbackData));
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (
    var captureName = reactName + "Capture", listeners = [];
    null !== targetFiber;

  ) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
      null === stateNode ||
      ((_instance2 = getListener(targetFiber, captureName)),
      null != _instance2 &&
        listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ),
      (_instance2 = getListener(targetFiber, reactName)),
      null != _instance2 &&
        listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
    targetFiber = targetFiber.return;
  }
  return listeners;
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(
  dispatchQueue,
  event,
  target,
  common,
  inCapturePhase
) {
  for (
    var registrationName = event._reactName, listeners = [];
    null !== target && target !== common;

  ) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
      null === stateNode ||
      ((alternate = stateNode),
      inCapturePhase
        ? ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            ))
        : inCapturePhase ||
          ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
    target = target.return;
  }
  0 !== listeners.length &&
    dispatchQueue.push({ event: event, listeners: listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup)
    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function noop$1() {}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value
        ? "body" === tag ||
          ("textarea" === tag && "" === value) ||
          setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          "body" !== tag &&
          setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (
        null == value ||
        "function" === typeof value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue &&
          ("formAction" === key
            ? ("input" !== tag &&
                setProp(domElement, tag, "name", props.name, props, null),
              setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              ))
            : (setProp(domElement, tag, "encType", props.encType, props, null),
              setProp(domElement, tag, "method", props.method, props, null),
              setProp(domElement, tag, "target", props.target, props, null)));
      if (
        null == value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (
        null == value ||
        "function" === typeof value ||
        "boolean" === typeof value ||
        "symbol" === typeof value
      ) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "" + value)
        : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "")
        : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value
        ? domElement.setAttribute(key, "")
        : !1 !== value &&
            null != value &&
            "function" !== typeof value &&
            "symbol" !== typeof value
          ? domElement.setAttribute(key, value)
          : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value &&
      "function" !== typeof value &&
      "symbol" !== typeof value &&
      !isNaN(value) &&
      1 <= value
        ? domElement.setAttribute(key, value)
        : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value ||
      "function" === typeof value ||
      "symbol" === typeof value ||
      isNaN(value)
        ? domElement.removeAttribute(key)
        : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (
        !(2 < key.length) ||
        ("o" !== key[0] && "O" !== key[0]) ||
        ("n" !== key[1] && "N" !== key[1])
      )
        (key = aliases.get(key) || key),
          setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value
        ? setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (
            "o" === key[0] &&
            "n" === key[1] &&
            ((props = key.endsWith("Capture")),
            (tag = key.slice(2, props ? key.length - 7 : void 0)),
            (prevValue = domElement[internalPropsKey] || null),
            (prevValue = null != prevValue ? prevValue[key] : null),
            "function" === typeof prevValue &&
              domElement.removeEventListener(tag, prevValue, props),
            "function" === typeof value)
          ) {
            "function" !== typeof prevValue &&
              null !== prevValue &&
              (key in domElement
                ? (domElement[key] = null)
                : domElement.hasAttribute(key) &&
                  domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement
            ? (domElement[key] = value)
            : !0 === value
              ? domElement.setAttribute(key, "")
              : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet &&
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = (propKey = propValue = hasSrcSet = null),
        checked = null,
        defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$186 = props[hasSrc];
          if (null != propValue$186)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$186;
                break;
              case "type":
                propValue = propValue$186;
                break;
              case "checked":
                checked = propValue$186;
                break;
              case "defaultChecked":
                defaultChecked = propValue$186;
                break;
              case "value":
                propKey = propValue$186;
                break;
              case "defaultValue":
                defaultValue = propValue$186;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$186)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$186, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        !1
      );
      track(domElement);
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (
          props.hasOwnProperty(hasSrcSet) &&
          ((defaultValue = props[hasSrcSet]), null != defaultValue)
        )
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag
        ? updateOptions(domElement, !!hasSrc, tag, !1)
        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (
          props.hasOwnProperty(propValue) &&
          ((defaultValue = props[propValue]), null != defaultValue)
        )
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      track(domElement);
      return;
    case "option":
      for (checked in props)
        if (
          props.hasOwnProperty(checked) &&
          ((hasSrc = props[checked]), null != hasSrc)
        )
          switch (checked) {
            case "selected":
              domElement.selected =
                hasSrc &&
                "function" !== typeof hasSrc &&
                "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement),
        listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (
          props.hasOwnProperty(defaultChecked) &&
          ((hasSrc = props[defaultChecked]), null != hasSrc)
        )
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$186 in props)
          props.hasOwnProperty(propValue$186) &&
            ((hasSrc = props[propValue$186]),
            void 0 !== hasSrc &&
              setPropOnCustomElement(
                domElement,
                tag,
                propValue$186,
                hasSrc,
                props,
                void 0
              ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) &&
      ((hasSrc = props[defaultValue]),
      null != hasSrc &&
        setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) ||
                setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$203 in nextProps) {
        var propKey = nextProps[propKey$203];
        lastProp = lastProps[propKey$203];
        if (
          nextProps.hasOwnProperty(propKey$203) &&
          (null != propKey || null != lastProp)
        )
          switch (propKey$203) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp &&
                setProp(
                  domElement,
                  tag,
                  propKey$203,
                  propKey,
                  nextProps,
                  lastProp
                );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$203 = null;
      for (type in lastProps)
        if (
          ((lastDefaultValue = lastProps[type]),
          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
        )
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) ||
                setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
          }
      for (name in nextProps)
        if (
          ((type = nextProps[name]),
          (lastDefaultValue = lastProps[name]),
          nextProps.hasOwnProperty(name) &&
            (null != type || null != lastDefaultValue))
        )
          switch (name) {
            case "value":
              propKey$203 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue &&
                setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$203
        ? updateOptions(domElement, !!lastProps, propKey$203, !1)
        : !!nextProps !== !!lastProps &&
          (null != tag
            ? updateOptions(domElement, !!lastProps, tag, !0)
            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$203 = null;
      for (defaultValue in lastProps)
        if (
          ((name = lastProps[defaultValue]),
          lastProps.hasOwnProperty(defaultValue) &&
            null != name &&
            !nextProps.hasOwnProperty(defaultValue))
        )
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (
          ((name = nextProps[value]),
          (type = lastProps[value]),
          nextProps.hasOwnProperty(value) && (null != name || null != type))
        )
          switch (value) {
            case "value":
              propKey$203 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type &&
                setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$203, propKey);
      return;
    case "option":
      for (var propKey$219 in lastProps)
        if (
          ((propKey$203 = lastProps[propKey$219]),
          lastProps.hasOwnProperty(propKey$219) &&
            null != propKey$203 &&
            !nextProps.hasOwnProperty(propKey$219))
        )
          switch (propKey$219) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$219,
                null,
                nextProps,
                propKey$203
              );
          }
      for (lastDefaultValue in nextProps)
        if (
          ((propKey$203 = nextProps[lastDefaultValue]),
          (propKey = lastProps[lastDefaultValue]),
          nextProps.hasOwnProperty(lastDefaultValue) &&
            propKey$203 !== propKey &&
            (null != propKey$203 || null != propKey))
        )
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected =
                propKey$203 &&
                "function" !== typeof propKey$203 &&
                "symbol" !== typeof propKey$203;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$203,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$224 in lastProps)
        (propKey$203 = lastProps[propKey$224]),
          lastProps.hasOwnProperty(propKey$224) &&
            null != propKey$203 &&
            !nextProps.hasOwnProperty(propKey$224) &&
            setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);
      for (checked in nextProps)
        if (
          ((propKey$203 = nextProps[checked]),
          (propKey = lastProps[checked]),
          nextProps.hasOwnProperty(checked) &&
            propKey$203 !== propKey &&
            (null != propKey$203 || null != propKey))
        )
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$203)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$203,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$229 in lastProps)
          (propKey$203 = lastProps[propKey$229]),
            lastProps.hasOwnProperty(propKey$229) &&
              void 0 !== propKey$203 &&
              !nextProps.hasOwnProperty(propKey$229) &&
              setPropOnCustomElement(
                domElement,
                tag,
                propKey$229,
                void 0,
                nextProps,
                propKey$203
              );
        for (defaultChecked in nextProps)
          (propKey$203 = nextProps[defaultChecked]),
            (propKey = lastProps[defaultChecked]),
            !nextProps.hasOwnProperty(defaultChecked) ||
              propKey$203 === propKey ||
              (void 0 === propKey$203 && void 0 === propKey) ||
              setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$203,
                nextProps,
                propKey
              );
        return;
      }
  }
  for (var propKey$234 in lastProps)
    (propKey$203 = lastProps[propKey$234]),
      lastProps.hasOwnProperty(propKey$234) &&
        null != propKey$203 &&
        !nextProps.hasOwnProperty(propKey$234) &&
        setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);
  for (lastProp in nextProps)
    (propKey$203 = nextProps[lastProp]),
      (propKey = lastProps[lastProp]),
      !nextProps.hasOwnProperty(lastProp) ||
        propKey$203 === propKey ||
        (null == propKey$203 && null == propKey) ||
        setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType
    ? rootContainerElement
    : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type
    ? 0
    : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return (
    "textarea" === type ||
    "noscript" === type ||
    "string" === typeof props.children ||
    "number" === typeof props.children ||
    "bigint" === typeof props.children ||
    ("object" === typeof props.dangerouslySetInnerHTML &&
      null !== props.dangerouslySetInnerHTML &&
      null != props.dangerouslySetInnerHTML.__html)
  );
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask =
    "function" === typeof queueMicrotask
      ? queueMicrotask
      : "undefined" !== typeof localPromise
        ? function (callback) {
            return localPromise
              .resolve(null)
              .then(callback)
              .catch(handleErrorInNextTick);
          }
        : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node)) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(suspenseInstance);
          return;
        }
        depth--;
      } else ("$" !== node && "$?" !== node && "$!" !== node) || depth++;
    node = nextNode;
  } while (node);
  retryIfBlockedOn(suspenseInstance);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (
        !inRootOrSingleton &&
        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
      )
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if (
          "hidden" === anyProps.type &&
          instance.getAttribute("name") === name
        )
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (
            name !== anyProps.rel ||
            instance.getAttribute("href") !==
              (null == anyProps.href ? null : anyProps.href) ||
            instance.getAttribute("crossorigin") !==
              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
            instance.getAttribute("title") !==
              (null == anyProps.title ? null : anyProps.title)
          )
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if (
            (name !== (null == anyProps.src ? null : anyProps.src) ||
              instance.getAttribute("type") !==
                (null == anyProps.type ? null : anyProps.type) ||
              instance.getAttribute("crossorigin") !==
                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
            name &&
            instance.hasAttribute("async") &&
            !instance.hasAttribute("itemprop")
          )
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if (
        "$" === nodeType ||
        "$!" === nodeType ||
        "$?" === nodeType ||
        "F!" === nodeType ||
        "F" === nodeType
      )
        break;
      if ("/$" === nodeType) return null;
    }
  }
  return node;
}
function getParentSuspenseInstance(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if ("$" === data || "$!" === data || "$?" === data) {
        if (0 === depth) return targetInstance;
        depth--;
      } else "/$" === data && depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode
    ? container.getRootNode()
    : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type
    ? requestFormReset$1(formInst)
    : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref =
      escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref =
      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin &&
      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) ||
      (preconnectsSet.add(limitedEscapedHref),
      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
      null === ownerDocument.querySelector(limitedEscapedHref) &&
        ((href = ownerDocument.createElement("link")),
        setInitialProperties(href, "link", rel),
        markNodeAsHoistable(href),
        ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector =
      'link[rel="preload"][as="' +
      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
      '"]';
    "image" === as
      ? options && options.imageSrcSet
        ? ((preloadSelector +=
            '[imagesrcset="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) +
            '"]'),
          "string" === typeof options.imageSizes &&
            (preloadSelector +=
              '[imagesizes="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) +
              '"]'))
        : (preloadSelector +=
            '[href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]')
      : (preloadSelector +=
          '[href="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
          '"]');
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) ||
      ((href = assign(
        {
          rel: "preload",
          href:
            "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        },
        options
      )),
      preloadPropsMap.set(key, href),
      null !== ownerDocument.querySelector(preloadSelector) ||
        ("style" === as &&
          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
        ("script" === as &&
          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
        ((as = ownerDocument.createElement("link")),
        setInitialProperties(as, "link", href),
        markNodeAsHoistable(as),
        ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector =
        'link[rel="modulepreload"][as="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
        '"][href="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
        '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (
      !preloadPropsMap.has(key) &&
      ((href = assign({ rel: "modulepreload", href: href }, options)),
      preloadPropsMap.set(key, href),
      null === ownerDocument.querySelector(preloadSelector))
    ) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (
        (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
      )
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href: href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForStylesheet(href, options);
        var link = (resource = ownerDocument.createElement("link"));
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0 }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0, type: "module" }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result =
    rootInstanceStackCursor.current)
    ? getHoistableRoot(JSCompiler_inline_result)
    : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence &&
        "string" === typeof pendingProps.href
        ? ((currentProps = getStyleKey(pendingProps.href)),
          (pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles),
          (currentResource = pendingProps.get(currentProps)),
          currentResource ||
            ((currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }),
            pendingProps.set(currentProps, currentResource)),
          currentResource)
        : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (
        "stylesheet" === pendingProps.rel &&
        "string" === typeof pendingProps.href &&
        "string" === typeof pendingProps.precedence
      ) {
        type = getStyleKey(pendingProps.href);
        var styles$242 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles,
          resource$243 = styles$242.get(type);
        resource$243 ||
          ((JSCompiler_inline_result =
            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
          (resource$243 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }),
          styles$242.set(type, resource$243),
          (styles$242 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) &&
            !styles$242._p &&
            ((resource$243.instance = styles$242),
            (resource$243.state.loading = 5)),
          preloadPropsMap.has(type) ||
            ((pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }),
            preloadPropsMap.set(type, pendingProps),
            styles$242 ||
              preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$243.state
              )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$243;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return (
        (currentProps = pendingProps.async),
        (pendingProps = pendingProps.src),
        "string" === typeof pendingProps &&
        currentProps &&
        "function" !== typeof currentProps &&
        "symbol" !== typeof currentProps
          ? ((currentProps = getScriptKey(pendingProps)),
            (pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts),
            (currentResource = pendingProps.get(currentProps)),
            currentResource ||
              ((currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }),
              pendingProps.set(currentProps, currentResource)),
            currentResource)
          : { type: "void", instance: null, count: 0, state: null }
      );
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
    ? (state.loading = 1)
    : ((key = ownerDocument.createElement("link")),
      (state.preload = key),
      key.addEventListener("load", function () {
        return (state.loading |= 1);
      }),
      key.addEventListener("error", function () {
        return (state.loading |= 2);
      }),
      setInitialProperties(key, "link", preloadProps),
      markNodeAsHoistable(key),
      ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
            '"]'
        );
        if (instance)
          return (
            (resource.instance = instance),
            markNodeAsHoistable(instance),
            instance
          );
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return (resource.instance = instance);
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$248 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$248)
          return (
            (resource.state.loading |= 4),
            (resource.instance = instance$248),
            markNodeAsHoistable(instance$248),
            instance$248
          );
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) &&
          adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$248 = (
          hoistableRoot.ownerDocument || hoistableRoot
        ).createElement("link");
        markNodeAsHoistable(instance$248);
        var linkInstance = instance$248;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$248, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$248, props.precedence, hoistableRoot);
        return (resource.instance = instance$248);
      case "script":
        instance$248 = getScriptKey(props.src);
        if (
          (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$248)
          ))
        )
          return (
            (resource.instance = styleProps),
            markNodeAsHoistable(styleProps),
            styleProps
          );
        instance = props;
        if ((styleProps = preloadPropsMap.get(instance$248)))
          (instance = assign({}, props)),
            adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return (resource.instance = styleProps);
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type &&
      0 === (resource.state.loading & 4) &&
      ((instance = resource.instance),
      (resource.state.loading |= 4),
      insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (
    var nodes = root.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ),
      last = nodes.length ? nodes[nodes.length - 1] : null,
      prior = last,
      i = 0;
    i < nodes.length;
    i++
  ) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior
    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
    : ((precedence = 9 === root.nodeType ? root.head : root),
      precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin &&
    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy &&
    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin &&
    (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy &&
    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity &&
    (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = (tagCaches = new Map());
    caches.set(ownerDocument, cache);
  } else
    (caches = tagCaches),
      (cache = caches.get(ownerDocument)),
      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (
      !(
        node[internalHoistableMarker] ||
        node[internalInstanceKey] ||
        ("link" === type && "stylesheet" === node.getAttribute("rel"))
      ) &&
      "http://www.w3.org/2000/svg" !== node.namespaceURI
    ) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (
        "string" !== typeof props.precedence ||
        "string" !== typeof props.href ||
        "" === props.href
      )
        break;
      return !0;
    case "link":
      if (
        "string" !== typeof props.rel ||
        "string" !== typeof props.href ||
        "" === props.href ||
        props.onLoad ||
        props.onError
      )
        break;
      switch (props.rel) {
        case "stylesheet":
          return (
            (type = props.disabled),
            "string" === typeof props.precedence && null == type
          );
        default:
          return !0;
      }
    case "script":
      if (
        props.async &&
        "function" !== typeof props.async &&
        "symbol" !== typeof props.async &&
        !props.onLoad &&
        !props.onError &&
        props.src &&
        "string" === typeof props.src
      )
        return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
    ? !1
    : !0;
}
var suspendedState = null;
function noop() {}
function suspendResource(hoistableRoot, resource, props) {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  if (
    "stylesheet" === resource.type &&
    ("string" !== typeof props.media ||
      !1 !== matchMedia(props.media).matches) &&
    0 === (resource.state.loading & 4)
  ) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot &&
          "object" === typeof hoistableRoot &&
          "function" === typeof hoistableRoot.then &&
          (state.count++,
          (state = onUnsuspend.bind(state)),
          hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) &&
        adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) &&
      0 === (resource.state.loading & 3) &&
      (state.count++,
      (resource = onUnsuspend.bind(state)),
      hoistableRoot.addEventListener("load", resource),
      hoistableRoot.addEventListener("error", resource));
  }
}
function waitForCommitToBeReady() {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  state.stylesheets &&
    0 === state.count &&
    insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count
    ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets &&
            insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      }
    : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count)
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend &&
    (state.count++,
    (precedencesByRoot = new Map()),
    resources.forEach(insertStylesheetIntoRoot, state),
    (precedencesByRoot = null),
    onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (
        var nodes = root.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ),
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (
          "LINK" === node.nodeName ||
          "not all" !== node.getAttribute("media")
        )
          precedences.set(node.dataset.precedence, node), (last = node);
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i
      ? i.parentNode.insertBefore(nodes, i.nextSibling)
      : ((root = 9 === root.nodeType ? root.head : root),
        root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(
  containerInfo,
  tag,
  hydrate,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  formState
) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.finishedWork =
    this.pingCache =
    this.current =
    this.pendingChildren =
      null;
  this.timeoutHandle = -1;
  this.callbackNode =
    this.next =
    this.pendingContext =
    this.context =
    this.cancelPendingCommit =
      null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes =
    this.shellSuspendCounter =
    this.errorRecoveryDisabledLanes =
    this.finishedLanes =
    this.expiredLanes =
    this.warmLanes =
    this.pingedLanes =
    this.suspendedLanes =
    this.pendingLanes =
      0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  transitionCallbacks,
  formState
) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    formState
  );
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(
  rootFiber,
  lane,
  element,
  container,
  parentComponent,
  callback
) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context
    ? (container.context = parentComponent)
    : (container.pendingContext = parentComponent);
  container = createUpdate(lane);
  container.payload = { element: element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element &&
    (scheduleUpdateOnFiber(element, rootFiber, lane),
    entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 8),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ),
        clearIfContinuousEvent(domEventName, nativeEvent);
    else if (
      queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      )
    )
      nativeEvent.stopPropagation();
    else if (
      (clearIfContinuousEvent(domEventName, nativeEvent),
      eventSystemFlags & 4 &&
        -1 < discreteReplayableEvents.indexOf(domEventName))
    ) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << (31 - clz32(lanes));
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) &&
                    ((workInProgressRootRenderTargetTime = now() + 500),
                    flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 13:
              (root = enqueueConcurrentRenderForLane(fiber, 2)),
                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                flushSyncWork$1(),
                markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber &&
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(
  existingQueuedEvent,
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (
    null === existingQueuedEvent ||
    existingQueuedEvent.nativeEvent !== nativeEvent
  )
    return (
      (existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }),
      null !== blockedOn &&
        ((blockedOn = getInstanceFromNode(blockedOn)),
        null !== blockedOn && attemptContinuousHydration(blockedOn)),
      existingQueuedEvent
    );
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer &&
    -1 === blockedOn.indexOf(targetContainer) &&
    blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  switch (domEventName) {
    case "focusin":
      return (
        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "dragenter":
      return (
        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "mouseover":
      return (
        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return !0;
    case "gotpointercapture":
      return (
        (pointerId = nativeEvent.pointerId),
        queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ),
        !0
      );
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted)
      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
        if (
          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            if (13 === nearestMounted.tag) {
              var lane = requestUpdateLane(),
                root = enqueueConcurrentRenderForLane(nearestMounted, lane);
              null !== root &&
                scheduleUpdateOnFiber(root, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (
        3 === targetInst &&
        nearestMounted.stateNode.current.memoizedState.isDehydrated
      ) {
        queuedTarget.blockedOn =
          3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        return;
      }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (
    var targetContainers = queuedEvent.targetContainers;
    0 < targetContainers.length;

  ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return (
        (targetContainers = getInstanceFromNode(nextBlockedOn)),
        null !== targetContainers &&
          attemptContinuousHydration(targetContainers),
        (queuedEvent.blockedOn = nextBlockedOn),
        !1
      );
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus &&
    attemptReplayContinuousQueuedEvent(queuedFocus) &&
    (queuedFocus = null);
  null !== queuedDrag &&
    attemptReplayContinuousQueuedEvent(queuedDrag) &&
    (queuedDrag = null);
  null !== queuedMouse &&
    attemptReplayContinuousQueuedEvent(queuedMouse) &&
    (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked &&
    ((queuedEvent.blockedOn = null),
    hasScheduledReplayAttempt ||
      ((hasScheduledReplayAttempt = !0),
      Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue &&
    ((lastScheduledReplayQueue = formReplayingQueue),
    Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function () {
        lastScheduledReplayQueue === formReplayingQueue &&
          (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst &&
            (formReplayingQueue.splice(i, 3),
            (i -= 3),
            startHostTransition(
              formInst,
              {
                pending: !0,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
        }
      }
    ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (
    ;
    0 < queuedExplicitHydrationTargets.length &&
    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

  )
    attemptExplicitHydrationTarget(i),
      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (
            ((form = submitterOrAction),
            (formProps = submitterOrAction[internalPropsKey] || null))
          )
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action
          ? (i[queuedTarget + 1] = action)
          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
  function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      0 === root.tag && flushPassiveEffects();
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target: target, priority: updatePriority };
    for (
      var i = 0;
      i < queuedExplicitHydrationTargets.length &&
      0 !== updatePriority &&
      updatePriority < queuedExplicitHydrationTargets[i].priority;
      i++
    );
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;
if (
  "19.0.0" !==
  isomorphicReactPackageVersion$jscomp$inline_1686
)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1686,
      "19.0.0"
    )
  );
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement =
    null !== componentOrElement
      ? findCurrentHostFiberImpl(componentOrElement)
      : null;
  componentOrElement =
    null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2165 = {
  bundleType: 0,
  version: "19.0.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  findFiberByHostInstance: getClosestInstanceFromNode,
  reconcilerVersion: "19.0.0"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (
    !hook$jscomp$inline_2166.isDisabled &&
    hook$jscomp$inline_2166.supportsFiber
  )
    try {
      (rendererID = hook$jscomp$inline_2166.inject(
        internals$jscomp$inline_2165
      )),
        (injectedHook = hook$jscomp$inline_2166);
    } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.unstable_transitionCallbacks &&
      (transitionCallbacks = options.unstable_transitionCallbacks));
  options = createFiberRoot(
    container,
    1,
    !1,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    null
  );
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(
    8 === container.nodeType ? container.parentNode : container
  );
  return new ReactDOMRoot(options);
};
__webpack_unused_export__ = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null,
    formState = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.unstable_transitionCallbacks &&
      (transitionCallbacks = options.unstable_transitionCallbacks),
    void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container,
    1,
    !0,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    formState
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  initialChildren.current.lanes = isStrictMode;
  markRootUpdated$1(initialChildren, isStrictMode);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
__webpack_unused_export__ = "19.0.0";


/***/ }),

/***/ 6221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(96540);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  Internals;
exports.createPortal = function (children, container) {
  var key =
    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (
    !container ||
    (1 !== container.nodeType &&
      9 !== container.nodeType &&
      11 !== container.nodeType)
  )
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
  } finally {
    (ReactSharedInternals.T = previousTransition),
      (Internals.p = previousUpdatePriority),
      Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href &&
    (options
      ? ((options = options.crossOrigin),
        (options =
          "string" === typeof options
            ? "use-credentials" === options
              ? options
              : ""
            : void 0))
      : (options = null),
    Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity =
        "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority =
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0;
    "style" === as
      ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin: crossOrigin,
            integrity: integrity,
            fetchPriority: fetchPriority
          }
        )
      : "script" === as &&
        Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if (
    "string" === typeof href &&
    "object" === typeof options &&
    null !== options &&
    "string" === typeof options.as
  ) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity:
        "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority:
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0,
      referrerPolicy:
        "string" === typeof options.referrerPolicy
          ? options.referrerPolicy
          : void 0,
      imageSrcSet:
        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes:
        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as:
          "string" === typeof options.as && "script" !== options.as
            ? options.as
            : void 0,
        crossOrigin: crossOrigin,
        integrity:
          "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.0.0";


/***/ }),

/***/ 5338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(31247);
} else {}


/***/ }),

/***/ 40961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(6221);
} else {}


/***/ }),

/***/ 29869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if (
    "object" !== typeof partialState &&
    "function" !== typeof partialState &&
    null != partialState
  )
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray,
  ReactSharedInternals = { H: null, A: null, T: null, S: null },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, self, source, owner, props) {
  self = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== self ? self : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(
    oldElement.type,
    newKey,
    void 0,
    void 0,
    void 0,
    oldElement.props
  );
}
function isValidElement(object) {
  return (
    "object" === typeof object &&
    null !== object &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return (
    "$" +
    key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    })
  );
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key
    ? escape("" + element.key)
    : index.toString(36);
}
function noop$1() {}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (
        ("string" === typeof thenable.status
          ? thenable.then(noop$1, noop$1)
          : ((thenable.status = "pending"),
            thenable.then(
              function (fulfilledValue) {
                "pending" === thenable.status &&
                  ((thenable.status = "fulfilled"),
                  (thenable.value = fulfilledValue));
              },
              function (error) {
                "pending" === thenable.status &&
                  ((thenable.status = "rejected"), (thenable.reason = error));
              }
            )),
        thenable.status)
      ) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return (
              (invokeCallback = children._init),
              mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              )
            );
        }
    }
  if (invokeCallback)
    return (
      (callback = callback(children)),
      (invokeCallback =
        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
      isArrayImpl(callback)
        ? ((escapedPrefix = ""),
          null != invokeCallback &&
            (escapedPrefix =
              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
            return c;
          }))
        : null != callback &&
          (isValidElement(callback) &&
            (callback = cloneAndReplaceKey(
              callback,
              escapedPrefix +
                (null == callback.key ||
                (children && children.key === callback.key)
                  ? ""
                  : ("" + callback.key).replace(
                      userProvidedKeyEscapeRegex,
                      "$&/"
                    ) + "/") +
                invokeCallback
            )),
          array.push(callback)),
      1
    );
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0; i < children.length; i++)
      (nameSoFar = children[i]),
        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if (((i = getIteratorFn(children)), "function" === typeof i))
    for (
      children = i.call(children), i = 0;
      !(nameSoFar = children.next()).done;

    )
      (nameSoFar = nameSoFar.value),
        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " +
        ("[object Object]" === array
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : array) +
        "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function (moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 1), (payload._result = moduleObject);
      },
      function (error) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 2), (payload._result = error);
      }
    );
    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError =
  "function" === typeof reportError
    ? reportError
    : function (error) {
        if (
          "object" === typeof window &&
          "function" === typeof window.ErrorEvent
        ) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message:
              "object" === typeof error &&
              null !== error &&
              "string" === typeof error.message
                ? String(error.message)
                : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if (
          "object" === typeof process &&
          "function" === typeof process.emit
        ) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
function noop() {}
exports.Children = {
  map: mapChildren,
  forEach: function (children, forEachFunc, forEachContext) {
    mapChildren(
      children,
      function () {
        forEachFunc.apply(this, arguments);
      },
      forEachContext
    );
  },
  count: function (children) {
    var n = 0;
    mapChildren(children, function () {
      n++;
    });
    return n;
  },
  toArray: function (children) {
    return (
      mapChildren(children, function (child) {
        return child;
      }) || []
    );
  },
  only: function (children) {
    if (!isValidElement(children))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return children;
  }
};
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  ReactSharedInternals;
exports.act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign({}, element.props),
    key = element.key,
    owner = void 0;
  if (null != config)
    for (propName in (void 0 !== config.ref && (owner = void 0),
    void 0 !== config.key && (key = "" + config.key),
    config))
      !hasOwnProperty.call(config, propName) ||
        "key" === propName ||
        "__self" === propName ||
        "__source" === propName ||
        ("ref" === propName && void 0 === config.ref) ||
        (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, void 0, void 0, owner, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      hasOwnProperty.call(config, propName) &&
        "key" !== propName &&
        "__self" !== propName &&
        "__source" !== propName &&
        (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in ((childrenLength = type.defaultProps), childrenLength))
      void 0 === props[propName] &&
        (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, void 0, void 0, null, props);
};
exports.createRef = function () {
  return { current: null };
};
exports.forwardRef = function (render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue &&
      null !== returnValue &&
      "function" === typeof returnValue.then &&
      returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    ReactSharedInternals.T = prevTransition;
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (
  subscribe,
  getSnapshot,
  getServerSnapshot
) {
  return ReactSharedInternals.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.0.0";


/***/ }),

/***/ 96540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(29869);
} else {}


/***/ }),

/***/ 4477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index; ) {
    var parentIndex = (index - 1) >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node))
      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
    else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (
      var index = 0, length = heap.length, halfLength = length >>> 1;
      index < halfLength;

    ) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last))
        rightIndex < length && 0 > compare(right, left)
          ? ((heap[index] = right),
            (heap[rightIndex] = last),
            (index = rightIndex))
          : ((heap[index] = left),
            (heap[leftIndex] = last),
            (index = leftIndex));
      else if (rightIndex < length && 0 > compare(right, last))
        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
      else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer; ) {
    if (null === timer.callback) pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue),
        (timer.sortIndex = timer.expirationTime),
        push(taskQueue, timer);
    else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (null !== peek(taskQueue))
      (isHostCallbackScheduled = !0), requestHostCallback();
    else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
}
function performWorkUntilDeadline() {
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled &&
          ((isHostTimeoutScheduled = !1),
          localClearTimeout(taskTimeoutID),
          (taskTimeoutID = -1));
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (
              currentTask = peek(taskQueue);
              null !== currentTask &&
              !(
                currentTask.expirationTime > currentTime && shouldYieldToHost()
              );

            ) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(
                  currentTask.expirationTime <= currentTime
                );
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          (currentTask = null),
            (currentPriorityLevel = previousPriorityLevel),
            (isPerformingWork = !1);
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork
        ? schedulePerformWorkUntilDeadline()
        : (isMessageLoopRunning = !1);
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate)
  schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };
else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else
  schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
function requestHostCallback() {
  isMessageLoopRunning ||
    ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
}
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_continueExecution = function () {
  isHostCallbackScheduled ||
    isPerformingWork ||
    ((isHostCallbackScheduled = !0), requestHostCallback());
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps
    ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_getFirstCallbackNode = function () {
  return peek(taskQueue);
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_pauseExecution = function () {};
exports.unstable_requestPaint = function () {};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (
  priorityLevel,
  callback,
  options
) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options
    ? ((options = options.delay),
      (options =
        "number" === typeof options && 0 < options
          ? currentTime + options
          : currentTime))
    : (options = currentTime);
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime
    ? ((priorityLevel.sortIndex = options),
      push(timerQueue, priorityLevel),
      null === peek(taskQueue) &&
        priorityLevel === peek(timerQueue) &&
        (isHostTimeoutScheduled
          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
          : (isHostTimeoutScheduled = !0),
        requestHostTimeout(handleTimeout, options - currentTime)))
    : ((priorityLevel.sortIndex = timeout),
      push(taskQueue, priorityLevel),
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0), requestHostCallback()));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};


/***/ }),

/***/ 69982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(4477);
} else {}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "bundle." + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "ace-layout-root:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			6306: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkace_layout_root"] = self["webpackChunkace_layout_root"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./packages/react-ace-layout/build/bundle.index.js
var bundle_index = __webpack_require__(70590);
// EXTERNAL MODULE: ./packages/ace-layout/build/bundle.index.js
var build_bundle_index = __webpack_require__(43956);
;// ./packages/demo/menu_example.ts

let menuDefs = {
  "AWS Cloud9": "50,,,,",
  "File": "100,,,,",
  "Edit": "200,,,,",
  "Find": "300,,,,",
  "View": "400,,,,",
  "Go": "500,,,,",
  "Tools": "700,,,,",
  "Window": "800,,,,",
  "File/~1000000": "1000000,,,,",
  "View/~9999": "9999,,,,",
  "Window/Presets": "10200,,false,, ",
  "Window/Presets/Full IDE": "100,,false,, ",
  "Window/Presets/Minimal Editor": "200,,false,, ",
  "Window/Presets/Sublime Mode": "300,,false,, ",
  "View/Menu Bar": "250,check,true,false,",
  "Edit/~300": "300,,,,",
  "Edit/Cut": "400,,false,false,Ctrl-X",
  "Edit/Copy": "500,,false,false,Ctrl-C",
  "Edit/Paste": "600,,false,false,Ctrl-V",
  "View/Editors": "100,,false,, ",
  "View/~200": "200,,,,",
  "View/Tab Buttons": "300,check,true,false,",
  "AWS Cloud9/~280": "280,,,,",
  "AWS Cloud9/Preferences": "300,,false,false,Ctrl-,",
  "Tools/~100000": "100000,,,,",
  "Tools/Developer": "100100,,false,, ",
  "Tools/Developer/Start in Debug Mode": "900,,false,, ",
  "Window/Environment": "100,check,true,,Ctrl-I",
  "File/~600": "600,,,,",
  "File/Save": "700,,false,false,Ctrl-S",
  "File/Save As...": "800,,false,false,Ctrl-Shift-S",
  "File/Save All": "900,,false,false,",
  "File/Revert to Saved": "1000,,false,false,Ctrl-Shift-Q",
  "File/Revert All to Saved": "1100,,false,false,Alt-Shift-Q",
  "View/Editors/Image Viewer": "40000,radio,false,true, ",
  "View/Editors/Image Editor": "40000,radio,false,true, ",
  "File/New File": "100,,false,false,Alt-N",
  "File/New From Template": "200,,false,false, ",
  "File/New From Template/Text File": "200,,false,false, ",
  "File/New From Template/JavaScript File": "200,,false,false, ",
  "File/New From Template/HTML File": "200,,false,false, ",
  "File/New From Template/XML File": "200,,false,false, ",
  "File/New From Template/Python File": "200,,false,false, ",
  "File/New From Template/PHP File": "200,,false,false, ",
  "File/New From Template/C File": "200,,false,false, ",
  "File/New From Template/C++ File": "200,,false,false, ",
  "File/New From Template/Go File": "200,,false,false, ",
  "File/New From Template/Markdown": "200,,false,false, ",
  "File/New From Template/Node.js Web Server": "200,,false,false, ",
  "File/New From Template/Java Console Application": "200,,false,false, ",
  "File/Open...": "400,,false,false,Ctrl-E|Ctrl-O",
  "Edit/Undo": "100,,false,true,Ctrl-Z",
  "Edit/Redo": "200,,false,true,Ctrl-Shift-Z|Ctrl-Y",
  "Help": "1000,,,,",
  "Help/Key Bindings Editor": "250,,false,,",
  "View/Editors/Ace": "40000,radio,false,true, ",
  "Tools/Toggle Macro Recording": "20100,,false,false,Alt-Shift-R",
  "Tools/Play Macro": "20200,,false,false,Alt-R",
  "Edit/~700": "700,,,,",
  "Edit/Selection": "800,,false,, ",
  "Edit/Line": "900,,false,, ",
  "Edit/Text": "1000,,false,, ",
  "Edit/Comment": "1100,,false,, ",
  "Edit/Code Folding": "1200,,false,, ",
  "Edit/Line/Indent": "100,,false,false,Tab",
  "Edit/Line/Outdent": "200,,false,false,Shift-Tab",
  "Edit/Line/Move Line Up": "300,,false,false,Alt-Up",
  "Edit/Line/Move Line Down": "400,,false,false,Alt-Down",
  "Edit/Line/~500": "500,,,false,",
  "Edit/Line/Copy Lines Up": "600,,false,false,Alt-Shift-Up",
  "Edit/Line/Copy Lines Down": "700,,false,false,Alt-Shift-Down",
  "Edit/Line/~800": "800,,,false,",
  "Edit/Line/Remove Line": "900,,false,false,Ctrl-D",
  "Edit/Line/Remove to Line End": "1000,,false,false,Alt-Delete",
  "Edit/Line/Remove to Line Start": "1100,,false,false,Alt-Backspace",
  "Edit/Line/~1200": "1200,,,false,",
  "Edit/Line/Split Line": "1300,,false,false,",
  "Edit/Comment/Toggle Comment": "100,,false,false,Ctrl-/",
  "Edit/Text/Remove Word Right": "100,,false,false,Ctrl-Delete",
  "Edit/Text/Remove Word Left": "200,,false,false,Ctrl-Backspace",
  "Edit/Text/~300": "300,,,false,",
  "Edit/Text/Align": "400,,false,false,Ctrl-Alt-A",
  "Edit/Text/Transpose Letters": "500,,false,false,Alt-Shift-X",
  "Edit/Text/~600": "600,,,false,",
  "Edit/Text/To Upper Case": "700,,false,false,Ctrl-U",
  "Edit/Text/To Lower Case": "800,,false,false,Ctrl-Shift-U",
  "Edit/Code Folding/Toggle Fold": "100,,false,false,F2",
  "Edit/Code Folding/Unfold": "200,,false,false,Alt-Shift-L|Ctrl-Shift-F1",
  "Edit/Code Folding/~300": "300,,,false,",
  "Edit/Code Folding/Fold Other": "400,,false,false,Alt-0",
  "Edit/Code Folding/Fold All": "500,,false,false,",
  "Edit/Code Folding/Unfold All": "600,,false,false,Alt-Shift-0",
  "Edit/Selection/Select All": "100,,false,false,Ctrl-A",
  "Edit/Selection/Split Into Lines": "200,,false,false,Ctrl-Alt-L",
  "Edit/Selection/Single Selection": "300,,false,true,esc",
  "Edit/Selection/~400": "400,,,false,",
  "Edit/Selection/Multiple Selections": "500,,false,false, ",
  "Edit/Selection/~600": "600,,,false,",
  "Edit/Selection/Select Word Right": "700,,false,false,Ctrl-Shift-Right",
  "Edit/Selection/Select Word Left": "800,,false,false,Ctrl-Shift-Left",
  "Edit/Selection/~900": "900,,,false,",
  "Edit/Selection/Select to Line End": "1000,,false,false,Alt-Shift-Right",
  "Edit/Selection/Select to Line Start": "1100,,false,false,Alt-Shift-Left",
  "Edit/Selection/~1200": "1200,,,false,",
  "Edit/Selection/Select to Document End": "1300,,false,false,Ctrl-Shift-End",
  "Edit/Selection/Select to Document Start": "1400,,false,false,Ctrl-Shift-Home",
  "Edit/Selection/Multiple Selections/Add Cursor Up": "100,,false,false,Ctrl-Alt-Up",
  "Edit/Selection/Multiple Selections/Add Cursor Down": "200,,false,false,Ctrl-Alt-Down",
  "Edit/Selection/Multiple Selections/Move Active Cursor Up": "300,,false,false,Ctrl-Alt-Shift-Up",
  "Edit/Selection/Multiple Selections/Move Active Cursor Down": "400,,false,false,Ctrl-Alt-Shift-Down",
  "Edit/Selection/Multiple Selections/~500": "500,,,,",
  "Edit/Selection/Multiple Selections/Add Next Selection Match": "600,,false,false,Ctrl-Alt-Right",
  "Edit/Selection/Multiple Selections/Add Previous Selection Match": "700,,false,false,Ctrl-Alt-Left",
  "Edit/Selection/Multiple Selections/~800": "800,,,,",
  "Edit/Selection/Multiple Selections/Merge Selection Range": "900,,false,false,Ctrl-Alt-L",
  "View/~290000": "290000,,,,",
  "View/Font Size": "290001,,false,, ",
  "View/Font Size/Increase Font Size": "100,,false,false,Ctrl-+|Ctrl-=",
  "View/Font Size/Decrease Font Size": "200,,false,false,Ctrl--",
  "View/Gutter": "500,check,true,, ",
  "File/~1400": "1400,,,,",
  "File/Line Endings": "1500,,false,, ",
  "File/Line Endings/Windows (CRLF)": "200,radio,false,false, ",
  "File/Line Endings/Unix (LF)": "300,radio,false,false, ",
  "View/Syntax": "300000,,false,, ",
  "View/~400000": "400000,,,,",
  "View/Wrap Lines": "500000,check,false,false, ",
  "View/Wrap To Print Margin": "600000,check,false,false, ",
  "Go/~399": "399,,,,",
  "Go/Next Error": "499,,false,false,Alt-E",
  "Go/Previous Error": "599,,false,false,Alt-Shift-E",
  "Go/~799": "799,,,,",
  "Go/Word Right": "899,,false,false,Ctrl-Right",
  "Go/Word Left": "999,,false,false,Ctrl-Left",
  "Go/~1099": "1099,,,,",
  "Go/Line End": "1199,,false,false,Alt-Right|End",
  "Go/Line Start": "1299,,false,false,Alt-Left|Home",
  "Go/~1399": "1399,,,,",
  "Go/Jump to Matching Brace": "1499,,false,false,Ctrl-P",
  "Go/~1599": "1599,,,,",
  "Go/Scroll to Selection": "1699,,false,false,",
  "View/Themes": "350000,,false,false, ",
  "Go/Go to Anything...": "100,,false,false,Ctrl-P",
  "Go/Go to Symbol...": "110,,false,false,Ctrl-Shift-O",
  "Go/Go to File...": "120,,false,false,Ctrl-E|Ctrl-O",
  "Go/Go to Command...": "130,,false,false,Ctrl-.",
  "Window/Go": "10,check,true,, ",
  "AWS Cloud9/~300": "300,,,,",
  "AWS Cloud9/Go To Your Dashboard": "310,,false,, ",
  "AWS Cloud9/~350": "350,,,,",
  "AWS Cloud9/Open Your Project Settings": "400,,false,, ",
  "AWS Cloud9/Open Your User Settings": "400,,false,, ",
  "AWS Cloud9/Open Your Keymap": "600,,false,, ",
  "AWS Cloud9/Open Your Init Script": "700,,false,, ",
  "AWS Cloud9/Open Your Stylesheet": "800,,false,, ",
  "AWS Cloud9/Restart AWS Cloud9": "2000080,,false,false,Ctrl-R",
  "Tools/Strip Trailing Space": "100,,false,false,",
  "Tools/~200": "200,,,,",
  "Go/Go to Line...": "200,,false,false,Ctrl-G",
  "View/Status Bar": "600,check,true,, ",
  "File/~100000": "100000,,,,",
  "File/Close File": "110000,,false,false,Alt-W",
  "File/Close All Files": "120000,,false,false,Alt-Shift-W",
  "Window/Tabs": "10100,,false,, ",
  "Window/Tabs/Close Pane": "100,,false,,Ctrl-W",
  "Window/Tabs/Close All Tabs In All Panes": "200,,false,,Alt-Shift-W",
  "Window/Tabs/Close All But Current Tab": "300,,false,,Ctrl-Alt-W",
  "Window/Tabs/~1000000": "1000000,,,,",
  "Window/Tabs/Split Pane in Two Rows": "1000100,,false,,",
  "Window/Tabs/Split Pane in Two Columns": "1000200,,false,,",
  "Window/Tabs/~1000300": "1000300,,,,",
  "Window/Tabs/~1000400": "1000400,,,,",
  "Window/~9000": "9000,,,,",
  "Window/Navigation": "9100,,false,, ",
  "Window/Navigation/Tab to the Right": "100,,false,true,Ctrl-]",
  "Window/Navigation/Tab to the Left": "200,,false,true,Ctrl-[",
  "Window/Navigation/Next Tab in History": "300,,false,true,Ctrl-Tab|Alt-`",
  "Window/Navigation/Previous Tab in History": "400,,false,true,Ctrl-Shift-Tab|Alt-Shift-`",
  "Window/Navigation/~500": "500,,,,",
  "Window/Navigation/Move Tab to Right": "600,,false,false,Ctrl-Meta-Right",
  "Window/Navigation/Move Tab to Left": "700,,false,false,Ctrl-Meta-Left",
  "Window/Navigation/Move Tab to Up": "800,,false,false,Ctrl-Meta-Up",
  "Window/Navigation/Move Tab to Down": "900,,false,false,Ctrl-Meta-Down",
  "Window/Navigation/~1000": "1000,,,,",
  "Window/Navigation/Go to Pane to Right": "1100,,false,false,Ctrl-Meta-Right",
  "Window/Navigation/Go to Pane to Left": "1200,,false,false,Ctrl-Meta-Left",
  "Window/Navigation/Go to Pane to Up": "1300,,false,false,Ctrl-Meta-Up",
  "Window/Navigation/Go to Pane to Down": "1400,,false,false,Ctrl-Meta-Down",
  "Window/Navigation/~1500": "1500,,,,",
  "Window/Navigation/Next Pane in History": "1600,,false,false,Ctrl-`",
  "Window/Navigation/Previous Pane in History": "1700,,false,false,Ctrl-Shift-`",
  "Window/~10000": "10000,,,,",
  "/context": ",,,,",
  "/context/tree": "0,,false,,",
  "/context/tree/Copy file path": "800,,false,false,",
  "/context/tree/~850": "850,,,false,",
  /*"/context/tabs": {
      "Reveal in File Tree": "100,,false,false,Ctrl-Shift-L",
      "~200": "200,,,,",
      "Copy file path": "230,,false,false,",
      "~260": "260,,,,",
      "Close Tab": "300,,false,false,Alt-W",
      "Close All Tabs": "450,,false,false,Ctrl-W",
      "Close Other Tabs": "500,,false,false,Ctrl-Alt-W",
      "Close Tabs to the Left": "600,,false,true,",
      "Close Tabs to the Right": "700,,false,true,",
      "~750": "750,,,,",
      "Split Pane in Two Rows": "800,,false,false,",
      "Split Pane in Two Columns": "900,,false,false,",
      "~1000": "1000,,,,",
      "Duplicate View": "1010,,false,false,",
      "Run This File": "150,,false,false, ",
  },*/
  "View/~800": "800,,,,",
  "View/Layout": "900,,false,, ",
  "View/Layout/Single": "100,,false,false,",
  "View/Layout/Vertical Split": "100,,false,false,",
  "View/Layout/Horizontal Split": "200,,false,false,",
  "View/Layout/Cross Split": "300,,false,false,",
  "View/Layout/Split 1:2": "400,,false,false,",
  "View/Layout/Split 2:1": "500,,false,false,",
  "Window/Saved Layouts": "10050,,false,, ",
  "Edit/~650": "650,,,,",
  "Edit/Keyboard Mode": "660,,false,, ",
  "Edit/Keyboard Mode/Default": "1100,radio,true,, ",
  "Edit/Keyboard Mode/Vim": "1200,radio,false,, ",
  "Edit/Keyboard Mode/Emacs": "1300,radio,false,, ",
  "Edit/Keyboard Mode/Sublime": "1400,radio,false,, ",
  "Find/~10000": "10000,,,,",
  "Find/Find in Files...": "20000,,false,false,Ctrl-Shift-F",
  "Find/Find...": "100,,false,false,Ctrl-F",
  "Find/Find Next": "200,,false,false,Ctrl-K",
  "Find/Find Previous": "300,,false,false,Ctrl-Shift-K",
  "Find/~400": "400,,,,",
  "Find/Replace...": "500,,false,false,Alt-Shift-F|Ctrl-H",
  "Find/Replace Next": "600,,false,false,",
  "Find/Replace Previous": "700,,false,false,",
  "Find/Replace All": "800,,false,false,",
  "Tools/~2000": "2000,,,,",
  "Tools/Show Autocomplete": "2100,,false,false,Ctrl-Space|Alt-Space",
  "Tools/~10000": "10000,,,,",
  "Tools/Rename variable": "2100,,false,false,Ctrl-Alt-R",
  "Go/Jump to Definition": "1450,,false,false,F3",
  "Go/Find References": "1450,,false,false,Shift-F3",
  "Window/Debugger": "100,check,true,,",
  "Run": "600,,,,",
  "Run/Run": "1100,,false,true,Alt-F5",
  "Run/Run Last": "1200,,false,true,F5",
  "Run/~1300": "1300,,,,",
  "Run/Run With": "1400,,false,, ",
  "Run/Run History": "1500,,false,true, ",
  "Run/Run Configurations": "1600,,false,, ",
  "Run/~2600": "2600,,,,",
  "Run/Show Debugger at Break": "2700,check,true,, ",
  "Run/Run Configurations/~1000": "1000,,,,",
  "Run/Run Configurations/New Run Configuration": "1100,,false,, ",
  "Run/Run Configurations/Manage...": "1200,,false,, ",
  "Run/Run With/~1000": "1000,,,,",
  "Run/Run With/New Runner": "1100,,false,, ",
  "Run/Run With/Edit Runner": "1200,,false,, ",
  "Window/New Terminal": "30,,false,false,Alt-T",
  "Window/Navigation/Switch Between Editor and Terminal": "1550,,false,false,Alt-S",
  "Run/~10100": "10100,,,,",
  "Run/Build": "10200,,false,false,Ctrl-B",
  "Run/Cancel Build": "10300,,false,true,Ctrl-Shift-C",
  "Run/Build System": "10400,,false,, ",
  "Run/Show Build Result": "10500,,false,, ",
  "Run/~10600": "10600,,,,",
  "Run/Automatically Build Supported Files": "10700,check,false,, ",
  "Run/Save All on Build": "10800,check,true,, ",
  "Run/Build System/Automatic": "100,radio,true,, ",
  "Run/Build System/~200": "200,,,,",
  "Run/Build System/~1200": "1200,,,,",
  "Run/Build System/New Build System": "1300,,false,, ",
  "Window/New Immediate Window": "31,,false,, ",
  "View/Editors/Preview": "40000,radio,false,true, ",
  "Tools/Preview": "1000,,false,, ",
  "Tools/Preview/Live Preview Files": "100,,false,true, ",
  "Tools/Preview/Preview Running Application": "200,,false,, ",
  "Tools/Preview/~2000": "2000,,,,",
  "Tools/Preview/~4000": "4000,,,,",
  "Tools/Preview/Configure Preview URL...": "4200,,false,, ",
  "Tools/Preview/Show Active Servers...": "4300,,false,, ",
  "File/~1200": "1200,,,,",
  "File/Upload Local Files...": "1300,,false,, ",
  "Window/Outline": "50,check,true,,Ctrl-Shift-E",
  "View/Open Files": "210,check,false,, ",
  "Tools/Process List": "1100,,false,false,Ctrl-Alt-P",
  "Window/Installer...": "38,,false,false,",
  "Edit/Code Formatting": "1400,,false,, ",
  "Edit/Code Formatting/Apply Code Formatting": "100,,true,,Ctrl-Shift-B",
  "Edit/Code Formatting/Open Language & Formatting Preferences...": "200,,true,,",
  "File/Download Project": "1300,,false,, ",
  "File/Open Recent": "500,,false,, ",
  "File/Open Recent/~1000000": "1000000,,,,",
  "File/Open Recent/Clear Menu": "2000000,,false,true, ",
  "/user_info": "600,,,,",
  "/user_info/Go To Dashboard": "600,,false,, ",
  "Window/~40": "40,,,,",
  "/context/ace": "0,,false,,",
  "/context/ace-gutter": "0,,false,,",
  "/context/ace-gutter/Gutter Options": "1100,,false,, ",
  "/context/ace-gutter/Gutter Options/Show Line Numbers": "100,,false,,",
  "/context/ace-gutter/Gutter Options/Show Fold Widgets": "200,,false,,",
  "/context/terminal": ",,false,,",
  "/context/terminal/New Terminal Tab": "200,,false,,",
  "/context/terminal/~300": "300,,,,",
  "/context/terminal/Copy": "400,,false,,",
  "/context/terminal/Paste": "500,,false,,",
  "/context/terminal/Select All": "600,,false,,",
  "/context/terminal/Clear Buffer": "700,,false,,",
  "/context/terminal/~800": "800,,,,",
  "/context/terminal/Hint: Use Alt To Toggle Mouse Mode": "900,,false,,",
  "View/Syntax/Auto-Select": "100,radio,false,, ",
  "View/Syntax/Plain Text": "200,radio,true,, ",
  "View/Syntax/~300": "300,,,,",
  "View/Syntax/C and C++": "400,radio,false,, ",
  "View/Syntax/C#": "500,radio,false,, ",
  "View/Syntax/Clojure": "600,radio,false,, ",
  "View/Syntax/CoffeeScript": "700,radio,false,, ",
  "View/Syntax/CSS": "800,radio,false,, ",
  "View/Syntax/Dart": "900,radio,false,, ",
  "View/Syntax/Go": "1000,radio,false,, ",
  "View/Syntax/HTML": "1100,radio,false,, ",
  "View/Syntax/Jade": "1200,radio,false,, ",
  "View/Syntax/Java": "1300,radio,false,, ",
  "View/Syntax/JavaScript": "1400,radio,false,, ",
  "View/Syntax/JSON": "1500,radio,false,, ",
  "View/Syntax/LESS": "1600,radio,false,, ",
  "View/Syntax/Lua": "1700,radio,false,, ",
  "View/Syntax/Perl": "1800,radio,false,, ",
  "View/Syntax/PHP": "1900,radio,false,, ",
  "View/Syntax/Python": "2000,radio,false,, ",
  "View/Syntax/Ruby": "2100,radio,false,, ",
  "View/Syntax/Scala": "2200,radio,false,, ",
  "View/Syntax/SCSS": "2300,radio,false,, ",
  "View/Syntax/SH": "2400,radio,false,, ",
  "View/Syntax/SQL": "2500,radio,false,, ",
  "View/Syntax/Stylus": "2600,radio,false,, ",
  "View/Syntax/Text": "2700,radio,true,, ",
  "View/Syntax/Typescript": "2800,radio,false,, ",
  "View/Syntax/XML": "2900,radio,false,, ",
  "View/Syntax/XQuery": "3000,radio,false,, ",
  "View/Syntax/YAML": "3100,radio,false,, ",
  "View/Syntax/~3200": "3200,,,,",
  "View/Syntax/ABAP": "3300,radio,false,, ",
  "View/Syntax/ABC": "3400,radio,false,, ",
  "View/Syntax/ActionScript": "3500,radio,false,, ",
  "View/Syntax/ADA": "3600,radio,false,, ",
  "View/Syntax/Apache Conf": "3700,radio,false,, ",
  "View/Syntax/Apex": "3800,radio,false,, ",
  "View/Syntax/AQL": "3900,radio,false,, ",
  "View/Syntax/AsciiDoc": "4000,radio,false,, ",
  "View/Syntax/ASL": "4100,radio,false,, ",
  "View/Syntax/Assembly x86": "4200,radio,false,, ",
  "View/Syntax/AutoHotkey ": ",,false,,",
  "View/Syntax/AutoHotkey / AutoIt": "4300,,false,,",
  "View/Syntax/BatchFile": "4400,radio,false,, ",
  "View/Syntax/C9Search": "4500,radio,false,, ",
  "View/Syntax/Cirru": "4600,radio,false,, ",
  "View/Syntax/Cobol": "4700,radio,false,, ",
  "View/Syntax/ColdFusion": "4800,radio,false,, ",
  "View/Syntax/Crystal": "4900,radio,false,, ",
  "View/Syntax/Csound": "5000,radio,false,, ",
  "View/Syntax/Csound Document": "5100,radio,false,, ",
  "View/Syntax/Csound Score": "5200,radio,false,, ",
  "View/Syntax/Curly": "5300,radio,false,, ",
  "View/Syntax/D": "5400,radio,false,, ",
  "View/Syntax/Diff": "5500,radio,false,, ",
  "View/Syntax/Django": "5600,radio,false,, ",
  "View/Syntax/Dockerfile": "5700,radio,false,, ",
  "View/Syntax/Dot": "5800,radio,false,, ",
  "View/Syntax/Drools": "5900,radio,false,, ",
  "View/Syntax/Edifact": "6000,radio,false,, ",
  "View/Syntax/Eiffel": "6100,radio,false,, ",
  "View/Syntax/EJS": "6200,radio,false,, ",
  "View/Syntax/Elixir": "6300,radio,false,, ",
  "View/Syntax/Elm": "6400,radio,false,, ",
  "View/Syntax/Erlang": "6500,radio,false,, ",
  "View/Syntax/Forth": "6600,radio,false,, ",
  "View/Syntax/Fortran": "6700,radio,false,, ",
  "View/Syntax/FreeMarker": "6800,radio,false,, ",
  "View/Syntax/FSharp": "6900,radio,false,, ",
  "View/Syntax/FSL": "7000,radio,false,, ",
  "View/Syntax/Gcode": "7100,radio,false,, ",
  "View/Syntax/Gherkin": "7200,radio,false,, ",
  "View/Syntax/Gitignore": "7300,radio,false,, ",
  "View/Syntax/Glsl": "7400,radio,false,, ",
  "View/Syntax/Gobstones": "7500,radio,false,, ",
  "View/Syntax/GraphQLSchema": "7600,radio,false,, ",
  "View/Syntax/Groovy": "7700,radio,false,, ",
  "View/Syntax/HAML": "7800,radio,false,, ",
  "View/Syntax/Handlebars": "7900,radio,false,, ",
  "View/Syntax/Haskell": "8000,radio,false,, ",
  "View/Syntax/Haskell Cabal": "8100,radio,false,, ",
  "View/Syntax/haXe": "8200,radio,false,, ",
  "View/Syntax/Hjson": "8300,radio,false,, ",
  "View/Syntax/HTML (Elixir)": "8400,radio,false,, ",
  "View/Syntax/HTML (Ruby)": "8500,radio,false,, ",
  "View/Syntax/INI": "8600,radio,false,, ",
  "View/Syntax/Io": "8700,radio,false,, ",
  "View/Syntax/Jack": "8800,radio,false,, ",
  "View/Syntax/JSONiq": "8900,radio,false,, ",
  "View/Syntax/JSP": "9000,radio,false,, ",
  "View/Syntax/JSSM": "9100,radio,false,, ",
  "View/Syntax/JSX": "9200,radio,false,, ",
  "View/Syntax/Julia": "9300,radio,false,, ",
  "View/Syntax/Kotlin": "9400,radio,false,, ",
  "View/Syntax/LaTeX": "9500,radio,false,, ",
  "View/Syntax/Liquid": "9600,radio,false,, ",
  "View/Syntax/Lisp": "9700,radio,false,, ",
  "View/Syntax/LiveScript": "9800,radio,false,, ",
  "View/Syntax/LogiQL": "9900,radio,false,, ",
  "View/Syntax/LSL": "10000,radio,false,, ",
  "View/Syntax/LuaPage": "10100,radio,false,, ",
  "View/Syntax/Lucene": "10200,radio,false,, ",
  "View/Syntax/Makefile": "10300,radio,false,, ",
  "View/Syntax/Markdown": "10400,radio,false,, ",
  "View/Syntax/Mask": "10500,radio,false,, ",
  "View/Syntax/MATLAB": "10600,radio,false,, ",
  "View/Syntax/Maze": "10700,radio,false,, ",
  "View/Syntax/MEL": "10800,radio,false,, ",
  "View/Syntax/MIXAL": "10900,radio,false,, ",
  "View/Syntax/MUSHCode": "11000,radio,false,, ",
  "View/Syntax/MySQL": "11100,radio,false,, ",
  "View/Syntax/Nginx": "11200,radio,false,, ",
  "View/Syntax/Nim": "11300,radio,false,, ",
  "View/Syntax/Nix": "11400,radio,false,, ",
  "View/Syntax/NSIS": "11500,radio,false,, ",
  "View/Syntax/Objective-C": "11600,radio,false,, ",
  "View/Syntax/OCaml": "11700,radio,false,, ",
  "View/Syntax/Pascal": "11800,radio,false,, ",
  "View/Syntax/Perl 6": "11900,radio,false,, ",
  "View/Syntax/pgSQL": "12000,radio,false,, ",
  "View/Syntax/PHP (Blade Template)": "12100,radio,false,, ",
  "View/Syntax/Pig": "12200,radio,false,, ",
  "View/Syntax/Powershell": "12300,radio,false,, ",
  "View/Syntax/Praat": "12400,radio,false,, ",
  "View/Syntax/Prolog": "12500,radio,false,, ",
  "View/Syntax/Properties": "12600,radio,false,, ",
  "View/Syntax/Protobuf": "12700,radio,false,, ",
  "View/Syntax/Puppet": "12800,radio,false,, ",
  "View/Syntax/R": "12900,radio,false,, ",
  "View/Syntax/Razor": "13000,radio,false,, ",
  "View/Syntax/RDoc": "13100,radio,false,, ",
  "View/Syntax/Red": "13200,radio,false,, ",
  "View/Syntax/RHTML": "13300,radio,false,, ",
  "View/Syntax/RST": "13400,radio,false,, ",
  "View/Syntax/Rust": "13500,radio,false,, ",
  "View/Syntax/SASS": "13600,radio,false,, ",
  "View/Syntax/SCAD": "13700,radio,false,, ",
  "View/Syntax/Scheme": "13800,radio,false,, ",
  "View/Syntax/SJS": "13900,radio,false,, ",
  "View/Syntax/Slim": "14000,radio,false,, ",
  "View/Syntax/Smarty": "14100,radio,false,, ",
  "View/Syntax/Soy Template": "14200,radio,false,, ",
  "View/Syntax/Space": "14300,radio,false,, ",
  "View/Syntax/SQLServer": "14400,radio,false,, ",
  "View/Syntax/SVG": "14500,radio,false,, ",
  "View/Syntax/Swift": "14600,radio,false,, ",
  "View/Syntax/Tcl": "14700,radio,false,, ",
  "View/Syntax/Terraform": "14800,radio,false,, ",
  "View/Syntax/Tex": "14900,radio,false,, ",
  "View/Syntax/Textile": "15000,radio,false,, ",
  "View/Syntax/Toml": "15100,radio,false,, ",
  "View/Syntax/TSX": "15200,radio,false,, ",
  "View/Syntax/Twig": "15300,radio,false,, ",
  "View/Syntax/Vala": "15400,radio,false,, ",
  "View/Syntax/VBScript": "15500,radio,false,, ",
  "View/Syntax/Velocity": "15600,radio,false,, ",
  "View/Syntax/Verilog": "15700,radio,false,, ",
  "View/Syntax/VHDL": "15800,radio,false,, ",
  "View/Syntax/Visualforce": "15900,radio,false,, ",
  "View/Syntax/Wollok": "16000,radio,false,, ",
  "View/Syntax/Zeek": "16100,radio,false,, ",
  "View/Themes/UI Themes": "0,,false,false, ",
  "View/Themes/~200": "200,,,false,",
  "View/Themes/UI Themes/Classic Dark": "0,radio,false,, ",
  "View/Themes/UI Themes/Classic Dark Gray": "0,radio,false,, ",
  "View/Themes/UI Themes/Flat Light": "0,radio,false,, ",
  "View/Themes/Ambiance": "200,radio,false,false, ",
  "View/Themes/Chrome": "201,radio,false,false, ",
  "View/Themes/Cloud9": "202,,false,false, ",
  "View/Themes/Cloud9/Cloud9 Day": ",radio,false,, ",
  "View/Themes/Cloud9/Cloud9 Night": ",radio,false,, ",
  "View/Themes/Cloud9/Cloud9 Night Low-Color": ",radio,false,, ",
  "View/Themes/Clouds": "203,,false,false, ",
  "View/Themes/Clouds/Clouds": ",radio,false,, ",
  "View/Themes/Clouds/Clouds Midnight": ",radio,false,, ",
  "View/Themes/Cobalt": "204,radio,false,false, ",
  "View/Themes/Crimson Editor": "205,radio,false,false, ",
  "View/Themes/Dawn": "206,radio,false,false, ",
  "View/Themes/Dreamweaver": "207,radio,false,false, ",
  "View/Themes/Eclipse": "208,radio,false,false, ",
  "View/Themes/GitHub": "209,radio,false,false, ",
  "View/Themes/Idle Fingers": "210,radio,false,false, ",
  "View/Themes/Kr Theme": "211,radio,false,false, ",
  "View/Themes/Merbivore": "212,,false,false, ",
  "View/Themes/Merbivore/Merbivore": ",radio,false,, ",
  "View/Themes/Merbivore/Merbivore Soft": ",radio,false,, ",
  "View/Themes/Mono Industrial": "213,radio,false,false, ",
  "View/Themes/Monokai": "214,radio,false,false, ",
  "View/Themes/Pastel On Dark": "215,radio,false,false, ",
  "View/Themes/Solarized": "216,,false,false, ",
  "View/Themes/Solarized/Solarized Dark": ",radio,false,, ",
  "View/Themes/Solarized/Solarized Light": ",radio,false,, ",
  "View/Themes/TextMate": "217,radio,false,false, ",
  "View/Themes/Tomorrow": "218,,false,false, ",
  "View/Themes/Tomorrow/Tomorrow": ",radio,false,, ",
  "View/Themes/Tomorrow/Tomorrow Night": ",radio,false,, ",
  "View/Themes/Tomorrow/Tomorrow Night Blue": ",radio,false,, ",
  "View/Themes/Tomorrow/Tomorrow Night Bright": ",radio,false,, ",
  "View/Themes/Tomorrow/Tomorrow Night Eighties": ",radio,false,, ",
  "View/Themes/Twilight": "219,radio,false,false, ",
  "View/Themes/Vibrant Ink": "220,radio,false,false, ",
  "View/Themes/Xcode": "221,radio,false,false, ",
  "View/Themes/Jett": "222,radio,false,false, ",
  "Window/Saved Layouts/Save...": "100,,false,,",
  "Window/Saved Layouts/Save And Close All...": "200,,false,,",
  "Window/Saved Layouts/~300": "300,,,,",
  "Window/Saved Layouts/Show Saved Layouts in File Tree": "400,,false,, ",
  "Window/Saved Layouts/~500": "500,,,,"
};
function addExampleMenuItems(menuManager, root, menuDefinitions = menuDefs) {
  let commands = [];
  Object.keys(menuDefinitions).forEach(function(x) {
    var _a;
    let item = menuDefinitions[x];
    let exec;
    if (typeof item == "object") {
      if (item.properties != void 0) {
        exec = item.exec;
        item = item.properties;
      } else {
        return addExampleMenuItems(menuManager, x, item);
      }
    }
    let parts = (_a = /(\d*),([^,]*),([^,]*),([^,]*),(.*)/.exec(item)) != null ? _a : [];
    let path = root ? root + "/" + x : x;
    let hotKey = (parts[5] || "").trim();
    if (exec && hotKey) {
      commands.push({
        bindKey: {
          win: hotKey,
          mac: hotKey
        },
        exec
      });
    }
    menuManager.addByPath(path, {
      className: path == "AWS Cloud9" ? "c9btn" : void 0,
      type: parts[2],
      checked: parts[3] == "true",
      disabled: parts[4] == "true",
      position: parseInt(parts[1]),
      hotKey,
      exec
    });
  });
  build_bundle_index.CommandManager.registerCommands(commands);
}

;// ./packages/demo/jsx/App.tsx
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const App = () => {
  const boxRef = (0,react.useRef)(null);
  const fileRef = (0,react.useRef)(null);
  const mainRef = (0,react.useRef)(null);
  const consoleRef = (0,react.useRef)(null);
  const aceTreeRef = (0,react.useRef)(null);
  const fileSystem = new build_bundle_index.FileSystemWeb();
  const openFolder = (e) => __async(void 0, null, function* () {
    const nodes = yield fileSystem.open();
    const aceTree = aceTreeRef.current.aceTreeInstance;
    aceTree.updateTreeData(nodes);
    aceTree.element.addEventListener("item-click", (evt) => {
      fileSystem.openFile(evt.detail);
    });
  });
  if (!menuDefs["View/Console"]) {
    menuDefs["View/Console"] = {
      properties: "700,check,false,false,F6",
      exec: () => consoleRef.current.boxInstance.toggleShowHide()
    };
    addExampleMenuItems(build_bundle_index.MenuManager.getInstance(), "", menuDefs);
  }
  (0,react.useEffect)(() => {
    const handleResize = () => {
      var _a;
      (_a = boxRef.current) == null ? void 0 : _a.boxInstance.setBox(0, 0, window.innerWidth, window.innerHeight);
    };
    window.addEventListener("resize", handleResize);
    const tabManager = build_bundle_index.TabManager.getInstance({
      containers: {
        main: mainRef.current.boxInstance,
        console: consoleRef.current.boxInstance
      },
      fileSystem
    });
    const panelManager = build_bundle_index.PanelManager.getInstance({
      layout: boxRef.current.boxInstance,
      locations: {
        left: {
          parent: boxRef.current.boxInstance,
          index: 0,
          size: 200
        }
      }
    });
    window.onbeforeunload = function() {
      tabManager.saveTo(localStorage);
      localStorage.tabs = JSON.stringify(tabManager.toJSON());
      localStorage.panels = JSON.stringify(panelManager.toJSON());
    };
    let tabState = {};
    let panelState = {};
    try {
      if (localStorage.tabs)
        tabState = JSON.parse(localStorage.tabs);
      if (localStorage.panels)
        panelState = JSON.parse(localStorage.panels);
    } catch (e) {
    }
    tabManager.setState(tabState);
    panelManager.setState(panelState);
    tabManager.restoreFrom(localStorage);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return /* @__PURE__ */ react.createElement(bundle_index.Box, { ref: boxRef, vertical: false, toolBars: {
    top: new build_bundle_index.MenuToolbar(),
    bottom: new build_bundle_index.PanelBar({})
  } }, /* @__PURE__ */ react.createElement(bundle_index.Box, { vertical: true }, /* @__PURE__ */ react.createElement(bundle_index.Box, { vertical: false }, /* @__PURE__ */ react.createElement(bundle_index.Box, { ref: fileRef, size: 200 }, /* @__PURE__ */ react.createElement(bundle_index.Button, { onClick: openFolder }, "Open Folder"), /* @__PURE__ */ react.createElement(bundle_index.AceTree, { ref: aceTreeRef })), /* @__PURE__ */ react.createElement(bundle_index.Box, { ref: mainRef, isMain: true })), /* @__PURE__ */ react.createElement(bundle_index.Box, { ref: consoleRef, isMain: true, ratio: 1, size: 100, buttons: [
    /* @__PURE__ */ react.createElement(bundle_index.Button, { title: "F6", className: "consoleCloseBtn", onClick: () => {
      consoleRef.current.boxInstance.hide();
    } }, "x")
  ] })));
};
/* harmony default export */ const jsx_App = (App);

// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
;// ./packages/demo/jsx/demo.tsx




const rootElement = document.getElementById("root");
if (!rootElement)
  throw new Error("Failed to find the root element");
const root = (0,client.createRoot)(rootElement);
root.render(/* @__PURE__ */ react.createElement(jsx_App, null));

})();

/******/ })()
;
//# sourceMappingURL=bundle.jsx.js.map